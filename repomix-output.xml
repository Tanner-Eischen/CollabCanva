This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursorignore
.env.example
.gitignore
.repomixignore
cors.json
database.rules.json
firebase.json
functions/.gitignore
functions/ENV_SETUP.md
functions/package.json
functions/src/ai-proxy.ts
functions/src/ai/contextBuilder.ts
functions/src/ai/safety.ts
functions/src/ai/tilemapGenerators.ts
functions/src/ai/toolExecutor.ts
functions/src/ai/toolRegistry.ts
functions/src/ai/tools/analysisTools.ts
functions/src/ai/tools/assetTools.ts
functions/src/ai/tools/layoutTools.ts
functions/src/ai/tools/optimizationTools.ts
functions/src/ai/tools/queryTools.ts
functions/src/ai/tools/shapeTools.ts
functions/src/ai/tools/tilemapTools.ts
functions/src/ai/tools/transformTools.ts
functions/src/ai/validation.ts
functions/src/index.ts
functions/src/services/tilemapBatch.ts
functions/tsconfig.json
index.html
package.json
postcss.config.js
pr32_ai_game_aware.md
public/assets/dirt.png
public/assets/eraser-32.png
public/assets/eyedropper-32.png
public/assets/flower-32.png
public/assets/grass-32.png
public/assets/paint-brush-32.png
public/assets/paint-bucket-32.png
public/assets/rock-32.png
public/assets/tiles/dirt/dirt_01.png
public/assets/tiles/dirt/dirt_02.png
public/assets/tiles/dirt/dirt_03.png
public/assets/tiles/dirt/dirt_04.png
public/assets/tiles/dirt/dirt_05.png
public/assets/tiles/dirt/dirt_06.png
public/assets/tiles/dirt/dirt_07.png
public/assets/tiles/dirt/dirt_08.png
public/assets/tiles/dirt/dirt_09.png
public/assets/tiles/flower/flower_01.png
public/assets/tiles/flower/flower_02.png
public/assets/tiles/flower/flower_03.png
public/assets/tiles/flower/flower_04.png
public/assets/tiles/flower/flower_05.png
public/assets/tiles/flower/flower_06.png
public/assets/tiles/flower/flower_07.png
public/assets/tiles/flower/flower_08.png
public/assets/tiles/flower/flower_09.png
public/assets/tiles/grass/grass_01.png
public/assets/tiles/grass/grass_02.png
public/assets/tiles/grass/grass_03.png
public/assets/tiles/grass/grass_04.png
public/assets/tiles/grass/grass_05.png
public/assets/tiles/grass/grass_06.png
public/assets/tiles/grass/grass_07.png
public/assets/tiles/grass/grass_08.png
public/assets/tiles/grass/grass_09.png
public/assets/tiles/stone/stone_01.png
public/assets/tiles/stone/stone_02.png
public/assets/tiles/stone/stone_03.png
public/assets/tiles/stone/stone_04.png
public/assets/tiles/stone/stone_05.png
public/assets/tiles/stone/stone_06.png
public/assets/tiles/stone/stone_07.png
public/assets/tiles/stone/stone_08.png
public/assets/tiles/stone/stone_09.png
public/assets/tiles/water/water_01.png
public/assets/tiles/water/water_02.png
public/assets/tiles/water/water_03.png
public/assets/tiles/water/water_04.png
public/assets/tiles/water/water_05.png
public/assets/tiles/water/water_06.png
public/assets/tiles/water/water_07.png
public/assets/tiles/water/water_08.png
public/assets/tiles/water/water_09.png
public/assets/water-32.png
public/vite.svg
src/algorithms/cellularAutomata.ts
src/algorithms/perlinNoise.ts
src/algorithms/randomWalk.ts
src/algorithms/waveFunctionCollapse.ts
src/App.css
src/App.tsx
src/assets/react.svg
src/commands/advanced/AlignmentCommand.ts
src/commands/advanced/AnimationCommand.ts
src/commands/advanced/BulkCommand.ts
src/commands/shape/ColorCommand.ts
src/commands/shape/CreateCommand.ts
src/commands/shape/DeleteCommand.ts
src/commands/shape/MoveCommand.ts
src/commands/shape/TransformCommand.ts
src/commands/shape/ZIndexCommand.ts
src/commands/tile/TileCommand.ts
src/commands/tile/TileFillCommand.ts
src/commands/tile/TileStrokeCommand.ts
src/components/ai/MessageBubble.tsx
src/components/ai/SmartSuggestions.tsx
src/components/animation/AnimationPreview.tsx
src/components/animation/AnimationTimeline.tsx
src/components/animation/FrameSelector.tsx
src/components/assets/AssetCard.tsx
src/components/assets/AssetLibrary.tsx
src/components/assets/AssetUploadModal.tsx
src/components/assets/AssetUploadModalEnhanced.tsx
src/components/assets/ManualSpriteSelector.tsx
src/components/assets/TilesetConfigurator.tsx
src/components/canvas/AnimatedSprite.tsx
src/components/canvas/Canvas.tsx
src/components/canvas/CanvasCard.tsx
src/components/canvas/PhysicsPreview.tsx
src/components/canvas/ShapeCanvas.tsx
src/components/canvas/ShapeRenderer.tsx
src/components/canvas/ShapeStatusBar.tsx
src/components/canvas/SpriteTile.tsx
src/components/Cursor.tsx
src/components/ErrorBoundary.tsx
src/components/export/ExportConfigPanel.tsx
src/components/export/ExportModal.tsx
src/components/export/ExportProgress.tsx
src/components/Group.tsx
src/components/KeyboardShortcuts.tsx
src/components/LayerItem.tsx
src/components/Login.tsx
src/components/panels/AIChatPanel.tsx
src/components/panels/LayerPanel.tsx
src/components/panels/PropertiesPanel.tsx
src/components/panels/TilePalette.tsx
src/components/physics/CollisionEditor.tsx
src/components/physics/PhysicsPanel.tsx
src/components/PresenceBar.tsx
src/components/ProtectedRoute.tsx
src/components/QuickActionsPopup.tsx
src/components/QuickPropertiesPopup.tsx
src/components/shapes/Circle.tsx
src/components/shapes/Line.tsx
src/components/shapes/Path.tsx
src/components/shapes/Polygon.tsx
src/components/shapes/Rectangle.tsx
src/components/shapes/RoundedRect.tsx
src/components/shapes/SelectionBox.tsx
src/components/shapes/Star.tsx
src/components/shapes/TextShape.tsx
src/components/TextEditor.tsx
src/components/tilemap/TilemapCanvas.tsx
src/components/tilemap/TilemapGrid.tsx
src/components/tilemap/TilemapLayer.tsx
src/components/tilemap/TileRenderer.tsx
src/components/tilemap/TileStatusBar.tsx
src/components/toolbar/AlignmentToolbar.tsx
src/components/toolbar/TilemapToolbar.tsx
src/components/toolbar/Toolbar.tsx
src/components/toolbar/ToolButton.tsx
src/components/ui/ColorPicker.tsx
src/components/ui/ContextMenu.tsx
src/components/ui/Skeleton.tsx
src/components/ui/Tooltip.tsx
src/components/ui/ZoomControls.tsx
src/constants/shortcuts.ts
src/constants/tilemapDefaults.ts
src/constants/tilesetAssets.ts
src/hooks/useAIChat.ts
src/hooks/useAssetLibrary.ts
src/hooks/useAuth.ts
src/hooks/useCanvas.ts
src/hooks/useCanvasList.ts
src/hooks/useCanvasViewport.ts
src/hooks/useContextMenu.ts
src/hooks/useGroups.ts
src/hooks/useKeyboardShortcuts.ts
src/hooks/useLayers.ts
src/hooks/usePresence.ts
src/hooks/useShapeKeyboardShortcuts.ts
src/hooks/useSpriteCache.ts
src/hooks/useTilemap.ts
src/hooks/useTilemapPainter.ts
src/index.css
src/main.tsx
src/pages/CanvasPage.tsx
src/pages/DashboardPage.tsx
src/services/ai/ai.ts
src/services/ai/gameTypeDetection.ts
src/services/ai/performanceProfiler.ts
src/services/assets/animation.ts
src/services/assets/assetFolders.ts
src/services/assets/assetUpload.ts
src/services/auth.ts
src/services/canvas/canvasManager.ts
src/services/canvas/canvasSync.ts
src/services/canvas/clipboard.ts
src/services/canvas/colorStorage.ts
src/services/canvas/commandHistory.ts
src/services/canvas/conflictResolution.ts
src/services/collaboration/alignment.ts
src/services/collaboration/groupSync.ts
src/services/firebase.ts
src/services/tilemap/tileFill.ts
src/services/tilemap/tilemapExport.ts
src/services/tilemap/tilemapImport.ts
src/services/tilemap/tilemapSync.ts
src/types/animation.ts
src/types/asset.ts
src/types/canvas.ts
src/types/command.ts
src/types/export.ts
src/types/firebase.ts
src/types/group.ts
src/types/layer.ts
src/types/selection.ts
src/types/tilemap.ts
src/utils/canvas/groupHelpers.ts
src/utils/canvas/pathHelpers.ts
src/utils/common/downloadHelper.ts
src/utils/common/throttle.ts
src/utils/exporters/baseExporter.ts
src/utils/exporters/genericExporter.ts
src/utils/exporters/godotExporter.ts
src/utils/migration/migrateToAutoTiles.ts
src/utils/migration/migrationScript.ts
src/utils/tilemap/autoTile.ts
src/utils/tilemap/spriteDetection.ts
src/utils/tilemap/tilesetSlicer.ts
src/vite-env.d.ts
storage.rules
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cors.json">
[
  {
    "origin": ["http://localhost:5173", "http://localhost:5174", "http://localhost:5175"],
    "method": ["GET", "POST", "PUT", "DELETE", "HEAD"],
    "maxAgeSeconds": 3600
  }
]
</file>

<file path="functions/src/ai/tools/analysisTools.ts">
/**
 * Analysis Tools
 * Analyze canvas content, detect patterns, and suggest improvements
 * PR-32: AI Game-Aware Enhancement
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import { checkUserPermission } from '../safety';

/**
 * Analyze Tilemap Tool
 * Analyzes the current tilemap and returns statistics
 */
export const analyzeTilemapTool: ToolDefinition = {
  name: 'analyzeTilemap',
  description: 'Analyze the current tilemap and return statistics: tile distribution, empty spaces, connected regions, and suggestions for improvement',
  parameters: {
    type: 'object',
    properties: {},
    required: [],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Get tilemap data
      const db = admin.database();
      const tilemapRef = db.ref(`canvases/${context.canvasId}/tilemap`);
      const tilemapSnap = await tilemapRef.once('value');
      const tilemapData = tilemapSnap.val();

      if (!tilemapData) {
        return {
          success: true,
          message: 'No tilemap exists yet. Create one with generateTilemap!',
          data: { empty: true },
        };
      }

      // Get tiles
      const tilesRef = db.ref(`canvases/${context.canvasId}/tilemap/tiles`);
      const tilesSnap = await tilesRef.once('value');
      const tiles = tilesSnap.val() || {};

      const width = tilemapData.width || 100;
      const height = tilemapData.height || 100;
      const totalCells = width * height;
      const tileCount = Object.keys(tiles).length;

      // Count tile types
      const tileTypes: Record<string, number> = {};
      for (const tile of Object.values(tiles) as any[]) {
        const type = tile.type || 'unknown';
        tileTypes[type] = (tileTypes[type] || 0) + 1;
      }

      // Calculate percentages
      const distribution = Object.entries(tileTypes).map(([type, count]) => ({
        type,
        count,
        percentage: ((count / tileCount) * 100).toFixed(1) + '%',
      }));

      // Analyze density
      const density = ((tileCount / totalCells) * 100).toFixed(1);
      const emptySpaces = totalCells - tileCount;

      // Generate suggestions
      const suggestions: string[] = [];

      if (tileCount === 0) {
        suggestions.push('Tilemap is empty. Use paintTileRegion or generateTilemap to add content.');
      } else if (tileCount < totalCells * 0.1) {
        suggestions.push('Tilemap is very sparse (< 10% filled). Consider generating more terrain.');
      } else if (tileCount > totalCells * 0.9) {
        suggestions.push('Tilemap is very dense (> 90% filled). Consider adding more empty/air spaces.');
      }

      // Check variety
      const uniqueTypes = Object.keys(tileTypes).length;
      if (uniqueTypes === 1) {
        suggestions.push('Only one tile type used. Add variety with different tile types.');
      } else if (uniqueTypes < 3) {
        suggestions.push('Limited tile variety. Consider adding more tile types for visual interest.');
      }

      // Check for dominant type
      const sortedTypes = distribution.sort((a, b) => b.count - a.count);
      if (sortedTypes.length > 0 && sortedTypes[0].count > tileCount * 0.8) {
        suggestions.push(`Tilemap is dominated by ${sortedTypes[0].type} tiles (${sortedTypes[0].percentage}). Add more variety.`);
      }

      return {
        success: true,
        message: `Analyzed ${width}x${height} tilemap with ${tileCount} tiles`,
        data: {
          dimensions: { width, height },
          totalCells,
          tileCount,
          emptySpaces,
          density: density + '%',
          distribution,
          uniqueTypes,
          suggestions,
        },
      };
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to analyze tilemap: ${error.message}`,
      };
    }
  },
};

/**
 * Detect Patterns Tool
 * Identifies common game patterns in the canvas
 */
export const detectPatternsTool: ToolDefinition = {
  name: 'detectPatterns',
  description: 'Detect common game patterns in the canvas: platformer level, top-down dungeon, puzzle grid, etc. Returns detected pattern type with confidence score and reasoning.',
  parameters: {
    type: 'object',
    properties: {},
    required: [],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Get canvas objects
      const db = admin.database();
      const objectsRef = db.ref(`canvases/${context.canvasId}/objects`);
      const objectsSnap = await objectsRef.once('value');
      const objects = objectsSnap.val() || {};

      // Get tilemap metadata
      const tilemapRef = db.ref(`canvases/${context.canvasId}/tilemap`);
      const tilemapSnap = await tilemapRef.once('value');
      const tilemapData = tilemapSnap.val();

      const objectArray = Object.values(objects) as any[];
      const objectCount = objectArray.length;

      // Detect game type
      let gameType = 'unknown';
      let confidence = 0;
      const reasoning: string[] = [];

      // Analyze object layout
      if (objectCount > 0) {
        const yPositions = objectArray.map(obj => obj.y || 0);
        const avgY = yPositions.reduce((sum, y) => sum + y, 0) / yPositions.length;
        const maxY = Math.max(...yPositions);
        const minY = Math.min(...yPositions);
        const yRange = maxY - minY;

        // Check for horizontal layers (platformer)
        const layers = new Set<number>();
        for (const y of yPositions) {
          layers.add(Math.floor(y / 100)); // 100px layer threshold
        }

        if (layers.size >= 3 && yRange > 300) {
          gameType = 'platformer';
          confidence = 0.7;
          reasoning.push(`${layers.size} horizontal layers detected`);
          reasoning.push('Objects distributed vertically (suggests gravity-based gameplay)');
        }

        // Check for grid pattern (puzzle/top-down)
        const xPositions = objectArray.map(obj => obj.x || 0);
        const xSpacing = new Map<number, number>();
        
        for (let i = 1; i < xPositions.length; i++) {
          const spacing = Math.round((xPositions[i] - xPositions[i - 1]) / 10) * 10;
          xSpacing.set(spacing, (xSpacing.get(spacing) || 0) + 1);
        }

        const maxSpacing = Math.max(...Array.from(xSpacing.values()));
        if (maxSpacing > objectCount * 0.3) {
          if (objectCount < 50) {
            gameType = 'puzzle';
            confidence = 0.65;
            reasoning.push('Regular grid pattern detected');
            reasoning.push('Low object count (typical for puzzle games)');
          } else {
            gameType = 'top-down';
            confidence = 0.6;
            reasoning.push('Grid-based layout detected');
          }
        }
      }

      // Analyze tilemap
      if (tilemapData) {
        const width = tilemapData.width || 0;
        const height = tilemapData.height || 0;
        const aspectRatio = width / height;

        if (aspectRatio > 2) {
          if (gameType === 'unknown' || confidence < 0.7) {
            gameType = 'platformer';
            confidence = Math.max(confidence, 0.6);
            reasoning.push('Wide aspect ratio suggests side-scrolling');
          }
        }

        if (width === height) {
          reasoning.push('Square tilemap (common in top-down games)');
          if (gameType === 'top-down') {
            confidence = Math.min(confidence + 0.1, 1.0);
          }
        }
      }

      // Default if nothing detected
      if (gameType === 'unknown') {
        confidence = 0.2;
        reasoning.push('Not enough content to detect specific pattern');
        reasoning.push('Add more objects or tilemap for better detection');
      }

      // Generate suggestions based on detected type
      const suggestions: string[] = [];
      
      switch (gameType) {
        case 'platformer':
          suggestions.push('Add platform terrain with generateTilemap (perlin-noise or cellular-automata)');
          suggestions.push('Place collectibles on platforms');
          suggestions.push('Add enemies or hazards');
          break;
        case 'top-down':
          suggestions.push('Generate dungeon layout with generateTilemap (cellular-automata)');
          suggestions.push('Add walls and boundaries');
          suggestions.push('Place doors and room transitions');
          break;
        case 'puzzle':
          suggestions.push('Create puzzle grid with regular spacing');
          suggestions.push('Add win condition indicators');
          suggestions.push('Consider adding UI elements');
          break;
        default:
          suggestions.push('Add more content to help detect game type');
          suggestions.push('Try generating a tilemap to establish level structure');
      }

      return {
        success: true,
        message: `Detected ${gameType} pattern with ${(confidence * 100).toFixed(0)}% confidence`,
        data: {
          gameType,
          confidence: (confidence * 100).toFixed(0) + '%',
          reasoning,
          suggestions,
          stats: {
            objectCount,
            tilemapSize: tilemapData ? { width: tilemapData.width, height: tilemapData.height } : null,
          },
        },
      };
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to detect patterns: ${error.message}`,
      };
    }
  },
};

/**
 * Suggest Improvement Tool
 * Analyzes canvas and suggests specific improvements
 */
export const suggestImprovementTool: ToolDefinition = {
  name: 'suggestImprovement',
  description: 'Analyze the current canvas and suggest specific improvements: missing elements, layout issues, variety improvements, etc.',
  parameters: {
    type: 'object',
    properties: {},
    required: [],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Get canvas objects
      const db = admin.database();
      const objectsRef = db.ref(`canvases/${context.canvasId}/objects`);
      const objectsSnap = await objectsRef.once('value');
      const objects = objectsSnap.val() || {};

      // Get tilemap
      const tilemapRef = db.ref(`canvases/${context.canvasId}/tilemap`);
      const tilemapSnap = await tilemapRef.once('value');
      const tilemapData = tilemapSnap.val();

      const tilesRef = db.ref(`canvases/${context.canvasId}/tilemap/tiles`);
      const tilesSnap = await tilesRef.once('value');
      const tiles = tilesSnap.val() || {};

      const objectArray = Object.values(objects) as any[];
      const objectCount = objectArray.length;
      const tileCount = Object.keys(tiles).length;

      const improvements: string[] = [];
      const warnings: string[] = [];

      // Check for empty canvas
      if (objectCount === 0 && tileCount === 0) {
        improvements.push('Canvas is empty! Start by generating a tilemap or adding some objects.');
        improvements.push('Try: generateTilemap with perlin-noise for natural terrain');
        improvements.push('Or: Add shapes as placeholders for game objects');
        
        return {
          success: true,
          message: 'Canvas needs content',
          data: { improvements, warnings, priority: 'high' },
        };
      }

      // Check tilemap
      if (tileCount === 0) {
        improvements.push('No tilemap detected. Add terrain with generateTilemap.');
        improvements.push('Suggested: Use cellular-automata for caves or perlin-noise for landscapes');
      } else if (tilemapData) {
        const width = tilemapData.width || 0;
        const height = tilemapData.height || 0;
        const totalCells = width * height;
        const density = tileCount / totalCells;

        if (density < 0.05) {
          improvements.push(`Tilemap is very sparse (${(density * 100).toFixed(1)}% filled). Consider generating more terrain.`);
        }

        // Count tile types
        const tileTypes = new Set<string>();
        for (const tile of Object.values(tiles) as any[]) {
          tileTypes.add(tile.type || 'unknown');
        }

        if (tileTypes.size === 1) {
          improvements.push('Only one tile type used. Add variety with paintTileRegion using different types.');
        }
      }

      // Check object variety
      if (objectCount > 0) {
        const objectTypes = new Set<string>();
        for (const obj of objectArray) {
          objectTypes.add(obj.type || 'unknown');
        }

        if (objectTypes.size === 1 && objectCount > 5) {
          improvements.push(`All ${objectCount} objects are the same type. Add variety with different shapes.`);
        }

        // Check for text objects (labels)
        const hasText = objectArray.some(obj => obj.type === 'text');
        if (!hasText && objectCount > 10) {
          improvements.push('Consider adding text labels for important areas (spawn point, goal, etc.)');
        }
      }

      // Check scale
      if (objectCount > 200) {
        warnings.push(`High object count (${objectCount}). Consider using tilemap for repetitive elements.`);
        improvements.push('Performance: Use tilemap for terrain instead of individual shapes');
      }

      if (tilemapData && tilemapData.width * tilemapData.height > 50000) {
        warnings.push('Large tilemap may impact performance. Consider reducing size.');
      }

      // General suggestions
      if (improvements.length === 0) {
        improvements.push('Canvas looks good! Consider adding:');
        improvements.push('- Animation for interactive objects');
        improvements.push('- Color variation for visual interest');
        improvements.push('- More detailed tilemap terrain');
      }

      const priority = warnings.length > 0 ? 'high' : improvements.length > 3 ? 'medium' : 'low';

      return {
        success: true,
        message: `Found ${improvements.length} improvement(s) and ${warnings.length} warning(s)`,
        data: {
          improvements,
          warnings,
          priority,
          stats: {
            objectCount,
            tileCount,
            canvasSize: tilemapData ? { width: tilemapData.width, height: tilemapData.height } : null,
          },
        },
      };
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to suggest improvements: ${error.message}`,
      };
    }
  },
};
</file>

<file path="functions/src/ai/tools/assetTools.ts">
/**
 * Asset Management Tools
 * AI tools for analyzing and managing game assets, animations, and exports
 * PR-31 & PR-32: Asset-aware AI integration with animation and export support
 */

import { ToolDefinition, ToolResult } from '../toolRegistry'
import { database } from '../../services/firebase'

/**
 * List all available assets
 * Helps AI know what sprites/tilesets are available to use
 */
export const listAssetsTool: ToolDefinition = {
  name: 'listAssets',
  description: 'List all available game assets (sprites, tilesets, etc.) that can be used in the canvas. Use this to see what visual assets are available before creating shapes or tilemaps.',
  parameters: {
    type: 'object',
    properties: {
      userId: {
        type: 'string',
        description: 'User ID to fetch assets for'
      },
      type: {
        type: 'string',
        enum: ['all', 'image', 'spritesheet', 'tileset', 'audio', 'font'],
        description: 'Filter by asset type (default: all)'
      }
    },
    required: ['userId']
  },
  execute: async (params: { userId: string; type?: string }): Promise<ToolResult> => {
    try {
      const { userId, type = 'all' } = params

      // Fetch assets from database
      const assetsRef = database.ref(`assets/${userId}`)
      const snapshot = await assetsRef.once('value')
      const assetsData = snapshot.val()

      if (!assetsData) {
        return {
          success: true,
          message: 'No assets found. User should upload some sprites or tilesets first.',
          data: { assets: [], count: 0 }
        }
      }

      // Convert to array and filter
      let assets = Object.entries(assetsData).map(([id, data]: [string, any]) => ({
        id,
        name: data.name,
        type: data.type,
        url: data.url,
        tags: data.tags || [],
        tilesetMetadata: data.tilesetMetadata,
        spriteSheetMetadata: data.spriteSheetMetadata,
        uploadedAt: data.uploadedAt
      }))

      if (type !== 'all') {
        assets = assets.filter(a => a.type === type)
      }

      // Build summary
      const summary = {
        total: assets.length,
        byType: assets.reduce((acc: any, asset) => {
          acc[asset.type] = (acc[asset.type] || 0) + 1
          return acc
        }, {}),
        tilesets: assets.filter(a => a.type === 'tileset').map(a => ({
          name: a.name,
          id: a.id,
          tileSize: a.tilesetMetadata ? `${a.tilesetMetadata.tileWidth}x${a.tilesetMetadata.tileHeight}` : 'unknown',
          tiles: a.tilesetMetadata?.tiles?.length || 0
        })),
        spritesheets: assets.filter(a => a.type === 'spritesheet').map(a => ({
          name: a.name,
          id: a.id,
          sprites: a.spriteSheetMetadata?.spriteSelections?.length || 0
        }))
      }

      return {
        success: true,
        message: `Found ${assets.length} asset(s). Tilesets: ${summary.tilesets.length}, Spritesheets: ${summary.spritesheets.length}`,
        data: {
          assets,
          summary
        }
      }
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to list assets: ${error.message}`
      }
    }
  }
}

/**
 * Analyze a sprite sheet / tileset
 * AI can examine an asset and suggest how to use it
 */
export const analyzeAssetTool: ToolDefinition = {
  name: 'analyzeAsset',
  description: 'Analyze a specific asset (sprite sheet or tileset) to understand its properties, tile sizes, and how it can be used. Returns detailed metadata about the asset.',
  parameters: {
    type: 'object',
    properties: {
      userId: {
        type: 'string',
        description: 'User ID'
      },
      assetId: {
        type: 'string',
        description: 'Asset ID to analyze'
      }
    },
    required: ['userId', 'assetId']
  },
  execute: async (params: { userId: string; assetId: string }): Promise<ToolResult> => {
    try {
      const { userId, assetId } = params

      // Fetch asset
      const assetRef = database.ref(`assets/${userId}/${assetId}`)
      const snapshot = await assetRef.once('value')
      const asset = snapshot.val()

      if (!asset) {
        return {
          success: false,
          error: `Asset ${assetId} not found`
        }
      }

      // Build analysis
      const analysis: any = {
        id: assetId,
        name: asset.name,
        type: asset.type,
        url: asset.url,
        tags: asset.tags || []
      }

      if (asset.tilesetMetadata) {
        analysis.tileset = {
          tileWidth: asset.tilesetMetadata.tileWidth,
          tileHeight: asset.tilesetMetadata.tileHeight,
          spacing: asset.tilesetMetadata.spacing || 0,
          margin: asset.tilesetMetadata.margin || 0,
          tiles: asset.tilesetMetadata.tiles || [],
          tileCount: asset.tilesetMetadata.tiles?.length || 0,
          hasAutoTile: asset.tilesetMetadata.autoTileMappings ? true : false,
          gridLayout: `${asset.tilesetMetadata.columns || '?'} columns × ${asset.tilesetMetadata.rows || '?'} rows`
        }
      }

      if (asset.spriteSheetMetadata) {
        analysis.spritesheet = {
          selectionMode: asset.spriteSheetMetadata.selectionMode || 'grid',
          sprites: asset.spriteSheetMetadata.spriteSelections || [],
          spriteCount: asset.spriteSheetMetadata.spriteSelections?.length || 0,
          sizes: asset.spriteSheetMetadata.spriteSelections?.map((s: any) => 
            `${s.name}: ${s.width}×${s.height}`
          ) || []
        }
      }

      // Generate usage suggestions
      const suggestions: string[] = []
      if (asset.type === 'tileset') {
        suggestions.push(`Use this tileset with the paintTileRegion tool to paint ${analysis.tileset?.tileCount || 0} different tiles`)
        if (analysis.tileset?.hasAutoTile) {
          suggestions.push('This tileset has auto-tile support for seamless terrain painting')
        }
      }
      if (asset.type === 'spritesheet') {
        suggestions.push(`This sprite sheet has ${analysis.spritesheet?.spriteCount || 0} individual sprites that can be used for game objects`)
      }

      return {
        success: true,
        message: `Analyzed ${asset.name} (${asset.type})`,
        data: {
          analysis,
          suggestions
        }
      }
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to analyze asset: ${error.message}`
      }
    }
  }
}

/**
 * Suggest tileset slicing strategy
 * AI examines image dimensions and suggests optimal slicing
 */
export const suggestSlicingTool: ToolDefinition = {
  name: 'suggestSlicing',
  description: 'Suggest how to slice/split a sprite sheet or tileset based on its dimensions. Recommends tile sizes, whether to use auto-detection or manual selection.',
  parameters: {
    type: 'object',
    properties: {
      width: {
        type: 'number',
        description: 'Image width in pixels'
      },
      height: {
        type: 'number',
        description: 'Image height in pixels'
      },
      imageUrl: {
        type: 'string',
        description: 'Optional URL to the image for visual analysis'
      }
    },
    required: ['width', 'height']
  },
  execute: async (params: { width: number; height: number; imageUrl?: string }): Promise<ToolResult> => {
    try {
      const { width, height } = params

      // Common tile sizes to check
      const commonSizes = [8, 16, 24, 32, 48, 64, 128]
      const suggestions: any[] = []

      // Check which tile sizes divide evenly
      for (const size of commonSizes) {
        const cols = width / size
        const rows = height / size

        if (Number.isInteger(cols) && Number.isInteger(rows)) {
          suggestions.push({
            tileSize: `${size}×${size}`,
            grid: `${cols}×${rows}`,
            totalTiles: cols * rows,
            confidence: 'high',
            reason: 'Divides evenly with no remainder'
          })
        }
      }

      // Check for near-matches (might have spacing/margin)
      for (const size of commonSizes) {
        const cols = Math.round(width / size)
        const rows = Math.round(height / size)
        const expectedWidth = cols * size
        const expectedHeight = rows * size
        const widthDiff = Math.abs(width - expectedWidth)
        const heightDiff = Math.abs(height - expectedHeight)

        // If close but not exact, might have spacing
        if (widthDiff > 0 && widthDiff < size * 0.3 && heightDiff > 0 && heightDiff < size * 0.3) {
          const avgSpacing = Math.round((widthDiff / cols + heightDiff / rows) / 2)
          if (avgSpacing > 0 && avgSpacing < 10) {
            suggestions.push({
              tileSize: `${size}×${size}`,
              grid: `${cols}×${rows}`,
              spacing: avgSpacing,
              totalTiles: cols * rows,
              confidence: 'medium',
              reason: `Likely has ${avgSpacing}px spacing between tiles`
            })
          }
        }
      }

      // Determine recommendation
      let recommendation = ''
      if (suggestions.length === 0) {
        recommendation = 'MANUAL_SELECTION_REQUIRED'
      } else if (suggestions[0].confidence === 'high') {
        recommendation = 'AUTO_DETECTION_RECOMMENDED'
      } else {
        recommendation = 'AUTO_DETECTION_WITH_SPACING'
      }

      return {
        success: true,
        message: `Analyzed ${width}×${height}px image. Found ${suggestions.length} possible tile configurations.`,
        data: {
          dimensions: { width, height },
          recommendation,
          suggestions: suggestions.slice(0, 5), // Top 5 suggestions
          advice: recommendation === 'MANUAL_SELECTION_REQUIRED' 
            ? 'This sprite sheet appears to have irregular sizes. Use manual selection with snap-to-grid (8px, 16px, or 32px) for best results.'
            : 'Auto-detection should work well. If results are not perfect, try adjusting spacing/margin or use manual selection.'
        }
      }
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to suggest slicing: ${error.message}`
      }
    }
  }
}

/**
 * Recommend asset for task
 * AI can ask which asset to use for a specific purpose
 */
export const recommendAssetTool: ToolDefinition = {
  name: 'recommendAsset',
  description: 'Recommend which asset to use for a specific game development task (e.g., "grass tiles", "player character", "enemy sprites"). Searches through available assets and suggests the best match.',
  parameters: {
    type: 'object',
    properties: {
      userId: {
        type: 'string',
        description: 'User ID'
      },
      purpose: {
        type: 'string',
        description: 'What you need the asset for (e.g., "grass terrain", "water tiles", "character sprite", "enemy")'
      },
      assetType: {
        type: 'string',
        enum: ['any', 'tileset', 'spritesheet', 'image'],
        description: 'Preferred asset type (default: any)'
      }
    },
    required: ['userId', 'purpose']
  },
  execute: async (params: { userId: string; purpose: string; assetType?: string }): Promise<ToolResult> => {
    try {
      const { userId, purpose, assetType = 'any' } = params

      // Fetch assets
      const assetsRef = database.ref(`assets/${userId}`)
      const snapshot = await assetsRef.once('value')
      const assetsData = snapshot.val()

      if (!assetsData) {
        return {
          success: false,
          error: 'No assets available. User should upload some assets first.'
        }
      }

      // Convert to array
      let assets = Object.entries(assetsData).map(([id, data]: [string, any]) => ({
        id,
        name: data.name,
        type: data.type,
        tags: data.tags || [],
        tilesetMetadata: data.tilesetMetadata,
        spriteSheetMetadata: data.spriteSheetMetadata
      }))

      // Filter by type if specified
      if (assetType !== 'any') {
        assets = assets.filter(a => a.type === assetType)
      }

      // Search for matching assets (name and tags)
      const searchTerms = purpose.toLowerCase().split(/\s+/)
      const scored = assets.map(asset => {
        let score = 0
        const assetText = `${asset.name} ${asset.tags.join(' ')}`.toLowerCase()

        // Score based on matching terms
        for (const term of searchTerms) {
          if (assetText.includes(term)) {
            score += 10
          }
        }

        // Boost tilesets for terrain-related queries
        if ((purpose.includes('terrain') || purpose.includes('tile') || purpose.includes('ground')) 
            && asset.type === 'tileset') {
          score += 5
        }

        return { asset, score }
      })

      // Sort by score
      scored.sort((a, b) => b.score - a.score)
      const matches = scored.filter(s => s.score > 0).map(s => s.asset)

      if (matches.length === 0) {
        return {
          success: false,
          error: `No assets found matching "${purpose}". Available assets: ${assets.map(a => a.name).join(', ')}`
        }
      }

      return {
        success: true,
        message: `Found ${matches.length} asset(s) matching "${purpose}". Best match: ${matches[0].name}`,
        data: {
          recommendation: matches[0],
          alternatives: matches.slice(1, 4),
          allAssets: assets.map(a => ({ id: a.id, name: a.name, type: a.type }))
        }
      }
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to recommend asset: ${error.message}`
      }
    }
  }
}

/**
 * Create Animation Tool
 * Create a sprite animation from a sprite sheet
 */
export const createAnimationTool: ToolDefinition = {
  name: 'createAnimation',
  description: 'Create a sprite animation from a sprite sheet by defining frame regions. This allows sprites to be animated on the canvas.',
  parameters: {
    type: 'object',
    properties: {
      name: {
        type: 'string',
        description: 'Name for the animation (e.g., "walk_right", "jump", "attack")'
      },
      spriteSheetId: {
        type: 'string',
        description: 'ID of the sprite sheet asset to use'
      },
      frames: {
        type: 'array',
        description: 'Array of frame definitions with x, y, width, height properties',
        items: {
          type: 'object',
          properties: {
            x: { type: 'number', description: 'X coordinate in sprite sheet' },
            y: { type: 'number', description: 'Y coordinate in sprite sheet' },
            width: { type: 'number', description: 'Frame width' },
            height: { type: 'number', description: 'Frame height' }
          }
        }
      },
      fps: {
        type: 'number',
        description: 'Frames per second (1-60, default: 12)',
        minimum: 1,
        maximum: 60
      },
      loop: {
        type: 'boolean',
        description: 'Whether the animation should loop (default: true)'
      },
      userId: {
        type: 'string',
        description: 'User ID'
      },
      canvasId: {
        type: 'string',
        description: 'Canvas ID (optional - if not provided, animation is global to user)'
      }
    },
    required: ['name', 'spriteSheetId', 'frames', 'userId']
  },
  execute: async (params: any): Promise<ToolResult> => {
    try {
      const {
        name,
        spriteSheetId,
        frames,
        fps = 12,
        loop = true,
        userId,
        canvasId
      } = params

      // Generate animation ID
      const animationId = `animation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      
      const animation = {
        id: animationId,
        userId,
        canvasId: canvasId || null,
        name,
        spriteSheetId,
        frames,
        fps,
        loop,
        createdAt: Date.now(),
        updatedAt: Date.now()
      }

      // Save to database
      await database.ref(`animations/${animationId}`).set(animation)

      return {
        success: true,
        message: `Created animation "${name}" with ${frames.length} frames at ${fps} FPS`,
        data: { animationId, animation }
      }
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to create animation: ${error.message}`
      }
    }
  }
}

/**
 * Export Canvas Tool
 * Export the canvas to various game engine formats
 */
export const exportCanvasTool: ToolDefinition = {
  name: 'exportCanvas',
  description: 'Export the canvas to a game engine format (Godot, Generic JSON). Validates the canvas and provides download instructions.',
  parameters: {
    type: 'object',
    properties: {
      canvasId: {
        type: 'string',
        description: 'Canvas ID to export'
      },
      format: {
        type: 'string',
        enum: ['godot', 'generic'],
        description: 'Export format: godot (.tscn) or generic (JSON + PNG)'
      },
      options: {
        type: 'object',
        description: 'Format-specific export options',
        properties: {
          includeAssets: { type: 'boolean', description: 'Include asset files in export (default: true)' },
          prettyPrint: { type: 'boolean', description: 'Format JSON for readability (default: true)' },
          includeDocumentation: { type: 'boolean', description: 'Include import instructions (default: true)' }
        }
      }
    },
    required: ['canvasId', 'format']
  },
  execute: async (params: any): Promise<ToolResult> => {
    try {
      const { canvasId, format, options = {} } = params

      // Note: Actual export is handled client-side by the export modal
      // This tool just provides information and validates the request
      
      return {
        success: true,
        message: `Export request created for canvas in ${format} format. The user will see an export modal with download options.`,
        data: {
          canvasId,
          format,
          options,
          instruction: 'Open the Export modal in the UI to download the exported files. The files will be packaged as a ZIP archive with instructions.'
        }
      }
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to export canvas: ${error.message}`
      }
    }
  }
}
</file>

<file path="functions/src/ai/tools/optimizationTools.ts">
/**
 * Optimization Tools
 * Analyze performance and suggest optimizations
 * PR-32: AI Game-Aware Enhancement
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import { checkUserPermission } from '../safety';

/**
 * Analyze Performance Tool
 * Analyzes canvas performance and identifies bottlenecks
 */
export const analyzePerformanceTool: ToolDefinition = {
  name: 'analyzePerformance',
  description: 'Analyze canvas performance and identify bottlenecks. Returns FPS estimate, object count, memory usage, and specific optimization suggestions.',
  parameters: {
    type: 'object',
    properties: {},
    required: [],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Get canvas objects
      const db = admin.database();
      const objectsRef = db.ref(`canvases/${context.canvasId}/objects`);
      const objectsSnap = await objectsRef.once('value');
      const objects = objectsSnap.val() || {};

      // Get tilemap
      const tilemapRef = db.ref(`canvases/${context.canvasId}/tilemap`);
      const tilemapSnap = await tilemapRef.once('value');
      const tilemapData = tilemapSnap.val();

      const tilesRef = db.ref(`canvases/${context.canvasId}/tilemap/tiles`);
      const tilesSnap = await tilesRef.once('value');
      const tiles = tilesSnap.val() || {};

      const objectCount = Object.keys(objects).length;
      const tileCount = Object.keys(tiles).length;

      // Estimate performance
      const performance = analyzeCanvasPerformance(
        objectCount,
        tileCount,
        tilemapData?.width,
        tilemapData?.height
      );

      return {
        success: true,
        message: `Performance analysis complete: ${performance.rating} (score: ${performance.score}/100)`,
        data: performance,
      };
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to analyze performance: ${error.message}`,
      };
    }
  },
};

/**
 * Estimate Export Size Tool
 * Estimates the export file size for different formats
 */
export const estimateExportSizeTool: ToolDefinition = {
  name: 'estimateExportSize',
  description: 'Estimate the export file size for different game engine formats (Generic JSON, Godot, Unity, Phaser).',
  parameters: {
    type: 'object',
    properties: {
      format: {
        type: 'string',
        description: 'Export format to estimate',
        enum: ['generic', 'godot', 'unity', 'phaser'],
      },
    },
    required: [],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Get canvas data
      const db = admin.database();
      const objectsRef = db.ref(`canvases/${context.canvasId}/objects`);
      const objectsSnap = await objectsRef.once('value');
      const objects = objectsSnap.val() || {};

      const tilesRef = db.ref(`canvases/${context.canvasId}/tilemap/tiles`);
      const tilesSnap = await tilesRef.once('value');
      const tiles = tilesSnap.val() || {};

      const objectCount = Object.keys(objects).length;
      const tileCount = Object.keys(tiles).length;

      // Estimate sizes for each format
      const estimates = {
        generic: estimateGenericSize(objectCount, tileCount),
        godot: estimateGodotSize(objectCount, tileCount),
        unity: estimateUnitySize(objectCount, tileCount),
        phaser: estimatePhaserSize(objectCount, tileCount),
      };

      const selectedFormat = params.format || 'generic';
      const estimate = estimates[selectedFormat];

      // Size warnings
      const warnings: string[] = [];
      if (estimate.totalKB > 1000) {
        warnings.push('Export size > 1 MB. Consider optimizing.');
      }
      if (estimate.totalKB > 5000) {
        warnings.push('Very large export (> 5 MB). May be slow to load in game engine.');
      }

      return {
        success: true,
        message: `Estimated ${selectedFormat} export size: ${(estimate.totalKB / 1024).toFixed(2)} MB`,
        data: {
          format: selectedFormat,
          estimate,
          allEstimates: estimates,
          warnings,
        },
      };
    } catch (error: any) {
      return {
        success: false,
        error: `Failed to estimate export size: ${error.message}`,
      };
    }
  },
};

/**
 * Analyze canvas performance
 */
function analyzeCanvasPerformance(
  objectCount: number,
  tileCount: number,
  tilemapWidth?: number,
  tilemapHeight?: number
): {
  score: number;
  rating: 'excellent' | 'good' | 'fair' | 'poor';
  fps: number;
  objectCount: number;
  tileCount: number;
  drawCalls: number;
  memoryMB: number;
  bottlenecks: string[];
  suggestions: string[];
} {
  let score = 100;
  const bottlenecks: string[] = [];
  const suggestions: string[] = [];

  // Estimate FPS
  let fps = 60;
  if (objectCount > 1000) fps -= 20;
  else if (objectCount > 500) fps -= 10;
  else if (objectCount > 200) fps -= 5;

  if (tileCount > 50000) fps -= 15;
  else if (tileCount > 10000) fps -= 5;

  fps = Math.max(fps, 15);

  // Calculate score
  if (objectCount > 1000) {
    score -= 30;
    bottlenecks.push(`Too many objects (${objectCount})`);
    suggestions.push('Use tilemap for terrain instead of individual shapes');
  } else if (objectCount > 500) {
    score -= 15;
    bottlenecks.push(`High object count (${objectCount})`);
    suggestions.push('Consider grouping or caching static objects');
  }

  if (tileCount > 50000) {
    score -= 25;
    bottlenecks.push(`Very large tilemap (${tileCount} tiles)`);
    suggestions.push('Reduce tilemap size or implement chunking');
  } else if (tileCount > 10000) {
    score -= 10;
  }

  if (fps < 30) {
    score -= 30;
    bottlenecks.push(`Low FPS (${fps.toFixed(1)})`);
    suggestions.push('Reduce object count or enable viewport culling');
  } else if (fps < 45) {
    score -= 15;
  }

  // Estimate draw calls and memory
  const drawCalls = objectCount + Math.ceil(tileCount / 1000);
  const memoryMB = (objectCount * 0.001) + (tileCount * 0.0001);

  if (drawCalls > 2000) {
    score -= 20;
    bottlenecks.push(`Excessive draw calls (${drawCalls})`);
    suggestions.push('Batch objects with same properties');
  }

  score = Math.max(0, score);

  // Rating
  let rating: 'excellent' | 'good' | 'fair' | 'poor';
  if (score >= 80) {
    rating = 'excellent';
  } else if (score >= 60) {
    rating = 'good';
    if (suggestions.length === 0) {
      suggestions.push('Performance is good. Minor optimizations possible.');
    }
  } else if (score >= 40) {
    rating = 'fair';
    suggestions.push('Optimizations recommended for better performance');
  } else {
    rating = 'poor';
    suggestions.push('Significant optimizations required');
  }

  return {
    score,
    rating,
    fps,
    objectCount,
    tileCount,
    drawCalls,
    memoryMB,
    bottlenecks,
    suggestions
  };
}

/**
 * Estimate Generic JSON export size
 */
function estimateGenericSize(objectCount: number, tileCount: number): {
  objectsKB: number;
  tilemapKB: number;
  metadataKB: number;
  totalKB: number;
} {
  // JSON is verbose, ~200 bytes per object
  const objectsKB = (objectCount * 0.2);
  
  // Tiles are simpler, ~50 bytes each
  const tilemapKB = (tileCount * 0.05);
  
  // Metadata and schema
  const metadataKB = 2;

  return {
    objectsKB: parseFloat(objectsKB.toFixed(2)),
    tilemapKB: parseFloat(tilemapKB.toFixed(2)),
    metadataKB,
    totalKB: parseFloat((objectsKB + tilemapKB + metadataKB).toFixed(2))
  };
}

/**
 * Estimate Godot export size
 */
function estimateGodotSize(objectCount: number, tileCount: number): {
  sceneKB: number;
  assetsKB: number;
  totalKB: number;
} {
  // .tscn format is text-based, ~150 bytes per node
  const sceneKB = (objectCount * 0.15) + (tileCount * 0.03);
  
  // Assume some assets are referenced
  const assetsKB = 10; // Placeholder for external assets

  return {
    sceneKB: parseFloat(sceneKB.toFixed(2)),
    assetsKB,
    totalKB: parseFloat((sceneKB + assetsKB).toFixed(2))
  };
}

/**
 * Estimate Unity export size
 */
function estimateUnitySize(objectCount: number, tileCount: number): {
  prefabKB: number;
  assetsKB: number;
  totalKB: number;
} {
  // Prefab format is YAML-based
  const prefabKB = (objectCount * 0.18) + (tileCount * 0.04);
  
  // Assets
  const assetsKB = 15;

  return {
    prefabKB: parseFloat(prefabKB.toFixed(2)),
    assetsKB,
    totalKB: parseFloat((prefabKB + assetsKB).toFixed(2))
  };
}

/**
 * Estimate Phaser export size
 */
function estimatePhaserSize(objectCount: number, tileCount: number): {
  sceneKB: number;
  atlasKB: number;
  totalKB: number;
} {
  // Scene JSON
  const sceneKB = (objectCount * 0.12) + (tileCount * 0.03);
  
  // Texture atlas
  const atlasKB = 5;

  return {
    sceneKB: parseFloat(sceneKB.toFixed(2)),
    atlasKB,
    totalKB: parseFloat((sceneKB + atlasKB).toFixed(2))
  };
}
</file>

<file path="src/algorithms/cellularAutomata.ts">
/**
 * Cellular Automata Generator
 * Implements cave and dungeon generation using cellular automata rules
 */

/**
 * Parameters for cellular automata generation
 */
export interface CellularAutomataParams {
  initialDensity: number; // Starting fill ratio (0-1), higher = more walls
  birthLimit: number; // Neighbors needed for cell birth (typically 4)
  deathLimit: number; // Neighbors needed to stay alive (typically 4)
  iterations: number; // Simulation steps (4-10 typical)
  seed?: number; // Seed for reproducible generation
}

/**
 * Default parameters for cave generation
 */
export const DEFAULT_CAVE_PARAMS: CellularAutomataParams = {
  initialDensity: 0.45,
  birthLimit: 4,
  deathLimit: 3,
  iterations: 5
};

/**
 * Default parameters for dungeon generation
 */
export const DEFAULT_DUNGEON_PARAMS: CellularAutomataParams = {
  initialDensity: 0.48,
  birthLimit: 4,
  deathLimit: 4,
  iterations: 4
};

/**
 * Seeded random number generator
 */
class SeededRandom {
  private seed: number;

  constructor(seed: number) {
    this.seed = seed;
  }

  next(): number {
    const x = Math.sin(this.seed++) * 10000;
    return x - Math.floor(x);
  }
}

/**
 * Initialize random grid based on density
 * Returns 2D array where true = wall, false = floor
 */
function initializeGrid(
  width: number,
  height: number,
  density: number,
  random: SeededRandom
): boolean[][] {
  const grid: boolean[][] = [];

  for (let y = 0; y < height; y++) {
    const row: boolean[] = [];
    for (let x = 0; x < width; x++) {
      // Always wall on edges
      if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
        row.push(true);
      } else {
        row.push(random.next() < density);
      }
    }
    grid.push(row);
  }

  return grid;
}

/**
 * Count alive neighbors (Moore neighborhood - 8 neighbors)
 */
function countAliveNeighbors(
  grid: boolean[][],
  x: number,
  y: number
): number {
  let count = 0;
  const height = grid.length;
  const width = grid[0]?.length || 0;

  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue; // Skip self

      const nx = x + dx;
      const ny = y + dy;

      // Treat out of bounds as walls
      if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
        count++;
      } else if (grid[ny][nx]) {
        count++;
      }
    }
  }

  return count;
}

/**
 * Apply cellular automata rules for one step
 */
function step(
  grid: boolean[][],
  birthLimit: number,
  deathLimit: number
): boolean[][] {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const newGrid: boolean[][] = [];

  for (let y = 0; y < height; y++) {
    const row: boolean[] = [];
    for (let x = 0; x < width; x++) {
      const neighbors = countAliveNeighbors(grid, x, y);
      const isAlive = grid[y][x];

      // Keep edges as walls
      if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
        row.push(true);
      }
      // Apply birth/death rules
      else if (isAlive) {
        row.push(neighbors >= deathLimit);
      } else {
        row.push(neighbors >= birthLimit);
      }
    }
    newGrid.push(row);
  }

  return newGrid;
}

/**
 * Generate cave or dungeon using cellular automata
 * Returns 2D array where true = wall, false = floor
 */
export function generateCave(
  width: number,
  height: number,
  params: CellularAutomataParams = DEFAULT_CAVE_PARAMS
): boolean[][] {
  const random = new SeededRandom(params.seed || Date.now());

  // Initialize random grid
  let grid = initializeGrid(width, height, params.initialDensity, random);

  // Apply cellular automata rules
  for (let i = 0; i < params.iterations; i++) {
    grid = step(grid, params.birthLimit, params.deathLimit);
  }

  return grid;
}

/**
 * Remove single-tile islands (smoothing pass)
 * Fills in isolated floor tiles, removes isolated walls
 */
export function removeIslands(
  grid: boolean[][],
  minRegionSize: number = 5
): boolean[][] {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const newGrid = grid.map(row => [...row]);

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const neighbors = countAliveNeighbors(grid, x, y);

      // If floor surrounded by walls, fill it
      if (!grid[y][x] && neighbors >= 7) {
        newGrid[y][x] = true;
      }

      // If wall surrounded by floors, remove it
      if (grid[y][x] && neighbors <= 1) {
        newGrid[y][x] = false;
      }
    }
  }

  return newGrid;
}

/**
 * Flood fill to find connected regions
 */
function floodFill(
  grid: boolean[][],
  startX: number,
  startY: number,
  visited: Set<string>
): number {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const queue: [number, number][] = [[startX, startY]];
  let count = 0;

  while (queue.length > 0) {
    const [x, y] = queue.shift()!;
    const key = `${x},${y}`;

    if (visited.has(key)) continue;
    if (x < 0 || x >= width || y < 0 || y >= height) continue;
    if (grid[y][x]) continue; // Wall

    visited.add(key);
    count++;

    // Add neighbors
    queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
  }

  return count;
}

/**
 * Find all regions and connect them with corridors
 * Ensures all floor areas are connected
 */
export function connectRegions(grid: boolean[][]): boolean[][] {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const visited = new Set<string>();
  const regions: { x: number; y: number; size: number }[] = [];

  // Find all regions
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const key = `${x},${y}`;
      if (!visited.has(key) && !grid[y][x]) {
        const size = floodFill(grid, x, y, visited);
        if (size > 10) {
          // Only keep significant regions
          regions.push({ x, y, size });
        }
      }
    }
  }

  // If only one region, we're done
  if (regions.length <= 1) {
    return grid;
  }

  // Sort by size (largest first)
  regions.sort((a, b) => b.size - a.size);

  // Connect all regions to the largest one
  const newGrid = grid.map(row => [...row]);
  const mainRegion = regions[0];

  for (let i = 1; i < regions.length; i++) {
    const region = regions[i];

    // Draw corridor from region to main region
    let x = region.x;
    let y = region.y;

    // Move horizontally
    while (x !== mainRegion.x) {
      newGrid[y][x] = false;
      x += x < mainRegion.x ? 1 : -1;
    }

    // Move vertically
    while (y !== mainRegion.y) {
      newGrid[y][x] = false;
      y += y < mainRegion.y ? 1 : -1;
    }

    // Widen corridor slightly
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1) {
          if (Math.random() > 0.5) {
            // Random widening
            newGrid[ny][nx] = false;
          }
        }
      }
    }
  }

  return newGrid;
}

/**
 * Convert boolean grid to tilemap
 * Maps walls to 'wall' tile type, floors to 'floor' tile type
 */
export function gridToTilemap(
  grid: boolean[][],
  wallTile: string = 'stone',
  floorTile: string = 'dirt'
): string[][] {
  return grid.map(row =>
    row.map(isWall => (isWall ? wallTile : floorTile))
  );
}

/**
 * Generate complete cave tilemap with all processing
 */
export function generateCaveTilemap(
  width: number,
  height: number,
  params: CellularAutomataParams = DEFAULT_CAVE_PARAMS,
  options: {
    removeIslands?: boolean;
    connectRegions?: boolean;
    wallTile?: string;
    floorTile?: string;
  } = {}
): string[][] {
  const {
    removeIslands: shouldRemoveIslands = true,
    connectRegions: shouldConnectRegions = true,
    wallTile = 'stone',
    floorTile = 'dirt'
  } = options;

  // Generate base cave
  let grid = generateCave(width, height, params);

  // Post-processing
  if (shouldRemoveIslands) {
    grid = removeIslands(grid);
  }

  if (shouldConnectRegions) {
    grid = connectRegions(grid);
  }

  // Convert to tilemap
  return gridToTilemap(grid, wallTile, floorTile);
}

/**
 * Get random floor position (for placing objects)
 */
export function getRandomFloorPosition(
  grid: boolean[][],
  random?: SeededRandom
): { x: number; y: number } | null {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const rng = random || new SeededRandom(Date.now());

  // Try up to 100 times to find floor tile
  for (let attempt = 0; attempt < 100; attempt++) {
    const x = Math.floor(rng.next() * width);
    const y = Math.floor(rng.next() * height);

    if (!grid[y][x]) {
      return { x, y };
    }
  }

  // Fallback: find first floor tile
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      if (!grid[y][x]) {
        return { x, y };
      }
    }
  }

  return null;
}

/**
 * Count floor tiles (useful for density metrics)
 */
export function countFloorTiles(grid: boolean[][]): number {
  let count = 0;
  for (const row of grid) {
    for (const cell of row) {
      if (!cell) count++;
    }
  }
  return count;
}

/**
 * Get density of cave (ratio of floor to total)
 */
export function getCaveDensity(grid: boolean[][]): number {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const total = width * height;
  const floor = countFloorTiles(grid);
  return floor / total;
}
</file>

<file path="src/algorithms/perlinNoise.ts">
/**
 * Perlin Noise Generator
 * Implements classic Perlin noise for natural-looking terrain generation
 */

/**
 * Parameters for Perlin noise generation
 */
export interface PerlinNoiseParams {
  scale: number; // Controls feature size (0.01-1.0)
  octaves: number; // Number of noise layers (1-8)
  persistence: number; // Amplitude multiplier per octave (0-1)
  lacunarity: number; // Frequency multiplier per octave (>1)
  seed?: number; // Seed for reproducible generation
}

/**
 * Height map thresholds for tile type mapping
 */
export interface HeightMapThresholds {
  [tileType: string]: { min: number; max: number };
}

/**
 * Default Perlin noise parameters
 */
export const DEFAULT_PERLIN_PARAMS: PerlinNoiseParams = {
  scale: 0.1,
  octaves: 4,
  persistence: 0.5,
  lacunarity: 2.0,
  seed: Math.random() * 1000000
};

/**
 * Permutation table for Perlin noise (Ken Perlin's original)
 */
const PERMUTATION = [
  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
  36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
  234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
  88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
  134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
  230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
  1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
  116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
  124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
  47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
  154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
  108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
  242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
  239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
  50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
  141, 128, 195, 78, 66, 215, 61, 156, 180
];

/**
 * Seeded random number generator (for reproducible noise)
 */
class SeededRandom {
  private seed: number;

  constructor(seed: number) {
    this.seed = seed;
  }

  next(): number {
    const x = Math.sin(this.seed++) * 10000;
    return x - Math.floor(x);
  }
}

/**
 * Perlin Noise Generator class
 */
export class PerlinNoiseGenerator {
  private p: number[];
  private random: SeededRandom;

  constructor(seed?: number) {
    this.random = new SeededRandom(seed || Date.now());
    this.p = new Array(512);

    // Create seeded permutation table
    const perm = [...PERMUTATION];
    
    // Fisher-Yates shuffle with seeded random
    if (seed !== undefined) {
      for (let i = perm.length - 1; i > 0; i--) {
        const j = Math.floor(this.random.next() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
    }

    // Duplicate permutation table
    for (let i = 0; i < 256; i++) {
      this.p[i] = this.p[i + 256] = perm[i];
    }
  }

  /**
   * Fade function for smooth interpolation (6t^5 - 15t^4 + 10t^3)
   */
  private fade(t: number): number {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  /**
   * Linear interpolation
   */
  private lerp(t: number, a: number, b: number): number {
    return a + t * (b - a);
  }

  /**
   * Gradient function
   */
  private grad(hash: number, x: number, y: number): number {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  /**
   * 2D Perlin noise function
   * Returns value between -1 and 1
   */
  private noise2D(x: number, y: number): number {
    // Find unit grid cell containing point
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;

    // Get relative xy coordinates of point within cell
    x -= Math.floor(x);
    y -= Math.floor(y);

    // Compute fade curves
    const u = this.fade(x);
    const v = this.fade(y);

    // Hash coordinates of 4 cube corners
    const aa = this.p[this.p[X] + Y];
    const ab = this.p[this.p[X] + Y + 1];
    const ba = this.p[this.p[X + 1] + Y];
    const bb = this.p[this.p[X + 1] + Y + 1];

    // Blend results from 4 corners
    return this.lerp(
      v,
      this.lerp(u, this.grad(aa, x, y), this.grad(ba, x - 1, y)),
      this.lerp(u, this.grad(ab, x, y - 1), this.grad(bb, x - 1, y - 1))
    );
  }

  /**
   * Generate 2D Perlin noise with octaves
   * Returns value between -1 and 1
   */
  public noise(x: number, y: number, params: PerlinNoiseParams): number {
    let value = 0;
    let amplitude = 1;
    let frequency = params.scale;
    let maxValue = 0;

    // Add octaves
    for (let i = 0; i < params.octaves; i++) {
      value += this.noise2D(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;

      amplitude *= params.persistence;
      frequency *= params.lacunarity;
    }

    // Normalize to [-1, 1]
    return value / maxValue;
  }
}

/**
 * Generate a height map using Perlin noise
 * Returns 2D array of normalized values (0-1)
 */
export function generateHeightMap(
  width: number,
  height: number,
  params: PerlinNoiseParams = DEFAULT_PERLIN_PARAMS
): number[][] {
  const generator = new PerlinNoiseGenerator(params.seed);
  const heightMap: number[][] = [];

  for (let y = 0; y < height; y++) {
    const row: number[] = [];
    for (let x = 0; x < width; x++) {
      // Get noise value (-1 to 1) and normalize to (0 to 1)
      const noiseValue = generator.noise(x, y, params);
      const normalized = (noiseValue + 1) / 2;
      row.push(normalized);
    }
    heightMap.push(row);
  }

  return heightMap;
}

/**
 * Convert height map to tilemap using thresholds
 * Maps height values to tile types
 */
export function heightMapToTilemap(
  heightMap: number[][],
  thresholds: HeightMapThresholds
): string[][] {
  const height = heightMap.length;
  const width = heightMap[0]?.length || 0;
  const tilemap: string[][] = [];

  for (let y = 0; y < height; y++) {
    const row: string[] = [];
    for (let x = 0; x < width; x++) {
      const value = heightMap[y][x];

      // Find matching tile type
      let tileType = 'grass'; // default
      for (const [type, range] of Object.entries(thresholds)) {
        if (value >= range.min && value < range.max) {
          tileType = type;
          break;
        }
      }

      row.push(tileType);
    }
    tilemap.push(row);
  }

  return tilemap;
}

/**
 * Default thresholds for common terrain types
 */
export const DEFAULT_TERRAIN_THRESHOLDS: HeightMapThresholds = {
  water: { min: 0.0, max: 0.3 },
  sand: { min: 0.3, max: 0.4 },
  grass: { min: 0.4, max: 0.6 },
  dirt: { min: 0.6, max: 0.7 },
  stone: { min: 0.7, max: 0.85 },
  mountain: { min: 0.85, max: 1.0 }
};

/**
 * Generate a complete terrain tilemap in one call
 */
export function generateTerrainTilemap(
  width: number,
  height: number,
  params: PerlinNoiseParams = DEFAULT_PERLIN_PARAMS,
  thresholds: HeightMapThresholds = DEFAULT_TERRAIN_THRESHOLDS
): string[][] {
  const heightMap = generateHeightMap(width, height, params);
  return heightMapToTilemap(heightMap, thresholds);
}

/**
 * Apply smoothing to height map (reduces noise, makes terrain gentler)
 */
export function smoothHeightMap(
  heightMap: number[][],
  radius: number = 1
): number[][] {
  const height = heightMap.length;
  const width = heightMap[0]?.length || 0;
  const smoothed: number[][] = [];

  for (let y = 0; y < height; y++) {
    const row: number[] = [];
    for (let x = 0; x < width; x++) {
      let sum = 0;
      let count = 0;

      // Average with neighbors
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const nx = x + dx;
          const ny = y + dy;

          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            sum += heightMap[ny][nx];
            count++;
          }
        }
      }

      row.push(sum / count);
    }
    smoothed.push(row);
  }

  return smoothed;
}
</file>

<file path="src/algorithms/randomWalk.ts">
/**
 * Random Walk Generator
 * Implements path and river generation using random walk algorithm
 */

/**
 * Direction for random walk
 */
type Direction = 'north' | 'south' | 'east' | 'west';

/**
 * Parameters for random walk generation
 */
export interface RandomWalkParams {
  steps: number; // Length of walk (number of steps)
  turnProbability: number; // Chance to change direction (0-1)
  branchProbability: number; // Chance to split path (0-1)
  width: number; // Path thickness (1-10)
  seed?: number; // Seed for reproducible generation
}

/**
 * Default parameters for path generation
 */
export const DEFAULT_PATH_PARAMS: RandomWalkParams = {
  steps: 100,
  turnProbability: 0.2,
  branchProbability: 0.05,
  width: 2,
  seed: Date.now()
};

/**
 * Default parameters for river generation
 */
export const DEFAULT_RIVER_PARAMS: RandomWalkParams = {
  steps: 150,
  turnProbability: 0.15,
  branchProbability: 0.1,
  width: 3,
  seed: Date.now()
};

/**
 * Seeded random number generator
 */
class SeededRandom {
  private seed: number;

  constructor(seed: number) {
    this.seed = seed;
  }

  next(): number {
    const x = Math.sin(this.seed++) * 10000;
    return x - Math.floor(x);
  }

  choice<T>(array: T[]): T {
    return array[Math.floor(this.next() * array.length)];
  }
}

/**
 * Get direction vector
 */
function getDirectionVector(direction: Direction): { dx: number; dy: number } {
  switch (direction) {
    case 'north':
      return { dx: 0, dy: -1 };
    case 'south':
      return { dx: 0, dy: 1 };
    case 'east':
      return { dx: 1, dy: 0 };
    case 'west':
      return { dx: -1, dy: 0 };
  }
}

/**
 * Get perpendicular directions
 */
function getPerpendicularDirections(direction: Direction): Direction[] {
  switch (direction) {
    case 'north':
    case 'south':
      return ['east', 'west'];
    case 'east':
    case 'west':
      return ['north', 'south'];
  }
}

/**
 * Perform random walk and return list of coordinates
 */
export function generatePath(
  startX: number,
  startY: number,
  params: RandomWalkParams = DEFAULT_PATH_PARAMS
): Array<{ x: number; y: number }> {
  const random = new SeededRandom(params.seed || Date.now());
  const path: Array<{ x: number; y: number }> = [];
  const branches: Array<{
    x: number;
    y: number;
    direction: Direction;
    remainingSteps: number;
  }> = [];

  let x = startX;
  let y = startY;
  let direction: Direction = random.choice(['north', 'south', 'east', 'west']);

  // Main walk
  for (let step = 0; step < params.steps; step++) {
    path.push({ x, y });

    // Branch?
    if (random.next() < params.branchProbability && branches.length < 3) {
      const branchDirection = random.choice(
        getPerpendicularDirections(direction)
      );
      branches.push({
        x,
        y,
        direction: branchDirection,
        remainingSteps: Math.floor(params.steps * 0.3) // Branches are shorter
      });
    }

    // Turn?
    if (random.next() < params.turnProbability) {
      direction = random.choice(getPerpendicularDirections(direction));
    }

    // Move
    const { dx, dy } = getDirectionVector(direction);
    x += dx;
    y += dy;
  }

  // Process branches
  for (const branch of branches) {
    let bx = branch.x;
    let by = branch.y;
    let bDirection = branch.direction;

    for (let step = 0; step < branch.remainingSteps; step++) {
      path.push({ x: bx, y: by });

      // Branches turn less frequently
      if (random.next() < params.turnProbability * 0.5) {
        bDirection = random.choice(getPerpendicularDirections(bDirection));
      }

      const { dx, dy } = getDirectionVector(bDirection);
      bx += dx;
      by += dy;
    }
  }

  return path;
}

/**
 * Apply width to path coordinates
 */
export function thickenPath(
  path: Array<{ x: number; y: number }>,
  width: number
): Array<{ x: number; y: number }> {
  if (width <= 1) return path;

  const thickPath: Array<{ x: number; y: number }> = [];
  const added = new Set<string>();
  const radius = Math.floor(width / 2);

  for (const { x, y } of path) {
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        // Use circular shape instead of square
        if (dx * dx + dy * dy <= radius * radius) {
          const key = `${x + dx},${y + dy}`;
          if (!added.has(key)) {
            thickPath.push({ x: x + dx, y: y + dy });
            added.add(key);
          }
        }
      }
    }
  }

  return thickPath;
}

/**
 * Smooth path using Catmull-Rom spline (simplified)
 * Returns interpolated points between original path points
 */
export function smoothPath(
  path: Array<{ x: number; y: number }>,
  smoothness: number = 4
): Array<{ x: number; y: number }> {
  if (path.length < 3) return path;

  const smoothed: Array<{ x: number; y: number }> = [];

  for (let i = 0; i < path.length - 1; i++) {
    const p0 = path[Math.max(0, i - 1)];
    const p1 = path[i];
    const p2 = path[i + 1];
    const p3 = path[Math.min(path.length - 1, i + 2)];

    for (let t = 0; t < smoothness; t++) {
      const u = t / smoothness;
      const uu = u * u;
      const uuu = uu * u;

      // Catmull-Rom spline formula (simplified)
      const x =
        0.5 *
        (2 * p1.x +
          (-p0.x + p2.x) * u +
          (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * uu +
          (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * uuu);

      const y =
        0.5 *
        (2 * p1.y +
          (-p0.y + p2.y) * u +
          (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * uu +
          (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * uuu);

      smoothed.push({ x: Math.round(x), y: Math.round(y) });
    }
  }

  // Add last point
  smoothed.push(path[path.length - 1]);

  return smoothed;
}

/**
 * Apply variable width to path (organic-looking)
 */
export function applyWidthVariation(
  path: Array<{ x: number; y: number }>,
  baseWidth: number,
  variation: number = 0.3,
  seed?: number
): Array<{ x: number; y: number }> {
  const random = new SeededRandom(seed || Date.now());
  const result: Array<{ x: number; y: number }> = [];

  for (let i = 0; i < path.length; i++) {
    const { x, y } = path[i];
    const widthMultiplier = 1 + (random.next() - 0.5) * variation;
    const width = Math.max(1, Math.round(baseWidth * widthMultiplier));

    // Add thickened point
    const thick = thickenPath([{ x, y }], width);
    result.push(...thick);
  }

  // Remove duplicates
  const unique = new Map<string, { x: number; y: number }>();
  for (const point of result) {
    unique.set(`${point.x},${point.y}`, point);
  }

  return Array.from(unique.values());
}

/**
 * Convert path coordinates to tilemap overlay
 * Places path tiles at coordinates, returns sparse map
 */
export function pathToTilemap(
  path: Array<{ x: number; y: number }>,
  pathTile: string = 'water'
): Map<string, string> {
  const tilemap = new Map<string, string>();

  for (const { x, y } of path) {
    tilemap.set(`${x},${y}`, pathTile);
  }

  return tilemap;
}

/**
 * Apply path to existing tilemap (overlay)
 */
export function applyPathToTilemap(
  baseTilemap: string[][],
  path: Array<{ x: number; y: number }>,
  pathTile: string = 'water'
): string[][] {
  const height = baseTilemap.length;
  const width = baseTilemap[0]?.length || 0;

  // Clone base tilemap
  const newTilemap = baseTilemap.map(row => [...row]);

  // Apply path
  for (const { x, y } of path) {
    if (x >= 0 && x < width && y >= 0 && y < height) {
      newTilemap[y][x] = pathTile;
    }
  }

  return newTilemap;
}

/**
 * Generate river across tilemap
 * Starts from one edge, walks to another
 */
export function generateRiver(
  width: number,
  height: number,
  params: RandomWalkParams = DEFAULT_RIVER_PARAMS,
  options: {
    smooth?: boolean;
    variableWidth?: boolean;
  } = {}
): Array<{ x: number; y: number }> {
  const { smooth = true, variableWidth = true } = options;

  // Start from random position on top edge
  const random = new SeededRandom(params.seed || Date.now());
  const startX = Math.floor(random.next() * width);
  const startY = 0;

  // Generate path towards bottom
  let path = generatePath(startX, startY, {
    ...params,
    steps: height * 2 // Ensure we reach bottom
  });

  // Filter path to bounds
  path = path.filter(({ x, y }) => x >= 0 && x < width && y >= 0 && y < height);

  // Smooth path
  if (smooth) {
    path = smoothPath(path, 3);
  }

  // Apply width
  if (variableWidth) {
    path = applyWidthVariation(path, params.width, 0.4, params.seed);
  } else {
    path = thickenPath(path, params.width);
  }

  return path;
}

/**
 * Generate complete path tilemap
 */
export function generatePathTilemap(
  width: number,
  height: number,
  startX: number,
  startY: number,
  params: RandomWalkParams = DEFAULT_PATH_PARAMS,
  options: {
    baseTile?: string;
    pathTile?: string;
    smooth?: boolean;
    variableWidth?: boolean;
  } = {}
): string[][] {
  const {
    baseTile = 'grass',
    pathTile = 'dirt',
    smooth = false,
    variableWidth = false
  } = options;

  // Initialize base tilemap
  const tilemap: string[][] = [];
  for (let y = 0; y < height; y++) {
    const row: string[] = [];
    for (let x = 0; x < width; x++) {
      row.push(baseTile);
    }
    tilemap.push(row);
  }

  // Generate path
  let path = generatePath(startX, startY, params);

  // Smooth if requested
  if (smooth) {
    path = smoothPath(path);
  }

  // Apply width
  if (variableWidth) {
    path = applyWidthVariation(path, params.width, 0.3, params.seed);
  } else {
    path = thickenPath(path, params.width);
  }

  // Apply to tilemap
  return applyPathToTilemap(tilemap, path, pathTile);
}

/**
 * Check if path connects two points (roughly)
 */
export function pathConnects(
  path: Array<{ x: number; y: number }>,
  targetX: number,
  targetY: number,
  threshold: number = 5
): boolean {
  for (const { x, y } of path) {
    const distance = Math.sqrt((x - targetX) ** 2 + (y - targetY) ** 2);
    if (distance < threshold) {
      return true;
    }
  }
  return false;
}

/**
 * Get path length (total distance traveled)
 */
export function getPathLength(path: Array<{ x: number; y: number }>): number {
  let length = 0;
  for (let i = 1; i < path.length; i++) {
    const dx = path[i].x - path[i - 1].x;
    const dy = path[i].y - path[i - 1].y;
    length += Math.sqrt(dx * dx + dy * dy);
  }
  return length;
}
</file>

<file path="src/algorithms/waveFunctionCollapse.ts">
/**
 * Wave Function Collapse (WFC) Generator
 * Implements constraint-based generation for tilemaps
 * Simplified version optimized for game development
 */

/**
 * Tile with adjacency constraints
 */
export interface WFCTile {
  id: string; // Tile identifier
  weight: number; // Probability weight (higher = more common)
  adjacencyRules: {
    north: string[]; // Valid tile IDs that can be placed to the north
    south: string[];
    east: string[];
    west: string[];
  };
}

/**
 * Parameters for WFC generation
 */
export interface WFCParams {
  width: number;
  height: number;
  tiles: WFCTile[];
  seed?: number;
  maxAttempts?: number; // Max attempts before restart (default: 100)
}

/**
 * Cell state in WFC grid
 */
interface WFCCell {
  collapsed: boolean;
  possibleTiles: Set<string>;
  entropy: number;
}

/**
 * Seeded random number generator
 */
class SeededRandom {
  private seed: number;

  constructor(seed: number) {
    this.seed = seed;
  }

  next(): number {
    const x = Math.sin(this.seed++) * 10000;
    return x - Math.floor(x);
  }

  choice<T>(array: T[]): T {
    return array[Math.floor(this.next() * array.length)];
  }

  weightedChoice(tiles: WFCTile[], possibleIds: Set<string>): WFCTile {
    const possible = tiles.filter(t => possibleIds.has(t.id));
    const totalWeight = possible.reduce((sum, t) => sum + t.weight, 0);
    let random = this.next() * totalWeight;

    for (const tile of possible) {
      random -= tile.weight;
      if (random <= 0) return tile;
    }

    return possible[possible.length - 1];
  }
}

/**
 * Initialize WFC grid with all possibilities
 */
function initializeGrid(
  width: number,
  height: number,
  tileIds: string[]
): WFCCell[][] {
  const grid: WFCCell[][] = [];

  for (let y = 0; y < height; y++) {
    const row: WFCCell[] = [];
    for (let x = 0; x < width; x++) {
      row.push({
        collapsed: false,
        possibleTiles: new Set(tileIds),
        entropy: tileIds.length
      });
    }
    grid.push(row);
  }

  return grid;
}

/**
 * Calculate entropy (number of possible tiles) for a cell
 */
function calculateEntropy(cell: WFCCell, random: SeededRandom): number {
  if (cell.collapsed) return 0;
  // Add small random noise to break ties
  return cell.possibleTiles.size + random.next() * 0.1;
}

/**
 * Find cell with lowest entropy (most constrained)
 */
function findLowestEntropyCell(
  grid: WFCCell[][],
  random: SeededRandom
): { x: number; y: number } | null {
  const height = grid.length;
  const width = grid[0]?.length || 0;

  let minEntropy = Infinity;
  let bestCells: Array<{ x: number; y: number }> = [];

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const cell = grid[y][x];
      if (!cell.collapsed && cell.possibleTiles.size > 0) {
        const entropy = calculateEntropy(cell, random);
        if (entropy < minEntropy) {
          minEntropy = entropy;
          bestCells = [{ x, y }];
        } else if (Math.abs(entropy - minEntropy) < 0.01) {
          bestCells.push({ x, y });
        }
      }
    }
  }

  if (bestCells.length === 0) return null;
  return random.choice(bestCells);
}

/**
 * Get neighbors of a cell
 */
function getNeighbors(
  grid: WFCCell[][],
  x: number,
  y: number
): Array<{
  x: number;
  y: number;
  direction: 'north' | 'south' | 'east' | 'west';
}> {
  const height = grid.length;
  const width = grid[0]?.length || 0;
  const neighbors: Array<{
    x: number;
    y: number;
    direction: 'north' | 'south' | 'east' | 'west';
  }> = [];

  if (y > 0) neighbors.push({ x, y: y - 1, direction: 'north' });
  if (y < height - 1) neighbors.push({ x, y: y + 1, direction: 'south' });
  if (x < width - 1) neighbors.push({ x: x + 1, y, direction: 'east' });
  if (x > 0) neighbors.push({ x: x - 1, y, direction: 'west' });

  return neighbors;
}

/**
 * Opposite direction
 */
function oppositeDirection(
  direction: 'north' | 'south' | 'east' | 'west'
): 'north' | 'south' | 'east' | 'west' {
  switch (direction) {
    case 'north':
      return 'south';
    case 'south':
      return 'north';
    case 'east':
      return 'west';
    case 'west':
      return 'east';
  }
}

/**
 * Propagate constraints from a collapsed cell
 */
function propagate(
  grid: WFCCell[][],
  startX: number,
  startY: number,
  tiles: WFCTile[],
  tileMap: Map<string, WFCTile>
): boolean {
  const queue: Array<{ x: number; y: number }> = [{ x: startX, y: startY }];
  const visited = new Set<string>();

  while (queue.length > 0) {
    const { x, y } = queue.shift()!;
    const key = `${x},${y}`;

    if (visited.has(key)) continue;
    visited.add(key);

    const cell = grid[y][x];
    const neighbors = getNeighbors(grid, x, y);

    for (const neighbor of neighbors) {
      const nCell = grid[neighbor.y][neighbor.x];
      if (nCell.collapsed) continue;

      // Find valid tiles for neighbor based on current cell's possibilities
      const validNeighborTiles = new Set<string>();

      for (const tileId of cell.possibleTiles) {
        const tile = tileMap.get(tileId);
        if (!tile) continue;

        const oppositeDir = oppositeDirection(neighbor.direction);
        for (const validId of tile.adjacencyRules[neighbor.direction]) {
          validNeighborTiles.add(validId);
        }
      }

      // Constrain neighbor
      const oldSize = nCell.possibleTiles.size;
      nCell.possibleTiles = new Set(
        [...nCell.possibleTiles].filter(id => validNeighborTiles.has(id))
      );

      // Contradiction?
      if (nCell.possibleTiles.size === 0) {
        return false; // Contradiction detected
      }

      // If changed, add to queue
      if (nCell.possibleTiles.size < oldSize) {
        nCell.entropy = nCell.possibleTiles.size;
        queue.push({ x: neighbor.x, y: neighbor.y });
      }
    }
  }

  return true; // Success
}

/**
 * Collapse a cell to a specific tile
 */
function collapseCell(
  grid: WFCCell[][],
  x: number,
  y: number,
  tile: WFCTile
): void {
  const cell = grid[y][x];
  cell.collapsed = true;
  cell.possibleTiles = new Set([tile.id]);
  cell.entropy = 0;
}

/**
 * Check if grid is fully collapsed
 */
function isFullyCollapsed(grid: WFCCell[][]): boolean {
  for (const row of grid) {
    for (const cell of row) {
      if (!cell.collapsed) return false;
    }
  }
  return true;
}

/**
 * Generate tilemap using Wave Function Collapse
 */
export function collapse(params: WFCParams): string[][] | null {
  const { width, height, tiles, seed, maxAttempts = 100 } = params;
  const random = new SeededRandom(seed || Date.now());
  const tileMap = new Map(tiles.map(t => [t.id, t]));
  const tileIds = tiles.map(t => t.id);

  // Initialize grid
  let grid = initializeGrid(width, height, tileIds);

  let attempts = 0;

  while (!isFullyCollapsed(grid) && attempts < maxAttempts) {
    attempts++;

    // Find cell with lowest entropy
    const cell = findLowestEntropyCell(grid, random);
    if (!cell) break; // No more cells to collapse

    const { x, y } = cell;
    const currentCell = grid[y][x];

    // Choose tile based on weights
    const chosenTile = random.weightedChoice(tiles, currentCell.possibleTiles);

    // Collapse cell
    collapseCell(grid, x, y, chosenTile);

    // Propagate constraints
    const success = propagate(grid, x, y, tiles, tileMap);

    // If contradiction, restart
    if (!success) {
      console.warn(`WFC: Contradiction detected, restarting (attempt ${attempts}/${maxAttempts})`);
      grid = initializeGrid(width, height, tileIds);
      attempts++;

      if (attempts >= maxAttempts) {
        console.error('WFC: Max attempts reached, generation failed');
        return null;
      }
    }
  }

  // Convert to tilemap
  const tilemap: string[][] = [];
  for (let y = 0; y < height; y++) {
    const row: string[] = [];
    for (let x = 0; x < width; x++) {
      const cell = grid[y][x];
      if (cell.possibleTiles.size > 0) {
        row.push([...cell.possibleTiles][0]);
      } else {
        // Fallback to first tile if no possibilities
        row.push(tileIds[0]);
      }
    }
    tilemap.push(row);
  }

  return tilemap;
}

/**
 * Create standard platform tileset with constraints
 */
export function createPlatformTileset(): WFCTile[] {
  return [
    {
      id: 'grass',
      weight: 3,
      adjacencyRules: {
        north: ['grass', 'air', 'dirt'],
        south: ['grass', 'dirt'],
        east: ['grass', 'air', 'dirt'],
        west: ['grass', 'air', 'dirt']
      }
    },
    {
      id: 'dirt',
      weight: 5,
      adjacencyRules: {
        north: ['grass', 'dirt'],
        south: ['dirt', 'stone'],
        east: ['dirt', 'grass', 'stone'],
        west: ['dirt', 'grass', 'stone']
      }
    },
    {
      id: 'stone',
      weight: 2,
      adjacencyRules: {
        north: ['dirt', 'stone'],
        south: ['stone'],
        east: ['stone', 'dirt'],
        west: ['stone', 'dirt']
      }
    },
    {
      id: 'air',
      weight: 4,
      adjacencyRules: {
        north: ['air', 'grass'],
        south: ['air', 'grass'],
        east: ['air', 'grass'],
        west: ['air', 'grass']
      }
    }
  ];
}

/**
 * Create dungeon tileset with constraints
 */
export function createDungeonTileset(): WFCTile[] {
  return [
    {
      id: 'wall',
      weight: 3,
      adjacencyRules: {
        north: ['wall', 'floor'],
        south: ['wall', 'floor'],
        east: ['wall', 'floor'],
        west: ['wall', 'floor']
      }
    },
    {
      id: 'floor',
      weight: 5,
      adjacencyRules: {
        north: ['floor', 'wall', 'door'],
        south: ['floor', 'wall', 'door'],
        east: ['floor', 'wall', 'door'],
        west: ['floor', 'wall', 'door']
      }
    },
    {
      id: 'door',
      weight: 1,
      adjacencyRules: {
        north: ['floor'],
        south: ['floor'],
        east: ['wall'],
        west: ['wall']
      }
    }
  ];
}

/**
 * Create water/land tileset
 */
export function createTerrainTileset(): WFCTile[] {
  return [
    {
      id: 'water',
      weight: 4,
      adjacencyRules: {
        north: ['water', 'sand'],
        south: ['water', 'sand'],
        east: ['water', 'sand'],
        west: ['water', 'sand']
      }
    },
    {
      id: 'sand',
      weight: 2,
      adjacencyRules: {
        north: ['sand', 'water', 'grass'],
        south: ['sand', 'water', 'grass'],
        east: ['sand', 'water', 'grass'],
        west: ['sand', 'water', 'grass']
      }
    },
    {
      id: 'grass',
      weight: 5,
      adjacencyRules: {
        north: ['grass', 'sand', 'dirt'],
        south: ['grass', 'sand', 'dirt'],
        east: ['grass', 'sand', 'dirt'],
        west: ['grass', 'sand', 'dirt']
      }
    },
    {
      id: 'dirt',
      weight: 3,
      adjacencyRules: {
        north: ['dirt', 'grass', 'stone'],
        south: ['dirt', 'grass', 'stone'],
        east: ['dirt', 'grass', 'stone'],
        west: ['dirt', 'grass', 'stone']
      }
    },
    {
      id: 'stone',
      weight: 2,
      adjacencyRules: {
        north: ['stone', 'dirt'],
        south: ['stone', 'dirt'],
        east: ['stone', 'dirt'],
        west: ['stone', 'dirt']
      }
    }
  ];
}

/**
 * Create custom tileset from adjacency rules object
 */
export function createCustomTileset(
  rules: Record<string, {
    weight: number;
    north: string[];
    south: string[];
    east: string[];
    west: string[];
  }>
): WFCTile[] {
  return Object.entries(rules).map(([id, rule]) => ({
    id,
    weight: rule.weight,
    adjacencyRules: {
      north: rule.north,
      south: rule.south,
      east: rule.east,
      west: rule.west
    }
  }));
}

/**
 * Generate platform-style tilemap (good for sidescrollers)
 */
export function generatePlatformTilemap(
  width: number,
  height: number,
  seed?: number
): string[][] | null {
  return collapse({
    width,
    height,
    tiles: createPlatformTileset(),
    seed,
    maxAttempts: 100
  });
}

/**
 * Generate dungeon-style tilemap
 */
export function generateDungeonTilemap(
  width: number,
  height: number,
  seed?: number
): string[][] | null {
  return collapse({
    width,
    height,
    tiles: createDungeonTileset(),
    seed,
    maxAttempts: 100
  });
}

/**
 * Generate terrain tilemap with water/land
 */
export function generateTerrainTilemap(
  width: number,
  height: number,
  seed?: number
): string[][] | null {
  return collapse({
    width,
    height,
    tiles: createTerrainTileset(),
    seed,
    maxAttempts: 100
  });
}
</file>

<file path="src/commands/advanced/AlignmentCommand.ts">
// AlignmentCommand - Undo/Redo for alignment operations (PR-18)

import type { Command } from '../../types/command'

/**
 * Command for alignment and distribution operations
 * Undo: Restore old positions
 * Redo: Apply new positions
 */
export class AlignmentCommand implements Command {
  readonly type = 'alignment' as const
  
  private shapeIds: string[]
  private oldPositions: Map<string, { x: number; y: number }>
  private newPositions: Map<string, { x: number; y: number }>
  private updateShape: (id: string, updates: { x: number; y: number }) => void
  private syncPosition: (id: string, x: number, y: number) => Promise<void>

  constructor(
    shapeIds: string[],
    oldPositions: Map<string, { x: number; y: number }>,
    newPositions: Map<string, { x: number; y: number }>,
    updateShape: (id: string, updates: { x: number; y: number }) => void,
    syncPosition: (id: string, x: number, y: number) => Promise<void>
  ) {
    this.shapeIds = shapeIds
    this.oldPositions = oldPositions
    this.newPositions = newPositions
    this.updateShape = updateShape
    this.syncPosition = syncPosition
  }

  execute(): void {
    // Apply new positions
    this.shapeIds.forEach((id) => {
      const newPos = this.newPositions.get(id)
      if (newPos) {
        this.updateShape(id, newPos)
        this.syncPosition(id, newPos.x, newPos.y).catch((error) => {
          console.error('Failed to sync alignment position:', error)
        })
      }
    })
  }

  undo(): void {
    // Restore old positions
    this.shapeIds.forEach((id) => {
      const oldPos = this.oldPositions.get(id)
      if (oldPos) {
        this.updateShape(id, oldPos)
        this.syncPosition(id, oldPos.x, oldPos.y).catch((error) => {
          console.error('Failed to sync alignment position in undo:', error)
        })
      }
    })
  }

  redo(): void {
    // Re-apply new positions
    this.execute()
  }
}
</file>

<file path="src/commands/advanced/AnimationCommand.ts">
/**
 * Animation Commands for Undo/Redo System
 * PR-31: Animation Integration
 */

import { ref, set, remove, update } from 'firebase/database'
import { db } from '../../services/firebase'
import type { Shape } from '../../types/canvas'

/**
 * Command: Create Animated Sprite
 * Adds an animated sprite to the canvas
 */
export class CreateAnimatedSpriteCommand {
  private canvasId: string
  private shape: Shape
  private executed: boolean = false

  constructor(canvasId: string, shape: Shape) {
    this.canvasId = canvasId
    this.shape = shape
  }

  async execute(): Promise<void> {
    if (this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shape.id}`)
    await set(shapeRef, this.shape)
    this.executed = true
  }

  async undo(): Promise<void> {
    if (!this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shape.id}`)
    await remove(shapeRef)
    this.executed = false
  }

  getDescription(): string {
    return `Create animated sprite "${this.shape.animationId}"`
  }
}

/**
 * Command: Update Animation Playback
 * Changes animation playback state (playing/paused, current frame)
 */
export class UpdateAnimationCommand {
  private canvasId: string
  private shapeId: string
  private oldState: {
    currentFrame?: number
    isPlaying?: boolean
  }
  private newState: {
    currentFrame?: number
    isPlaying?: boolean
  }
  private executed: boolean = false

  constructor(
    canvasId: string,
    shapeId: string,
    oldState: { currentFrame?: number; isPlaying?: boolean },
    newState: { currentFrame?: number; isPlaying?: boolean }
  ) {
    this.canvasId = canvasId
    this.shapeId = shapeId
    this.oldState = oldState
    this.newState = newState
  }

  async execute(): Promise<void> {
    if (this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shapeId}`)
    await update(shapeRef, this.newState)
    this.executed = true
  }

  async undo(): Promise<void> {
    if (!this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shapeId}`)
    await update(shapeRef, this.oldState)
    this.executed = false
  }

  getDescription(): string {
    if (this.newState.isPlaying !== undefined) {
      return this.newState.isPlaying ? 'Play animation' : 'Pause animation'
    }
    if (this.newState.currentFrame !== undefined) {
      return `Set animation frame to ${this.newState.currentFrame}`
    }
    return 'Update animation'
  }
}

/**
 * Command: Update Animated Sprite Properties
 * Changes sprite properties like flip, opacity, animation reference
 */
export class UpdateAnimatedSpriteCommand {
  private canvasId: string
  private shapeId: string
  private oldProps: Partial<Shape>
  private newProps: Partial<Shape>
  private executed: boolean = false

  constructor(
    canvasId: string,
    shapeId: string,
    oldProps: Partial<Shape>,
    newProps: Partial<Shape>
  ) {
    this.canvasId = canvasId
    this.shapeId = shapeId
    this.oldProps = oldProps
    this.newProps = newProps
  }

  async execute(): Promise<void> {
    if (this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shapeId}`)
    await update(shapeRef, this.newProps)
    this.executed = true
  }

  async undo(): Promise<void> {
    if (!this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shapeId}`)
    await update(shapeRef, this.oldProps)
    this.executed = false
  }

  getDescription(): string {
    const changes: string[] = []
    
    if (this.newProps.flipX !== this.oldProps.flipX) {
      changes.push('flip X')
    }
    if (this.newProps.flipY !== this.oldProps.flipY) {
      changes.push('flip Y')
    }
    if (this.newProps.opacity !== this.oldProps.opacity) {
      changes.push('opacity')
    }
    if (this.newProps.animationId !== this.oldProps.animationId) {
      changes.push('animation')
    }
    
    return changes.length > 0 
      ? `Update sprite: ${changes.join(', ')}` 
      : 'Update sprite properties'
  }
}

/**
 * Command: Delete Animated Sprite
 * Removes an animated sprite from the canvas
 */
export class DeleteAnimatedSpriteCommand {
  private canvasId: string
  private shape: Shape
  private executed: boolean = false

  constructor(canvasId: string, shape: Shape) {
    this.canvasId = canvasId
    this.shape = shape
  }

  async execute(): Promise<void> {
    if (this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shape.id}`)
    await remove(shapeRef)
    this.executed = true
  }

  async undo(): Promise<void> {
    if (!this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shape.id}`)
    await set(shapeRef, this.shape)
    this.executed = false
  }

  getDescription(): string {
    return `Delete animated sprite "${this.shape.animationId}"`
  }
}

/**
 * Command: Change Animation
 * Switches an animated sprite to a different animation
 */
export class ChangeAnimationCommand {
  private canvasId: string
  private shapeId: string
  private oldAnimationId: string
  private newAnimationId: string
  private executed: boolean = false

  constructor(
    canvasId: string,
    shapeId: string,
    oldAnimationId: string,
    newAnimationId: string
  ) {
    this.canvasId = canvasId
    this.shapeId = shapeId
    this.oldAnimationId = oldAnimationId
    this.newAnimationId = newAnimationId
  }

  async execute(): Promise<void> {
    if (this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shapeId}`)
    await update(shapeRef, {
      animationId: this.newAnimationId,
      currentFrame: 0, // Reset to first frame
      isPlaying: true // Start playing new animation
    })
    this.executed = true
  }

  async undo(): Promise<void> {
    if (!this.executed) return
    
    const shapeRef = ref(db, `canvases/${this.canvasId}/objects/${this.shapeId}`)
    await update(shapeRef, {
      animationId: this.oldAnimationId,
      currentFrame: 0,
      isPlaying: true
    })
    this.executed = false
  }

  getDescription(): string {
    return `Change animation to "${this.newAnimationId}"`
  }
}
</file>

<file path="src/commands/advanced/BulkCommand.ts">
// BulkCommand - Undo/Redo for multiple operations at once (PR-14)

import type { Command } from '../../types/command'

/**
 * Command for bulk operations (multiple commands executed together)
 * Undo: Undo all commands in reverse order
 * Redo: Redo all commands in original order
 */
export class BulkCommand implements Command {
  readonly type = 'bulk' as const
  
  private commands: Command[]

  constructor(commands: Command[]) {
    this.commands = commands
  }

  execute(): void {
    // Execute all commands in order
    this.commands.forEach((command) => {
      command.execute()
    })
  }

  undo(): void {
    // Undo all commands in reverse order
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo()
    }
  }

  redo(): void {
    // Redo all commands in original order
    this.commands.forEach((command) => {
      command.redo()
    })
  }
}
</file>

<file path="src/commands/shape/ColorCommand.ts">
// ColorCommand - Undo/Redo for color changes (PR-15)

import type { Command } from '../../types/command'

/**
 * Color data for a shape
 */
interface ColorData {
  fill: string
  stroke?: string
  strokeWidth?: number
}

/**
 * Command for changing shape colors
 * Undo: Restore old colors
 * Redo: Apply new colors
 */
export class ColorCommand implements Command {
  readonly type = 'color' as const
  
  private shapeId: string
  private oldColors: ColorData
  private newColors: ColorData
  private updateShapeInState: (id: string, updates: Partial<ColorData>) => void
  private syncUpdate: (id: string, updates: Partial<ColorData>) => Promise<void>

  constructor(
    shapeId: string,
    oldColors: ColorData,
    newColors: ColorData,
    updateShapeInState: (id: string, updates: Partial<ColorData>) => void,
    syncUpdate: (id: string, updates: Partial<ColorData>) => Promise<void>
  ) {
    this.shapeId = shapeId
    this.oldColors = oldColors
    this.newColors = newColors
    this.updateShapeInState = updateShapeInState
    this.syncUpdate = syncUpdate
  }

  execute(): void {
    // Apply new colors to local state
    this.updateShapeInState(this.shapeId, this.newColors)
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, this.newColors).catch((error) => {
      console.error('Failed to sync color change:', error)
    })
  }

  undo(): void {
    // Restore old colors in local state
    this.updateShapeInState(this.shapeId, this.oldColors)
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, this.oldColors).catch((error) => {
      console.error('Failed to sync color change in undo:', error)
    })
  }

  redo(): void {
    // Re-apply new colors in local state
    this.updateShapeInState(this.shapeId, this.newColors)
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, this.newColors).catch((error) => {
      console.error('Failed to sync color change in redo:', error)
    })
  }
}
</file>

<file path="src/commands/shape/CreateCommand.ts">
// CreateCommand - Undo/Redo for shape creation (PR-14)

import type { Command } from '../../types/command'
import type { Shape } from '../../types/canvas'

/**
 * Command for creating shapes
 * Undo: Delete the created shape
 * Redo: Recreate the shape
 */
export class CreateCommand implements Command {
  readonly type = 'create' as const
  
  private shape: Shape
  private addShapeToState: (shape: Shape) => void
  private removeShapeFromState: (id: string) => void
  private syncCreate: (shape: Shape) => Promise<void>
  private syncDelete: (id: string) => Promise<void>

  constructor(
    shape: Shape,
    addShapeToState: (shape: Shape) => void,
    removeShapeFromState: (id: string) => void,
    syncCreate: (shape: Shape) => Promise<void>,
    syncDelete: (id: string) => Promise<void>
  ) {
    this.shape = shape
    this.addShapeToState = addShapeToState
    this.removeShapeFromState = removeShapeFromState
    this.syncCreate = syncCreate
    this.syncDelete = syncDelete
  }

  execute(): void {
    // Add shape to local state
    this.addShapeToState(this.shape)
    
    // Sync to Firebase
    this.syncCreate(this.shape).catch((error) => {
      console.error('Failed to sync shape creation:', error)
    })
  }

  undo(): void {
    // Remove shape from local state
    this.removeShapeFromState(this.shape.id)
    
    // Sync deletion to Firebase
    this.syncDelete(this.shape.id).catch((error) => {
      console.error('Failed to sync shape deletion in undo:', error)
    })
  }

  redo(): void {
    // Re-add shape to local state
    this.addShapeToState(this.shape)
    
    // Sync creation to Firebase
    this.syncCreate(this.shape).catch((error) => {
      console.error('Failed to sync shape creation in redo:', error)
    })
  }
}
</file>

<file path="src/commands/shape/DeleteCommand.ts">
// DeleteCommand - Undo/Redo for shape deletion (PR-14)

import type { Command } from '../../types/command'
import type { Shape } from '../../types/canvas'

/**
 * Command for deleting shapes
 * Undo: Recreate the deleted shape with same ID and properties
 * Redo: Delete the shape again
 */
export class DeleteCommand implements Command {
  readonly type = 'delete' as const
  
  private shape: Shape
  private addShapeToState: (shape: Shape) => void
  private removeShapeFromState: (id: string) => void
  private syncCreate: (shape: Shape) => Promise<void>
  private syncDelete: (id: string) => Promise<void>

  constructor(
    shape: Shape,
    addShapeToState: (shape: Shape) => void,
    removeShapeFromState: (id: string) => void,
    syncCreate: (shape: Shape) => Promise<void>,
    syncDelete: (id: string) => Promise<void>
  ) {
    this.shape = shape
    this.addShapeToState = addShapeToState
    this.removeShapeFromState = removeShapeFromState
    this.syncCreate = syncCreate
    this.syncDelete = syncDelete
  }

  execute(): void {
    // Remove shape from local state
    this.removeShapeFromState(this.shape.id)
    
    // Sync deletion to Firebase
    this.syncDelete(this.shape.id).catch((error) => {
      console.error('Failed to sync shape deletion:', error)
    })
  }

  undo(): void {
    // Recreate shape with same ID and properties
    this.addShapeToState(this.shape)
    
    // Sync creation to Firebase
    this.syncCreate(this.shape).catch((error) => {
      console.error('Failed to sync shape recreation in undo:', error)
    })
  }

  redo(): void {
    // Delete shape again
    this.removeShapeFromState(this.shape.id)
    
    // Sync deletion to Firebase
    this.syncDelete(this.shape.id).catch((error) => {
      console.error('Failed to sync shape deletion in redo:', error)
    })
  }
}
</file>

<file path="src/commands/shape/MoveCommand.ts">
// MoveCommand - Undo/Redo for shape movement (PR-14)

import type { Command } from '../../types/command'

/**
 * Position data for a shape
 */
interface Position {
  x: number
  y: number
}

/**
 * Command for moving shapes
 * Undo: Restore old position
 * Redo: Apply new position
 */
export class MoveCommand implements Command {
  readonly type = 'move' as const
  
  private shapeId: string
  private oldPosition: Position
  private newPosition: Position
  private updateShapeInState: (id: string, updates: Partial<{ x: number; y: number }>) => void
  private syncUpdate: (id: string, updates: Partial<{ x: number; y: number }>) => Promise<void>

  constructor(
    shapeId: string,
    oldPosition: Position,
    newPosition: Position,
    updateShapeInState: (id: string, updates: Partial<{ x: number; y: number }>) => void,
    syncUpdate: (id: string, updates: Partial<{ x: number; y: number }>) => Promise<void>
  ) {
    this.shapeId = shapeId
    this.oldPosition = oldPosition
    this.newPosition = newPosition
    this.updateShapeInState = updateShapeInState
    this.syncUpdate = syncUpdate
  }

  execute(): void {
    // Apply new position to local state
    this.updateShapeInState(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    })
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    }).catch((error) => {
      console.error('Failed to sync shape move:', error)
    })
  }

  undo(): void {
    // Restore old position in local state
    this.updateShapeInState(this.shapeId, {
      x: this.oldPosition.x,
      y: this.oldPosition.y,
    })
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, {
      x: this.oldPosition.x,
      y: this.oldPosition.y,
    }).catch((error) => {
      console.error('Failed to sync shape move in undo:', error)
    })
  }

  redo(): void {
    // Re-apply new position in local state
    this.updateShapeInState(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    })
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    }).catch((error) => {
      console.error('Failed to sync shape move in redo:', error)
    })
  }
}
</file>

<file path="src/commands/shape/TransformCommand.ts">
// TransformCommand - Undo/Redo for shape transformation (PR-14)

import type { Command } from '../../types/command'

/**
 * Transform data for a shape (size and rotation)
 */
interface Transform {
  width: number
  height: number
  rotation?: number
}

/**
 * Command for transforming shapes (resize, rotate)
 * Undo: Restore old transform
 * Redo: Apply new transform
 */
export class TransformCommand implements Command {
  readonly type = 'transform' as const
  
  private shapeId: string
  private oldTransform: Transform
  private newTransform: Transform
  private updateShapeInState: (id: string, updates: Partial<Transform>) => void
  private syncUpdate: (id: string, updates: Partial<Transform>) => Promise<void>

  constructor(
    shapeId: string,
    oldTransform: Transform,
    newTransform: Transform,
    updateShapeInState: (id: string, updates: Partial<Transform>) => void,
    syncUpdate: (id: string, updates: Partial<Transform>) => Promise<void>
  ) {
    this.shapeId = shapeId
    this.oldTransform = oldTransform
    this.newTransform = newTransform
    this.updateShapeInState = updateShapeInState
    this.syncUpdate = syncUpdate
  }

  execute(): void {
    // Apply new transform to local state
    this.updateShapeInState(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    })
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    }).catch((error) => {
      console.error('Failed to sync shape transform:', error)
    })
  }

  undo(): void {
    // Restore old transform in local state
    this.updateShapeInState(this.shapeId, {
      width: this.oldTransform.width,
      height: this.oldTransform.height,
      rotation: this.oldTransform.rotation,
    })
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, {
      width: this.oldTransform.width,
      height: this.oldTransform.height,
      rotation: this.oldTransform.rotation,
    }).catch((error) => {
      console.error('Failed to sync shape transform in undo:', error)
    })
  }

  redo(): void {
    // Re-apply new transform in local state
    this.updateShapeInState(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    })
    
    // Sync to Firebase
    this.syncUpdate(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    }).catch((error) => {
      console.error('Failed to sync shape transform in redo:', error)
    })
  }
}
</file>

<file path="src/commands/shape/ZIndexCommand.ts">
// ZIndexCommand - Undo/Redo for z-index changes (PR-17)

import type { Command } from '../../types/command'

/**
 * Command for changing z-index of shapes
 * Undo: Restore old z-index values
 * Redo: Apply new z-index values
 */
export class ZIndexCommand implements Command {
  readonly type = 'zindex' as const
  
  private shapeIds: string[]
  private oldZIndices: Map<string, number>
  private newZIndices: Map<string, number>
  private updateShape: (id: string, updates: { zIndex: number }) => void
  private syncZIndex: (id: string, zIndex: number) => Promise<void>

  constructor(
    shapeIds: string[],
    oldZIndices: Map<string, number>,
    newZIndices: Map<string, number>,
    updateShape: (id: string, updates: { zIndex: number }) => void,
    syncZIndex: (id: string, zIndex: number) => Promise<void>
  ) {
    this.shapeIds = shapeIds
    this.oldZIndices = oldZIndices
    this.newZIndices = newZIndices
    this.updateShape = updateShape
    this.syncZIndex = syncZIndex
  }

  execute(): void {
    // Apply new z-indices
    this.shapeIds.forEach((id) => {
      const newZIndex = this.newZIndices.get(id)
      if (newZIndex !== undefined) {
        this.updateShape(id, { zIndex: newZIndex })
        this.syncZIndex(id, newZIndex).catch((error) => {
          console.error('Failed to sync z-index change:', error)
        })
      }
    })
  }

  undo(): void {
    // Restore old z-indices
    this.shapeIds.forEach((id) => {
      const oldZIndex = this.oldZIndices.get(id)
      if (oldZIndex !== undefined) {
        this.updateShape(id, { zIndex: oldZIndex })
        this.syncZIndex(id, oldZIndex).catch((error) => {
          console.error('Failed to sync z-index change in undo:', error)
        })
      }
    })
  }

  redo(): void {
    // Re-apply new z-indices
    this.execute()
  }
}
</file>

<file path="src/commands/tile/TileCommand.ts">
/**
 * TileCommand - Single tile and bulk tile commands with undo/redo
 * Handles setting or deleting tiles with proper state management
 * Supports auto-tile variant preservation
 */

import type { Command } from '../../types/command'
import type { TileData } from '../../types/tilemap'

/**
 * Command for setting or deleting a single tile
 * Undo: Restore previous tile state (including variant)
 * Redo: Re-apply new tile state (including variant)
 */
export class TileSetCommand implements Command {
  readonly type = 'create' as const // Reuse 'create' type for tiles
  
  private x: number
  private y: number
  private oldTile: TileData | undefined
  private newTile: TileData
  private setTileInState: (x: number, y: number, tile: TileData) => void
  private deleteTileInState: (x: number, y: number) => void

  constructor(
    x: number,
    y: number,
    oldTile: TileData | undefined,
    newTile: TileData,
    setTileInState: (x: number, y: number, tile: TileData) => void,
    deleteTileInState: (x: number, y: number) => void
  ) {
    this.x = x
    this.y = y
    // Store complete tile data including variant
    this.oldTile = oldTile ? { ...oldTile } : undefined
    this.newTile = { ...newTile }
    this.setTileInState = setTileInState
    this.deleteTileInState = deleteTileInState
  }

  execute(): void {
    // Set tile in state (syncs to Firebase automatically via hook)
    this.setTileInState(this.x, this.y, this.newTile)
  }

  undo(): void {
    if (this.oldTile) {
      // Restore previous tile (with variant)
      this.setTileInState(this.x, this.y, this.oldTile)
    } else {
      // Delete tile if there was no previous tile
      this.deleteTileInState(this.x, this.y)
    }
  }

  redo(): void {
    // Re-apply the new tile (with variant)
    this.setTileInState(this.x, this.y, this.newTile)
  }
}

/**
 * Command for bulk tile operations (paint strokes, fill, etc.)
 * Efficiently handles multiple tile changes as a single undoable action
 */
export class BulkTileCommand implements Command {
  readonly type = 'create' as const
  
  private tiles: Array<{
    x: number
    y: number
    oldTile: TileData | undefined
    newTile: TileData | null // null indicates deletion
  }>
  private setTileInState: (x: number, y: number, tile: TileData) => void
  private deleteTileInState: (x: number, y: number) => void

  constructor(
    tiles: Array<{
      x: number
      y: number
      oldTile: TileData | undefined
      newTile: TileData | null
    }>,
    setTileInState: (x: number, y: number, tile: TileData) => void,
    deleteTileInState: (x: number, y: number) => void
  ) {
    // Deep copy tile data to preserve variants
    this.tiles = tiles.map((t) => ({
      x: t.x,
      y: t.y,
      oldTile: t.oldTile ? { ...t.oldTile } : undefined,
      newTile: t.newTile ? { ...t.newTile } : null,
    }))
    this.setTileInState = setTileInState
    this.deleteTileInState = deleteTileInState
  }

  execute(): void {
    // Apply all tile changes
    this.tiles.forEach(({ x, y, newTile }) => {
      if (newTile) {
        this.setTileInState(x, y, newTile)
      } else {
        this.deleteTileInState(x, y)
      }
    })
  }

  undo(): void {
    // Restore all previous tiles
    this.tiles.forEach(({ x, y, oldTile }) => {
      if (oldTile) {
        this.setTileInState(x, y, oldTile)
      } else {
        this.deleteTileInState(x, y)
      }
    })
  }

  redo(): void {
    // Re-apply all tile changes
    this.execute()
  }
}
</file>

<file path="src/commands/tile/TileFillCommand.ts">
/**
 * TileFillCommand - Flood fill command for tilemap
 * Extends TileStrokeCommand since it's also a bulk operation
 */

import { TileStrokeCommand } from './TileStrokeCommand'
import type { TileData } from '../../types/tilemap'

/**
 * Command for flood fill operations
 * Uses TileStrokeCommand internally since fill is just a bulk tile change
 * 
 * This is a specialized version that can show progress indicators
 * and provide metadata about the fill operation
 */
export class TileFillCommand extends TileStrokeCommand {
  private fillStartX: number
  private fillStartY: number
  private fillTileCount: number

  constructor(
    fillStartX: number,
    fillStartY: number,
    changes: Array<{ x: number; y: number; oldTile: TileData | undefined; newTile: TileData | null }>,
    setTilesInState: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void,
    deleteTilesInState: (tiles: Array<{ x: number; y: number }>) => void
  ) {
    super(changes, setTilesInState, deleteTilesInState)
    this.fillStartX = fillStartX
    this.fillStartY = fillStartY
    this.fillTileCount = changes.length
  }

  /**
   * Get metadata about the fill operation
   */
  getFillMetadata() {
    return {
      startX: this.fillStartX,
      startY: this.fillStartY,
      tileCount: this.fillTileCount,
    }
  }

  // All other methods inherited from TileStrokeCommand
}
</file>

<file path="src/commands/tile/TileStrokeCommand.ts">
/**
 * TileStrokeCommand - Bulk tile set/delete command for paint strokes
 * Handles multiple tile changes in a single undo/redo operation
 */

import type { Command } from '../../types/command'
import type { TileData } from '../../types/tilemap'

/**
 * Tile change record
 */
interface TileChange {
  x: number
  y: number
  oldTile: TileData | undefined
  newTile: TileData | null // null = deletion
}

/**
 * Command for paint strokes (multiple tiles changed at once)
 * Similar to BulkCommand but for tiles
 * Undo: Restore all previous tile states
 * Redo: Re-apply all new tile states
 */
export class TileStrokeCommand implements Command {
  readonly type = 'bulk' as const
  
  private changes: TileChange[]
  private setTilesInState: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void
  private deleteTilesInState: (tiles: Array<{ x: number; y: number }>) => void

  constructor(
    changes: TileChange[],
    setTilesInState: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void,
    deleteTilesInState: (tiles: Array<{ x: number; y: number }>) => void
  ) {
    this.changes = changes
    this.setTilesInState = setTilesInState
    this.deleteTilesInState = deleteTilesInState
  }

  execute(): void {
    // Apply all new tiles
    const tilesToSet: Array<{ x: number; y: number; tile: TileData }> = []
    const tilesToDelete: Array<{ x: number; y: number }> = []
    
    this.changes.forEach((change) => {
      if (change.newTile === null) {
        tilesToDelete.push({ x: change.x, y: change.y })
      } else {
        tilesToSet.push({ x: change.x, y: change.y, tile: change.newTile })
      }
    })
    
    if (tilesToSet.length > 0) {
      this.setTilesInState(tilesToSet)
    }
    if (tilesToDelete.length > 0) {
      this.deleteTilesInState(tilesToDelete)
    }
  }

  undo(): void {
    // Restore all old tiles
    const tilesToSet: Array<{ x: number; y: number; tile: TileData }> = []
    const tilesToDelete: Array<{ x: number; y: number }> = []
    
    this.changes.forEach((change) => {
      if (change.oldTile) {
        tilesToSet.push({ x: change.x, y: change.y, tile: change.oldTile })
      } else {
        tilesToDelete.push({ x: change.x, y: change.y })
      }
    })
    
    if (tilesToSet.length > 0) {
      this.setTilesInState(tilesToSet)
    }
    if (tilesToDelete.length > 0) {
      this.deleteTilesInState(tilesToDelete)
    }
  }

  redo(): void {
    // Re-execute the command
    this.execute()
  }
}
</file>

<file path="src/components/ai/SmartSuggestions.tsx">
/**
 * Smart Suggestions Component
 * Context-aware AI suggestions for game development
 * PR-32: AI Game-Aware Enhancement
 */

import React, { useEffect, useState } from 'react';
import { useCanvas } from '../../hooks/useCanvas';
import { useAssetLibrary } from '../../hooks/useAssetLibrary';
import { useTilemap } from '../../hooks/useTilemap';
import { detectGameType } from '../../services/ai/gameTypeDetection';

interface Suggestion {
  id: string;
  text: string;
  prompt: string; // What to send to AI
  icon?: string;
  category: 'generate' | 'improve' | 'optimize' | 'complete';
}

interface SmartSuggestionsProps {
  onSuggestionClick: (prompt: string) => void;
  maxSuggestions?: number;
}

export const SmartSuggestions: React.FC<SmartSuggestionsProps> = ({
  onSuggestionClick,
  maxSuggestions = 4
}) => {
  const { shapes } = useCanvas({ canvasId: 'default', userId: 'user' });
  const { assets } = useAssetLibrary({ userId: 'user' });
  const { meta, tiles } = useTilemap({ canvasId: 'default', userId: 'user' });
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);

  useEffect(() => {
    const newSuggestions = generateSuggestions(
      shapes,
      tiles ? tiles.size : 0,
      meta,
      assets
    );

    setSuggestions(newSuggestions.slice(0, maxSuggestions));
  }, [shapes, tiles, meta, assets, maxSuggestions]);

  if (suggestions.length === 0) {
    return null;
  }

  return (
    <div className="bg-white border border-gray-200 rounded-lg shadow-sm p-3 mb-4">
      <div className="flex items-center gap-2 mb-2">
        <span className="text-sm font-semibold text-gray-700">💡 Quick Actions</span>
      </div>
      
      <div className="flex flex-wrap gap-2">
        {suggestions.map((suggestion) => (
          <button
            key={suggestion.id}
            onClick={() => onSuggestionClick(suggestion.prompt)}
            className={`
              px-3 py-1.5 text-sm rounded-md transition-colors
              ${getCategoryColor(suggestion.category)}
              hover:scale-105 active:scale-95
            `}
            title={suggestion.prompt}
          >
            {suggestion.icon && <span className="mr-1">{suggestion.icon}</span>}
            {suggestion.text}
          </button>
        ))}
      </div>
    </div>
  );
};

/**
 * Generate context-aware suggestions
 */
function generateSuggestions(
  objects: any[],
  tileCount: number,
  tilemap: any,
  assets: any[]
): Suggestion[] {
  const suggestions: Suggestion[] = [];
  const objectCount = objects.length;

  // Empty canvas suggestions
  if (objectCount === 0 && tileCount === 0) {
    suggestions.push({
      id: 'gen_terrain',
      text: 'Generate terrain',
      prompt: 'Generate a natural-looking terrain tilemap using Perlin noise',
      icon: '🌍',
      category: 'generate'
    });

    suggestions.push({
      id: 'gen_cave',
      text: 'Create cave system',
      prompt: 'Generate a cave dungeon using cellular automata',
      icon: '🕳️',
      category: 'generate'
    });

    suggestions.push({
      id: 'add_shapes',
      text: 'Add basic shapes',
      prompt: 'Add some basic shapes to get started',
      icon: '▢',
      category: 'generate'
    });

    return suggestions;
  }

  // Detect game type
  const detection = detectGameType(objects, tilemap, tileCount);

  // Suggestions based on game type
  if (detection.type === 'platformer') {
    if (tileCount === 0) {
      suggestions.push({
        id: 'gen_platforms',
        text: 'Generate platforms',
        prompt: 'Generate platform terrain suitable for a platformer game',
        icon: '🎮',
        category: 'generate'
      });
    }

    if (objectCount < 10) {
      suggestions.push({
        id: 'add_enemies',
        text: 'Add enemies',
        prompt: 'Place some enemy objects on the platforms',
        icon: '👾',
        category: 'complete'
      });

      suggestions.push({
        id: 'add_collectibles',
        text: 'Add collectibles',
        prompt: 'Add collectible items like coins throughout the level',
        icon: '💰',
        category: 'complete'
      });
    }

    if (objectCount > 5 && tileCount > 0) {
      suggestions.push({
        id: 'arrange_level',
        text: 'Improve layout',
        prompt: 'Analyze the level layout and suggest improvements for better gameplay',
        icon: '📐',
        category: 'improve'
      });
    }
  }

  if (detection.type === 'top-down') {
    if (tileCount === 0) {
      suggestions.push({
        id: 'gen_dungeon',
        text: 'Generate dungeon',
        prompt: 'Generate a dungeon layout with rooms and corridors',
        icon: '🏰',
        category: 'generate'
      });
    }

    if (tileCount > 0 && objectCount < 5) {
      suggestions.push({
        id: 'add_doors',
        text: 'Add doors',
        prompt: 'Place doors between rooms in the dungeon',
        icon: '🚪',
        category: 'complete'
      });

      suggestions.push({
        id: 'add_npcs',
        text: 'Add NPCs',
        prompt: 'Place some NPCs or enemies in the dungeon rooms',
        icon: '🧙',
        category: 'complete'
      });
    }
  }

  if (detection.type === 'puzzle') {
    if (objectCount < 20) {
      suggestions.push({
        id: 'create_grid',
        text: 'Create puzzle grid',
        prompt: 'Create a regular grid for puzzle pieces',
        icon: '🧩',
        category: 'generate'
      });
    }
  }

  // General suggestions based on content
  if (tileCount > 0 && tileCount < 100) {
    suggestions.push({
      id: 'expand_tilemap',
      text: 'Expand tilemap',
      prompt: 'Expand the current tilemap with more varied terrain',
      icon: '➕',
      category: 'improve'
    });
  }

  // Performance suggestions
  if (objectCount > 500) {
    suggestions.push({
      id: 'optimize',
      text: 'Optimize performance',
      prompt: 'Analyze performance and suggest optimizations',
      icon: '⚡',
      category: 'optimize'
    });
  }

  // Asset suggestions
  if (assets.length > 0 && tileCount > 0) {
    suggestions.push({
      id: 'add_decorations',
      text: 'Add decorations',
      prompt: 'Add decorative elements using available assets to make the scene more interesting',
      icon: '🎨',
      category: 'improve'
    });
  }

  // Path/river suggestion
  if (tileCount > 100 && detection.type === 'top-down') {
    suggestions.push({
      id: 'add_river',
      text: 'Add river/path',
      prompt: 'Add a winding river or path through the terrain',
      icon: '🌊',
      category: 'improve'
    });
  }

  // Completion suggestions
  if (objectCount > 20 && tileCount > 100) {
    suggestions.push({
      id: 'analyze_scene',
      text: 'Analyze scene',
      prompt: 'Analyze the current scene and tell me what\'s missing',
      icon: '🔍',
      category: 'improve'
    });
  }

  return suggestions;
}

/**
 * Get color class for suggestion category
 */
function getCategoryColor(category: Suggestion['category']): string {
  switch (category) {
    case 'generate':
      return 'bg-green-50 text-green-700 hover:bg-green-100 border border-green-200';
    case 'improve':
      return 'bg-blue-50 text-blue-700 hover:bg-blue-100 border border-blue-200';
    case 'optimize':
      return 'bg-orange-50 text-orange-700 hover:bg-orange-100 border border-orange-200';
    case 'complete':
      return 'bg-purple-50 text-purple-700 hover:bg-purple-100 border border-purple-200';
    default:
      return 'bg-gray-50 text-gray-700 hover:bg-gray-100 border border-gray-200';
  }
}
</file>

<file path="src/components/animation/AnimationPreview.tsx">
/**
 * Animation Preview Component (PR-31)
 * Live preview of sprite animation
 */

import { useState, useEffect, useRef } from 'react'
import type { Animation } from '../../types/animation'
import { getFrameAtTime, calculateAnimationDuration } from '../../services/assets/animation'

interface AnimationPreviewProps {
  animation: Animation
  spriteSheetUrl: string
  scale?: number
  autoPlay?: boolean
  background?: 'transparent' | 'checkerboard' | 'white' | 'black'
}

export function AnimationPreview({
  animation,
  spriteSheetUrl,
  scale = 2,
  autoPlay = true,
  background = 'checkerboard'
}: AnimationPreviewProps) {
  const [isPlaying, setIsPlaying] = useState(autoPlay)
  const [currentFrameIndex, setCurrentFrameIndex] = useState(0)
  const [spriteSheetImage, setSpriteSheetImage] = useState<HTMLImageElement | null>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const animationStartTime = useRef<number>(Date.now())
  const animationFrameRef = useRef<number | null>(null)

  // Load sprite sheet
  useEffect(() => {
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.onload = () => setSpriteSheetImage(img)
    img.src = spriteSheetUrl
  }, [spriteSheetUrl])

  // Animation loop
  useEffect(() => {
    if (!isPlaying || !spriteSheetImage) {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = null
      }
      return
    }

    const animate = () => {
      const elapsed = Date.now() - animationStartTime.current
      const totalDuration = calculateAnimationDuration(animation)
      const frameIndex = getFrameAtTime(animation, elapsed % totalDuration)
      setCurrentFrameIndex(frameIndex)

      animationFrameRef.current = requestAnimationFrame(animate)
    }

    animationStartTime.current = Date.now()
    animationFrameRef.current = requestAnimationFrame(animate)

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [isPlaying, spriteSheetImage, animation])

  // Draw current frame
  useEffect(() => {
    if (!canvasRef.current || !spriteSheetImage || !animation.frames[currentFrameIndex]) return

    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    const frame = animation.frames[currentFrameIndex]
    
    canvas.width = frame.width * scale
    canvas.height = frame.height * scale

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    // Draw background
    if (background === 'checkerboard') {
      drawCheckerboard(ctx, canvas.width, canvas.height)
    } else if (background !== 'transparent') {
      ctx.fillStyle = background
      ctx.fillRect(0, 0, canvas.width, canvas.height)
    }

    // Draw frame
    ctx.imageSmoothingEnabled = false
    ctx.drawImage(
      spriteSheetImage,
      frame.x, frame.y, frame.width, frame.height,
      0, 0, canvas.width, canvas.height
    )
  }, [spriteSheetImage, currentFrameIndex, scale, background, animation])

  const drawCheckerboard = (ctx: CanvasRenderingContext2D, width: number, height: number) => {
    const tileSize = 8
    ctx.fillStyle = '#e0e0e0'
    ctx.fillRect(0, 0, width, height)
    ctx.fillStyle = '#f5f5f5'
    
    for (let y = 0; y < height; y += tileSize) {
      for (let x = 0; x < width; x += tileSize) {
        if ((x / tileSize + y / tileSize) % 2 === 0) {
          ctx.fillRect(x, y, tileSize, tileSize)
        }
      }
    }
  }

  const togglePlayback = () => {
    if (isPlaying) {
      setIsPlaying(false)
    } else {
      animationStartTime.current = Date.now()
      setIsPlaying(true)
    }
  }

  return (
    <div className="inline-block">
      {/* Preview canvas */}
      <div 
        className="border border-gray-300 rounded mb-2 inline-block cursor-pointer"
        onClick={togglePlayback}
        title={isPlaying ? 'Click to pause' : 'Click to play'}
      >
        <canvas
          ref={canvasRef}
          style={{ 
            imageRendering: 'pixelated',
            display: 'block'
          }}
        />
      </div>

      {/* Controls */}
      <div className="flex items-center justify-between gap-2">
        <button
          onClick={togglePlayback}
          className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm"
        >
          {isPlaying ? 'Pause' : 'Play'}
        </button>

        <span className="text-sm text-gray-600">
          Frame {currentFrameIndex + 1}/{animation.frames.length}
        </span>

        <div className="flex items-center gap-1">
          <label className="text-xs text-gray-600">Scale:</label>
          <span className="text-sm font-medium text-gray-900">{scale}x</span>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/animation/AnimationTimeline.tsx">
/**
 * Animation Timeline Component (PR-31)
 * Timeline editor for sprite animations
 */

import { useState, useRef, useEffect } from 'react'
import type { Animation, AnimationFrame } from '../../types/animation'

interface AnimationTimelineProps {
  animation: Animation
  spriteSheetUrl: string
  onUpdateFrames: (frames: AnimationFrame[]) => void
  onUpdateFps: (fps: number) => void
  onUpdateLoop: (loop: boolean) => void
}

export function AnimationTimeline({
  animation,
  spriteSheetUrl,
  onUpdateFrames,
  onUpdateFps,
  onUpdateLoop
}: AnimationTimelineProps) {
  const [selectedFrameIndex, setSelectedFrameIndex] = useState<number | null>(null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentPlayFrame, setCurrentPlayFrame] = useState(0)
  const [draggedFrameIndex, setDraggedFrameIndex] = useState<number | null>(null)
  const playIntervalRef = useRef<number | null>(null)
  const spriteSheetImageRef = useRef<HTMLImageElement | null>(null)

  // Load sprite sheet image
  useEffect(() => {
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.src = spriteSheetUrl
    img.onload = () => {
      spriteSheetImageRef.current = img
    }
  }, [spriteSheetUrl])

  // Animation playback
  useEffect(() => {
    if (!isPlaying) {
      if (playIntervalRef.current) {
        clearInterval(playIntervalRef.current)
        playIntervalRef.current = null
      }
      return
    }

    const frameDuration = 1000 / animation.fps
    playIntervalRef.current = window.setInterval(() => {
      setCurrentPlayFrame(prev => {
        const next = prev + 1
        if (next >= animation.frames.length) {
          if (animation.loop) {
            return 0
          } else {
            setIsPlaying(false)
            return prev
          }
        }
        return next
      })
    }, frameDuration)

    return () => {
      if (playIntervalRef.current) {
        clearInterval(playIntervalRef.current)
      }
    }
  }, [isPlaying, animation.fps, animation.frames.length, animation.loop])

  // Handle play/pause
  const togglePlayback = () => {
    if (isPlaying) {
      setIsPlaying(false)
    } else {
      setCurrentPlayFrame(0)
      setIsPlaying(true)
    }
  }

  // Handle frame selection
  const selectFrame = (index: number) => {
    setSelectedFrameIndex(index)
    setIsPlaying(false)
    setCurrentPlayFrame(index)
  }

  // Handle frame deletion
  const deleteFrame = (index: number) => {
    if (animation.frames.length <= 1) return // Don't allow deleting last frame
    
    const newFrames = animation.frames.filter((_, i) => i !== index)
    onUpdateFrames(newFrames)
    
    if (selectedFrameIndex === index) {
      setSelectedFrameIndex(null)
    } else if (selectedFrameIndex !== null && selectedFrameIndex > index) {
      setSelectedFrameIndex(selectedFrameIndex - 1)
    }
  }

  // Handle frame duplication
  const duplicateFrame = (index: number) => {
    const frameToDuplicate = animation.frames[index]
    const newFrames = [
      ...animation.frames.slice(0, index + 1),
      { ...frameToDuplicate },
      ...animation.frames.slice(index + 1)
    ]
    onUpdateFrames(newFrames)
  }

  // Handle drag start
  const handleDragStart = (index: number) => {
    setDraggedFrameIndex(index)
  }

  // Handle drag over
  const handleDragOver = (e: React.DragEvent, index: number) => {
    e.preventDefault()
    if (draggedFrameIndex === null || draggedFrameIndex === index) return

    const newFrames = [...animation.frames]
    const [draggedFrame] = newFrames.splice(draggedFrameIndex, 1)
    newFrames.splice(index, 0, draggedFrame)

    onUpdateFrames(newFrames)
    setDraggedFrameIndex(index)
  }

  // Handle drag end
  const handleDragEnd = () => {
    setDraggedFrameIndex(null)
  }

  // Render frame thumbnail
  const renderFrameThumbnail = (frame: AnimationFrame, size: number = 64) => {
    const canvas = document.createElement('canvas')
    canvas.width = size
    canvas.height = size
    const ctx = canvas.getContext('2d')
    if (!ctx || !spriteSheetImageRef.current) return null

    // Scale to fit
    const scale = Math.min(size / frame.width, size / frame.height)
    const scaledWidth = frame.width * scale
    const scaledHeight = frame.height * scale
    const offsetX = (size - scaledWidth) / 2
    const offsetY = (size - scaledHeight) / 2

    // Draw frame
    ctx.drawImage(
      spriteSheetImageRef.current,
      frame.x, frame.y, frame.width, frame.height,
      offsetX, offsetY, scaledWidth, scaledHeight
    )

    return canvas.toDataURL()
  }

  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4">
      {/* Controls */}
      <div className="mb-4 flex items-center justify-between gap-4">
        {/* Playback controls */}
        <div className="flex items-center gap-2">
          <button
            onClick={togglePlayback}
            className="p-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            title={isPlaying ? 'Pause' : 'Play'}
          >
            {isPlaying ? (
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z" />
              </svg>
            ) : (
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z" />
              </svg>
            )}
          </button>

          <button
            onClick={() => {
              setIsPlaying(false)
              setCurrentPlayFrame(0)
            }}
            className="p-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors"
            title="Stop"
          >
            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M6 6h12v12H6z" />
            </svg>
          </button>

          <div className="flex items-center gap-2 ml-2">
            <label htmlFor="loop-toggle" className="text-sm text-gray-700">
              Loop
            </label>
            <input
              id="loop-toggle"
              type="checkbox"
              checked={animation.loop}
              onChange={(e) => onUpdateLoop(e.target.checked)}
              className="w-4 h-4"
            />
          </div>
        </div>

        {/* FPS control */}
        <div className="flex items-center gap-2">
          <label htmlFor="fps-slider" className="text-sm text-gray-700">
            FPS:
          </label>
          <input
            id="fps-slider"
            type="range"
            min="1"
            max="60"
            value={animation.fps}
            onChange={(e) => onUpdateFps(parseInt(e.target.value))}
            className="w-32"
          />
          <span className="text-sm font-medium text-gray-900 w-8">{animation.fps}</span>
        </div>

        {/* Frame count */}
        <div className="text-sm text-gray-600">
          Frame {currentPlayFrame + 1} / {animation.frames.length}
        </div>
      </div>

      {/* Timeline */}
      <div className="relative">
        {/* Frame strip */}
        <div className="flex gap-2 overflow-x-auto pb-2">
          {animation.frames.map((frame, index) => (
            <div
              key={index}
              draggable
              onDragStart={() => handleDragStart(index)}
              onDragOver={(e) => handleDragOver(e, index)}
              onDragEnd={handleDragEnd}
              onClick={() => selectFrame(index)}
              className={`flex-shrink-0 cursor-pointer border-2 rounded transition-all ${
                selectedFrameIndex === index
                  ? 'border-blue-500 bg-blue-50'
                  : currentPlayFrame === index && isPlaying
                  ? 'border-green-500 bg-green-50'
                  : 'border-gray-300 hover:border-gray-400'
              }`}
            >
              {/* Frame thumbnail */}
              <div className="w-20 h-20 bg-gray-100 flex items-center justify-center">
                {spriteSheetImageRef.current && (
                  <img
                    src={renderFrameThumbnail(frame, 64) || ''}
                    alt={`Frame ${index}`}
                    className="max-w-full max-h-full"
                    style={{ imageRendering: 'pixelated' }}
                  />
                )}
              </div>

              {/* Frame info */}
              <div className="px-2 py-1 bg-white">
                <div className="text-xs text-gray-600 text-center">
                  {index}
                </div>
              </div>

              {/* Frame actions */}
              <div className="flex gap-1 p-1 bg-gray-50">
                <button
                  onClick={(e) => {
                    e.stopPropagation()
                    duplicateFrame(index)
                  }}
                  className="flex-1 text-xs px-1 py-0.5 bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                  title="Duplicate"
                >
                  ⧉
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation()
                    deleteFrame(index)
                  }}
                  className="flex-1 text-xs px-1 py-0.5 bg-red-100 text-red-700 rounded hover:bg-red-200"
                  title="Delete"
                  disabled={animation.frames.length <= 1}
                >
                  ×
                </button>
              </div>
            </div>
          ))}
        </div>

        {/* Playhead indicator */}
        {isPlaying && (
          <div
            className="absolute top-0 bottom-0 w-0.5 bg-green-500 pointer-events-none transition-all"
            style={{
              left: `${(currentPlayFrame * 88) + 40}px` // 80px width + 8px gap
            }}
          />
        )}
      </div>

      {/* Selected frame details */}
      {selectedFrameIndex !== null && (
        <div className="mt-4 p-3 bg-gray-50 rounded border border-gray-200">
          <h4 className="text-sm font-medium text-gray-700 mb-2">
            Frame {selectedFrameIndex} Details
          </h4>
          <div className="grid grid-cols-2 gap-2 text-xs text-gray-600">
            <div>X: {animation.frames[selectedFrameIndex].x}</div>
            <div>Y: {animation.frames[selectedFrameIndex].y}</div>
            <div>Width: {animation.frames[selectedFrameIndex].width}</div>
            <div>Height: {animation.frames[selectedFrameIndex].height}</div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/components/animation/FrameSelector.tsx">
/**
 * Frame Selector Component (PR-31)
 * Select frames from a sprite sheet for animations
 */

import { useState, useRef, useEffect } from 'react'
import type { AnimationFrame } from '../../types/animation'
import { autoGenerateFrames } from '../../services/assets/animation'

interface FrameSelectorProps {
  spriteSheetUrl: string
  spriteSheetWidth: number
  spriteSheetHeight: number
  onAddFrame: (frame: AnimationFrame) => void
  onAddMultipleFrames: (frames: AnimationFrame[]) => void
}

export function FrameSelector({
  spriteSheetUrl,
  spriteSheetWidth,
  spriteSheetHeight,
  onAddFrame,
  onAddMultipleFrames
}: FrameSelectorProps) {
  const [frameWidth, setFrameWidth] = useState(32)
  const [frameHeight, setFrameHeight] = useState(32)
  const [spacing, setSpacing] = useState(0)
  const [margin, setMargin] = useState(0)
  const [selectedRegion, setSelectedRegion] = useState<AnimationFrame | null>(null)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState<{ x: number; y: number } | null>(null)
  const [spriteSheetImage, setSpriteSheetImage] = useState<HTMLImageElement | null>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)

  // Load sprite sheet
  useEffect(() => {
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.onload = () => setSpriteSheetImage(img)
    img.src = spriteSheetUrl
  }, [spriteSheetUrl])

  // Draw sprite sheet with grid overlay
  useEffect(() => {
    if (!canvasRef.current || !spriteSheetImage) return

    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    canvas.width = spriteSheetImage.width
    canvas.height = spriteSheetImage.height

    // Draw sprite sheet
    ctx.drawImage(spriteSheetImage, 0, 0)

    // Draw grid overlay
    ctx.strokeStyle = 'rgba(0, 120, 255, 0.3)'
    ctx.lineWidth = 1

    for (let y = margin; y < spriteSheetImage.height; y += frameHeight + spacing) {
      for (let x = margin; x < spriteSheetImage.width; x += frameWidth + spacing) {
        if (x + frameWidth <= spriteSheetImage.width && y + frameHeight <= spriteSheetImage.height) {
          ctx.strokeRect(x, y, frameWidth, frameHeight)
        }
      }
    }

    // Draw selected region
    if (selectedRegion) {
      ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'
      ctx.lineWidth = 2
      ctx.strokeRect(selectedRegion.x, selectedRegion.y, selectedRegion.width, selectedRegion.height)
      
      // Highlight fill
      ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'
      ctx.fillRect(selectedRegion.x, selectedRegion.y, selectedRegion.width, selectedRegion.height)
    }
  }, [spriteSheetImage, frameWidth, frameHeight, spacing, margin, selectedRegion])

  // Handle canvas click/drag
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current) return

    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    setIsDragging(true)
    setDragStart({ x, y })
    setSelectedRegion({ x, y, width: 0, height: 0 })
  }

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging || !dragStart || !canvasRef.current) return

    const rect = canvasRef.current.getBoundingClientRect()
    const currentX = e.clientX - rect.left
    const currentY = e.clientY - rect.top

    const x = Math.min(dragStart.x, currentX)
    const y = Math.min(dragStart.y, currentY)
    const width = Math.abs(currentX - dragStart.x)
    const height = Math.abs(currentY - dragStart.y)

    setSelectedRegion({ x, y, width, height })
  }

  const handleMouseUp = () => {
    setIsDragging(false)
    setDragStart(null)
  }

  // Handle quick frame select (click on grid cell)
  const handleQuickSelect = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (isDragging) return // Don't quick select while dragging
    if (!canvasRef.current) return

    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    // Snap to grid
    const gridX = Math.floor((x - margin) / (frameWidth + spacing))
    const gridY = Math.floor((y - margin) / (frameHeight + spacing))

    const frameX = margin + gridX * (frameWidth + spacing)
    const frameY = margin + gridY * (frameHeight + spacing)

    if (
      frameX >= 0 && frameX + frameWidth <= spriteSheetWidth &&
      frameY >= 0 && frameY + frameHeight <= spriteSheetHeight
    ) {
      setSelectedRegion({
        x: frameX,
        y: frameY,
        width: frameWidth,
        height: frameHeight
      })
    }
  }

  // Add selected frame to animation
  const handleAddFrame = () => {
    if (selectedRegion && selectedRegion.width > 0 && selectedRegion.height > 0) {
      onAddFrame(selectedRegion)
    }
  }

  // Auto-generate all frames
  const handleAutoGenerateFrames = () => {
    const frames = autoGenerateFrames(
      spriteSheetWidth,
      spriteSheetHeight,
      frameWidth,
      frameHeight,
      { spacing, margin }
    )
    onAddMultipleFrames(frames)
  }

  // Common frame sizes
  const commonSizes = [16, 32, 48, 64, 128]

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Frame Size
          </label>
          <div className="grid grid-cols-2 gap-2">
            <div>
              <label className="block text-xs text-gray-600 mb-1">Width</label>
              <input
                type="number"
                value={frameWidth}
                onChange={(e) => setFrameWidth(Math.max(1, parseInt(e.target.value) || 1))}
                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                min="1"
              />
            </div>
            <div>
              <label className="block text-xs text-gray-600 mb-1">Height</label>
              <input
                type="number"
                value={frameHeight}
                onChange={(e) => setFrameHeight(Math.max(1, parseInt(e.target.value) || 1))}
                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                min="1"
              />
            </div>
          </div>

          {/* Quick sizes */}
          <div className="mt-2 flex flex-wrap gap-1">
            {commonSizes.map(size => (
              <button
                key={size}
                onClick={() => {
                  setFrameWidth(size)
                  setFrameHeight(size)
                }}
                className="px-2 py-0.5 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200"
              >
                {size}×{size}
              </button>
            ))}
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Grid Settings
          </label>
          <div className="grid grid-cols-2 gap-2">
            <div>
              <label className="block text-xs text-gray-600 mb-1">Spacing</label>
              <input
                type="number"
                value={spacing}
                onChange={(e) => setSpacing(Math.max(0, parseInt(e.target.value) || 0))}
                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                min="0"
              />
            </div>
            <div>
              <label className="block text-xs text-gray-600 mb-1">Margin</label>
              <input
                type="number"
                value={margin}
                onChange={(e) => setMargin(Math.max(0, parseInt(e.target.value) || 0))}
                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                min="0"
              />
            </div>
          </div>
        </div>
      </div>

      {/* Actions */}
      <div className="flex gap-2">
        <button
          onClick={handleAutoGenerateFrames}
          className="flex-1 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors text-sm"
        >
          Auto-Generate All Frames
        </button>
        <button
          onClick={handleAddFrame}
          disabled={!selectedRegion || selectedRegion.width === 0}
          className="flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
        >
          Add Selected Frame
        </button>
      </div>

      {/* Sprite sheet preview */}
      <div className="border border-gray-300 rounded overflow-auto max-h-96 bg-gray-50">
        <canvas
          ref={canvasRef}
          className="cursor-crosshair"
          style={{ imageRendering: 'pixelated' }}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
          onClick={handleQuickSelect}
        />
      </div>

      {/* Selected region info */}
      {selectedRegion && selectedRegion.width > 0 && (
        <div className="p-3 bg-blue-50 border border-blue-200 rounded text-sm">
          <div className="font-medium text-blue-800 mb-1">Selected Region</div>
          <div className="grid grid-cols-2 gap-2 text-xs text-blue-700">
            <div>X: {Math.round(selectedRegion.x)}</div>
            <div>Y: {Math.round(selectedRegion.y)}</div>
            <div>Width: {Math.round(selectedRegion.width)}</div>
            <div>Height: {Math.round(selectedRegion.height)}</div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/components/assets/AssetCard.tsx">
/**
 * Asset Card Component (PR-31)
 * Displays an asset thumbnail with actions
 */

import { useState } from 'react'
import type { Asset } from '../../types/asset'

interface AssetCardProps {
  asset: Asset
  isSelected: boolean
  onSelect: (assetId: string) => void
  onDelete: (assetId: string) => void
  onUseAsTileset?: (assetId: string) => void
  onCreateAnimation?: (assetId: string) => void
}

const TYPE_BADGES: Record<string, { label: string; color: string }> = {
  image: { label: 'Image', color: 'bg-gray-500' },
  spritesheet: { label: 'Sprite', color: 'bg-purple-500' },
  tileset: { label: 'Tileset', color: 'bg-green-500' },
  audio: { label: 'Audio', color: 'bg-blue-500' },
  font: { label: 'Font', color: 'bg-orange-500' }
}

export function AssetCard({
  asset,
  isSelected,
  onSelect,
  onDelete,
  onUseAsTileset,
  onCreateAnimation
}: AssetCardProps) {
  const [showActions, setShowActions] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)

  const badge = TYPE_BADGES[asset.type] || TYPE_BADGES.image

  const handleDelete = () => {
    if (showDeleteConfirm) {
      onDelete(asset.id)
      setShowDeleteConfirm(false)
    } else {
      setShowDeleteConfirm(true)
      setTimeout(() => setShowDeleteConfirm(false), 3000) // Auto-cancel after 3s
    }
  }

  return (
    <div
      className={`relative group bg-white rounded-lg shadow-sm hover:shadow-md transition-all cursor-pointer ${
        isSelected ? 'ring-2 ring-blue-500' : 'border border-gray-200'
      }`}
      onClick={() => onSelect(asset.id)}
      onMouseEnter={() => setShowActions(true)}
      onMouseLeave={() => setShowActions(false)}
    >
      {/* Thumbnail */}
      <div className="aspect-square bg-gray-100 rounded-t-lg overflow-hidden relative">
        {asset.thumbnailUrl || asset.url ? (
          <img
            src={asset.thumbnailUrl || asset.url}
            alt={asset.name}
            className="w-full h-full object-contain"
            loading="lazy"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-gray-400">
            <svg className="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
              />
            </svg>
          </div>
        )}

        {/* Type badge */}
        <div className={`absolute top-2 left-2 ${badge.color} text-white text-xs px-2 py-1 rounded`}>
          {badge.label}
        </div>

        {/* Hover actions */}
        {showActions && (
          <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
            {asset.type === 'spritesheet' && onCreateAnimation && (
              <button
                onClick={(e) => {
                  e.stopPropagation()
                  onCreateAnimation(asset.id)
                }}
                className="px-3 py-1.5 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 transition-colors"
                title="Create Animation"
              >
                Animate
              </button>
            )}
            
            {(asset.type === 'tileset' || asset.type === 'image') && onUseAsTileset && (
              <button
                onClick={(e) => {
                  e.stopPropagation()
                  onUseAsTileset(asset.id)
                }}
                className="px-3 py-1.5 bg-green-600 text-white text-sm rounded hover:bg-green-700 transition-colors"
                title="Use as Tileset"
              >
                Tileset
              </button>
            )}
            
            <button
              onClick={(e) => {
                e.stopPropagation()
                handleDelete()
              }}
              className={`px-3 py-1.5 text-white text-sm rounded transition-colors ${
                showDeleteConfirm
                  ? 'bg-red-700 hover:bg-red-800'
                  : 'bg-red-600 hover:bg-red-700'
              }`}
              title={showDeleteConfirm ? 'Click again to confirm' : 'Delete'}
            >
              {showDeleteConfirm ? 'Confirm?' : 'Delete'}
            </button>
          </div>
        )}
      </div>

      {/* Info */}
      <div className="p-3">
        <h3 className="font-medium text-gray-900 truncate text-sm" title={asset.name}>
          {asset.name}
        </h3>
        <div className="mt-1 flex items-center justify-between text-xs text-gray-500">
          <span>{asset.metadata.width} × {asset.metadata.height}</span>
          <span>{(asset.metadata.fileSize / 1024).toFixed(0)} KB</span>
        </div>
        
        {/* Tags */}
        {asset.tags && asset.tags.length > 0 && (
          <div className="mt-2 flex flex-wrap gap-1">
            {asset.tags.slice(0, 2).map((tag) => (
              <span
                key={tag}
                className="inline-block px-2 py-0.5 bg-blue-50 text-blue-700 text-xs rounded"
              >
                {tag}
              </span>
            ))}
            {asset.tags.length > 2 && (
              <span className="inline-block px-2 py-0.5 bg-gray-100 text-gray-600 text-xs rounded">
                +{asset.tags.length - 2}
              </span>
            )}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/assets/AssetLibrary.tsx">
/**
 * Asset Library Panel Component (PR-31)
 * Main panel for browsing and managing assets
 */

import { useState, useMemo } from 'react'
import { AssetCard } from './AssetCard'
import { AssetUploadModalEnhanced } from './AssetUploadModalEnhanced'
import { useAssetLibrary } from '../../hooks/useAssetLibrary'
import type { AssetType } from '../../types/asset'

interface AssetLibraryProps {
  userId: string
  onClose?: () => void
  onSelectAsset?: (assetId: string) => void
}

export function AssetLibrary({ userId, onClose, onSelectAsset }: AssetLibraryProps) {
  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false)
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid')
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedTypeFilter, setSelectedTypeFilter] = useState<AssetType | 'all'>('all')

  const {
    assets,
    isLoading,
    error,
    selectedAssetId,
    uploadProgress,
    uploadAsset: handleUploadAsset,
    deleteAsset: handleDeleteAsset,
    selectAsset,
    getFilteredAssets,
    getAllTags,
    searchAssets,
    filterByType
  } = useAssetLibrary({ userId })

  // Apply search and filters
  useMemo(() => {
    searchAssets(searchQuery)
  }, [searchQuery, searchAssets])

  useMemo(() => {
    if (selectedTypeFilter === 'all') {
      filterByType(null)
    } else {
      filterByType(selectedTypeFilter)
    }
  }, [selectedTypeFilter, filterByType])

  const filteredAssets = getFilteredAssets()
  const tags = getAllTags()

  // Handle asset upload
  const handleUpload = async (
    file: File,
    metadata: { name: string; type?: AssetType; tags: string[] }
  ) => {
    await handleUploadAsset(file, metadata)
    setIsUploadModalOpen(false)
  }

  const handleAssetSelect = (assetId: string) => {
    selectAsset(assetId)
    if (onSelectAsset) {
      onSelectAsset(assetId)
    }
  }

  // Count assets by type
  const assetCounts = useMemo(() => {
    const counts: Record<string, number> = {
      all: assets?.length || 0,
      image: 0,
      spritesheet: 0,
      tileset: 0,
      audio: 0,
      font: 0
    }

    assets?.forEach(asset => {
      counts[asset.type] = (counts[asset.type] || 0) + 1
    })

    return counts
  }, [assets])

  return (
    <div className="h-full flex flex-col bg-white border-r border-gray-200">
      {/* Header */}
      <div className="p-4 border-b border-gray-200">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-gray-800">Asset Library</h2>
          {onClose && (
            <button
              onClick={onClose}
              className="text-gray-500 hover:text-gray-700"
              title="Close"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>

        {/* Upload button */}
        <button
          onClick={() => setIsUploadModalOpen(true)}
          className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          Upload Asset
        </button>
      </div>

      {/* Search and filters */}
      <div className="p-4 border-b border-gray-200 space-y-3">
        {/* Search bar */}
        <div className="relative">
          <input
            type="text"
            placeholder="Search assets..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-9 pr-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
          />
          <svg
            className="absolute left-3 top-2.5 w-4 h-4 text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            />
          </svg>
        </div>

        {/* Type filter */}
        <div className="flex flex-wrap gap-1.5">
          <button
            onClick={() => setSelectedTypeFilter('all')}
            className={`px-3 py-1 text-xs rounded transition-colors ${
              selectedTypeFilter === 'all'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            All ({assetCounts.all})
          </button>
          <button
            onClick={() => setSelectedTypeFilter('image')}
            className={`px-3 py-1 text-xs rounded transition-colors ${
              selectedTypeFilter === 'image'
                ? 'bg-gray-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Images ({assetCounts.image})
          </button>
          <button
            onClick={() => setSelectedTypeFilter('spritesheet')}
            className={`px-3 py-1 text-xs rounded transition-colors ${
              selectedTypeFilter === 'spritesheet'
                ? 'bg-purple-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Sprites ({assetCounts.spritesheet})
          </button>
          <button
            onClick={() => setSelectedTypeFilter('tileset')}
            className={`px-3 py-1 text-xs rounded transition-colors ${
              selectedTypeFilter === 'tileset'
                ? 'bg-green-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Tilesets ({assetCounts.tileset})
          </button>
        </div>

        {/* View mode toggle */}
        <div className="flex justify-end">
          <div className="inline-flex rounded border border-gray-300">
            <button
              onClick={() => setViewMode('grid')}
              className={`px-3 py-1 text-xs ${
                viewMode === 'grid'
                  ? 'bg-gray-200 text-gray-900'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
              title="Grid view"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"
                />
              </svg>
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`px-3 py-1 text-xs border-l border-gray-300 ${
                viewMode === 'list'
                  ? 'bg-gray-200 text-gray-900'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
              title="List view"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4 6h16M4 12h16M4 18h16"
                />
              </svg>
            </button>
          </div>
        </div>
      </div>

      {/* Upload progress */}
      {uploadProgress.size > 0 && (
        <div className="p-4 border-b border-gray-200 bg-blue-50">
          {Array.from(uploadProgress.values()).map((progress) => (
            <div key={progress.assetId} className="mb-2">
              <div className="flex justify-between text-sm mb-1">
                <span className="text-gray-700">{progress.fileName}</span>
                <span className="text-gray-600">{Math.round(progress.progress)}%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div
                  className="bg-blue-600 h-2 rounded-full transition-all"
                  style={{ width: `${progress.progress}%` }}
                />
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4">
        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <div className="text-gray-500">Loading assets...</div>
          </div>
        ) : error ? (
          <div className="flex items-center justify-center h-full">
            <div className="text-red-500">{error}</div>
          </div>
        ) : filteredAssets.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full text-gray-500">
            <svg className="w-16 h-16 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
              />
            </svg>
            <p className="text-lg font-medium">No assets found</p>
            <p className="text-sm mt-1">Upload your first asset to get started</p>
          </div>
        ) : (
          <div
            className={
              viewMode === 'grid'
                ? 'grid grid-cols-2 gap-3'
                : 'space-y-2'
            }
          >
            {filteredAssets.map((asset) => (
              <AssetCard
                key={asset.id}
                asset={asset}
                isSelected={selectedAssetId === asset.id}
                onSelect={handleAssetSelect}
                onDelete={handleDeleteAsset}
                onUseAsTileset={() => {
                  // TODO: Open tileset configurator
                  console.log('Use as tileset:', asset.id)
                }}
                onCreateAnimation={() => {
                  // TODO: Open animation creator
                  console.log('Create animation:', asset.id)
                }}
              />
            ))}
          </div>
        )}
      </div>

      {/* Upload modal */}
      <AssetUploadModalEnhanced
        isOpen={isUploadModalOpen}
        onClose={() => setIsUploadModalOpen(false)}
        onUpload={handleUpload}
      />
    </div>
  )
}
</file>

<file path="src/components/assets/AssetUploadModal.tsx">
/**
 * Asset Upload Modal Component (PR-31)
 * Drag-and-drop file upload with preview and metadata
 */

import { useState, useCallback, useRef } from 'react'
import { validateAssetFile, generateThumbnail } from '../../services/assets/assetUpload'
import type { AssetType } from '../../types/asset'

interface AssetUploadModalProps {
  isOpen: boolean
  onClose: () => void
  onUpload: (file: File, metadata: {
    name: string
    type?: AssetType
    tags: string[]
  }) => Promise<void>
  initialType?: AssetType
}

export function AssetUploadModal({
  isOpen,
  onClose,
  onUpload,
  initialType
}: AssetUploadModalProps) {
  const [file, setFile] = useState<File | null>(null)
  const [preview, setPreview] = useState<string | null>(null)
  const [name, setName] = useState('')
  const [tags, setTags] = useState<string[]>([])
  const [tagInput, setTagInput] = useState('')
  const [type, setType] = useState<AssetType>(initialType || 'image')
  const [isDragging, setIsDragging] = useState(false)
  const [isUploading, setIsUploading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [validation, setValidation] = useState<{ errors: string[]; warnings: string[] } | null>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleFileSelect = useCallback(async (selectedFile: File) => {
    setError(null)
    
    // Validate file
    const validationResult = validateAssetFile(selectedFile)
    setValidation(validationResult)
    
    if (!validationResult.valid) {
      setError(validationResult.errors.join(', '))
      return
    }

    setFile(selectedFile)
    
    // Auto-fill name from filename
    if (!name) {
      const fileName = selectedFile.name.replace(/\.[^/.]+$/, '')
      setName(fileName)
    }

    // Generate preview
    try {
      const previewUrl = await generateThumbnail(selectedFile, 300)
      setPreview(previewUrl)
    } catch (err) {
      console.warn('Failed to generate preview:', err)
    }
  }, [name])

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(true)
  }, [])

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(false)
  }, [])

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(false)

    const droppedFiles = Array.from(e.dataTransfer.files)
    if (droppedFiles.length > 0) {
      handleFileSelect(droppedFiles[0])
    }
  }, [handleFileSelect])

  const handleFileInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFiles = e.target.files
    if (selectedFiles && selectedFiles.length > 0) {
      handleFileSelect(selectedFiles[0])
    }
  }, [handleFileSelect])

  const handleAddTag = useCallback(() => {
    const trimmedTag = tagInput.trim()
    if (trimmedTag && !tags.includes(trimmedTag)) {
      setTags([...tags, trimmedTag])
      setTagInput('')
    }
  }, [tagInput, tags])

  const handleRemoveTag = useCallback((tagToRemove: string) => {
    setTags(tags.filter(t => t !== tagToRemove))
  }, [tags])

  const handleUpload = useCallback(async () => {
    if (!file || !name.trim()) {
      setError('Please provide a file and name')
      return
    }

    setIsUploading(true)
    setError(null)

    try {
      await onUpload(file, {
        name: name.trim(),
        type,
        tags
      })

      // Reset form
      setFile(null)
      setPreview(null)
      setName('')
      setTags([])
      setType('image')
      setValidation(null)
      
      onClose()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed')
    } finally {
      setIsUploading(false)
    }
  }, [file, name, type, tags, onUpload, onClose])

  const handleReset = useCallback(() => {
    setFile(null)
    setPreview(null)
    setName('')
    setTags([])
    setType(initialType || 'image')
    setError(null)
    setValidation(null)
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
  }, [initialType])

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold text-gray-800">Upload Asset</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 text-2xl"
            disabled={isUploading}
          >
            ×
          </button>
        </div>

        {/* Drag and drop zone */}
        <div
          className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
            isDragging
              ? 'border-blue-500 bg-blue-50'
              : 'border-gray-300 hover:border-gray-400'
          }`}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
        >
          {!file ? (
            <>
              <div className="mb-4">
                <svg
                  className="mx-auto h-12 w-12 text-gray-400"
                  stroke="currentColor"
                  fill="none"
                  viewBox="0 0 48 48"
                >
                  <path
                    d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
                    strokeWidth={2}
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  />
                </svg>
              </div>
              <p className="text-gray-600 mb-2">Drag and drop your image here, or</p>
              <button
                onClick={() => fileInputRef.current?.click()}
                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
              >
                Browse Files
              </button>
              <input
                ref={fileInputRef}
                type="file"
                accept="image/png,image/jpeg,image/jpg,image/webp,image/gif"
                onChange={handleFileInputChange}
                className="hidden"
              />
              <p className="text-sm text-gray-500 mt-2">
                Supported formats: PNG, JPG, WEBP, GIF (max 10MB)
              </p>
            </>
          ) : (
            <>
              {preview && (
                <img
                  src={preview}
                  alt="Preview"
                  className="max-w-full max-h-64 mx-auto mb-4 rounded"
                />
              )}
              <p className="text-gray-600 mb-2">{file.name}</p>
              <p className="text-sm text-gray-500 mb-4">
                {(file.size / 1024 / 1024).toFixed(2)} MB
              </p>
              <button
                onClick={handleReset}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors"
              >
                Choose Different File
              </button>
            </>
          )}
        </div>

        {/* Validation messages */}
        {validation && (
          <div className="mt-4">
            {validation.warnings.length > 0 && (
              <div className="bg-yellow-50 border border-yellow-200 rounded p-3 mb-2">
                <p className="text-sm text-yellow-800 font-semibold mb-1">Warnings:</p>
                {validation.warnings.map((warning, i) => (
                  <p key={i} className="text-sm text-yellow-700">• {warning}</p>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Error message */}
        {error && (
          <div className="mt-4 bg-red-50 border border-red-200 rounded p-3">
            <p className="text-sm text-red-800">{error}</p>
          </div>
        )}

        {/* Metadata form */}
        {file && (
          <div className="mt-6 space-y-4">
            {/* Name input */}
            <div>
              <label htmlFor="asset-name" className="block text-sm font-medium text-gray-700 mb-1">
                Asset Name <span className="text-red-500">*</span>
              </label>
              <input
                id="asset-name"
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., grass_tileset"
              />
            </div>

            {/* Type selection */}
            <div>
              <label htmlFor="asset-type" className="block text-sm font-medium text-gray-700 mb-1">
                Asset Type
              </label>
              <select
                id="asset-type"
                value={type}
                onChange={(e) => setType(e.target.value as AssetType)}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="image">Image</option>
                <option value="spritesheet">Sprite Sheet</option>
                <option value="tileset">Tileset</option>
              </select>
            </div>

            {/* Tags input */}
            <div>
              <label htmlFor="asset-tags" className="block text-sm font-medium text-gray-700 mb-1">
                Tags
              </label>
              <div className="flex gap-2 mb-2">
                <input
                  id="asset-tags"
                  type="text"
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Add tags..."
                />
                <button
                  onClick={handleAddTag}
                  className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors"
                >
                  Add
                </button>
              </div>
              {tags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {tags.map((tag) => (
                    <span
                      key={tag}
                      className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
                    >
                      {tag}
                      <button
                        onClick={() => handleRemoveTag(tag)}
                        className="hover:text-blue-900"
                      >
                        ×
                      </button>
                    </span>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}

        {/* Actions */}
        <div className="mt-6 flex justify-end gap-3">
          <button
            onClick={onClose}
            disabled={isUploading}
            className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors disabled:opacity-50"
          >
            Cancel
          </button>
          <button
            onClick={handleUpload}
            disabled={!file || !name.trim() || isUploading}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isUploading ? 'Uploading...' : 'Upload'}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/assets/AssetUploadModalEnhanced.tsx">
/**
 * Enhanced Asset Upload Modal with Manual Sprite Selection
 * PR-31: Supports both auto-detection and manual sprite selection
 */

import { useState, useCallback, useEffect } from 'react';
import { ManualSpriteSelector } from './ManualSpriteSelector';
import { detectSpritesByTransparency, detectedSpritesToSelections } from '../../utils/tilemap/spriteDetection';
import type { AssetType, SpriteSelection } from '../../types/asset';

interface AssetUploadModalEnhancedProps {
  isOpen: boolean;
  onClose: () => void;
  onUpload: (file: File, metadata: {
    name: string;
    type?: AssetType;
    tags: string[];
    spriteSelections?: SpriteSelection[];
  }) => Promise<void>;
}

type UploadMode = 'basic' | 'manual-select';

export function AssetUploadModalEnhanced({
  isOpen,
  onClose,
  onUpload
}: AssetUploadModalEnhancedProps) {
  const [file, setFile] = useState<File | null>(null);
  const [preview, setPreview] = useState<string | null>(null);
  const [name, setName] = useState('');
  const [tags, setTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState('');
  const [type, setType] = useState<AssetType>('image');
  const [mode, setMode] = useState<UploadMode>('basic');
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Sprite selection state
  const [spriteSelections, setSpriteSelections] = useState<SpriteSelection[]>([]);
  
  // Visual detection state
  const [isDetectingSprites, setIsDetectingSprites] = useState(false);
  const [detectionResult, setDetectionResult] = useState<any>(null);

  const handleFileSelect = useCallback(async (selectedFile: File) => {
    setError(null);
    
    // Validate file size
    if (selectedFile.size > 10 * 1024 * 1024) {
      setError('File too large (max 10MB)');
      return;
    }

    setFile(selectedFile);
    
    // Auto-fill name
    if (!name) {
      const fileName = selectedFile.name.replace(/\.[^/.]+$/, '');
      setName(fileName);
    }

    // Generate preview
    try {
      const url = URL.createObjectURL(selectedFile);
      setPreview(url);

      // If sprite sheet or tileset, switch to sprite selection mode
      if (type === 'spritesheet' || type === 'tileset') {
        setMode('manual-select');
      }
    } catch (err) {
      console.warn('Failed to process image:', err);
    }
  }, [name, type]);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    const droppedFiles = Array.from(e.dataTransfer.files);
    if (droppedFiles.length > 0) {
      handleFileSelect(droppedFiles[0]);
    }
  }, [handleFileSelect]);

  const handleAddTag = useCallback(() => {
    const trimmedTag = tagInput.trim();
    if (trimmedTag && !tags.includes(trimmedTag)) {
      setTags([...tags, trimmedTag]);
      setTagInput('');
    }
  }, [tagInput, tags]);

  const handleRemoveTag = useCallback((tagToRemove: string) => {
    setTags(tags.filter(t => t !== tagToRemove));
  }, [tags]);

  const handleUpload = useCallback(async () => {
    if (!file || !name.trim()) {
      setError('Please provide a file and name');
      return;
    }

    // Validate configurations
    if (mode === 'manual-select' && spriteSelections.length === 0) {
      setError('Please select at least one sprite');
      return;
    }

    setIsUploading(true);
    setError(null);

    try {
      await onUpload(file, {
        name: name.trim(),
        type,
        tags,
        spriteSelections: mode === 'manual-select' ? spriteSelections : undefined
      });

      // Reset form
      setFile(null);
      setPreview(null);
      setName('');
      setTags([]);
      setType('image');
      setMode('basic');
      setSpriteSelections([]);
      setDetectionResult(null);
      
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setIsUploading(false);
    }
  }, [file, name, type, tags, mode, spriteSelections, onUpload, onClose]);

  const handleVisualDetection = useCallback(async () => {
    if (!preview) return;
    
    setIsDetectingSprites(true);
    setError(null);
    
    try {
      // Run visual sprite detection
      const result = await detectSpritesByTransparency(preview, 8, 2);
      setDetectionResult(result);
      
      // Convert detected sprites to selections
      const selections = detectedSpritesToSelections(result.sprites);
      console.log('🎯 Visual Detection Complete:', {
        spritesDetected: result.sprites.length,
        selections: selections,
        gridDetected: result.gridDetected,
        suggestedTileSize: result.suggestedTileSize,
        note: 'All dimensions snapped to 8px grid (game-friendly)'
      });
      setSpriteSelections(selections);
      
      // Show success message
      if (result.sprites.length > 0) {
        setError(null);
        console.log(`✅ Detected ${result.sprites.length} sprites automatically!`);
      } else {
        setError('No sprites detected. Try manual selection or adjust the image.');
      }
    } catch (err) {
      console.error('Visual detection failed:', err);
      setError('Visual detection failed. Please use manual selection.');
    } finally {
      setIsDetectingSprites(false);
    }
  }, [preview]);

  const handleReset = useCallback(() => {
    setFile(null);
    setPreview(null);
    setMode('basic');
    setSpriteSelections([]);
    setDetectionResult(null);
    setError(null);
  }, []);

  // Auto-run visual detection when switching to manual mode
  useEffect(() => {
    if (mode === 'manual-select' && preview && !detectionResult && spriteSelections.length === 0) {
      // Automatically run visual detection on first visit to manual tab
      handleVisualDetection();
    }
  }, [mode, preview, detectionResult, spriteSelections.length, handleVisualDetection]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-7xl max-h-[95vh] flex flex-col">
        {/* Header */}
        <div className="flex justify-between items-center p-6 border-b border-gray-200">
          <h2 className="text-2xl font-bold text-gray-800">Upload Asset</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 text-2xl w-8 h-8 flex items-center justify-center"
            disabled={isUploading}
          >
            ×
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-hidden flex flex-col">
          {!file ? (
            /* File upload area */
            <div className="p-6">
              <div
                className="border-2 border-dashed rounded-lg p-12 text-center transition-colors border-gray-300 hover:border-gray-400"
                onDragOver={handleDragOver}
                onDrop={handleDrop}
              >
                <div className="mb-4">
                  <svg
                    className="mx-auto h-16 w-16 text-gray-400"
                    stroke="currentColor"
                    fill="none"
                    viewBox="0 0 48 48"
                  >
                    <path
                      d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
                      strokeWidth={2}
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                  </svg>
                </div>
                <p className="text-gray-600 mb-3 text-lg">Drag and drop your image here, or</p>
                <input
                  type="file"
                  accept="image/png,image/jpeg,image/jpg,image/webp"
                  onChange={(e) => e.target.files && handleFileSelect(e.target.files[0])}
                  className="hidden"
                  id="file-input"
                />
                <label
                  htmlFor="file-input"
                  className="cursor-pointer inline-block px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                >
                  Browse Files
                </label>
                <p className="text-sm text-gray-500 mt-3">
                  Supported: PNG, JPG, WEBP (max 10MB)
                </p>
              </div>

              {/* Type selection */}
              <div className="mt-6">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  What type of asset is this?
                </label>
                <div className="grid grid-cols-3 gap-3">
                  <button
                    onClick={() => setType('image')}
                    className={`p-4 border-2 rounded-lg text-center transition-colors ${
                      type === 'image'
                        ? 'border-blue-500 bg-blue-50'
                        : 'border-gray-200 hover:border-gray-300'
                    }`}
                  >
                    <div className="font-semibold">Single Image</div>
                    <div className="text-xs text-gray-500 mt-1">Individual sprite or icon</div>
                  </button>
                  <button
                    onClick={() => setType('spritesheet')}
                    className={`p-4 border-2 rounded-lg text-center transition-colors ${
                      type === 'spritesheet'
                        ? 'border-blue-500 bg-blue-50'
                        : 'border-gray-200 hover:border-gray-300'
                    }`}
                  >
                    <div className="font-semibold">Sprite Sheet</div>
                    <div className="text-xs text-gray-500 mt-1">Multiple sprites (trees, items)</div>
                  </button>
                  <button
                    onClick={() => setType('tileset')}
                    className={`p-4 border-2 rounded-lg text-center transition-colors ${
                      type === 'tileset'
                        ? 'border-blue-500 bg-blue-50'
                        : 'border-gray-200 hover:border-gray-300'
                    }`}
                  >
                    <div className="font-semibold">Tileset</div>
                    <div className="text-xs text-gray-500 mt-1">Uniform grid tiles</div>
                  </button>
                </div>
              </div>
            </div>
          ) : (
            /* Configuration area */
            <div className="flex-1 flex flex-col overflow-hidden">
              {/* Tabs */}
              <div className="border-b border-gray-200 px-6">
                <div className="flex gap-4">
                  <button
                    onClick={() => setMode('basic')}
                    className={`px-4 py-3 font-medium transition-colors border-b-2 ${
                      mode === 'basic'
                        ? 'border-blue-500 text-blue-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700'
                    }`}
                  >
                    Basic Info
                  </button>
                  {(type === 'spritesheet' || type === 'tileset') && (
                    <button
                      onClick={() => setMode('manual-select')}
                      className={`px-4 py-3 font-medium transition-colors border-b-2 ${
                        mode === 'manual-select'
                          ? 'border-blue-500 text-blue-600'
                          : 'border-transparent text-gray-500 hover:text-gray-700'
                      }`}
                    >
                      Sprite Selection
                      {spriteSelections.length > 0 && (
                        <span className="ml-2 text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-800">
                          {spriteSelections.length}
                        </span>
                      )}
                    </button>
                  )}
                </div>
              </div>

              {/* Tab content */}
              <div className="flex-1 overflow-auto">
                {mode === 'basic' && (
                  <div className="p-6 space-y-4 max-w-2xl">
                    {/* Preview */}
                    {preview && (
                      <div className="border rounded-lg p-4 bg-gray-50">
                        <img src={preview} alt="Preview" className="max-w-full max-h-64 mx-auto rounded" />
                      </div>
                    )}

                    {/* Name */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Asset Name <span className="text-red-500">*</span>
                      </label>
                      <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="e.g., forest_trees"
                      />
                    </div>

                    {/* Tags */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Tags</label>
                      <div className="flex gap-2 mb-2">
                        <input
                          type="text"
                          value={tagInput}
                          onChange={(e) => setTagInput(e.target.value)}
                          onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}
                          className="flex-1 px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="Add tags..."
                        />
                        <button
                          onClick={handleAddTag}
                          className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                        >
                          Add
                        </button>
                      </div>
                      {tags.length > 0 && (
                        <div className="flex flex-wrap gap-2">
                          {tags.map((tag) => (
                            <span
                              key={tag}
                              className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
                            >
                              {tag}
                              <button onClick={() => handleRemoveTag(tag)} className="hover:text-blue-900">
                                ×
                              </button>
                            </span>
                          ))}
                        </div>
                      )}
                    </div>

                    {/* File info */}
                    <div className="text-sm text-gray-600">
                      <p>File: {file.name}</p>
                      <p>Size: {(file.size / 1024 / 1024).toFixed(2)} MB</p>
                    </div>

                    <button
                      onClick={handleReset}
                      className="text-sm text-blue-600 hover:text-blue-700"
                    >
                      Choose different file
                    </button>
                  </div>
                )}

                {mode === 'manual-select' && preview && (
                  <div className="flex flex-col h-full">
                    {/* Visual Detection Controls */}
                    <div className="p-4 bg-white border-b border-gray-200">
                      <div className="flex items-center justify-between mb-3">
                        <div className="flex items-center gap-3">
                          <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
                            <svg className="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1v-4zM14 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
                            </svg>
                          </div>
                          <div>
                            <h3 className="font-semibold text-gray-900">Sprite Selection</h3>
                            <p className="text-xs text-gray-500">
                              Auto-detect sprites or draw boxes manually
                            </p>
                          </div>
                        </div>
                        <button
                          onClick={handleVisualDetection}
                          disabled={isDetectingSprites}
                          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 text-sm font-medium"
                        >
                          {isDetectingSprites ? (
                            <>
                              <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                              Detecting...
                            </>
                          ) : (
                            <>
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                              </svg>
                              Auto-Detect
                            </>
                          )}
                        </button>
                      </div>
                      
                      {/* Detection result info */}
                      {detectionResult && (
                        <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg">
                          <div className="flex items-center justify-between text-sm">
                            <div className="flex items-center gap-4">
                              <div className="flex items-center gap-2">
                                <span className="text-gray-700">Detected:</span>
                                <span className="font-semibold text-blue-900">{detectionResult.sprites.length} sprites</span>
                              </div>
                              {detectionResult.gridDetected && detectionResult.suggestedTileSize && (
                                <div className="flex items-center gap-2">
                                  <span className="text-gray-700">Grid:</span>
                                  <span className="font-semibold text-blue-900">
                                    {detectionResult.suggestedTileSize.width}×{detectionResult.suggestedTileSize.height}px
                                  </span>
                                </div>
                              )}
                            </div>
                            <div className="flex items-center gap-2">
                              <span className="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-medium">
                                8px-aligned
                              </span>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                    
                    {/* Manual Sprite Selector */}
                    <div className="flex-1 overflow-hidden">
                      <ManualSpriteSelector
                        imageUrl={preview}
                        onSelectionsChange={(selections) => setSpriteSelections(selections)}
                        initialSelections={spriteSelections}
                      />
                    </div>
                  </div>
                )}
              </div>

              {/* Error message */}
              {error && (
                <div className="mx-6 mb-4 bg-red-50 border border-red-200 rounded p-3">
                  <p className="text-sm text-red-800">{error}</p>
                </div>
              )}

              {/* Actions */}
              <div className="border-t border-gray-200 p-6 flex justify-between">
                <button
                  onClick={handleReset}
                  disabled={isUploading}
                  className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded transition-colors"
                >
                  Start Over
                </button>
                <div className="flex gap-3">
                  <button
                    onClick={onClose}
                    disabled={isUploading}
                    className="px-6 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors disabled:opacity-50"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleUpload}
                    disabled={!file || !name.trim() || isUploading}
                    className="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {isUploading ? 'Uploading...' : 'Upload Asset'}
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/assets/ManualSpriteSelector.tsx">
/**
 * Manual Sprite Selector
 * Allows users to manually define sprite bounds for irregular sprite sheets
 * PR-31: Enhancement for non-uniform sprite collections
 */

import React, { useState, useRef, useEffect } from 'react';
import { Stage, Layer, Image as KonvaImage, Rect, Text } from 'react-konva';
import useImage from 'use-image';

export interface SpriteSelection {
  id: string;
  name: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

interface ManualSpriteSelectorProps {
  imageUrl: string;
  onSelectionsChange: (selections: SpriteSelection[]) => void;
  initialSelections?: SpriteSelection[];
}

export const ManualSpriteSelector: React.FC<ManualSpriteSelectorProps> = ({
  imageUrl,
  onSelectionsChange,
  initialSelections = []
}) => {
  const [image] = useImage(imageUrl, 'anonymous');
  const [selections, setSelections] = useState<SpriteSelection[]>(initialSelections);
  const [isDrawing, setIsDrawing] = useState(false);
  const [drawStart, setDrawStart] = useState<{ x: number; y: number } | null>(null);
  const [currentRect, setCurrentRect] = useState<{ x: number; y: number; width: number; height: number } | null>(null);
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [snapToGrid, setSnapToGrid] = useState(true);
  const [gridSize, setGridSize] = useState(16);
  const stageRef = useRef<any>(null);

  // Container size
  const [containerSize, setContainerSize] = useState({ width: 800, height: 600 });

  useEffect(() => {
    const updateSize = () => {
      const container = document.getElementById('sprite-selector-container');
      if (container) {
        setContainerSize({
          width: container.clientWidth,
          height: container.clientHeight
        });
      }
    };

    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, []);

  // Update selections when initialSelections change (e.g., after auto-detection)
  useEffect(() => {
    if (initialSelections.length > 0) {
      setSelections(initialSelections);
    }
  }, [initialSelections]);

  useEffect(() => {
    onSelectionsChange(selections);
  }, [selections]);

  // Snap to grid helper
  const snap = (value: number) => {
    if (!snapToGrid) return value;
    return Math.round(value / gridSize) * gridSize;
  };

  // Handle mouse down - start drawing
  const handleMouseDown = (e: any) => {
    // Only start drawing if we didn't click on an existing selection or text
    const targetName = e.target.name ? e.target.name() : null;
    if (targetName === 'selection' || targetName === 'selection-text') {
      return; // Let the selection's onClick handle it
    }

    const stage = e.target.getStage();
    const pointerPosition = stage.getPointerPosition();
    const x = snap((pointerPosition.x - pan.x) / zoom);
    const y = snap((pointerPosition.y - pan.y) / zoom);

    setIsDrawing(true);
    setDrawStart({ x, y });
    setCurrentRect({ x, y, width: 0, height: 0 });
    setSelectedId(null);
  };

  // Handle mouse move - update rectangle
  const handleMouseMove = (e: any) => {
    if (!isDrawing || !drawStart) return;

    const stage = e.target.getStage();
    const pointerPosition = stage.getPointerPosition();
    const x2 = snap((pointerPosition.x - pan.x) / zoom);
    const y2 = snap((pointerPosition.y - pan.y) / zoom);

    // Calculate rectangle from start point to current point (works in all directions)
    setCurrentRect({
      x: Math.min(drawStart.x, x2),
      y: Math.min(drawStart.y, y2),
      width: Math.abs(x2 - drawStart.x),
      height: Math.abs(y2 - drawStart.y)
    });
  };

  // Handle mouse up - finish drawing
  const handleMouseUp = () => {
    if (!isDrawing || !currentRect) return;

    // Only add if rectangle has meaningful size
    if (currentRect.width > 5 && currentRect.height > 5) {
      const newSelection: SpriteSelection = {
        id: `sprite_${Date.now()}`,
        name: `Sprite ${selections.length + 1}`,
        x: Math.round(currentRect.x),
        y: Math.round(currentRect.y),
        width: Math.round(currentRect.width),
        height: Math.round(currentRect.height)
      };

      setSelections([...selections, newSelection]);
      setSelectedId(newSelection.id);
    }

    setIsDrawing(false);
    setCurrentRect(null);
    setDrawStart(null);
  };

  // Delete selected sprite
  const deleteSelection = (id: string) => {
    setSelections(selections.filter(s => s.id !== id));
    if (selectedId === id) setSelectedId(null);
  };

  // Update sprite name
  const updateSpriteName = (id: string, name: string) => {
    setSelections(selections.map(s => 
      s.id === id ? { ...s, name } : s
    ));
  };

  // Clear all selections
  const clearAll = () => {
    if (window.confirm('Clear all sprite selections?')) {
      setSelections([]);
      setSelectedId(null);
    }
  };

  // Zoom controls
  const handleZoomIn = () => setZoom(Math.min(zoom * 1.5, 5));
  const handleZoomOut = () => setZoom(Math.max(zoom / 1.5, 0.25));
  const handleResetZoom = () => { setZoom(1); setPan({ x: 0, y: 0 }); };

  // Handle wheel for zoom
  const handleWheel = (e: any) => {
    e.evt.preventDefault();

    const stage = e.target.getStage();
    const oldScale = zoom;
    const pointer = stage.getPointerPosition();

    const mousePointTo = {
      x: (pointer.x - pan.x) / oldScale,
      y: (pointer.y - pan.y) / oldScale,
    };

    const newScale = e.evt.deltaY > 0 
      ? Math.max(oldScale / 1.1, 0.25)
      : Math.min(oldScale * 1.1, 5);

    setZoom(newScale);
    setPan({
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    });
  };

  return (
    <div className="flex flex-col h-full">
      {/* Toolbar */}
      <div className="bg-gray-100 border-b border-gray-300 p-3 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span className="text-sm font-semibold text-gray-700">
            Draw rectangles around each sprite
          </span>
          <span className="text-xs text-gray-500">
            ({selections.length} sprite{selections.length !== 1 ? 's' : ''} selected)
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Zoom controls */}
          <button
            onClick={handleZoomOut}
            className="px-2 py-1 bg-white border border-gray-300 rounded hover:bg-gray-50 text-sm"
            title="Zoom Out"
          >
            −
          </button>
          <span className="text-sm text-gray-600 min-w-[60px] text-center">
            {(zoom * 100).toFixed(0)}%
          </span>
          <button
            onClick={handleZoomIn}
            className="px-2 py-1 bg-white border border-gray-300 rounded hover:bg-gray-50 text-sm"
            title="Zoom In"
          >
            +
          </button>
          <button
            onClick={handleResetZoom}
            className="px-3 py-1 bg-white border border-gray-300 rounded hover:bg-gray-50 text-sm"
          >
            Reset
          </button>

          <div className="w-px h-6 bg-gray-300 mx-1" />

          {/* Snap to Grid controls */}
          <button
            onClick={() => setSnapToGrid(!snapToGrid)}
            className={`px-3 py-1 border rounded text-sm ${
              snapToGrid 
                ? 'bg-blue-500 text-white border-blue-600' 
                : 'bg-white border-gray-300 hover:bg-gray-50'
            }`}
            title="Toggle snap to grid"
          >
            Snap: {snapToGrid ? 'ON' : 'OFF'}
          </button>
          
          {snapToGrid && (
            <div className="flex items-center gap-1 bg-white border border-gray-300 rounded px-2 py-1">
              <span className="text-xs text-gray-600">Grid:</span>
              {[8, 16, 32].map(size => (
                <button
                  key={size}
                  onClick={() => setGridSize(size)}
                  className={`px-2 py-0.5 text-xs rounded ${
                    gridSize === size
                      ? 'bg-blue-500 text-white'
                      : 'hover:bg-gray-100'
                  }`}
                >
                  {size}
                </button>
              ))}
            </div>
          )}

          <div className="w-px h-6 bg-gray-300 mx-1" />

          {/* Clear all */}
          <button
            onClick={clearAll}
            disabled={selections.length === 0}
            className="px-3 py-1 bg-red-50 text-red-700 border border-red-200 rounded hover:bg-red-100 text-sm disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Clear All
          </button>
        </div>
      </div>

      {/* Main content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Canvas */}
        <div id="sprite-selector-container" className="flex-1 bg-gray-200 overflow-hidden">
          <Stage
            ref={stageRef}
            width={containerSize.width}
            height={containerSize.height}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onWheel={handleWheel}
            style={{ cursor: isDrawing ? 'crosshair' : 'default' }}
          >
            <Layer
              x={pan.x}
              y={pan.y}
              scaleX={zoom}
              scaleY={zoom}
            >
              {/* Background image */}
              {image && (
                <KonvaImage
                  image={image}
                  listening={false}
                />
              )}

              {/* Grid overlay */}
              {snapToGrid && image && (
                <>
                  {/* Vertical grid lines */}
                  {Array.from({ length: Math.ceil(image.width / gridSize) + 1 }).map((_, i) => {
                    const x = i * gridSize;
                    return (
                      <Rect
                        key={`v-${i}`}
                        x={x}
                        y={0}
                        width={1}
                        height={image.height}
                        fill="rgba(59, 130, 246, 0.15)"
                        listening={false}
                      />
                    );
                  })}
                  {/* Horizontal grid lines */}
                  {Array.from({ length: Math.ceil(image.height / gridSize) + 1 }).map((_, i) => {
                    const y = i * gridSize;
                    return (
                      <Rect
                        key={`h-${i}`}
                        x={0}
                        y={y}
                        width={image.width}
                        height={1}
                        fill="rgba(59, 130, 246, 0.15)"
                        listening={false}
                      />
                    );
                  })}
                </>
              )}

              {/* Existing selections */}
              {selections.map((selection) => (
                <React.Fragment key={selection.id}>
                  <Rect
                    name="selection"
                    x={selection.x}
                    y={selection.y}
                    width={selection.width}
                    height={selection.height}
                    stroke={selectedId === selection.id ? '#3b82f6' : '#10b981'}
                    strokeWidth={selectedId === selection.id ? 3 : 2}
                    dash={selectedId === selection.id ? undefined : [5, 5]}
                    fill={selectedId === selection.id ? 'rgba(59, 130, 246, 0.1)' : 'rgba(16, 185, 129, 0.1)'}
                    onClick={() => setSelectedId(selection.id)}
                    onTap={() => setSelectedId(selection.id)}
                  />
                  <Text
                    name="selection-text"
                    x={selection.x}
                    y={selection.y - 18}
                    text={selection.name}
                    fontSize={14}
                    fill={selectedId === selection.id ? '#3b82f6' : '#10b981'}
                    fontStyle="bold"
                  />
                  <Text
                    name="selection-text"
                    x={selection.x}
                    y={selection.y + selection.height + 2}
                    text={`${selection.width}×${selection.height}`}
                    fontSize={11}
                    fill="#666"
                  />
                </React.Fragment>
              ))}

              {/* Current drawing rectangle */}
              {isDrawing && currentRect && (
                <Rect
                  x={currentRect.x}
                  y={currentRect.y}
                  width={currentRect.width}
                  height={currentRect.height}
                  stroke="#ef4444"
                  strokeWidth={2}
                  dash={[5, 5]}
                  fill="rgba(239, 68, 68, 0.1)"
                />
              )}
            </Layer>
          </Stage>
        </div>

        {/* Sidebar - Sprite List */}
        <div className="w-80 bg-white border-l border-gray-300 flex flex-col">
          <div className="p-3 border-b border-gray-200">
            <h3 className="font-semibold text-gray-800">Sprite List</h3>
            <p className="text-xs text-gray-500 mt-1">
              Click a sprite to select, or draw a new rectangle on the canvas
            </p>
          </div>

          <div className="flex-1 overflow-y-auto">
            {selections.length === 0 ? (
              <div className="p-6 text-center text-gray-400">
                <svg className="w-16 h-16 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
                <p className="text-sm">No sprites defined</p>
                <p className="text-xs mt-1">Draw rectangles to select sprites</p>
              </div>
            ) : (
              <div className="divide-y divide-gray-200">
                {selections.map((selection) => (
                  <div
                    key={selection.id}
                    className={`p-3 hover:bg-gray-50 cursor-pointer transition-colors ${
                      selectedId === selection.id ? 'bg-blue-50 border-l-4 border-blue-500' : ''
                    }`}
                    onClick={() => setSelectedId(selection.id)}
                  >
                    <div className="flex items-start justify-between gap-2">
                      <div className="flex-1 min-w-0">
                        <input
                          type="text"
                          value={selection.name}
                          onChange={(e) => updateSpriteName(selection.id, e.target.value)}
                          onClick={(e) => e.stopPropagation()}
                          className="w-full px-2 py-1 text-sm font-medium bg-transparent border border-transparent hover:border-gray-300 rounded focus:outline-none focus:border-blue-500"
                          placeholder="Sprite name"
                        />
                        <div className="text-xs text-gray-500 mt-1 space-y-0.5">
                          <div>Position: ({selection.x}, {selection.y})</div>
                          <div>Size: {selection.width} × {selection.height}</div>
                        </div>
                      </div>

                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteSelection(selection.id);
                        }}
                        className="text-red-500 hover:text-red-700 p-1"
                        title="Delete sprite"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Export preview */}
          {selections.length > 0 && (
            <div className="p-3 border-t border-gray-200 bg-gray-50">
              <button
                onClick={() => {
                  const json = JSON.stringify({ frames: selections }, null, 2);
                  const blob = new Blob([json], { type: 'application/json' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = 'sprites.json';
                  a.click();
                  URL.revokeObjectURL(url);
                }}
                className="w-full px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-medium"
              >
                Export JSON ({selections.length} sprites)
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Instructions */}
      <div className="bg-blue-50 border-t border-blue-200 px-4 py-2">
        <div className="flex items-center gap-2 text-xs text-blue-800">
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span>
            <strong>Tip:</strong> Click and drag to draw rectangles around sprites. 
            Use mouse wheel to zoom. Click sprites in the list to select them.
          </span>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/assets/TilesetConfigurator.tsx">
/**
 * Tileset Configurator Component (PR-31)
 * Configure sprite sheet slicing and auto-tile mapping
 */

import { useState, useEffect, useRef, useMemo } from 'react'
import {
  autoDetectTileSize,
  sliceTileset,
  validateTilesetConfig,
  loadImage,
  getImageData
} from '../../utils/tilemap/tilesetSlicer'
import type { Asset, TilesetMetadata } from '../../types/asset'

interface TilesetConfiguratorProps {
  asset: Asset
  onSave: (metadata: TilesetMetadata) => Promise<void>
  onClose: () => void
}

export function TilesetConfigurator({ asset, onSave, onClose }: TilesetConfiguratorProps) {
  const [tileWidth, setTileWidth] = useState(32)
  const [tileHeight, setTileHeight] = useState(32)
  const [spacing, setSpacing] = useState(0)
  const [margin, setMargin] = useState(0)
  const [isDetecting, setIsDetecting] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [validation, setValidation] = useState<{ valid: boolean; errors: string[] } | null>(null)
  const [previewImage, setPreviewImage] = useState<HTMLImageElement | null>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)

  // Load image
  useEffect(() => {
    const loadImg = async () => {
      try {
        const img = await loadImage(asset.url)
        setPreviewImage(img)

        // Auto-detect on initial load
        handleAutoDetect(img)
      } catch (error) {
        console.error('Failed to load image:', error)
      }
    }

    loadImg()
  }, [asset.url])

  // Auto-detect tile size
  const handleAutoDetect = async (img?: HTMLImageElement) => {
    const image = img || previewImage
    if (!image) return

    setIsDetecting(true)
    try {
      const imageData = getImageData(image)
      const detection = autoDetectTileSize(imageData)
      
      setTileWidth(detection.tileWidth)
      setTileHeight(detection.tileHeight)
      setSpacing(detection.spacing)
      setMargin(detection.margin)
    } catch (error) {
      console.error('Auto-detection failed:', error)
    } finally {
      setIsDetecting(false)
    }
  }

  // Validate configuration
  useEffect(() => {
    if (!previewImage) return

    const result = validateTilesetConfig(
      previewImage.width,
      previewImage.height,
      tileWidth,
      tileHeight,
      spacing,
      margin
    )
    setValidation(result)
  }, [previewImage, tileWidth, tileHeight, spacing, margin])

  // Calculate tile grid
  const tileGrid = useMemo(() => {
    if (!previewImage || !validation?.valid) return null

    const imageData = getImageData(previewImage)
    return sliceTileset(imageData, tileWidth, tileHeight, spacing, margin)
  }, [previewImage, tileWidth, tileHeight, spacing, margin, validation])

  // Draw preview
  useEffect(() => {
    if (!canvasRef.current || !previewImage || !tileGrid) return

    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    canvas.width = previewImage.width
    canvas.height = previewImage.height

    // Draw image
    ctx.drawImage(previewImage, 0, 0)

    // Draw grid overlay
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'
    ctx.lineWidth = 1

    tileGrid.tiles.forEach(tile => {
      ctx.strokeRect(tile.x, tile.y, tile.width, tile.height)
    })

    // Draw tile indices
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'
    ctx.font = `${Math.min(tileWidth, tileHeight) / 3}px sans-serif`
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'

    tileGrid.tiles.forEach(tile => {
      const centerX = tile.x + tile.width / 2
      const centerY = tile.y + tile.height / 2
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'
      ctx.fillText(tile.index.toString(), centerX, centerY)
    })
  }, [previewImage, tileGrid, tileWidth, tileHeight])

  // Save configuration
  const handleSave = async () => {
    if (!validation?.valid || !tileGrid) return

    setIsSaving(true)
    try {
      await onSave(tileGrid.metadata)
      onClose()
    } catch (error) {
      console.error('Failed to save tileset config:', error)
    } finally {
      setIsSaving(false)
    }
  }

  // Common tile sizes
  const commonSizes = [8, 16, 24, 32, 48, 64, 128]

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl max-w-6xl w-full max-h-[90vh] overflow-hidden flex flex-col">
        {/* Header */}
        <div className="p-4 border-b border-gray-200 flex justify-between items-center">
          <div>
            <h2 className="text-xl font-bold text-gray-800">Configure Tileset</h2>
            <p className="text-sm text-gray-600 mt-1">{asset.name}</p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 text-2xl"
            disabled={isSaving}
          >
            ×
          </button>
        </div>

        <div className="flex flex-1 overflow-hidden">
          {/* Preview */}
          <div className="flex-1 p-4 overflow-auto bg-gray-50">
            <div className="flex items-center justify-center min-h-full">
              <canvas
                ref={canvasRef}
                className="border border-gray-300 shadow-sm max-w-full"
                style={{
                  imageRendering: 'pixelated',
                  maxHeight: '70vh'
                }}
              />
            </div>
          </div>

          {/* Configuration panel */}
          <div className="w-80 border-l border-gray-200 p-4 overflow-y-auto">
            <div className="space-y-4">
              {/* Auto-detect button */}
              <button
                onClick={() => handleAutoDetect()}
                disabled={isDetecting || !previewImage}
                className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isDetecting ? 'Detecting...' : 'Auto-Detect Grid'}
              </button>

              {/* Tile size */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Tile Size
                </label>
                <div className="grid grid-cols-2 gap-2 mb-2">
                  <div>
                    <label className="block text-xs text-gray-600 mb-1">Width</label>
                    <input
                      type="number"
                      value={tileWidth}
                      onChange={(e) => setTileWidth(Math.max(1, parseInt(e.target.value) || 1))}
                      className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                      min="1"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-600 mb-1">Height</label>
                    <input
                      type="number"
                      value={tileHeight}
                      onChange={(e) => setTileHeight(Math.max(1, parseInt(e.target.value) || 1))}
                      className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                      min="1"
                    />
                  </div>
                </div>

                {/* Common sizes */}
                <div className="flex flex-wrap gap-1">
                  {commonSizes.map(size => (
                    <button
                      key={size}
                      onClick={() => {
                        setTileWidth(size)
                        setTileHeight(size)
                      }}
                      className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors"
                    >
                      {size}×{size}
                    </button>
                  ))}
                </div>
              </div>

              {/* Spacing */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Spacing
                  <span className="text-xs text-gray-500 ml-1">(between tiles)</span>
                </label>
                <input
                  type="number"
                  value={spacing}
                  onChange={(e) => setSpacing(Math.max(0, parseInt(e.target.value) || 0))}
                  className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                  min="0"
                />
              </div>

              {/* Margin */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Margin
                  <span className="text-xs text-gray-500 ml-1">(around grid)</span>
                </label>
                <input
                  type="number"
                  value={margin}
                  onChange={(e) => setMargin(Math.max(0, parseInt(e.target.value) || 0))}
                  className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                  min="0"
                />
              </div>

              {/* Stats */}
              {tileGrid && validation?.valid && (
                <div className="p-3 bg-green-50 border border-green-200 rounded">
                  <h3 className="text-sm font-medium text-green-800 mb-2">Grid Info</h3>
                  <div className="space-y-1 text-xs text-green-700">
                    <p>Columns: {tileGrid.metadata.columns}</p>
                    <p>Rows: {tileGrid.metadata.rows}</p>
                    <p>Total Tiles: {tileGrid.metadata.tileCount}</p>
                  </div>
                </div>
              )}

              {/* Validation errors */}
              {validation && !validation.valid && (
                <div className="p-3 bg-red-50 border border-red-200 rounded">
                  <h3 className="text-sm font-medium text-red-800 mb-2">Configuration Issues</h3>
                  <div className="space-y-1">
                    {validation.errors.map((error, i) => (
                      <p key={i} className="text-xs text-red-700">• {error}</p>
                    ))}
                  </div>
                </div>
              )}

              {/* Image info */}
              {previewImage && (
                <div className="pt-4 border-t border-gray-200">
                  <h3 className="text-sm font-medium text-gray-700 mb-2">Image Info</h3>
                  <div className="space-y-1 text-xs text-gray-600">
                    <p>Dimensions: {previewImage.width} × {previewImage.height}</p>
                    <p>File Size: {(asset.metadata.fileSize / 1024).toFixed(1)} KB</p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-gray-200 flex justify-end gap-3">
          <button
            onClick={onClose}
            disabled={isSaving}
            className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors disabled:opacity-50"
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            disabled={!validation?.valid || isSaving}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSaving ? 'Saving...' : 'Save Configuration'}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/canvas/AnimatedSprite.tsx">
/**
 * AnimatedSprite Component
 * Renders a sprite with frame-by-frame animation on the canvas
 * PR-31: Animation Integration
 */

import { useRef, useEffect, useState, useCallback } from 'react'
import { Image as KonvaImage, Transformer } from 'react-konva'
import type Konva from 'konva'
import useImage from 'use-image'
import { ref, onValue } from 'firebase/database'
import { db } from '../../services/firebase'
import type { Animation } from '../../types/animation'

interface AnimatedSpriteProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  animationId: string
  spriteSheetId?: string
  currentFrame?: number
  isPlaying?: boolean
  flipX?: boolean
  flipY?: boolean
  opacity?: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
  onFrameChange?: (frame: number) => void
}

/**
 * AnimatedSprite shape component
 * Plays sprite sheet animations with frame cycling
 */
export default function AnimatedSprite({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  animationId,
  spriteSheetId,
  currentFrame: initialFrame = 0,
  isPlaying = true,
  flipX = false,
  flipY = false,
  opacity = 1,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
  onFrameChange,
}: AnimatedSpriteProps) {
  const shapeRef = useRef<Konva.Image>(null)
  const trRef = useRef<Konva.Transformer>(null)
  
  // Animation state
  const [animation, setAnimation] = useState<Animation | null>(null)
  const [currentFrame, setCurrentFrame] = useState(initialFrame)
  const [spriteSheetUrl, setSpriteSheetUrl] = useState<string>('')
  const lastFrameTime = useRef<number>(Date.now())
  const frameAccumulator = useRef<number>(0)
  
  // Load sprite sheet image
  const [image] = useImage(spriteSheetUrl, 'anonymous')

  // Load animation data from Firebase
  useEffect(() => {
    if (!animationId) return

    const animationRef = ref(db, `animations/${animationId}`)
    const unsubscribe = onValue(animationRef, (snapshot) => {
      const data = snapshot.val()
      if (data) {
        setAnimation(data as Animation)
        
        // Load sprite sheet URL
        if (data.spriteSheetId || spriteSheetId) {
          const assetId = data.spriteSheetId || spriteSheetId
          const assetRef = ref(db, `assets/${assetId}`)
          onValue(assetRef, (assetSnapshot) => {
            const assetData = assetSnapshot.val()
            if (assetData && assetData.url) {
              setSpriteSheetUrl(assetData.url)
            }
          })
        }
      }
    })

    return () => unsubscribe()
  }, [animationId, spriteSheetId])

  // Animation frame cycling
  useEffect(() => {
    if (!isPlaying || !animation || animation.frames.length === 0) return

    const animate = () => {
      const now = Date.now()
      const deltaTime = now - lastFrameTime.current
      lastFrameTime.current = now

      // Accumulate time
      frameAccumulator.current += deltaTime

      // Get current frame data
      const frameData = animation.frames[currentFrame]
      const frameDuration = frameData?.duration || (1000 / (animation.fps || 12))

      // Check if it's time to advance to next frame
      if (frameAccumulator.current >= frameDuration) {
        frameAccumulator.current = 0
        
        const nextFrame = currentFrame + 1
        
        if (nextFrame >= animation.frames.length) {
          // End of animation
          if (animation.loop) {
            // Loop back to start
            setCurrentFrame(0)
            onFrameChange?.(0)
          } else {
            // Stop at last frame
            // Keep current frame
          }
        } else {
          // Advance to next frame
          setCurrentFrame(nextFrame)
          onFrameChange?.(nextFrame)
        }
      }

      requestRef.current = requestAnimationFrame(animate)
    }

    const requestRef = { current: 0 }
    requestRef.current = requestAnimationFrame(animate)

    return () => {
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current)
      }
    }
  }, [isPlaying, animation, currentFrame, onFrameChange])

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to width/height instead
    node.scaleX(1)
    node.scaleY(1)

    onTransformEnd(
      Math.max(10, node.width() * scaleX), // min width 10px
      Math.max(10, node.height() * scaleY), // min height 10px
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  // Get current frame crop coordinates
  const getCrop = useCallback(() => {
    if (!animation || !animation.frames[currentFrame]) {
      return { x: 0, y: 0, width: 32, height: 32 }
    }

    const frame = animation.frames[currentFrame]
    return {
      x: frame.x,
      y: frame.y,
      width: frame.width,
      height: frame.height
    }
  }, [animation, currentFrame])

  if (!image || !animation) {
    // Show placeholder while loading
    return null
  }

  const crop = getCrop()

  return (
    <>
      <KonvaImage
        ref={shapeRef}
        x={x}
        y={y}
        width={width}
        height={height}
        rotation={rotation}
        image={image}
        crop={crop}
        scaleX={flipX ? -1 : 1}
        scaleY={flipY ? -1 : 1}
        offsetX={flipX ? width : 0}
        offsetY={flipY ? height : 0}
        opacity={opacity}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
        // Visual feedback
        shadowColor="black"
        shadowBlur={isSelected ? 10 : 0}
        shadowOpacity={isSelected ? 0.3 : 0}
      />
      
      {isSelected && (
        <Transformer
          ref={trRef}
          rotateEnabled={true}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          borderStroke="#3B82F6"
          borderStrokeWidth={2}
          anchorFill="#3B82F6"
          anchorStroke="#FFFFFF"
          anchorSize={8}
          anchorCornerRadius={4}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/canvas/Canvas.tsx">
import type { ViewportTransform, ToolType } from '../../types/canvas'
import type { TileMode } from '../../types/tilemap'
import ShapeCanvas from './ShapeCanvas'
import TilemapCanvas from '../tilemap/TilemapCanvas'

interface CanvasProps {
  selectedTool: ToolType
  onShapeSelect: (id: string | null) => void
  deleteTriggered?: number
  onUndoRedoChange?: (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => void
  canvasId?: string
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
  onZoomControlsReady?: (zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => void
  snapToGrid?: boolean
  onColorSamplingReady?: (fn: (callback: (color: string) => void) => void) => void
  // NEW: Tilemap mode support
  isTilemapMode?: boolean
  onExportFunctionsReady?: (exportJSON: () => void, exportPNG: () => void) => void
  // Tilemap state props (passed through when in tilemap mode)
  tileMode?: TileMode
  onTileModeChange?: (mode: TileMode) => void
  brushSize?: number
  onBrushSizeChange?: (size: number) => void
  autoTilingEnabled?: boolean
  onAutoTilingToggle?: () => void
  showTileGrid?: boolean
  onTileGridToggle?: () => void
  selectedPaletteIndex?: number
  onPaletteIndexChange?: (index: number) => void
  selectedVariant?: number
  onVariantChange?: (variant: number | undefined) => void
  plainColor?: string
  onPlainColorChange?: (color: string) => void
  aiChat?: React.ReactNode // Optional AI chat to render in status bar (tilemap mode)
}

/**
 * Canvas Component - Main orchestrator between Shape and Tilemap modes
 * 
 * This component acts as a simple mode switcher that delegates to specialized canvas implementations:
 * 
 * - **ShapeCanvas**: Traditional vector drawing with shapes, text, paths, lines, etc.
 *   - Supports full shape editing, grouping, alignment, z-index control
 *   - Includes undo/redo, copy/paste, keyboard shortcuts
 *   - Real-time collaboration with presence cursors
 * 
 * - **TilemapCanvas**: Grid-based tile painting for game development
 *   - Grid-aligned tile painting with stamp/erase/fill/pick modes
 *   - Chunked Firebase storage for scalability
 *   - Optimized rendering with viewport culling
 *   - Export/import functionality for game engines
 * 
 * This refactored architecture keeps each mode self-contained and maintainable.
 * Each canvas mode shares the viewport hook for consistent pan/zoom behavior.
 */
export default function Canvas({
  selectedTool,
  onShapeSelect,
  deleteTriggered,
  onUndoRedoChange,
  canvasId = 'default-canvas',
  onViewportChange,
  onZoomChange,
  onZoomControlsReady,
  snapToGrid: snapToGridProp = false,
  onColorSamplingReady,
  isTilemapMode = false,
  onExportFunctionsReady,
  tileMode = 'stamp',
  onTileModeChange = () => {},
  brushSize = 1,
  onBrushSizeChange = () => {},
  autoTilingEnabled = false,
  onAutoTilingToggle = () => {},
  showTileGrid = true,
  onTileGridToggle = () => {},
  selectedPaletteIndex = 0,
  onPaletteIndexChange = () => {},
  selectedVariant,
  onVariantChange,
  plainColor = '#ffffff',
  onPlainColorChange = () => {},
  aiChat,
}: CanvasProps) {
  // Simple orchestrator - delegate to the appropriate canvas mode
  if (isTilemapMode) {
    return (
      <TilemapCanvas
        canvasId={canvasId}
        onViewportChange={onViewportChange}
        onZoomChange={onZoomChange}
        onZoomControlsReady={onZoomControlsReady}
        onUndoRedoChange={onUndoRedoChange}
        onExportFunctionsReady={onExportFunctionsReady}
        tileMode={tileMode}
        onTileModeChange={onTileModeChange}
        brushSize={brushSize}
        onBrushSizeChange={onBrushSizeChange}
        autoTilingEnabled={autoTilingEnabled}
        onAutoTilingToggle={onAutoTilingToggle}
        showGrid={showTileGrid}
        onGridToggle={onTileGridToggle}
        selectedPaletteIndex={selectedPaletteIndex}
        onPaletteIndexChange={onPaletteIndexChange}
        selectedVariant={selectedVariant}
        onVariantChange={onVariantChange}
        plainColor={plainColor}
        onPlainColorChange={onPlainColorChange}
        aiChat={aiChat}
      />
    )
  }

  return (
    <ShapeCanvas
      selectedTool={selectedTool}
      onShapeSelect={onShapeSelect}
      deleteTriggered={deleteTriggered}
      onUndoRedoChange={onUndoRedoChange}
      canvasId={canvasId}
      onViewportChange={onViewportChange}
      onZoomChange={onZoomChange}
      onZoomControlsReady={onZoomControlsReady}
      snapToGrid={snapToGridProp}
      onColorSamplingReady={onColorSamplingReady}
    />
  )
}
</file>

<file path="src/components/canvas/CanvasCard.tsx">
/**
 * CanvasCard Component (PR-22)
 * Individual canvas card in dashboard with thumbnail, name, and actions
 */

import { useState, useRef, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import type { CanvasMetadata } from '../../services/canvas/canvasManager'
import { Tooltip } from '../ui/Tooltip'

interface CanvasCardProps {
  canvas: CanvasMetadata
  onDelete: (canvasId: string) => void
  onDuplicate: (canvasId: string) => void
  onRename: (canvasId: string, newName: string) => void
}

/**
 * Format relative time (e.g., "2 mins ago")
 */
function getRelativeTime(timestamp: number): string {
  const now = Date.now()
  const diff = now - timestamp
  const seconds = Math.floor(diff / 1000)
  const minutes = Math.floor(seconds / 60)
  const hours = Math.floor(minutes / 60)
  const days = Math.floor(hours / 24)

  if (seconds < 60) return 'Just now'
  if (minutes < 60) return `${minutes} ${minutes === 1 ? 'min' : 'mins'} ago`
  if (hours < 24) return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`
  if (days < 30) return `${days} ${days === 1 ? 'day' : 'days'} ago`
  
  return new Date(timestamp).toLocaleDateString()
}

/**
 * Canvas card component for dashboard grid
 */
export function CanvasCard({ canvas, onDelete, onDuplicate, onRename }: CanvasCardProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [editedName, setEditedName] = useState(canvas.name)
  const [showMenu, setShowMenu] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)
  const navigate = useNavigate()

  // Close menu when clicking outside
  useEffect(() => {
    if (!showMenu) return

    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setShowMenu(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showMenu])

  const handleCardClick = () => {
    if (!isEditing) {
      navigate(`/canvas/${canvas.id}`)
    }
  }

  const handleNameDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setIsEditing(true)
    setEditedName(canvas.name)
  }

  const handleNameSubmit = () => {
    if (editedName.trim() && editedName !== canvas.name) {
      onRename(canvas.id, editedName.trim())
    }
    setIsEditing(false)
  }

  const handleNameCancel = () => {
    setEditedName(canvas.name)
    setIsEditing(false)
  }

  const handleMenuClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowMenu(!showMenu)
  }

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (confirm(`Delete "${canvas.name}"? This cannot be undone.`)) {
      onDelete(canvas.id)
    }
    setShowMenu(false)
  }

  const handleDuplicate = (e: React.MouseEvent) => {
    e.stopPropagation()
    onDuplicate(canvas.id)
    setShowMenu(false)
  }

  const handleRename = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowMenu(false)
    setIsEditing(true)
  }

  return (
    <div
      className="group bg-white rounded-lg border border-neutral-200 hover:border-neutral-300 hover:shadow-medium transition-all duration-150 cursor-pointer overflow-hidden"
      onClick={handleCardClick}
    >
      {/* Thumbnail */}
      <div className="relative w-full h-[180px] bg-neutral-100 overflow-hidden">
        {canvas.thumbnail ? (
          <img
            src={canvas.thumbnail}
            alt={canvas.name}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            <span className="text-neutral-400 text-4xl">📄</span>
          </div>
        )}

        {/* Menu button (shows on hover) */}
        <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
          <Tooltip content="More options" side="left">
            <button
              onClick={handleMenuClick}
              className="w-8 h-8 bg-white rounded-lg shadow-medium flex items-center justify-center hover:bg-neutral-50 transition-colors"
            >
              <span className="text-neutral-600">•••</span>
            </button>
          </Tooltip>

          {/* Dropdown menu */}
          {showMenu && (
            <div
              ref={menuRef}
              className="absolute right-0 top-10 bg-white border border-neutral-200 rounded-lg shadow-hard py-1 z-10 min-w-[140px]"
            >
              <button
                onClick={handleRename}
                className="w-full text-left px-4 py-2 text-sm hover:bg-neutral-100 text-neutral-700"
              >
                Rename
              </button>
              <button
                onClick={handleDuplicate}
                className="w-full text-left px-4 py-2 text-sm hover:bg-neutral-100 text-neutral-700"
              >
                Duplicate
              </button>
              <div className="border-t border-neutral-200 my-1" />
              <button
                onClick={handleDelete}
                className="w-full text-left px-4 py-2 text-sm hover:bg-red-50 text-red-600"
              >
                Delete
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Canvas info */}
      <div className="p-4">
        {isEditing ? (
          <input
            type="text"
            value={editedName}
            onChange={(e) => setEditedName(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleNameSubmit()
              if (e.key === 'Escape') handleNameCancel()
            }}
            onBlur={handleNameSubmit}
            onClick={(e) => e.stopPropagation()}
            autoFocus
            className="w-full text-sm font-semibold text-neutral-900 bg-neutral-100 px-2 py-1 rounded border-2 border-primary-500 focus:outline-none"
          />
        ) : (
          <h3
            onDoubleClick={handleNameDoubleClick}
            className="text-sm font-semibold text-neutral-900 truncate mb-1"
          >
            {canvas.name}
          </h3>
        )}
        <p className="text-xs text-neutral-500">
          Edited {getRelativeTime(canvas.updatedAt)}
        </p>
      </div>
    </div>
  )
}
</file>

<file path="src/components/canvas/PhysicsPreview.tsx">
/**
 * Physics Preview Mode
 * Simulates basic physics for preview purposes
 * PR-31: Physics Preview System
 * 
 * Note: This is a simplified preview. For production games, use your game engine's physics.
 */

import { useState, useEffect, useRef } from 'react'
import { Circle, Rect, Group } from 'react-konva'
import type { PhysicsProperties } from '../physics/PhysicsPanel'
import type { CollisionShape } from '../physics/CollisionEditor'
import type { Shape } from '../../types/canvas'

interface PhysicsObject {
  id: string
  shape: Shape
  physics: PhysicsProperties
  collision?: CollisionShape
  velocityX: number
  velocityY: number
}

interface PhysicsPreviewProps {
  shapes: Shape[]
  physicsMap: Map<string, PhysicsProperties>
  collisionMap: Map<string, CollisionShape>
  isPlaying: boolean
  onShapeUpdate: (id: string, x: number, y: number, rotation?: number) => void
}

const GRAVITY = 980 // pixels per second^2 (standard gravity)
const FPS = 60
const TIME_STEP = 1000 / FPS

/**
 * PhysicsPreview component
 * Lightweight physics simulation for preview purposes
 */
export default function PhysicsPreview({
  shapes,
  physicsMap,
  collisionMap,
  isPlaying,
  onShapeUpdate,
}: PhysicsPreviewProps) {
  const [physicsObjects, setPhysicsObjects] = useState<PhysicsObject[]>([])
  const requestRef = useRef<number>(0)
  const lastTime = useRef<number>(Date.now())
  const accumulatorRef = useRef<number>(0)

  // Initialize physics objects
  useEffect(() => {
    const objects: PhysicsObject[] = shapes
      .filter((shape) => {
        const physics = physicsMap.get(shape.id)
        return physics && physics.enabled
      })
      .map((shape) => ({
        id: shape.id,
        shape,
        physics: physicsMap.get(shape.id)!,
        collision: collisionMap.get(shape.id),
        velocityX: 0,
        velocityY: 0,
      }))

    setPhysicsObjects(objects)
  }, [shapes, physicsMap, collisionMap])

  // Physics simulation loop
  useEffect(() => {
    if (!isPlaying || physicsObjects.length === 0) return

    const simulate = () => {
      const now = Date.now()
      const frameTime = now - lastTime.current
      lastTime.current = now

      accumulatorRef.current += frameTime

      while (accumulatorRef.current >= TIME_STEP) {
        // Physics step
        setPhysicsObjects((objects) => {
          return objects.map((obj) => {
            if (obj.physics.bodyType === 'static') {
              // Static objects don't move
              return obj
            }

            if (obj.physics.bodyType === 'kinematic') {
              // Kinematic objects move with set velocity (no physics applied)
              const newX = obj.shape.x + obj.velocityX * (TIME_STEP / 1000)
              const newY = obj.shape.y + obj.velocityY * (TIME_STEP / 1000)
              
              onShapeUpdate(obj.id, newX, newY, obj.shape.rotation)
              
              return {
                ...obj,
                shape: {
                  ...obj.shape,
                  x: newX,
                  y: newY,
                },
              }
            }

            // Dynamic objects: Apply physics
            const dt = TIME_STEP / 1000

            // Apply gravity
            const gravityForce = GRAVITY * obj.physics.gravityScale * obj.physics.mass
            let newVelocityY = obj.velocityY + (gravityForce * dt) / obj.physics.mass

            // Apply velocity
            let newX = obj.shape.x + obj.velocityX * dt
            let newY = obj.shape.y + newVelocityY * dt

            // Simple ground collision (y = canvas bottom)
            const canvasBottom = 600 // TODO: Get from canvas config
            const objectBottom = newY + (obj.shape.height || 0)
            
            if (objectBottom > canvasBottom) {
              // Hit ground
              newY = canvasBottom - (obj.shape.height || 0)
              newVelocityY = -newVelocityY * obj.physics.bounce
              
              // Apply friction
              obj.velocityX *= (1 - obj.physics.friction)
              
              // Stop if moving very slowly
              if (Math.abs(newVelocityY) < 10) {
                newVelocityY = 0
              }
              if (Math.abs(obj.velocityX) < 1) {
                obj.velocityX = 0
              }
            }

            onShapeUpdate(obj.id, newX, newY, obj.shape.rotation)

            return {
              ...obj,
              shape: {
                ...obj.shape,
                x: newX,
                y: newY,
              },
              velocityY: newVelocityY,
            }
          })
        })

        accumulatorRef.current -= TIME_STEP
      }

      requestRef.current = requestAnimationFrame(simulate)
    }

    requestRef.current = requestAnimationFrame(simulate)

    return () => {
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current)
      }
    }
  }, [isPlaying, physicsObjects, onShapeUpdate])

  // Render debug collision shapes
  return (
    <>
      {physicsObjects.map((obj) => {
        const collision = obj.collision
        if (!collision) return null

        const key = `collision-debug-${obj.id}`

        if (collision.type === 'box') {
          return (
            <Rect
              key={key}
              x={obj.shape.x + (collision.x || 0)}
              y={obj.shape.y + (collision.y || 0)}
              width={collision.width || obj.shape.width}
              height={collision.height || obj.shape.height}
              rotation={obj.shape.rotation || 0}
              stroke="#10b981"
              strokeWidth={1}
              dash={[3, 3]}
              listening={false}
            />
          )
        }

        if (collision.type === 'circle') {
          const radius = collision.radius || Math.min(obj.shape.width, obj.shape.height) / 2
          return (
            <Circle
              key={key}
              x={obj.shape.x + (collision.x || 0)}
              y={obj.shape.y + (collision.y || 0)}
              radius={radius}
              stroke="#10b981"
              strokeWidth={1}
              dash={[3, 3]}
              listening={false}
            />
          )
        }

        return null
      })}
    </>
  )
}
</file>

<file path="src/components/export/ExportConfigPanel.tsx">
/**
 * Export Configuration Panel Component
 * Configure export options for selected format
 */

import React, { useState } from 'react'
import { ArrowLeft, Settings } from 'lucide-react'
import type { 
  ExportFormat, 
  ExportOptions, 
  GenericExportOptions, 
  GodotExportOptions 
} from '../../types/export'
import { genericExporter } from '../../utils/exporters/genericExporter'
import { godotExporter } from '../../utils/exporters/godotExporter'

interface ExportConfigPanelProps {
  canvasId: string
  format: ExportFormat
  onExport: (options: ExportOptions) => void
  onBack: () => void
}

export default function ExportConfigPanel({ 
  canvasId, 
  format, 
  onExport, 
  onBack 
}: ExportConfigPanelProps) {
  // Get default options based on format
  const getDefaultOptions = (): ExportOptions => {
    switch (format) {
      case 'generic':
        return genericExporter.getDefaultOptions()
      case 'godot':
        return godotExporter.getDefaultOptions()
      default:
        return genericExporter.getDefaultOptions()
    }
  }

  const [options, setOptions] = useState<ExportOptions>(getDefaultOptions())

  const updateOption = (key: string, value: any) => {
    setOptions(prev => ({ ...prev, [key]: value }))
  }

  const handleExport = () => {
    onExport(options)
  }

  // Get supported features for current format
  const getSupportedFeatures = (): string[] => {
    switch (format) {
      case 'generic':
        return genericExporter.getSupportedFeatures()
      case 'godot':
        return godotExporter.getSupportedFeatures()
      default:
        return []
    }
  }

  return (
    <div className="space-y-6">
      {/* Back button */}
      <button
        onClick={onBack}
        className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors"
      >
        <ArrowLeft className="w-4 h-4" />
        Back to format selection
      </button>

      {/* Configuration options */}
      <div className="bg-gray-50 dark:bg-gray-900 rounded-lg p-6 space-y-6">
        <div className="flex items-center gap-2 text-lg font-semibold text-gray-900 dark:text-white">
          <Settings className="w-5 h-5" />
          Export Options
        </div>

        {/* Common options */}
        <div className="space-y-4">
          <label className="flex items-center gap-3 cursor-pointer">
            <input
              type="checkbox"
              checked={options.includeAssets}
              onChange={(e) => updateOption('includeAssets', e.target.checked)}
              className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
            />
            <div>
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Include Assets
              </div>
              <div className="text-xs text-gray-600 dark:text-gray-400">
                Embed referenced images in export (increases file size)
              </div>
            </div>
          </label>

          <label className="flex items-center gap-3 cursor-pointer">
            <input
              type="checkbox"
              checked={options.prettyPrint}
              onChange={(e) => updateOption('prettyPrint', e.target.checked)}
              className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
            />
            <div>
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Pretty Print JSON
              </div>
              <div className="text-xs text-gray-600 dark:text-gray-400">
                Format JSON for readability (recommended for debugging)
              </div>
            </div>
          </label>

          <label className="flex items-center gap-3 cursor-pointer">
            <input
              type="checkbox"
              checked={options.includeDocumentation}
              onChange={(e) => updateOption('includeDocumentation', e.target.checked)}
              className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
            />
            <div>
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Include Documentation
              </div>
              <div className="text-xs text-gray-600 dark:text-gray-400">
                Add README with import instructions
              </div>
            </div>
          </label>
        </div>

        {/* Format-specific options */}
        {format === 'generic' && (
          <GenericOptions 
            options={options as GenericExportOptions} 
            updateOption={updateOption} 
          />
        )}

        {format === 'godot' && (
          <GodotOptions 
            options={options as GodotExportOptions} 
            updateOption={updateOption} 
          />
        )}
      </div>

      {/* Supported features */}
      <div className="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-4">
        <h4 className="text-sm font-semibold text-blue-900 dark:text-blue-300 mb-3">
          Supported Features
        </h4>
        <ul className="space-y-1">
          {getSupportedFeatures().map((feature, index) => (
            <li key={index} className="text-sm text-blue-800 dark:text-blue-200 flex items-start gap-2">
              <span className="text-green-600 dark:text-green-400 mt-0.5">✓</span>
              <span>{feature}</span>
            </li>
          ))}
        </ul>
      </div>

      {/* Export button */}
      <button
        onClick={handleExport}
        className="w-full px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors"
      >
        Start Export
      </button>
    </div>
  )
}

/**
 * Generic format specific options
 */
function GenericOptions({ 
  options, 
  updateOption 
}: { 
  options: GenericExportOptions
  updateOption: (key: string, value: any) => void
}) {
  return (
    <div className="space-y-4 pt-4 border-t border-gray-200 dark:border-gray-700">
      <h4 className="text-sm font-semibold text-gray-900 dark:text-white">
        Generic JSON Options
      </h4>

      <label className="flex items-center gap-3 cursor-pointer">
        <input
          type="checkbox"
          checked={options.includeSchema}
          onChange={(e) => updateOption('includeSchema', e.target.checked)}
          className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
        />
        <div>
          <div className="text-sm font-medium text-gray-900 dark:text-white">
            Include JSON Schema
          </div>
          <div className="text-xs text-gray-600 dark:text-gray-400">
            Add schema.json file for format documentation
          </div>
        </div>
      </label>

      <div>
        <label className="block text-sm font-medium text-gray-900 dark:text-white mb-2">
          Coordinate System
        </label>
        <select
          value={options.coordinateSystem}
          onChange={(e) => updateOption('coordinateSystem', e.target.value as 'top-left' | 'center')}
          className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg text-sm focus:ring-2 focus:ring-blue-500"
        >
          <option value="top-left">Top-Left Origin (most engines)</option>
          <option value="center">Center Origin (some physics engines)</option>
        </select>
        <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
          Choose coordinate system for your target engine
        </p>
      </div>

      <label className="flex items-center gap-3 cursor-pointer opacity-50">
        <input
          type="checkbox"
          checked={options.exportPNGLayers}
          onChange={(e) => updateOption('exportPNGLayers', e.target.checked)}
          className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
          disabled
        />
        <div>
          <div className="text-sm font-medium text-gray-900 dark:text-white">
            Export PNG Layers (Coming Soon)
          </div>
          <div className="text-xs text-gray-600 dark:text-gray-400">
            Export each layer as separate PNG image
          </div>
        </div>
      </label>
    </div>
  )
}

/**
 * Godot format specific options
 */
function GodotOptions({ 
  options, 
  updateOption 
}: { 
  options: GodotExportOptions
  updateOption: (key: string, value: any) => void 
}) {
  return (
    <div className="space-y-4 pt-4 border-t border-gray-200 dark:border-gray-700">
      <h4 className="text-sm font-semibold text-gray-900 dark:text-white">
        Godot Engine Options
      </h4>

      <div>
        <label className="block text-sm font-medium text-gray-900 dark:text-white mb-2">
          Target Godot Version
        </label>
        <select
          value={options.targetVersion}
          onChange={(e) => updateOption('targetVersion', e.target.value as '3.x' | '4.x')}
          className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg text-sm focus:ring-2 focus:ring-blue-500"
        >
          <option value="4.x">Godot 4.x (Recommended)</option>
          <option value="3.x">Godot 3.x</option>
        </select>
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-900 dark:text-white mb-2">
          Node Naming Scheme
        </label>
        <select
          value={options.nodeNamingScheme}
          onChange={(e) => updateOption('nodeNamingScheme', e.target.value as 'descriptive' | 'simple')}
          className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg text-sm focus:ring-2 focus:ring-blue-500"
        >
          <option value="descriptive">Descriptive (e.g., "PlayerSprite_0")</option>
          <option value="simple">Simple (e.g., "Rectangle_0")</option>
        </select>
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-900 dark:text-white mb-2">
          Pixels Per Unit: {options.pixelsPerUnit}
        </label>
        <input
          type="range"
          min="0.1"
          max="5"
          step="0.1"
          value={options.pixelsPerUnit}
          onChange={(e) => updateOption('pixelsPerUnit', parseFloat(e.target.value))}
          className="w-full"
        />
        <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
          Scaling factor for object sizes (1 = no scaling)
        </p>
      </div>

      <label className="flex items-center gap-3 cursor-pointer">
        <input
          type="checkbox"
          checked={options.includePhysics}
          onChange={(e) => updateOption('includePhysics', e.target.checked)}
          className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
        />
        <div>
          <div className="text-sm font-medium text-gray-900 dark:text-white">
            Include Physics Nodes
          </div>
          <div className="text-xs text-gray-600 dark:text-gray-400">
            Add CollisionShape2D nodes (requires manual configuration)
          </div>
        </div>
      </label>

      <label className="flex items-center gap-3 cursor-pointer">
        <input
          type="checkbox"
          checked={options.includeAutoTiles}
          onChange={(e) => updateOption('includeAutoTiles', e.target.checked)}
          className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
        />
        <div>
          <div className="text-sm font-medium text-gray-900 dark:text-white">
            Include Auto-Tile Configuration
          </div>
          <div className="text-xs text-gray-600 dark:text-gray-400">
            Export tilemap auto-tiling rules (if present)
          </div>
        </div>
      </label>
    </div>
  )
}
</file>

<file path="src/components/export/ExportModal.tsx">
/**
 * Export Modal Component
 * Main modal for selecting export format and configuring options
 */

import React, { useState } from 'react'
import { X, FileJson, Code, Download, FileText } from 'lucide-react'
import type { ExportFormat } from '../../types/export'
import ExportConfigPanel from './ExportConfigPanel'
import ExportProgress from './ExportProgress'

interface ExportModalProps {
  isOpen: boolean
  onClose: () => void
  canvasId: string
  canvasName: string
}

interface ExportFormatOption {
  format: ExportFormat
  name: string
  description: string
  icon: React.ReactNode
  popular?: boolean
  beta?: boolean
}

const EXPORT_FORMATS: ExportFormatOption[] = [
  {
    format: 'generic',
    name: 'Generic JSON',
    description: 'Engine-agnostic JSON format. Works with any game engine.',
    icon: <FileJson className="w-8 h-8" />,
    popular: true
  },
  {
    format: 'godot',
    name: 'Godot Engine',
    description: 'Export to Godot .tscn scene format (3.x and 4.x)',
    icon: <Code className="w-8 h-8" />,
    popular: true
  },
  {
    format: 'unity',
    name: 'Unity',
    description: 'Export to Unity prefab format',
    icon: <FileText className="w-8 h-8" />,
    beta: true
  },
  {
    format: 'phaser',
    name: 'Phaser',
    description: 'Export to Phaser 3 JSON scene format',
    icon: <Download className="w-8 h-8" />,
    beta: true
  }
]

export default function ExportModal({ isOpen, onClose, canvasId, canvasName }: ExportModalProps) {
  const [selectedFormat, setSelectedFormat] = useState<ExportFormat | null>(null)
  const [isExporting, setIsExporting] = useState(false)

  if (!isOpen) return null

  const handleFormatSelect = (format: ExportFormat) => {
    // Check if format is available
    const formatOption = EXPORT_FORMATS.find(f => f.format === format)
    if (formatOption?.beta) {
      alert('This export format is coming soon! For now, use Generic JSON export.')
      return
    }
    
    setSelectedFormat(format)
  }

  const handleBack = () => {
    if (!isExporting) {
      setSelectedFormat(null)
    }
  }

  const handleStartExport = () => {
    setIsExporting(true)
  }

  const handleExportComplete = () => {
    setIsExporting(false)
    setSelectedFormat(null)
  }

  const handleClose = () => {
    if (!isExporting) {
      setSelectedFormat(null)
      onClose()
    }
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
              {selectedFormat ? 'Export Configuration' : 'Export Canvas'}
            </h2>
            <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
              {selectedFormat 
                ? `Configure ${EXPORT_FORMATS.find(f => f.format === selectedFormat)?.name} export options`
                : `Choose your target game engine or export format`
              }
            </p>
          </div>
          <button
            onClick={handleClose}
            disabled={isExporting}
            className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            aria-label="Close modal"
          >
            <X className="w-5 h-5 text-gray-600 dark:text-gray-400" />
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
          {!selectedFormat ? (
            /* Format Selection Grid */
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {EXPORT_FORMATS.map((formatOption) => (
                <button
                  key={formatOption.format}
                  onClick={() => handleFormatSelect(formatOption.format)}
                  className={`
                    relative p-6 border-2 rounded-lg text-left transition-all hover:shadow-lg
                    ${formatOption.beta 
                      ? 'border-gray-300 dark:border-gray-600 opacity-75 cursor-not-allowed' 
                      : 'border-gray-300 dark:border-gray-600 hover:border-blue-500 dark:hover:border-blue-400'
                    }
                  `}
                  disabled={formatOption.beta}
                >
                  {/* Popular badge */}
                  {formatOption.popular && (
                    <div className="absolute top-3 right-3 px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs font-semibold rounded">
                      POPULAR
                    </div>
                  )}

                  {/* Beta badge */}
                  {formatOption.beta && (
                    <div className="absolute top-3 right-3 px-2 py-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300 text-xs font-semibold rounded">
                      COMING SOON
                    </div>
                  )}

                  {/* Icon */}
                  <div className="text-blue-600 dark:text-blue-400 mb-4">
                    {formatOption.icon}
                  </div>

                  {/* Name */}
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
                    {formatOption.name}
                  </h3>

                  {/* Description */}
                  <p className="text-sm text-gray-600 dark:text-gray-400">
                    {formatOption.description}
                  </p>

                  {/* Features list */}
                  <div className="mt-4 space-y-1">
                    {formatOption.format === 'generic' && (
                      <>
                        <div className="text-xs text-green-600 dark:text-green-400">✓ Works with any engine</div>
                        <div className="text-xs text-green-600 dark:text-green-400">✓ Complete canvas data</div>
                        <div className="text-xs text-green-600 dark:text-green-400">✓ JSON schema included</div>
                      </>
                    )}
                    {formatOption.format === 'godot' && (
                      <>
                        <div className="text-xs text-green-600 dark:text-green-400">✓ Godot 3.x and 4.x</div>
                        <div className="text-xs text-green-600 dark:text-green-400">✓ TileMap support</div>
                        <div className="text-xs text-green-600 dark:text-green-400">✓ Ready-to-use scenes</div>
                      </>
                    )}
                  </div>
                </button>
              ))}
            </div>
          ) : isExporting ? (
            /* Export Progress */
            <ExportProgress
              canvasId={canvasId}
              canvasName={canvasName}
              format={selectedFormat}
              onComplete={handleExportComplete}
              onCancel={handleBack}
            />
          ) : (
            /* Configuration Panel */
            <ExportConfigPanel
              canvasId={canvasId}
              format={selectedFormat}
              onExport={handleStartExport}
              onBack={handleBack}
            />
          )}
        </div>

        {/* Footer */}
        {!selectedFormat && !isExporting && (
          <div className="p-6 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900">
            <div className="flex items-start gap-2 text-sm text-gray-600 dark:text-gray-400">
              <div className="text-blue-600 dark:text-blue-400 mt-0.5">ℹ️</div>
              <div>
                <strong>Recommendation:</strong> For maximum compatibility, export to <strong>Generic JSON</strong> first. 
                You can always re-export to engine-specific formats later.
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/export/ExportProgress.tsx">
/**
 * Export Progress Component
 * Shows export progress and handles download
 */

import React, { useEffect, useState } from 'react'
import { Check, Download, AlertCircle, Loader2, FileArchive } from 'lucide-react'
import type { 
  ExportFormat, 
  ExportProgress as ExportProgressType, 
  ExportResult,
  ExportOptions
} from '../../types/export'
import { genericExporter } from '../../utils/exporters/genericExporter'
import { godotExporter } from '../../utils/exporters/godotExporter'
import { createZipFromFiles, downloadBlob } from '../../utils/exporters/baseExporter'

interface ExportProgressProps {
  canvasId: string
  canvasName: string
  format: ExportFormat
  options?: ExportOptions
  onComplete: () => void
  onCancel: () => void
}

export default function ExportProgress({ 
  canvasId, 
  canvasName, 
  format, 
  options,
  onComplete, 
  onCancel 
}: ExportProgressProps) {
  const [progress, setProgress] = useState<ExportProgressType>({
    stage: 'validating',
    progress: 0,
    message: 'Initializing export...',
    warnings: [],
    errors: []
  })
  const [result, setResult] = useState<ExportResult | null>(null)
  const [isDownloading, setIsDownloading] = useState(false)

  useEffect(() => {
    performExport()
  }, [])

  const performExport = async () => {
    try {
      let exporter
      let exportOptions: ExportOptions

      // Get exporter and options for format
      switch (format) {
        case 'generic':
          exporter = genericExporter
          exportOptions = options || genericExporter.getDefaultOptions()
          break
        case 'godot':
          exporter = godotExporter
          exportOptions = options || godotExporter.getDefaultOptions()
          break
        default:
          throw new Error(`Unsupported export format: ${format}`)
      }

      // Perform export with progress callback
      const exportResult = await exporter.export(
        canvasId,
        exportOptions,
        (progressUpdate) => {
          setProgress(progressUpdate)
        }
      )

      setResult(exportResult)

      if (!exportResult.success) {
        setProgress({
          stage: 'error',
          progress: 0,
          message: 'Export failed',
          warnings: exportResult.warnings,
          errors: ['Export failed. See errors below.']
        })
      }
    } catch (error) {
      console.error('Export error:', error)
      setProgress({
        stage: 'error',
        progress: 0,
        message: 'Export failed',
        warnings: [],
        errors: [error instanceof Error ? error.message : 'Unknown error']
      })
    }
  }

  const handleDownload = async () => {
    if (!result || !result.success) return

    setIsDownloading(true)

    try {
      // Create ZIP file from export files
      const zipBlob = await createZipFromFiles(result.files)
      
      // Generate filename
      const timestamp = new Date().toISOString().split('T')[0]
      const formatName = format === 'generic' ? 'json' : format
      const filename = `${canvasName}_${formatName}_${timestamp}.zip`

      // Download
      downloadBlob(zipBlob, filename)

      // Small delay for user feedback
      setTimeout(() => {
        setIsDownloading(false)
      }, 500)
    } catch (error) {
      console.error('Download error:', error)
      alert('Failed to create download. Please try again.')
      setIsDownloading(false)
    }
  }

  const handleClose = () => {
    if (result?.success) {
      onComplete()
    } else {
      onCancel()
    }
  }

  const getStageIcon = (stage: string) => {
    switch (stage) {
      case 'complete':
        return <Check className="w-5 h-5 text-green-600" />
      case 'error':
        return <AlertCircle className="w-5 h-5 text-red-600" />
      default:
        return <Loader2 className="w-5 h-5 text-blue-600 animate-spin" />
    }
  }

  const getStageColor = (stage: string) => {
    switch (stage) {
      case 'complete':
        return 'text-green-600 dark:text-green-400'
      case 'error':
        return 'text-red-600 dark:text-red-400'
      default:
        return 'text-blue-600 dark:text-blue-400'
    }
  }

  return (
    <div className="space-y-6">
      {/* Progress indicator */}
      <div className="bg-gray-50 dark:bg-gray-900 rounded-lg p-6 space-y-4">
        <div className="flex items-center gap-3">
          {getStageIcon(progress.stage)}
          <div className="flex-1">
            <div className={`text-sm font-medium ${getStageColor(progress.stage)}`}>
              {progress.message}
            </div>
          </div>
          <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">
            {progress.progress}%
          </div>
        </div>

        {/* Progress bar */}
        <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 overflow-hidden">
          <div
            className={`h-full transition-all duration-300 ${
              progress.stage === 'complete'
                ? 'bg-green-600'
                : progress.stage === 'error'
                ? 'bg-red-600'
                : 'bg-blue-600'
            }`}
            style={{ width: `${progress.progress}%` }}
          />
        </div>

        {/* Stage description */}
        <div className="text-xs text-gray-600 dark:text-gray-400">
          {progress.stage === 'validating' && 'Checking canvas data for export compatibility...'}
          {progress.stage === 'collecting' && 'Gathering objects, assets, and tilemap data...'}
          {progress.stage === 'converting' && `Converting to ${format} format...`}
          {progress.stage === 'packaging' && 'Creating export files and packaging...'}
          {progress.stage === 'complete' && '🎉 Export completed successfully!'}
          {progress.stage === 'error' && 'Export failed. Please check errors below.'}
        </div>
      </div>

      {/* Warnings */}
      {progress.warnings.length > 0 && (
        <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
          <div className="flex items-start gap-2">
            <AlertCircle className="w-5 h-5 text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <h4 className="text-sm font-semibold text-yellow-900 dark:text-yellow-300 mb-2">
                Warnings
              </h4>
              <ul className="space-y-1">
                {progress.warnings.map((warning, index) => (
                  <li key={index} className="text-sm text-yellow-800 dark:text-yellow-200">
                    • {warning}
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}

      {/* Errors */}
      {progress.errors.length > 0 && (
        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
          <div className="flex items-start gap-2">
            <AlertCircle className="w-5 h-5 text-red-600 dark:text-red-400 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <h4 className="text-sm font-semibold text-red-900 dark:text-red-300 mb-2">
                Errors
              </h4>
              <ul className="space-y-1">
                {progress.errors.map((error, index) => (
                  <li key={index} className="text-sm text-red-800 dark:text-red-200">
                    • {error}
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}

      {/* Success state with download */}
      {progress.stage === 'complete' && result?.success && (
        <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-6 space-y-4">
          <div className="flex items-center gap-3">
            <FileArchive className="w-8 h-8 text-green-600 dark:text-green-400" />
            <div>
              <h3 className="text-lg font-semibold text-green-900 dark:text-green-300">
                Export Ready!
              </h3>
              <p className="text-sm text-green-700 dark:text-green-400">
                Your canvas has been exported successfully. {result.files.length} file(s) ready for download.
              </p>
            </div>
          </div>

          {/* Download button */}
          <button
            onClick={handleDownload}
            disabled={isDownloading}
            className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-green-600 hover:bg-green-700 disabled:bg-green-400 text-white font-semibold rounded-lg transition-colors"
          >
            {isDownloading ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin" />
                Preparing download...
              </>
            ) : (
              <>
                <Download className="w-5 h-5" />
                Download ZIP ({result.files.length} files)
              </>
            )}
          </button>

          {/* Instructions preview */}
          {result.instructions && (
            <details className="text-sm">
              <summary className="cursor-pointer text-green-800 dark:text-green-300 font-medium hover:text-green-900 dark:hover:text-green-200">
                View import instructions
              </summary>
              <div className="mt-3 p-4 bg-white dark:bg-gray-800 rounded border border-green-200 dark:border-green-800">
                <pre className="text-xs text-gray-700 dark:text-gray-300 whitespace-pre-wrap font-mono">
                  {result.instructions.substring(0, 500)}...
                </pre>
                <p className="text-xs text-gray-600 dark:text-gray-400 mt-2">
                  Full instructions included in README.md file
                </p>
              </div>
            </details>
          )}
        </div>
      )}

      {/* Actions */}
      <div className="flex gap-3">
        {progress.stage === 'complete' && result?.success ? (
          <button
            onClick={handleClose}
            className="flex-1 px-6 py-3 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-900 dark:text-white font-semibold rounded-lg transition-colors"
          >
            Close
          </button>
        ) : progress.stage === 'error' ? (
          <>
            <button
              onClick={onCancel}
              className="flex-1 px-6 py-3 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-900 dark:text-white font-semibold rounded-lg transition-colors"
            >
              Back
            </button>
            <button
              onClick={performExport}
              className="flex-1 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors"
            >
              Retry Export
            </button>
          </>
        ) : (
          <button
            disabled
            className="flex-1 px-6 py-3 bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 font-semibold rounded-lg cursor-not-allowed"
          >
            Exporting...
          </button>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/panels/AIChatPanel.tsx">
/**
 * AI Chat Panel Component
 * Collapsible chat interface for AI agent
 * PR-30: Task 5.1
 */

import React, { useState, useRef, useEffect } from 'react';
import { useAIChat } from '../../hooks/useAIChat';
import { MessageBubble } from '../ai/MessageBubble';
import { isAIEnabled } from '../../services/ai/ai';

interface AIChatPanelProps {
  canvasId: string;
  userId: string;
  selectedShapes: string[];
  viewport: {
    x: number;
    y: number;
    width: number;
    height: number;
    zoom: number;
  };
  mode: 'shapes' | 'tilemap';
  tilemapMeta?: any;
  onClose: () => void;
}

const EXAMPLE_COMMANDS = [
  'Create a red circle at (200, 200)',
  'Arrange selected shapes in a grid',
  'Generate a noise terrain tilemap 50x50',
  'Move selected shapes right by 100 pixels',
  'Align all shapes to the left',
];

export const AIChatPanel: React.FC<AIChatPanelProps> = ({
  canvasId,
  userId,
  selectedShapes,
  viewport,
  mode,
  tilemapMeta,
  onClose,
}) => {
  const [input, setInput] = useState('');
  const [isExpanded, setIsExpanded] = useState(false);
  const [isCollapsed, setIsCollapsed] = useState(false);
  const [showPopup, setShowPopup] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const { messages, isLoading, error, sendMessage, clearMessages } = useAIChat({
    canvasId,
    userId,
    onToolExecuted: (results) => {
      console.log('Tools executed:', results);
    },
  });

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Focus input on mount or when popup opens
  useEffect(() => {
    if (!isCollapsed || showPopup) {
      inputRef.current?.focus();
    }
  }, [isCollapsed, showPopup]);

  const handleSend = () => {
    if (!input.trim() || isLoading) return;

    sendMessage(input, {
      selectedShapes,
      viewport,
      mode,
      tilemapMeta,
    });

    setInput('');
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handleExampleClick = (command: string) => {
    setInput(command);
    inputRef.current?.focus();
  };

  // Close popup on Escape key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && showPopup) {
        setShowPopup(false);
      }
    };
    
    if (showPopup) {
      window.addEventListener('keydown', handleEscape);
      return () => window.removeEventListener('keydown', handleEscape);
    }
  }, [showPopup]);

  // Auto-hide messages after 5 seconds (only last 2 messages visible)
  const recentMessages = messages.slice(-2);

  // Responsive collapse on small screens (640px = standard mobile breakpoint)
  useEffect(() => {
    const handleResize = () => {
      const shouldCollapse = window.innerWidth < 640;
      setIsCollapsed(shouldCollapse);
      // Close popup when expanding back to full view
      if (!shouldCollapse && showPopup) {
        setShowPopup(false);
      }
    };
    
    handleResize(); // Check on mount
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [showPopup]);

  // AI not enabled - show message in collapsed state
  if (!isAIEnabled()) {
    return (
      <div className="flex items-center gap-2 px-3 py-1 bg-gray-500/20 rounded text-white/50 text-xs">
        <span>🤖</span>
        <span className="hidden sm:inline">AI Not Enabled</span>
      </div>
    );
  }

  // If collapsed to button
  if (isCollapsed) {
    return (
      <>
        {/* Floating Messages (Toast Style) - Above status bar */}
        <div className="fixed left-1/2 -translate-x-1/2 bottom-12 pointer-events-none z-40">
          <div className="flex flex-col-reverse gap-2 items-center">
            {isLoading && (
              <div className="bg-gray-800/90 backdrop-blur-sm px-3 py-1.5 rounded-full shadow-lg text-xs text-white">
                AI thinking...
              </div>
            )}
            {recentMessages.map(message => (
              <div
                key={message.id}
                className={`max-w-md px-3 py-1.5 rounded-full shadow-lg text-xs ${
                  message.role === 'user'
                    ? 'bg-blue-500 text-white'
                    : message.role === 'error'
                    ? 'bg-red-500 text-white'
                    : 'bg-gray-800/90 backdrop-blur-sm text-white'
                }`}
              >
                {message.role === 'assistant' && '🤖 '}
                <span className="truncate">{message.content}</span>
              </div>
            ))}
          </div>
        </div>

        {/* Collapsed Button - Positioned in status bar */}
        <button
          onClick={() => setShowPopup(!showPopup)}
          className="flex items-center gap-2 px-3 py-1 bg-blue-500/20 hover:bg-blue-500/30 rounded text-white text-xs transition-colors"
          title={showPopup ? "Close AI Assistant" : "Open AI Assistant"}
        >
          <span>🤖</span>
          <span className="hidden sm:inline">AI</span>
        </button>

        {/* Popup Modal for collapsed state */}
        {showPopup && (
          <>
            {/* Backdrop */}
            <div 
              className="fixed inset-0 bg-black/50 z-[100]"
              onClick={() => setShowPopup(false)}
            />
            
            {/* Popup Chat Window */}
            <div className="fixed inset-x-4 bottom-16 top-16 sm:left-auto sm:right-4 sm:w-96 sm:top-auto sm:bottom-16 sm:max-h-[600px] bg-white rounded-lg shadow-2xl border border-gray-200 z-[101] flex flex-col">
              {/* Header */}
              <div className="px-4 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white flex items-center justify-between rounded-t-lg flex-shrink-0">
                <div className="flex items-center gap-2">
                  <span>🤖</span>
                  <span className="text-sm font-semibold">AI Assistant</span>
                </div>
                <div className="flex items-center gap-2">
                  <button
                    onClick={clearMessages}
                    className="text-xs hover:bg-white/20 px-2 py-1 rounded transition-colors"
                    title="Clear chat"
                  >
                    Clear
                  </button>
                  <button
                    onClick={() => setShowPopup(false)}
                    className="hover:bg-white/20 p-1 rounded transition-colors"
                    title="Close"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>
              </div>

              {/* Messages */}
              <div className="flex-1 p-4 space-y-3 overflow-y-auto">
                {messages.length === 0 ? (
                  <div className="text-center py-8">
                    <p className="text-sm text-gray-500 mb-4">No messages yet.</p>
                    <div className="space-y-2">
                      <p className="text-xs text-gray-400 font-semibold">Try these:</p>
                      {EXAMPLE_COMMANDS.slice(0, 3).map((cmd, i) => (
                        <button
                          key={i}
                          onClick={() => handleExampleClick(cmd)}
                          className="block w-full text-left text-xs text-blue-600 hover:bg-blue-50 px-3 py-2 rounded transition-colors"
                        >
                          {cmd}
                        </button>
                      ))}
                    </div>
                  </div>
                ) : (
                  <>
                    {messages.map(message => <MessageBubble key={message.id} message={message} />)}
                    <div ref={messagesEndRef} />
                  </>
                )}
                {isLoading && (
                  <div className="flex items-center gap-2 text-gray-500 text-sm px-4 py-2">
                    <div className="flex gap-1">
                      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                    </div>
                    <span>AI thinking...</span>
                  </div>
                )}
                {error && (
                  <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded text-xs">
                    {error}
                  </div>
                )}
              </div>

              {/* Input Area */}
              <div className="p-4 border-t border-gray-200 flex-shrink-0">
                <div className="flex gap-2">
                  <input
                    ref={inputRef}
                    type="text"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyPress={handleKeyPress}
                    placeholder="Ask AI anything..."
                    className="flex-1 px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    disabled={isLoading}
                  />
                  <button
                    onClick={handleSend}
                    disabled={isLoading || !input.trim()}
                    className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors text-sm font-medium"
                    title="Send (Enter)"
                  >
                    Send
                  </button>
                </div>
                <div className="mt-2 flex items-center gap-2 text-xs text-gray-500">
                  <span className={mode === 'shapes' ? 'text-blue-600' : ''}>
                    {mode === 'shapes' ? '🎨 Shapes' : '🗺️ Tilemap'}
                  </span>
                  {selectedShapes.length > 0 && (
                    <>
                      <span>•</span>
                      <span>{selectedShapes.length} selected</span>
                    </>
                  )}
                </div>
              </div>
            </div>
          </>
        )}
      </>
    );
  }

  return (
    <>
      {/* Floating Messages (Toast Style) - Above status bar */}
      <div className="fixed left-4 bottom-12 pointer-events-none z-40 max-w-md">
        <div className="flex flex-col-reverse gap-2 items-center">
          {isLoading && (
            <div className="bg-gray-800/90 backdrop-blur-sm px-4 py-2 rounded-full shadow-lg flex items-center gap-2 animate-fade-in">
              <div className="flex gap-1">
                <div className="w-1.5 h-1.5 bg-white/70 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                <div className="w-1.5 h-1.5 bg-white/70 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                <div className="w-1.5 h-1.5 bg-white/70 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
              </div>
              <span className="text-white text-xs">AI thinking...</span>
            </div>
          )}
          
          {recentMessages.map(message => (
            <div
              key={message.id}
              className={`max-w-md px-4 py-2 rounded-full shadow-lg text-xs animate-slide-up ${
                message.role === 'user'
                  ? 'bg-blue-500 text-white'
                  : message.role === 'error'
                  ? 'bg-red-500 text-white'
                  : 'bg-gray-800/90 backdrop-blur-sm text-white'
              }`}
            >
              <div className="flex items-center gap-2">
                {message.role === 'assistant' && '🤖'}
                {message.role === 'user' && '👤'}
                {message.role === 'error' && '⚠️'}
                <span className="truncate max-w-xs">{message.content}</span>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Inline Status Bar AI Chat - Rendered in status bar left slot */}
      <div className="flex items-center gap-1 sm:gap-2 pointer-events-auto flex-1 min-w-0">
        {/* AI Indicator */}
        <div className="flex items-center gap-1 flex-shrink-0">
          <div className="w-1 h-1 bg-green-400 rounded-full animate-pulse" />
          <span className="text-[10px] font-medium text-white">🤖</span>
        </div>

        {/* Input - responsive width */}
        <input
          ref={inputRef}
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder="Ask AI..."
          className="flex-1 min-w-[80px] max-w-md px-2 py-0.5 text-[10px] focus:outline-none bg-white/10 text-white placeholder-white/50 rounded border border-white/20 focus:border-blue-400 transition-colors"
          disabled={isLoading}
        />

        {/* Mode indicator - hide on very small screens */}
        <span className="hidden sm:inline text-[10px] text-white/70 flex-shrink-0">
          {mode === 'shapes' ? '🎨' : '🗺️'}
        </span>

        {/* Send Button */}
        <button
          onClick={handleSend}
          disabled={isLoading || !input.trim()}
          className="p-1 bg-blue-500/80 hover:bg-blue-500 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex-shrink-0"
          title="Send (Enter)"
        >
          <svg className="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
          </svg>
        </button>

        {/* Expand History Button - hide on very small screens */}
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="hidden sm:block p-1 text-white/70 hover:text-white transition-colors flex-shrink-0"
          title={isExpanded ? 'Hide history' : 'Show history'}
        >
          <svg className="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
          </svg>
        </button>

        {/* Close Button - optional on very small screens */}
        <button
          onClick={onClose}
          className="p-1 text-white/50 hover:text-white transition-colors flex-shrink-0"
          title="Close AI"
        >
          <svg className="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>

        {/* Error inline */}
        {error && (
          <div className="absolute left-0 bottom-full mb-1 bg-red-500 text-white text-[10px] px-2 py-0.5 rounded shadow-lg whitespace-nowrap z-50">
            {error}
          </div>
        )}
      </div>

      {/* Expanded History Panel */}
      {isExpanded && (
        <div className="fixed left-1/2 -translate-x-1/2 bottom-24 w-96 max-h-80 bg-white rounded-lg shadow-2xl border border-gray-200 overflow-hidden z-20">
          {/* Header */}
          <div className="px-3 py-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white flex items-center justify-between">
            <span className="text-xs font-semibold">Chat History</span>
            <button
              onClick={clearMessages}
              className="text-xs hover:bg-white/20 px-2 py-0.5 rounded"
            >
              Clear
            </button>
          </div>

          {/* Messages */}
          <div className="p-3 space-y-2 overflow-y-auto max-h-64">
            {messages.length === 0 ? (
              <div className="text-center py-4 text-xs text-gray-500">
                No messages yet. Try: "Create a blue rectangle"
              </div>
            ) : (
              messages.map(message => <MessageBubble key={message.id} message={message} />)
            )}
          </div>
        </div>
      )}
    </>
  );
};
</file>

<file path="src/components/panels/LayerPanel.tsx">
/**
 * LayerPanel Component (PR-19)
 * Right sidebar showing layer hierarchy with visibility, lock, and reordering
 */

import { useState, useMemo } from 'react'
import { LayerItem } from '../LayerItem'
import { ColorPicker } from '../ui/ColorPicker'
import type { Layer } from '../../types/layer'
import type { Shape } from '../../types/canvas'
import type { Group } from '../../types/group'

interface LayerPanelProps {
  shapes: Shape[]
  groups: Group[]
  selectedIds: Set<string>
  onSelectLayer: (id: string) => void
  onToggleVisibility: (id: string) => void
  onToggleLock: (id: string) => void
  onRenameLayer: (id: string, newName: string) => void
  onDelete?: (id: string) => void
  // Design panel props
  onUpdateColors?: (fill: string, stroke: string, strokeWidth: number) => void
  onUpdateShapeProps?: (id: string, updates: Partial<Shape>) => void
  recentColors?: string[]
  onRequestColorSample?: (callback: (color: string) => void) => void
  // Theme for collab spaces
  collabTheme?: { 
    primary: string
    secondary: string
    gradient: string
    displayName: string
    softBg: string
    softBorder: string
  } | null
}

/**
 * LayerPanel component for displaying and managing layer hierarchy
 * Shows all objects and groups in a hierarchical list with controls
 */
export function LayerPanel({
  shapes,
  groups,
  selectedIds,
  onSelectLayer,
  onToggleVisibility,
  onToggleLock,
  onRenameLayer,
  onDelete,
  onUpdateColors,
  onUpdateShapeProps,
  recentColors = [],
  onRequestColorSample,
  collabTheme,
}: LayerPanelProps) {
  const [activeTab, setActiveTab] = useState<'layers' | 'design'>('layers')
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set())
  const [panelState, setPanelState] = useState<'hidden' | 'expanded'>('expanded')
  
  // Design panel state
  const [showFillPicker, setShowFillPicker] = useState(false)
  const [showStrokePicker, setShowStrokePicker] = useState(false)
  
  // Get selected shapes
  const selectedShapes = Array.from(selectedIds)
    .map(id => shapes.find(s => s.id === id))
    .filter((s): s is Shape => s !== undefined)
  
  // Check if any selected shape is text
  const isTextSelected = selectedShapes.length === 1 && selectedShapes[0].type === 'text'
  
  // Get common fill color
  const commonFill = useMemo(() => {
    if (selectedShapes.length === 0) return '#3B82F6FF'
    const fills = selectedShapes.map(s => s.fill || '#3B82F6FF')
    return fills.every(f => f === fills[0]) ? fills[0] : 'multiple'
  }, [selectedShapes])
  
  // Get common stroke color
  const commonStroke = useMemo(() => {
    if (selectedShapes.length === 0) return '#000000FF'
    const strokes = selectedShapes.map(s => s.stroke || '#000000FF')
    return strokes.every(s => s === strokes[0]) ? strokes[0] : 'multiple'
  }, [selectedShapes])
  
  // Get common stroke width
  const commonStrokeWidth = useMemo(() => {
    if (selectedShapes.length === 0) return 2
    const widths = selectedShapes.map(s => s.strokeWidth || 2)
    return widths.every(w => w === widths[0]) ? widths[0] : 2
  }, [selectedShapes])
  
  // Font families for text
  const FONT_FAMILIES = [
    'Inter, sans-serif',
    'Arial, sans-serif',
    'Georgia, serif',
    'Times New Roman, serif',
    'Courier New, monospace',
    'Comic Sans MS, cursive',
    'Impact, fantasy',
  ]

  /**
   * Convert shapes and groups into layer tree structure
   */
  const layerTree = useMemo(() => {
    const layers: Layer[] = []
    
    // Add shapes that are not in groups
    shapes.forEach((shape) => {
      const isInGroup = groups.some((g) => g.memberIds.includes(shape.id))
      if (!isInGroup) {
        // Generate readable names for each shape type
        let layerName = ''
        
        switch (shape.type) {
          case 'rectangle':
            layerName = `Rectangle ${shape.id.slice(-4)}`
            break
          case 'circle':
            layerName = `Circle ${shape.id.slice(-4)}`
            break
          case 'text':
            layerName = shape.text ? `"${shape.text.slice(0, 15)}"` : `Text ${shape.id.slice(-4)}`
            break
          case 'line':
            layerName = `Line ${shape.id.slice(-4)}`
            break
          case 'path':
            layerName = `Path ${shape.id.slice(-4)}`
            break
          case 'polygon':
            layerName = `Polygon ${shape.id.slice(-4)}`
            break
          case 'star':
            layerName = `Star ${shape.id.slice(-4)}`
            break
          case 'roundRect':
            layerName = `Rounded Rect ${shape.id.slice(-4)}`
            break
          default:
            layerName = `${shape.type} ${shape.id.slice(-4)}`
        }
        
        layers.push({
          id: shape.id,
          name: layerName,
          type: 'shape',
          visible: true,
          locked: false,
          zIndex: shape.zIndex || 0,
        })
      }
    })
    
    // Add groups with their children
    groups.forEach((group) => {
      // Check if this group is itself a member of another group
      const isInGroup = groups.some((g) => g.memberIds.includes(group.id))
      if (!isInGroup) {
        const children: Layer[] = []
        
        // Add group members as children
        group.memberIds.forEach((memberId) => {
          const shape = shapes.find((s) => s.id === memberId)
          const childGroup = groups.find((g) => g.id === memberId)
          
          if (shape) {
            // Use same naming as ungrouped shapes
            let childName = ''
            switch (shape.type) {
              case 'rectangle': childName = `Rectangle ${shape.id.slice(-4)}`; break
              case 'circle': childName = `Circle ${shape.id.slice(-4)}`; break
              case 'text': childName = shape.text ? `"${shape.text.slice(0, 15)}"` : `Text ${shape.id.slice(-4)}`; break
              case 'line': childName = `Line ${shape.id.slice(-4)}`; break
              case 'path': childName = `Path ${shape.id.slice(-4)}`; break
              case 'polygon': childName = `Polygon ${shape.id.slice(-4)}`; break
              case 'star': childName = `Star ${shape.id.slice(-4)}`; break
              case 'roundRect': childName = `Rounded Rect ${shape.id.slice(-4)}`; break
              default: childName = `${shape.type} ${shape.id.slice(-4)}`
            }
            
            children.push({
              id: shape.id,
              name: childName,
              type: 'shape',
              visible: true,
              locked: false,
              zIndex: shape.zIndex || 0,
              parentId: group.id,
            })
          } else if (childGroup) {
            // Nested group
            children.push({
              id: childGroup.id,
              name: childGroup.name,
              type: 'group',
              visible: childGroup.visible,
              locked: childGroup.locked,
              zIndex: childGroup.zIndex || 0,
              parentId: group.id,
            })
          }
        })
        
        layers.push({
          id: group.id,
          name: group.name,
          type: 'group',
          visible: group.visible,
          locked: group.locked,
          zIndex: group.zIndex || 0,
          children,
        })
      }
    })
    
    // Sort by z-index (highest first in layer panel)
    return layers.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0))
  }, [shapes, groups])

  const toggleGroupExpand = (groupId: string) => {
    const newExpanded = new Set(expandedGroups)
    if (newExpanded.has(groupId)) {
      newExpanded.delete(groupId)
    } else {
      newExpanded.add(groupId)
    }
    setExpandedGroups(newExpanded)
  }

  const renderLayer = (layer: Layer, level: number = 0): React.ReactNode => {
    const isSelected = selectedIds.has(layer.id)
    const isExpanded = expandedGroups.has(layer.id)

    return (
      <LayerItem
        key={layer.id}
        layer={layer}
        isSelected={isSelected}
        level={level}
        onSelect={onSelectLayer}
        onToggleVisibility={onToggleVisibility}
        onToggleLock={onToggleLock}
        onRename={onRenameLayer}
        onDelete={onDelete}
        isExpanded={isExpanded}
        onToggleExpand={
          layer.type === 'group' ? () => toggleGroupExpand(layer.id) : undefined
        }
        themed={!!collabTheme}
      >
        {layer.children?.map((child) => renderLayer(child, level + 1))}
      </LayerItem>
    )
  }

  const togglePanelState = () => {
    if (panelState === 'expanded') setPanelState('hidden')
    else setPanelState('expanded')
  }

  if (panelState === 'hidden') {
    // Floating toggle button when hidden (positioned above status bar)
    return (
      <button
        onClick={togglePanelState}
        className="fixed right-4 bottom-[56px] z-30 w-10 h-10 bg-white rounded-full shadow-lg border border-gray-300 hover:bg-gray-50 flex items-center justify-center"
        title="Show layers panel"
      >
        <span className="text-lg text-gray-700">☰</span>
      </button>
    )
  }

  return (
    <div
      className="w-80 h-[calc(100%-56px)] my-2 mr-2 rounded-lg shadow-lg flex flex-col transition-all duration-200 relative overflow-hidden bg-gradient-to-br from-slate-900/95 to-slate-800/95 backdrop-blur-md"
    >
      {/* Dot pattern overlay */}
      <div 
        className="absolute inset-0" 
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>
      
      {/* Content wrapper */}
      <div className="relative z-10 flex flex-col h-full">
      {/* Header with Toggle Button */}
      <div className="flex items-center justify-between px-3 py-2.5 bg-gradient-to-r from-slate-900/95 to-slate-800/95 border-b border-white/10">
        <h3 className="text-sm font-semibold text-white/90 uppercase tracking-wider">
          Layers
        </h3>
        <button
          onClick={togglePanelState}
          className="p-1 rounded transition-colors hover:bg-white/20 text-white"
          title="Hide layers panel"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>

      {/* Tabs */}
      <div className="flex border-b border-white/20">
        <button
          className={`flex-1 px-4 py-2.5 text-sm font-medium flex items-center justify-center gap-2 transition-colors ${
            activeTab === 'layers'
              ? 'text-white border-b-2 border-white'
              : 'text-white/70 hover:text-white'
          }`}
          onClick={() => setActiveTab('layers')}
        >
          <span className="text-base">☰</span>
          Layers
        </button>
        <button
          className={`flex-1 px-4 py-2.5 text-sm font-medium flex items-center justify-center gap-2 transition-colors ${
            activeTab === 'design'
              ? 'text-white border-b-2 border-white'
              : 'text-white/70 hover:text-white'
          }`}
          onClick={() => setActiveTab('design')}
        >
          <span className="text-base">◐</span>
          Design
        </button>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto" id="layers-content">
        {activeTab === 'layers' ? (
          <div className="py-2">
            {layerTree.length === 0 ? (
              <div className="px-4 py-8 text-center text-sm text-white/60">
                No layers yet
              </div>
            ) : (
              layerTree.map((layer) => renderLayer(layer))
            )}
          </div>
        ) : (
          <div className="p-4 space-y-4 overflow-y-auto">
            {selectedShapes.length === 0 ? (
              <div className="text-center text-sm py-8 text-white/60">
                Select a shape to edit properties
              </div>
            ) : (
              <>
                {/* Text Formatting Section */}
                {isTextSelected && (
                  <div className="space-y-3 pb-4 rounded-lg p-3 bg-white/10 border-b border-white/20">
                    <h4 className="text-xs font-semibold uppercase text-white/90">Text</h4>
                    
                    {/* Font Family */}
                    <div>
                      <label className="text-xs font-medium block mb-1 text-white/90">Font</label>
                      <select
                        value={selectedShapes[0].fontFamily || 'Inter, sans-serif'}
                        onChange={(e) => onUpdateShapeProps?.(selectedShapes[0].id, {
                          fontFamily: e.target.value
                        })}
                        className="w-full px-2 py-1.5 border rounded text-xs focus:outline-none focus:ring-1 bg-white/20 border-white/30 text-white focus:ring-white/50"
                      >
                        {FONT_FAMILIES.map(font => (
                          <option key={font} value={font}>
                            {font.split(',')[0]}
                          </option>
                        ))}
                      </select>
                    </div>
                    
                    {/* Font Size */}
                    <div>
                      <div className="flex justify-between items-center mb-1">
                        <label className="text-xs font-medium text-white/90">Size</label>
                        <span className="text-xs text-white/70">{selectedShapes[0].fontSize || 20}px</span>
                      </div>
                      <input
                        type="range"
                        min="12"
                        max="72"
                        value={selectedShapes[0].fontSize || 20}
                        onChange={(e) => onUpdateShapeProps?.(selectedShapes[0].id, {
                          fontSize: parseInt(e.target.value)
                        })}
                        className="w-full"
                      />
                    </div>
                    
                    {/* Style Toggles */}
                    <div>
                      <label className="text-xs font-medium block mb-1 text-white/90">Style</label>
                      <div className="flex gap-1">
                        <button
                          onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                            fontWeight: selectedShapes[0].fontWeight === 'bold' ? 'normal' : 'bold'
                          })}
                          className={`px-2 py-1 text-xs font-bold border rounded transition-colors ${
                            selectedShapes[0].fontWeight === 'bold'
                              ? 'bg-blue-500 text-white border-blue-500'
                              : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                          }`}
                        >
                          B
                        </button>
                        <button
                          onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                            fontStyle: selectedShapes[0].fontStyle === 'italic' ? 'normal' : 'italic'
                          })}
                          className={`px-2 py-1 text-xs italic border rounded transition-colors ${
                            selectedShapes[0].fontStyle === 'italic'
                              ? 'bg-blue-500 text-white border-blue-500'
                              : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                          }`}
                        >
                          I
                        </button>
                        <button
                          onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                            textDecoration: selectedShapes[0].textDecoration === 'underline' ? '' : 'underline'
                          })}
                          className={`px-2 py-1 text-xs underline border rounded transition-colors ${
                            selectedShapes[0].textDecoration === 'underline'
                              ? 'bg-blue-500 text-white border-blue-500'
                              : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                          }`}
                        >
                          U
                        </button>
                      </div>
                    </div>
                    
                    {/* Text Align */}
                    <div>
                      <label className="text-xs font-medium block mb-1 text-white/90">Align</label>
                      <div className="flex gap-1">
                        {(['left', 'center', 'right'] as const).map(align => (
                          <button
                            key={align}
                            onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                              textAlign: align
                            })}
                            className={`flex-1 px-2 py-1 text-xs border rounded transition-colors ${
                              (selectedShapes[0].textAlign || 'left') === align
                                ? 'bg-blue-500 text-white border-blue-500'
                                : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                            }`}
                          >
                            {align === 'left' ? '⬅' : align === 'center' ? '↔' : '➡'}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>
                )}

                {/* Fill Color */}
                <div className="rounded-lg p-2 bg-white/10">
                  <button
                    onClick={() => setShowFillPicker(!showFillPicker)}
                    className="w-full flex items-center justify-between p-2 rounded hover:bg-white/20 transition-colors"
                  >
                    <div className="flex items-center gap-2">
                      <div
                        className="w-5 h-5 rounded border border-white/40"
                        style={{ backgroundColor: commonFill === 'multiple' ? '#CCCCCC' : commonFill }}
                      />
                      <span className="text-xs font-medium text-white/90">Fill</span>
                    </div>
                    <svg className={`w-3 h-3 transition-transform text-white/80 ${showFillPicker ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>
                  {showFillPicker && (
                    <div className="mt-2">
                      <ColorPicker
                        value={commonFill === 'multiple' ? '#3B82F6FF' : commonFill}
                        onChange={(color) => onUpdateColors?.(color, commonStroke === 'multiple' ? '#000000FF' : commonStroke, commonStrokeWidth)}
                        label="Fill"
                        recentColors={recentColors}
                        onRequestCanvasSample={onRequestColorSample ? () => onRequestColorSample((color) => {
                          onUpdateColors?.(color, commonStroke === 'multiple' ? '#000000FF' : commonStroke, commonStrokeWidth)
                        }) : undefined}
                      />
                    </div>
                  )}
                </div>

                {/* Stroke Color */}
                <div className="rounded-lg p-2 bg-white/10">
                  <button
                    onClick={() => setShowStrokePicker(!showStrokePicker)}
                    className="w-full flex items-center justify-between p-2 rounded hover:bg-white/20 transition-colors"
                  >
                    <div className="flex items-center gap-2">
                      <div
                        className="w-5 h-5 rounded border border-white/40"
                        style={{ backgroundColor: commonStroke === 'multiple' ? '#CCCCCC' : commonStroke }}
                      />
                      <span className="text-xs font-medium text-white/90">Stroke</span>
                    </div>
                    <svg className={`w-3 h-3 transition-transform text-white/80 ${showStrokePicker ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>
                  {showStrokePicker && (
                    <div className="mt-2">
                      <ColorPicker
                        value={commonStroke === 'multiple' ? '#000000FF' : commonStroke}
                        onChange={(color) => onUpdateColors?.(commonFill === 'multiple' ? '#3B82F6FF' : commonFill, color, commonStrokeWidth)}
                        label="Stroke"
                        recentColors={recentColors}
                        onRequestCanvasSample={onRequestColorSample ? () => onRequestColorSample((color) => {
                          onUpdateColors?.(commonFill === 'multiple' ? '#3B82F6FF' : commonFill, color, commonStrokeWidth)
                        }) : undefined}
                      />
                    </div>
                  )}
                </div>

                {/* Stroke Width */}
                <div className="rounded-lg p-3 bg-white/10">
                  <div className="flex justify-between items-center mb-1">
                    <label className="text-xs font-medium text-white/90">Stroke Width</label>
                    <span className="text-xs text-white/70">{commonStrokeWidth}px</span>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="20"
                    value={commonStrokeWidth}
                    onChange={(e) => onUpdateColors?.(
                      commonFill === 'multiple' ? '#3B82F6FF' : commonFill,
                      commonStroke === 'multiple' ? '#000000FF' : commonStroke,
                      parseInt(e.target.value)
                    )}
                    className="w-full"
                  />
                </div>
              </>
            )}
          </div>
        )}
      </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/panels/PropertiesPanel.tsx">
import React, { useState } from 'react'
import { ColorPicker } from '../ui/ColorPicker'
import type { Shape } from '../../types/canvas'

/**
 * PropertiesPanel Component
 * Right sidebar panel for editing selected shape properties
 */

interface PropertiesPanelProps {
  selectedShapes: Shape[]
  onUpdateColors: (
    fill?: string,
    stroke?: string,
    strokeWidth?: number
  ) => void
  onUpdateShapeProps?: (id: string, updates: Partial<Shape>) => void
  recentColors: string[]
  onRequestColorSample?: (callback: (color: string) => void) => void // PR-24: Color sampling callback
  onClose?: () => void // Performance: Close button callback
}

export const PropertiesPanel: React.FC<PropertiesPanelProps> = ({
  selectedShapes,
  onUpdateColors,
  onUpdateShapeProps,
  recentColors,
  onRequestColorSample,
  onClose,
}) => {
  const [showFillPicker, setShowFillPicker] = useState(false)
  const [showStrokePicker, setShowStrokePicker] = useState(false)

  if (selectedShapes.length === 0) {
    return null
  }

  // Get common values or "Multiple" indicator
  const getCommonValue = <T,>(
    getValue: (shape: Shape) => T | undefined
  ): T | 'multiple' | undefined => {
    const values = selectedShapes.map(getValue)
    const firstValue = values[0]

    // Check if all values are the same
    const allSame = values.every(
      (val) => JSON.stringify(val) === JSON.stringify(firstValue)
    )

    return allSame ? firstValue : 'multiple'
  }

  const commonFill = getCommonValue((s) => s.fill)
  const commonStroke = getCommonValue((s) => s.stroke)
  const commonStrokeWidth = getCommonValue((s) => s.strokeWidth || 0)

  const handleFillChange = (color: string) => {
    onUpdateColors(color, undefined, undefined)
  }

  const handleStrokeChange = (color: string) => {
    onUpdateColors(undefined, color, undefined)
  }

  const handleStrokeWidthChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const width = parseInt(e.target.value)
    onUpdateColors(undefined, undefined, width)
  }

  const handleRemoveStroke = () => {
    onUpdateColors(undefined, undefined, 0)
  }

  // Check if text shape is selected (PR-25)
  const isTextSelected = selectedShapes.length === 1 && selectedShapes[0].type === 'text'
  
  // Font family options
  const FONT_FAMILIES = [
    'Inter, sans-serif',
    'Arial, sans-serif',
    'Georgia, serif',
    'Courier New, monospace',
    'Comic Sans MS, cursive',
    'Impact, fantasy',
  ]

  return (
    <div className="absolute right-0 top-0 h-full w-64 bg-white border-l border-gray-200 shadow-lg overflow-y-auto z-10">
      <div className="p-4 space-y-6">
        {/* Header with Close Button */}
        <div className="border-b pb-2 flex justify-between items-start">
          <div>
            <h3 className="text-sm font-semibold text-purple-700 flex items-center gap-2">
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
              </svg>
              Design Properties
            </h3>
            <p className="text-xs text-gray-500 mt-1">
              {selectedShapes.length === 1
                ? '1 shape selected'
                : `${selectedShapes.length} shapes selected`}
            </p>
          </div>
          {onClose && (
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors p-1 hover:bg-gray-100 rounded"
              title="Close design panel (Esc)"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>

        {/* Text Formatting Section (PR-25) */}
        {isTextSelected && (
          <div className="space-y-4 pb-4 border-b">
            <h4 className="text-xs font-semibold text-gray-500 uppercase">Text Formatting</h4>
            
            {/* Font Family */}
            <div>
              <label className="text-sm font-medium text-gray-700 block mb-1">
                Font Family
              </label>
              <select
                value={selectedShapes[0].fontFamily || 'Inter, sans-serif'}
                onChange={(e) => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                  fontFamily: e.target.value
                })}
                className="w-full px-2 py-1 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
              >
                {FONT_FAMILIES.map(font => (
                  <option key={font} value={font} style={{ fontFamily: font }}>
                    {font.split(',')[0]}
                  </option>
                ))}
              </select>
            </div>
            
            {/* Font Size */}
            <div>
              <div className="flex justify-between items-center mb-1">
                <label className="text-sm font-medium text-gray-700">Font Size</label>
                <span className="text-xs text-gray-500">{selectedShapes[0].fontSize || 20}px</span>
              </div>
              <input
                type="range"
                min="12"
                max="72"
                step="1"
                value={selectedShapes[0].fontSize || 20}
                onChange={(e) => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                  fontSize: parseInt(e.target.value)
                })}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>12px</span>
                <span>72px</span>
              </div>
            </div>
            
            {/* Style Toggles */}
            <div>
              <label className="text-sm font-medium text-gray-700 block mb-1">Style</label>
              <div className="flex gap-1">
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    fontWeight: selectedShapes[0].fontWeight === 'bold' ? 'normal' : 'bold'
                  })}
                  className={`px-3 py-1 font-bold border rounded text-sm ${
                    selectedShapes[0].fontWeight === 'bold'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Bold"
                >
                  B
                </button>
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    fontStyle: selectedShapes[0].fontStyle === 'italic' ? 'normal' : 'italic'
                  })}
                  className={`px-3 py-1 italic border rounded text-sm ${
                    selectedShapes[0].fontStyle === 'italic'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Italic"
                >
                  I
                </button>
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    textDecoration: selectedShapes[0].textDecoration === 'underline' ? '' : 'underline'
                  })}
                  className={`px-3 py-1 underline border rounded text-sm ${
                    selectedShapes[0].textDecoration === 'underline'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Underline"
                >
                  U
                </button>
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    textDecoration: selectedShapes[0].textDecoration === 'line-through' ? '' : 'line-through'
                  })}
                  className={`px-3 py-1 line-through border rounded text-sm ${
                    selectedShapes[0].textDecoration === 'line-through'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Strikethrough"
                >
                  S
                </button>
              </div>
            </div>
            
            {/* Text Align */}
            <div>
              <label className="text-sm font-medium text-gray-700 block mb-1">Align</label>
              <div className="flex gap-1">
                {['left', 'center', 'right'].map(align => (
                  <button
                    key={align}
                    onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                      textAlign: align as 'left' | 'center' | 'right'
                    })}
                    className={`flex-1 px-3 py-1 border rounded text-sm ${
                      (selectedShapes[0].textAlign || 'left') === align
                        ? 'bg-blue-500 text-white border-blue-500'
                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                    }`}
                    title={`Align ${align}`}
                  >
                    {align === 'left' ? '⬅' : align === 'center' ? '↔' : '➡'}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Fill Color */}
        <div>
          <button
            onClick={() => setShowFillPicker(!showFillPicker)}
            className="w-full flex items-center justify-between p-2 rounded hover:bg-gray-50 transition-colors"
          >
            <div className="flex items-center gap-2">
              <div
                className="w-6 h-6 rounded border-2 border-gray-300"
                style={{
                  backgroundColor:
                    commonFill === 'multiple' ? '#CCCCCC' : commonFill,
                  backgroundImage:
                    commonFill === 'multiple'
                      ? 'repeating-linear-gradient(45deg, #999 0, #999 2px, #CCC 2px, #CCC 4px)'
                      : undefined,
                }}
              />
              <span className="text-sm font-medium text-gray-700">
                {commonFill === 'multiple' ? 'Fill (Multiple)' : 'Fill'}
              </span>
            </div>
            <svg
              className={`w-4 h-4 text-gray-500 transition-transform ${
                showFillPicker ? 'rotate-180' : ''
              }`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>

          {showFillPicker && (
            <div className="mt-2 p-3 bg-gray-50 rounded">
              <ColorPicker
                value={
                  commonFill === 'multiple' ? '#3B82F6FF' : (commonFill as string)
                }
                onChange={handleFillChange}
                label=""
                recentColors={recentColors}
                showOpacity={true}
                onRequestCanvasSample={
                  onRequestColorSample
                    ? () => onRequestColorSample(handleFillChange)
                    : undefined
                }
              />
            </div>
          )}
        </div>

        {/* Stroke Color */}
        <div>
          <button
            onClick={() => setShowStrokePicker(!showStrokePicker)}
            className="w-full flex items-center justify-between p-2 rounded hover:bg-gray-50 transition-colors"
          >
            <div className="flex items-center gap-2">
              <div
                className="w-6 h-6 rounded border-2 border-gray-300"
                style={{
                  backgroundColor:
                    commonStroke === 'multiple'
                      ? '#CCCCCC'
                      : commonStroke || 'transparent',
                  backgroundImage:
                    commonStroke === 'multiple'
                      ? 'repeating-linear-gradient(45deg, #999 0, #999 2px, #CCC 2px, #CCC 4px)'
                      : !commonStroke
                      ? 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)'
                      : undefined,
                  backgroundSize: '10px 10px',
                  backgroundPosition: '0 0, 0 5px, 5px -5px, -5px 0px',
                }}
              />
              <span className="text-sm font-medium text-gray-700">
                {commonStroke === 'multiple' ? 'Stroke (Multiple)' : 'Stroke'}
              </span>
            </div>
            <svg
              className={`w-4 h-4 text-gray-500 transition-transform ${
                showStrokePicker ? 'rotate-180' : ''
              }`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>

          {showStrokePicker && (
            <div className="mt-2 p-3 bg-gray-50 rounded">
              <ColorPicker
                value={
                  commonStroke === 'multiple'
                    ? '#000000FF'
                    : (commonStroke as string) || '#000000FF'
                }
                onChange={handleStrokeChange}
                label=""
                recentColors={recentColors}
                showOpacity={true}
                onRequestCanvasSample={
                  onRequestColorSample
                    ? () => onRequestColorSample(handleStrokeChange)
                    : undefined
                }
              />
              {commonStroke && commonStroke !== 'multiple' && (
                <button
                  onClick={handleRemoveStroke}
                  className="mt-2 w-full px-3 py-1 text-xs bg-red-50 text-red-600 rounded hover:bg-red-100 transition-colors"
                >
                  Remove Stroke
                </button>
              )}
            </div>
          )}
        </div>

        {/* Stroke Width */}
        {(commonStroke || commonStroke === 'multiple') && (
          <div>
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-medium text-gray-700">
                Stroke Width
              </span>
              <span className="text-xs text-gray-500">
                {commonStrokeWidth === 'multiple'
                  ? 'Multiple'
                  : `${commonStrokeWidth}px`}
              </span>
            </div>
            <input
              type="range"
              min="0"
              max="20"
              step="1"
              value={
                commonStrokeWidth === 'multiple' ? 2 : (commonStrokeWidth as number)
              }
              onChange={handleStrokeWidthChange}
              className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-1">
              <span>0px</span>
              <span>20px</span>
            </div>
          </div>
        )}

        {/* Shape-Specific Controls (PR-16) */}
        {selectedShapes.length === 1 && onUpdateShapeProps && (
          <>
            {/* Line: Arrow Controls */}
            {selectedShapes[0].type === 'line' && selectedShapes[0].arrows && (
              <div className="pt-4 border-t">
                <h4 className="text-sm font-semibold text-gray-800 mb-3">
                  Arrows
                </h4>
                <div className="space-y-2">
                  <label className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      checked={selectedShapes[0].arrows.start || false}
                      onChange={(e) =>
                        onUpdateShapeProps(selectedShapes[0].id, {
                          arrows: {
                            ...selectedShapes[0].arrows,
                            start: e.target.checked,
                          },
                        })
                      }
                      className="rounded border-gray-300"
                    />
                    <span className="text-sm text-gray-700">Start Arrow</span>
                  </label>
                  <label className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      checked={selectedShapes[0].arrows.end || false}
                      onChange={(e) =>
                        onUpdateShapeProps(selectedShapes[0].id, {
                          arrows: {
                            ...selectedShapes[0].arrows,
                            end: e.target.checked,
                          },
                        })
                      }
                      className="rounded border-gray-300"
                    />
                    <span className="text-sm text-gray-700">End Arrow</span>
                  </label>
                </div>
              </div>
            )}

            {/* Polygon: Sides Control */}
            {selectedShapes[0].type === 'polygon' && selectedShapes[0].sides !== undefined && (
              <div className="pt-4 border-t">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-semibold text-gray-800">
                    Sides
                  </span>
                  <span className="text-xs text-gray-500">
                    {selectedShapes[0].sides}
                  </span>
                </div>
                <input
                  type="range"
                  min="3"
                  max="12"
                  step="1"
                  value={selectedShapes[0].sides}
                  onChange={(e) =>
                    onUpdateShapeProps(selectedShapes[0].id, {
                      sides: parseInt(e.target.value),
                    })
                  }
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>3</span>
                  <span>12</span>
                </div>
              </div>
            )}

            {/* Star: Points Control */}
            {selectedShapes[0].type === 'star' && selectedShapes[0].sides !== undefined && (
              <div className="pt-4 border-t">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-semibold text-gray-800">
                    Points
                  </span>
                  <span className="text-xs text-gray-500">
                    {selectedShapes[0].sides}
                  </span>
                </div>
                <input
                  type="range"
                  min="3"
                  max="12"
                  step="1"
                  value={selectedShapes[0].sides}
                  onChange={(e) =>
                    onUpdateShapeProps(selectedShapes[0].id, {
                      sides: parseInt(e.target.value),
                    })
                  }
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>3</span>
                  <span>12</span>
                </div>
              </div>
            )}

            {/* Rounded Rectangle: Corner Radius Control */}
            {selectedShapes[0].type === 'roundRect' && selectedShapes[0].cornerRadius !== undefined && (
              <div className="pt-4 border-t">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-semibold text-gray-800">
                    Corner Radius
                  </span>
                  <span className="text-xs text-gray-500">
                    {selectedShapes[0].cornerRadius}px
                  </span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="50"
                  step="1"
                  value={selectedShapes[0].cornerRadius}
                  onChange={(e) =>
                    onUpdateShapeProps(selectedShapes[0].id, {
                      cornerRadius: parseInt(e.target.value),
                    })
                  }
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>0px</span>
                  <span>50px</span>
                </div>
              </div>
            )}
          </>
        )}

        {/* Shape Info */}
        <div className="pt-4 border-t">
          <div className="text-xs text-gray-500 space-y-1">
            {selectedShapes.length === 1 && (
              <>
                <div className="flex justify-between">
                  <span>Type:</span>
                  <span className="font-medium text-gray-700 capitalize">
                    {selectedShapes[0].type}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Size:</span>
                  <span className="font-medium text-gray-700">
                    {Math.round(selectedShapes[0].width)} ×{' '}
                    {Math.round(selectedShapes[0].height)}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Position:</span>
                  <span className="font-medium text-gray-700">
                    {Math.round(selectedShapes[0].x)},{' '}
                    {Math.round(selectedShapes[0].y)}
                  </span>
                </div>
                {selectedShapes[0].rotation && (
                  <div className="flex justify-between">
                    <span>Rotation:</span>
                    <span className="font-medium text-gray-700">
                      {Math.round(selectedShapes[0].rotation)}°
                    </span>
                  </div>
                )}
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/panels/TilePalette.tsx">
/**
 * TilePalette Component
 * Left-side panel for selecting tiles, modes, and tile size
 * Reuses Toolbar styling for consistency
 */

import { useEffect, useState } from 'react'
import type { TileMode, PaletteColor } from '../../types/tilemap'
import { hasSpriteAsset, getTilePath } from '../../constants/tilemapDefaults'

interface TilePaletteProps {
  palette: PaletteColor[]
  selectedIndex: number
  onSelectIndex: (index: number) => void
  selectedVariant?: number
  onVariantChange?: (variant: number) => void
  plainColor?: string
  onPlainColorChange?: (color: string) => void
  autoTilingEnabled?: boolean
  onToggleAutoTiling?: () => void
  brushSize?: number
  onBrushSizeChange?: (size: number) => void
  mode: TileMode
  onModeChange: (mode: TileMode) => void
  tileCount: number
  cursorPosition?: { x: number; y: number }
  showGrid?: boolean
  onToggleGrid?: () => void
}

/**
 * Tile palette panel - Figma-style vertical panel
 * Shows palette colors, drawing modes, and tile size selector
 */
export default function TilePalette({
  palette,
  selectedIndex,
  onSelectIndex,
  selectedVariant = 0,
  onVariantChange,
  plainColor = '#ffffff',
  onPlainColorChange,
  autoTilingEnabled = true,
  onToggleAutoTiling,
  brushSize = 1,
  onBrushSizeChange,
  mode,
  onModeChange,
  tileCount,
  cursorPosition,
  showGrid = true,
  onToggleGrid,
}: TilePaletteProps) {
  const [isExpanded, setIsExpanded] = useState(false)
  const [variantPopupTile, setVariantPopupTile] = useState<number | null>(null)
  const [backdropActive, setBackdropActive] = useState(false)
  const selectedTile = palette[selectedIndex]
  const isPlainTile = selectedTile?.type === 'plain'
  const hasSprite = selectedTile && hasSpriteAsset(selectedTile.type)
  
  // Activate backdrop after a brief delay to prevent immediate closure
  useEffect(() => {
    if (variantPopupTile !== null) {
      const timer = setTimeout(() => setBackdropActive(true), 100)
      return () => clearTimeout(timer)
    } else {
      setBackdropActive(false)
    }
  }, [variantPopupTile])
  // Keyboard shortcuts for palette selection (1-9)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Check if typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return
      }
      
      // Number keys 1-9 for palette selection
      const key = parseInt(e.key)
      if (key >= 1 && key <= Math.min(9, palette.length)) {
        onSelectIndex(key - 1)
        e.preventDefault()
      }
      
      // Mode shortcuts
      switch (e.key.toLowerCase()) {
        case 'b':
          onModeChange('stamp')
          e.preventDefault()
          break
        case 'e':
          onModeChange('erase')
          e.preventDefault()
          break
        case 'f':
          onModeChange('fill')
          e.preventDefault()
          break
        case 'i':
          onModeChange('pick')
          e.preventDefault()
          break
      }
    }
    
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [palette.length, onSelectIndex, onModeChange])
  
  const modes: Array<{
    mode: TileMode
    iconPath?: string
    icon?: string
    label: string
    shortcut: string
  }> = [
    { 
      mode: 'stamp', 
      iconPath: '/assets/paint-brush-32.png',
      label: 'Paint', 
      shortcut: 'B' 
    },
    { 
      mode: 'erase', 
      iconPath: '/assets/eraser-32.png',
      label: 'Erase', 
      shortcut: 'E' 
    },
    { 
      mode: 'fill', 
      iconPath: '/assets/paint-bucket-32.png',
      label: 'Fill', 
      shortcut: 'F' 
    },
    { 
      mode: 'pick', 
      iconPath: '/assets/eyedropper-32.png',
      label: 'Eyedropper', 
      shortcut: 'I' 
    },
  ]
  
  return (
    <>
    <div 
      className="shadow-lg flex flex-col absolute z-50 rounded-lg transition-all duration-300 ease-in-out overflow-hidden bg-gradient-to-br from-slate-900/95 to-slate-800/95 backdrop-blur-md"
      style={{
        width: isExpanded ? '206px' : '60px',
        left: '8px',
        top: '8px',
        bottom: '48px', // 40px footer + 8px margin
      }}
      onMouseEnter={() => setIsExpanded(true)}
      onMouseLeave={() => setIsExpanded(false)}
    >
      {/* Dot pattern overlay */}
      <div 
        className="absolute inset-0 pointer-events-none" 
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>

      {/* Content */}
      <div className={`relative z-10 flex flex-col h-full overflow-y-auto overflow-x-hidden tilemap-panel-scroll ${isExpanded ? 'p-1.75 gap-1.75' : 'p-1.75 gap-1.75'}`}>
        {/* Header */}
        {isExpanded && (
          <div className="text-white/90 font-bold text-[14px] flex-shrink-0 uppercase tracking-wider px-2 py-1.5 rounded bg-gradient-to-r from-slate-900/95 to-slate-800/95 border border-white/10">
            Tilemap
        </div>
        )}
        
        {/* Mode Buttons */}
        <div className="flex flex-col gap-0.5 flex-shrink-0">
          {isExpanded && (
            <div className="text-white/90 text-[8px] uppercase tracking-wider font-semibold px-2 py-1 rounded bg-gradient-to-r from-slate-900/95 to-slate-800/95 border border-white/10">Mode</div>
          )}
          <div className="flex flex-col gap-0.5">
            {modes.map((modeOption) => (
              <button
                key={modeOption.mode}
                onClick={() => onModeChange(modeOption.mode)}
                className={`
                  rounded transition-all flex items-center gap-2
                  ${mode === modeOption.mode
                    ? 'bg-white/30 text-white shadow-lg'
                    : 'bg-white/5 text-white/60 hover:bg-white/15 hover:text-white'
                  }
                  ${isExpanded ? 'justify-start p-1.5' : 'justify-center p-1.5'}
                `}
                      title={`${modeOption.label} (${modeOption.shortcut})`}
                    >
                      {modeOption.iconPath ? (
                        <img 
                          src={modeOption.iconPath} 
                          alt={modeOption.label}
                          className="flex-shrink-0 w-4 h-4"
                          style={{ filter: mode === modeOption.mode ? 'brightness(1)' : 'brightness(0.7)' }}
                        />
                      ) : (
                        <span className="flex-shrink-0 text-base leading-none">{modeOption.icon}</span>
                      )}
                      {isExpanded && <span className="text-[10px] font-medium">{modeOption.label}</span>}
              </button>
            ))}
          </div>
        </div>
        
        {/* Brush Size Control */}
        {onBrushSizeChange && (
          <div className="flex flex-col gap-0.5 flex-shrink-0">
            {isExpanded && (
              <div className="text-white/90 text-[8px] uppercase tracking-wider font-semibold px-2 py-1 rounded bg-gradient-to-r from-slate-900/95 to-slate-800/95 border border-white/10">Brush</div>
            )}
            {isExpanded ? (
              <div className="flex flex-col gap-0.5">
                <input
                  type="range"
                  min="1"
                  max="5"
                  step="1"
                  value={brushSize}
                  onChange={(e) => onBrushSizeChange(Number(e.target.value))}
                  className="w-full cursor-pointer brush-slider"
                  style={{
                    background: `linear-gradient(to right, white 0%, white ${((brushSize - 1) / 4) * 100}%, rgba(255,255,255,0.2) ${((brushSize - 1) / 4) * 100}%, rgba(255,255,255,0.2) 100%)`
                  }}
                />
                <div className="text-white/70 text-[9px] text-center font-mono">{brushSize}×{brushSize}</div>
              </div>
            ) : (
              <div className="text-white/90 text-[9px] text-center font-mono bg-white/5 py-1 rounded">
                {brushSize}
          </div>
            )}
        </div>
        )}
        
                {/* Grid Toggle */}
                {onToggleGrid && (
                  <button
                    onClick={onToggleGrid}
                    className={`
                      rounded transition-all flex items-center gap-2 p-1.5
                      ${showGrid
                        ? 'bg-white/30 text-white shadow-md'
                        : 'bg-white/5 text-white/60 hover:bg-white/15'
                      }
                      ${isExpanded ? 'justify-start' : 'justify-center'}
                    `}
                    title="Toggle Grid (G)"
                  >
                    <span className="flex-shrink-0 text-base leading-none">#</span>
                    {isExpanded && <span className="text-[10px] font-medium">Grid</span>}
                  </button>
                )}
        
        {/* Palette Tiles */}
        <div className={`flex flex-col flex-shrink-0 ${isExpanded ? 'gap-1' : 'gap-0.5'}`}>
          {isExpanded && (
            <div className="text-white/90 text-[8px] uppercase tracking-wider font-semibold px-2 py-1 rounded bg-gradient-to-r from-slate-900/95 to-slate-800/95 border border-white/10">
              Tiles
          </div>
        )}
          <div className={`flex flex-col ${isExpanded ? 'gap-1' : 'gap-0.5'}`}>
            {palette.map((paletteColor, index) => {
              const hasSprite = hasSpriteAsset(paletteColor.type)
              const tilePath = hasSprite ? getTilePath(paletteColor.type, 4) : null // Use variant 4 (center) for preview
              const isPlain = paletteColor.type === 'plain'
              
              return (
                <button
                  key={index}
                  onClick={(e) => {
                    e.stopPropagation() // Prevent click from bubbling to backdrop
                    onSelectIndex(index)
                    // Show variant popup if auto-tiling is off and this is a sprite tile
                    if (!autoTilingEnabled && hasSpriteAsset(paletteColor.type)) {
                      setVariantPopupTile(index)
                    }
                  }}
                  className={`
                    rounded transition-all relative overflow-hidden flex items-center gap-2
                    ${selectedIndex === index
                      ? 'ring-2 ring-white/60 bg-white/25 shadow-md'
                      : 'ring-1 ring-white/10 hover:ring-white/30 hover:bg-white/10'
                    }
                    ${isExpanded ? 'p-1.5' : 'p-1 justify-center'}
                  `}
                  title={`${paletteColor.name}${index < 9 ? ` (${index + 1})` : ''}`}
                >
                  {/* Tile Preview */}
                  <div 
                    className={`rounded flex-shrink-0 overflow-hidden flex items-center justify-center ${isExpanded ? 'w-6 h-6' : 'w-5 h-5'}`}
                    style={{ 
                      backgroundColor: isPlain ? (index === selectedIndex ? plainColor : paletteColor.color) : '#2a2a2a',
                      border: '1px solid rgba(255,255,255,0.2)'
                    }}
                  >
                    {hasSprite && tilePath ? (
                      <img
                        src={tilePath}
                        alt={paletteColor.name}
                        style={{
                          width: '100%',
                          height: '100%',
                          objectFit: 'contain',
                          imageRendering: 'pixelated',
                        }}
                      />
                    ) : null}
                  </div>
                  
                  {isExpanded && (
                    <>
                      {/* Tile name */}
                      <span className="text-white/90 text-[10px] font-medium flex-1 text-left">
                        {paletteColor.name}
                      </span>
                      
                      {/* Keyboard shortcut */}
                {index < 9 && (
                        <span className="text-[8px] font-mono text-white/40">
                    {index + 1}
                        </span>
                      )}
                    </>
                )}
              </button>
              )
            })}
          </div>
        </div>
        
        {/* Color Picker for Plain Tile */}
        {isPlainTile && isExpanded && (
          <div className="flex flex-col gap-1 flex-shrink-0">
            <div className="text-white/90 text-[8px] uppercase tracking-wider font-semibold px-2 py-1 rounded bg-gradient-to-r from-slate-900/95 to-slate-800/95 border border-white/10">
              Color
            </div>
            <input
              type="color"
              value={plainColor}
              onChange={(e) => onPlainColorChange?.(e.target.value)}
              className="w-full h-8 rounded cursor-pointer border border-white/20"
            />
            </div>
          )}
        
                {/* Auto-Tiling Toggle (only show for sprite tiles) */}
                {hasSprite && onToggleAutoTiling && (
                  <button
                    onClick={onToggleAutoTiling}
                    className={`
                      rounded transition-all flex items-center gap-2 p-1.5
                      ${autoTilingEnabled
                        ? 'bg-white/30 text-white shadow-md'
                        : 'bg-white/5 text-white/60 hover:bg-white/15'
                      }
                      ${isExpanded ? 'justify-start' : 'justify-center'}
                    `}
                    title="Toggle Auto-Tiling (A)"
                  >
                    <span className="flex-shrink-0 text-base leading-none">⚡</span>
                    {isExpanded && <span className="text-[10px] font-medium">Auto-Tile</span>}
                  </button>
                )}
        
        {/* Variant info (only show when auto-tiling is OFF) - removed in favor of popup */}
        
        {/* Status Info (only show when expanded) */}
        {isExpanded && (
          <div className="flex flex-col gap-1 text-[8px] flex-shrink-0 mt-auto pt-2 border-t border-white/10">
            {cursorPosition && (
              <div className="flex justify-between text-white/50 px-1">
                <span className="font-semibold">Position</span>
                <span className="font-mono text-white/80">
                  {cursorPosition.x},{cursorPosition.y}
                </span>
              </div>
            )}
            <div className="flex justify-between text-white/50 px-1">
              <span className="font-semibold">Tiles</span>
              <span className="font-mono text-white/80">{tileCount}</span>
            </div>
          </div>
        )}
      </div>
    </div>

    {/* Horizontal Variant Popup (shows when clicking a tile with auto-tiling off) */}
    {variantPopupTile !== null && !autoTilingEnabled && (
      <>
        {/* Backdrop to close popup */}
        <div 
          className="fixed inset-0 z-40" 
          onClick={() => {
            if (backdropActive) {
              setVariantPopupTile(null)
            }
          }}
        />
        
        {/* Variant selector popup - positioned relative to the toolbar */}
        <div 
          className="absolute z-50 bg-gradient-to-br from-slate-700 to-slate-800 rounded-xl shadow-2xl p-2 border border-white/20"
          onClick={(e) => e.stopPropagation()}
          style={{
            left: isExpanded ? '234px' : '88px', // Position to the right of toolbar (8px + width + 8px margin)
            top: '50%',
            transform: 'translateY(-50%)',
            backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
            backgroundSize: '16px 16px'
          }}
        >
            <div className="text-white/90 text-[10px] font-semibold mb-2 px-1">
              {palette[variantPopupTile]?.name} Variants
            </div>
            <div className="flex gap-1">
              {Array.from({ length: 9 }, (_, variant) => {
                const tilePath = getTilePath(palette[variantPopupTile].type, variant)
                
                return (
                  <button
                    key={variant}
                    onClick={() => {
                      onVariantChange?.(variant)
                      setVariantPopupTile(null)
                    }}
                    className={`
                      w-10 h-10 rounded-lg transition-all relative overflow-hidden flex items-center justify-center
                      ${selectedVariant === variant
                        ? 'ring-2 ring-white/70 bg-white/30 shadow-lg'
                        : 'ring-1 ring-white/20 hover:ring-white/50 hover:bg-white/15'
                      }
                    `}
                    style={{ 
                      backgroundColor: selectedVariant === variant ? undefined : '#2a2a2a',
                      padding: '2px',
                    }}
                    title={`Variant ${variant + 1}`}
                  >
                    <img
                      src={tilePath}
                      alt={`Variant ${variant + 1}`}
                      style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain',
                        imageRendering: 'pixelated',
                      }}
                    />
                    <div className="absolute bottom-0 right-0 text-[7px] font-mono bg-black/80 text-white px-1 leading-none rounded-tl">
                      {variant + 1}
                    </div>
                  </button>
                )
              })}
            </div>
          </div>
        </>
      )}
    </>
  )
}
</file>

<file path="src/components/physics/CollisionEditor.tsx">
/**
 * Collision Shape Editor
 * Allows users to define collision shapes for game objects
 * PR-31: Physics Preview System
 */

import React, { useState, useEffect } from 'react'
import { Circle, Rect, Line } from 'react-konva'
import type Konva from 'konva'

export type CollisionShapeType = 'box' | 'circle' | 'polygon'

export interface CollisionShape {
  type: CollisionShapeType
  x: number // offset from sprite center
  y: number // offset from sprite center
  width?: number // for box
  height?: number // for box
  radius?: number // for circle
  points?: number[] // for polygon [x1, y1, x2, y2, ...]
}

interface CollisionEditorProps {
  shapeId: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  collision?: CollisionShape
  visible: boolean
  onUpdate: (collision: CollisionShape) => void
}

/**
 * CollisionEditor component
 * Visual editor for defining collision shapes on sprites
 */
export default function CollisionEditor({
  shapeId: _shapeId,
  x,
  y,
  width,
  height,
  rotation = 0,
  collision,
  visible,
  onUpdate,
}: CollisionEditorProps) {
  const [editMode, setEditMode] = useState<CollisionShapeType>('box')
  const [localCollision, setLocalCollision] = useState<CollisionShape>(
    collision || {
      type: 'box',
      x: 0,
      y: 0,
      width,
      height,
    }
  )

  useEffect(() => {
    if (collision) {
      setLocalCollision(collision)
      setEditMode(collision.type)
    }
  }, [collision])

  if (!visible) return null

  const handleDragMove = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    const updated: CollisionShape = {
      ...localCollision,
      x: node.x() - x,
      y: node.y() - y,
    }
    setLocalCollision(updated)
  }

  const handleDragEnd = () => {
    onUpdate(localCollision)
  }

  const handleTransform = (e: Konva.KonvaEventObject<Event>) => {
    const node = e.target as any
    
    if (localCollision.type === 'box') {
      const updated: CollisionShape = {
        ...localCollision,
        width: Math.abs(node.width() * node.scaleX()),
        height: Math.abs(node.height() * node.scaleY()),
      }
      setLocalCollision(updated)
      onUpdate(updated)
      
      // Reset scale
      node.scaleX(1)
      node.scaleY(1)
    } else if (localCollision.type === 'circle') {
      const updated: CollisionShape = {
        ...localCollision,
        radius: Math.abs(node.radius() * node.scaleX()),
      }
      setLocalCollision(updated)
      onUpdate(updated)
      
      // Reset scale
      node.scaleX(1)
      node.scaleY(1)
    }
  }

  // Render collision shape based on type
  if (localCollision.type === 'box') {
    return (
      <Rect
        x={x + (localCollision.x || 0)}
        y={y + (localCollision.y || 0)}
        width={localCollision.width || width}
        height={localCollision.height || height}
        rotation={rotation}
        stroke="#10b981" // green
        strokeWidth={2}
        dash={[5, 5]}
        fill="rgba(16, 185, 129, 0.1)"
        draggable
        onDragMove={handleDragMove}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransform}
      />
    )
  }

  if (localCollision.type === 'circle') {
    const radius = localCollision.radius || Math.min(width, height) / 2
    return (
      <Circle
        x={x + (localCollision.x || 0)}
        y={y + (localCollision.y || 0)}
        radius={radius}
        stroke="#10b981" // green
        strokeWidth={2}
        dash={[5, 5]}
        fill="rgba(16, 185, 129, 0.1)"
        draggable
        onDragMove={handleDragMove}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransform}
      />
    )
  }

  if (localCollision.type === 'polygon' && localCollision.points) {
    // Render polygon as series of lines
    const points = localCollision.points
    const lines: React.ReactElement[] = []
    
    for (let i = 0; i < points.length; i += 2) {
      const nextIndex = (i + 2) % points.length
      lines.push(
        <Line
          key={i}
          points={[
            x + points[i],
            y + points[i + 1],
            x + points[nextIndex],
            y + points[nextIndex + 1],
          ]}
          stroke="#10b981"
          strokeWidth={2}
          dash={[5, 5]}
        />
      )
    }
    
    return <>{lines}</>
  }

  return null
}
</file>

<file path="src/components/physics/PhysicsPanel.tsx">
/**
 * Physics Properties Panel
 * Configure physics properties for game objects
 * PR-31: Physics Preview System
 */

import { useState } from 'react'

export type BodyType = 'static' | 'dynamic' | 'kinematic'

export interface PhysicsProperties {
  enabled: boolean
  bodyType: BodyType
  mass: number
  friction: number
  bounce: number // restitution
  gravityScale: number
}

interface PhysicsPanelProps {
  shapeId: string | null
  properties?: PhysicsProperties
  onUpdate: (properties: PhysicsProperties) => void
}

const DEFAULT_PROPERTIES: PhysicsProperties = {
  enabled: false,
  bodyType: 'dynamic',
  mass: 1,
  friction: 0.5,
  bounce: 0.3,
  gravityScale: 1,
}

const PRESETS: Record<string, Partial<PhysicsProperties>> = {
  player: {
    bodyType: 'dynamic',
    mass: 1,
    friction: 0.8,
    bounce: 0,
    gravityScale: 1,
  },
  platform: {
    bodyType: 'static',
    mass: 0,
    friction: 0.6,
    bounce: 0,
    gravityScale: 0,
  },
  projectile: {
    bodyType: 'dynamic',
    mass: 0.1,
    friction: 0,
    bounce: 0.8,
    gravityScale: 0.5,
  },
}

/**
 * PhysicsPanel component
 * Allows configuration of physics properties for selected shapes
 */
export default function PhysicsPanel({
  shapeId,
  properties = DEFAULT_PROPERTIES,
  onUpdate,
}: PhysicsPanelProps) {
  const [localProps, setLocalProps] = useState<PhysicsProperties>(properties)

  if (!shapeId) {
    return (
      <div className="p-4 text-center text-gray-500">
        <p className="text-sm">Select an object to edit physics properties</p>
      </div>
    )
  }

  const handleChange = (updates: Partial<PhysicsProperties>) => {
    const updated = { ...localProps, ...updates }
    setLocalProps(updated)
    onUpdate(updated)
  }

  const applyPreset = (presetName: keyof typeof PRESETS) => {
    const preset = PRESETS[presetName]
    handleChange({ ...preset, enabled: true })
  }

  return (
    <div className="p-4 space-y-4">
      <h3 className="font-semibold text-gray-800 text-sm uppercase tracking-wide">
        Physics Properties
      </h3>

      {/* Enable Toggle */}
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium text-gray-700">
          Enable Physics
        </label>
        <button
          onClick={() => handleChange({ enabled: !localProps.enabled })}
          className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
            localProps.enabled ? 'bg-blue-600' : 'bg-gray-300'
          }`}
        >
          <span
            className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
              localProps.enabled ? 'translate-x-6' : 'translate-x-1'
            }`}
          />
        </button>
      </div>

      {localProps.enabled && (
        <>
          {/* Presets */}
          <div className="space-y-2">
            <label className="block text-sm font-medium text-gray-700">
              Presets
            </label>
            <div className="grid grid-cols-3 gap-2">
              <button
                onClick={() => applyPreset('player')}
                className="px-3 py-2 text-xs bg-blue-50 hover:bg-blue-100 text-blue-700 rounded border border-blue-200"
              >
                Player
              </button>
              <button
                onClick={() => applyPreset('platform')}
                className="px-3 py-2 text-xs bg-gray-50 hover:bg-gray-100 text-gray-700 rounded border border-gray-200"
              >
                Platform
              </button>
              <button
                onClick={() => applyPreset('projectile')}
                className="px-3 py-2 text-xs bg-orange-50 hover:bg-orange-100 text-orange-700 rounded border border-orange-200"
              >
                Projectile
              </button>
            </div>
          </div>

          {/* Body Type */}
          <div className="space-y-2">
            <label className="block text-sm font-medium text-gray-700">
              Body Type
            </label>
            <select
              value={localProps.bodyType}
              onChange={(e) => handleChange({ bodyType: e.target.value as BodyType })}
              className="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="dynamic">Dynamic (moves with physics)</option>
              <option value="static">Static (fixed position)</option>
              <option value="kinematic">Kinematic (controlled movement)</option>
            </select>
          </div>

          {/* Mass */}
          {localProps.bodyType === 'dynamic' && (
            <div className="space-y-2">
              <div className="flex justify-between">
                <label className="text-sm font-medium text-gray-700">Mass</label>
                <span className="text-sm text-gray-500">{localProps.mass}</span>
              </div>
              <input
                type="range"
                min="0.1"
                max="10"
                step="0.1"
                value={localProps.mass}
                onChange={(e) => handleChange({ mass: parseFloat(e.target.value) })}
                className="w-full"
              />
            </div>
          )}

          {/* Friction */}
          <div className="space-y-2">
            <div className="flex justify-between">
              <label className="text-sm font-medium text-gray-700">Friction</label>
              <span className="text-sm text-gray-500">{localProps.friction.toFixed(2)}</span>
            </div>
            <input
              type="range"
              min="0"
              max="1"
              step="0.05"
              value={localProps.friction}
              onChange={(e) => handleChange({ friction: parseFloat(e.target.value) })}
              className="w-full"
            />
          </div>

          {/* Bounce (Restitution) */}
          <div className="space-y-2">
            <div className="flex justify-between">
              <label className="text-sm font-medium text-gray-700">Bounce</label>
              <span className="text-sm text-gray-500">{localProps.bounce.toFixed(2)}</span>
            </div>
            <input
              type="range"
              min="0"
              max="1"
              step="0.05"
              value={localProps.bounce}
              onChange={(e) => handleChange({ bounce: parseFloat(e.target.value) })}
              className="w-full"
            />
          </div>

          {/* Gravity Scale */}
          {localProps.bodyType === 'dynamic' && (
            <div className="space-y-2">
              <div className="flex justify-between">
                <label className="text-sm font-medium text-gray-700">Gravity Scale</label>
                <span className="text-sm text-gray-500">{localProps.gravityScale.toFixed(2)}</span>
              </div>
              <input
                type="range"
                min="0"
                max="2"
                step="0.1"
                value={localProps.gravityScale}
                onChange={(e) => handleChange({ gravityScale: parseFloat(e.target.value) })}
                className="w-full"
              />
            </div>
          )}

          {/* Info */}
          <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded text-xs text-blue-800">
            <p className="font-medium">Preview Only</p>
            <p className="mt-1">
              Physics simulation is for preview purposes. Export to your game engine for production physics.
            </p>
          </div>
        </>
      )}
    </div>
  )
}
</file>

<file path="src/components/toolbar/AlignmentToolbar.tsx">
// AlignmentToolbar Component - Toolbar for alignment and distribution (PR-18)

import type { AlignmentType } from '../../services/collaboration/alignment'

interface AlignmentToolbarProps {
  visible: boolean
  selectedCount: number
  onAlign: (type: AlignmentType) => void
  onDistributeHorizontally: () => void
  onDistributeVertically: () => void
  onCenterInCanvas: () => void
}

/**
 * Alignment toolbar component that appears when 2+ shapes are selected
 * Provides buttons for alignment and distribution operations
 */
export function AlignmentToolbar({
  visible,
  selectedCount,
  onAlign,
  onDistributeHorizontally,
  onDistributeVertically,
  onCenterInCanvas,
}: AlignmentToolbarProps) {
  if (!visible) return null

  // Distribute buttons require at least 3 shapes
  const canDistribute = selectedCount >= 3

  return (
    <div className="bg-white border-b border-gray-300 px-4 py-2 flex items-center gap-2 shadow-sm">
      <span className="text-sm text-gray-600 mr-2">
        {selectedCount} selected
      </span>

      {/* Alignment Section */}
      <div className="flex items-center gap-1 border-r border-gray-300 pr-2">
        <button
          onClick={() => onAlign('left')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Left"
        >
          <span className="font-mono">|◀</span>
        </button>
        <button
          onClick={() => onAlign('center')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Center"
        >
          <span className="font-mono">|●|</span>
        </button>
        <button
          onClick={() => onAlign('right')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Right"
        >
          <span className="font-mono">▶|</span>
        </button>
      </div>

      {/* Vertical Alignment Section */}
      <div className="flex items-center gap-1 border-r border-gray-300 pr-2">
        <button
          onClick={() => onAlign('top')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Top"
        >
          <span className="font-mono">⬆|</span>
        </button>
        <button
          onClick={() => onAlign('middle')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Middle"
        >
          <span className="font-mono">—●—</span>
        </button>
        <button
          onClick={() => onAlign('bottom')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Bottom"
        >
          <span className="font-mono">|⬇</span>
        </button>
      </div>

      {/* Distribution Section */}
      <div className="flex items-center gap-1 border-r border-gray-300 pr-2">
        <button
          onClick={onDistributeHorizontally}
          disabled={!canDistribute}
          className={`px-3 py-1.5 text-sm rounded border transition-colors ${
            canDistribute
              ? 'bg-gray-100 hover:bg-gray-200 border-gray-300'
              : 'bg-gray-50 border-gray-200 text-gray-400 cursor-not-allowed'
          }`}
          title={canDistribute ? "Distribute Horizontally" : "Requires 3+ shapes"}
        >
          <span className="font-mono">←●●●→</span>
        </button>
        <button
          onClick={onDistributeVertically}
          disabled={!canDistribute}
          className={`px-3 py-1.5 text-sm rounded border transition-colors ${
            canDistribute
              ? 'bg-gray-100 hover:bg-gray-200 border-gray-300'
              : 'bg-gray-50 border-gray-200 text-gray-400 cursor-not-allowed'
          }`}
          title={canDistribute ? "Distribute Vertically" : "Requires 3+ shapes"}
        >
          <span className="font-mono">↑●●●↓</span>
        </button>
      </div>

      {/* Center in Canvas */}
      <div className="flex items-center gap-1">
        <button
          onClick={onCenterInCanvas}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Center in Canvas"
        >
          <span className="font-mono">⊕</span>
        </button>
      </div>
    </div>
  )
}
</file>

<file path="src/components/toolbar/TilemapToolbar.tsx">
import type { TileMode } from '../../types/tilemap'
import { ToolButton } from './ToolButton'

interface TilemapToolbarProps {
  mode: TileMode
  onModeChange: (mode: TileMode) => void
  brushSize: number
  onBrushSizeChange: (size: number) => void
  autoTilingEnabled: boolean
  onToggleAutoTiling: () => void
  showGrid: boolean
  onToggleGrid: () => void
  canUndo?: boolean
  canRedo?: boolean
  onUndo?: () => void
  onRedo?: () => void
}

/**
 * TilemapToolbar - Professional Figma-style vertical toolbar for tilemap mode
 * Uses the same ToolButton components as the main canvas toolbar
 */
export default function TilemapToolbar({
  mode,
  onModeChange,
  brushSize,
  onBrushSizeChange,
  autoTilingEnabled,
  onToggleAutoTiling,
  showGrid,
  onToggleGrid,
  canUndo = false,
  canRedo = false,
  onUndo,
  onRedo,
}: TilemapToolbarProps) {
  const tools: Array<{
    mode: TileMode
    icon?: string
    iconPath?: string
    label: string
    shortcut?: string
  }> = [
    { mode: 'stamp', iconPath: '/assets/paint-brush-32.png', icon: '🖌', label: 'Paint', shortcut: 'B' },
    { mode: 'erase', iconPath: '/assets/eraser-32.png', icon: '🧹', label: 'Erase', shortcut: 'E' },
    { mode: 'fill', iconPath: '/assets/paint-bucket-32.png', icon: '🪣', label: 'Fill', shortcut: 'F' },
    { mode: 'pick', iconPath: '/assets/eyedropper-32.png', icon: '💧', label: 'Eyedropper', shortcut: 'I' },
  ]

  return (
    <div 
      className="w-12 h-[calc(100%-16px)] my-2 ml-2 rounded-lg shadow-lg flex flex-col items-center py-3 gap-1 relative overflow-hidden bg-gradient-to-br from-slate-900/95 to-slate-800/95 backdrop-blur-md"
    >
      {/* Dot pattern overlay */}
      <div 
        className="absolute inset-0" 
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>
      
      {/* Content */}
      <div className="relative z-10 w-full flex flex-col items-center gap-1">
        {/* Tilemap Mode Tools */}
        {tools.map((tool) => (
          <ToolButton
            key={tool.mode}
            icon={tool.icon}
            iconPath={tool.iconPath}
            label={tool.label}
            shortcut={tool.shortcut}
            active={mode === tool.mode}
            onClick={() => onModeChange(tool.mode)}
            themed={true}
          />
        ))}

        {/* Separator */}
        <div className="w-9 h-px my-1 bg-white/20" />

        {/* Brush Size Control */}
        <div className="flex flex-col items-center gap-1 w-full px-1.5">
          <div className="text-white/70 text-[8px] text-center font-mono">{brushSize}×{brushSize}</div>
          <input
            type="range"
            min="1"
            max="5"
            step="1"
            value={brushSize}
            onChange={(e) => onBrushSizeChange(Number(e.target.value))}
            className="w-full cursor-pointer brush-slider"
            title={`Brush Size: ${brushSize}×${brushSize}`}
            style={{
              height: '4px',
              background: `linear-gradient(to right, white 0%, white ${((brushSize - 1) / 4) * 100}%, rgba(255,255,255,0.2) ${((brushSize - 1) / 4) * 100}%, rgba(255,255,255,0.2) 100%)`
            }}
          />
        </div>

        {/* Separator */}
        <div className="w-9 h-px my-1 bg-white/20" />

        {/* Grid Toggle */}
        <ToolButton
          icon="#"
          label="Toggle Grid"
          shortcut="G"
          active={showGrid}
          onClick={onToggleGrid}
          themed={true}
        />

        {/* Auto-Tiling Toggle */}
        <ToolButton
          icon="⚡"
          label="Auto-Tiling"
          shortcut="A"
          active={autoTilingEnabled}
          onClick={onToggleAutoTiling}
          themed={true}
        />

        {/* Spacer */}
        <div className="flex-1" />

        {/* Undo/Redo */}
        {onUndo && (
          <ToolButton
            icon="↶"
            label="Undo"
            shortcut="Ctrl+Z"
            disabled={!canUndo}
            onClick={onUndo}
            themed={true}
          />
        )}

        {onRedo && (
          <ToolButton
            icon="↷"
            label="Redo"
            shortcut="Ctrl+Shift+Z"
            disabled={!canRedo}
            onClick={onRedo}
            themed={true}
          />
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/toolbar/Toolbar.tsx">
import type { ToolType } from '../../types/canvas'
import { ToolButton } from '../toolbar/ToolButton'

interface ToolbarProps {
  selectedTool: ToolType
  onToolSelect: (tool: ToolType) => void
  hasSelection: boolean
  onDelete: () => void
  // PR-14: Undo/Redo
  canUndo?: boolean
  canRedo?: boolean
  onUndo?: () => void
  onRedo?: () => void
}

/**
 * Toolbar - Professional Figma-style left vertical toolbar (PR-20)
 * 48px width, fixed position, with tooltips
 */
export default function Toolbar({
  selectedTool,
  onToolSelect,
  hasSelection,
  onDelete,
  canUndo = false,
  canRedo = false,
  onUndo,
  onRedo,
}: ToolbarProps) {
  const tools: Array<{
    type: ToolType
    icon: string
    iconPath?: string
    label: string
    shortcut?: string
  }> = [
    // Selection & Navigation Tools
    { type: 'select', icon: '➤', label: 'Select', shortcut: 'V' },
    { type: 'hand', icon: '✥', label: 'Hand', shortcut: 'H' },
    
    // Basic Shapes
    { type: 'rectangle', icon: '▭', label: 'Rectangle', shortcut: 'R' },
    { type: 'circle', icon: '●', label: 'Circle', shortcut: 'O' },
    { type: 'roundRect', icon: '▢', label: 'Rounded Rectangle' },
    
    // Advanced Shapes
    { type: 'polygon', icon: '⬡', label: 'Polygon' },
    { type: 'star', icon: '★', label: 'Star' },
    { type: 'line', icon: '/', label: 'Line', shortcut: 'L' },
    
    // Drawing Tools
    { type: 'pencil', iconPath: '/assets/paint-brush-32.png', icon: '✎', label: 'Pencil', shortcut: 'P' },
    { type: 'pen', icon: '✒', label: 'Pen', shortcut: 'N' },
    
    // Text Tool
    { type: 'text', icon: 'T', label: 'Text', shortcut: 'T' },
    
    // Animation Tool (PR-31)
    { type: 'animation', icon: '🎬', label: 'Animation', shortcut: 'A' },
  ]

  return (
    <div 
      className="w-12 h-[calc(100%-56px)] my-2 ml-2 rounded-lg shadow-lg flex flex-col items-center relative overflow-hidden bg-gradient-to-br from-slate-900/95 to-slate-800/95 backdrop-blur-md"
    >
      {/* Dot pattern overlay */}
      <div 
        className="absolute inset-0 pointer-events-none" 
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>
      
      {/* Scrollable Content */}
      <div className="relative z-10 w-full flex flex-col items-center gap-1 py-3 overflow-y-auto overflow-x-hidden toolbar-scrollable">
      {/* Tool Buttons */}
      {tools.map((tool, index) => (
        <div key={tool.type}>
          <ToolButton
            icon={tool.icon}
            iconPath={tool.iconPath}
            label={tool.label}
            shortcut={tool.shortcut}
            active={selectedTool === tool.type}
            onClick={() => onToolSelect(tool.type)}
            themed={true}
          />
          
          {/* Separators between tool groups */}
          {(index === 1 || index === 7 || index === 9 || index === 11) && (
            <div className="w-9 h-px my-1 bg-white/20" />
          )}
        </div>
      ))}

      {/* Spacer - pushes action buttons to the bottom */}
      <div className="flex-1" />

      {/* Action Buttons */}
      {onUndo && (
        <ToolButton
          icon="↶"
          label="Undo"
          shortcut="Ctrl+Z"
          disabled={!canUndo}
          onClick={onUndo}
          themed={true}
        />
      )}

      {onRedo && (
        <ToolButton
          icon="↷"
          label="Redo"
          shortcut="Ctrl+Shift+Z"
          disabled={!canRedo}
          onClick={onRedo}
          themed={true}
        />
      )}

      {/* Separator before delete */}
      <div className="w-9 h-px my-1 bg-white/20" />

      {/* Delete Button */}
      <ToolButton
        icon="🗑"
        label="Delete"
        shortcut="Del"
        disabled={!hasSelection}
        onClick={onDelete}
        themed={true}
      />
      </div>
    </div>
  )
}
</file>

<file path="src/components/toolbar/ToolButton.tsx">
import type { ReactNode } from 'react'
import { Tooltip } from '../ui/Tooltip'

interface ToolButtonProps {
  icon?: ReactNode
  iconPath?: string
  label: string
  shortcut?: string
  active?: boolean
  disabled?: boolean
  onClick: () => void
  themed?: boolean
}

/**
 * ToolButton - Professional toolbar button with tooltip (PR-20)
 * 36px square, rounded corners, Figma-style hover states
 */
export function ToolButton({
  icon,
  iconPath,
  label,
  shortcut,
  active = false,
  disabled = false,
  onClick,
  themed = false,
}: ToolButtonProps) {
  const tooltipContent = shortcut ? `${label} (${shortcut})` : label

  return (
    <Tooltip content={tooltipContent} side="right">
      <button
        onClick={onClick}
        disabled={disabled}
        className={`
          w-9 h-9 rounded-lg flex items-center justify-center
          transition-all duration-150 relative
          focus:outline-none
          ${
            active
              ? themed
                ? 'bg-white/30 text-white shadow-sm'
                : 'bg-blue-500 text-white shadow-md'
              : disabled
              ? themed
                ? 'bg-white/10 text-white/40 cursor-not-allowed'
                : 'bg-neutral-50 text-neutral-400 cursor-not-allowed'
              : themed
                ? 'bg-white/15 text-white hover:bg-white/25'
                : 'bg-neutral-50 text-neutral-700 hover:bg-neutral-100'
          }
        `}
      >
        {iconPath ? (
          <img 
            src={iconPath} 
            alt={label}
            className="w-4 h-4"
            style={{ 
              filter: themed 
                ? (active ? 'brightness(2) invert(1)' : disabled ? 'brightness(0.5) invert(1)' : 'brightness(1.5) invert(1)') 
                : (active ? 'brightness(1)' : disabled ? 'brightness(0.5)' : 'brightness(0.9)'),
              display: 'block',
              visibility: 'visible',
              opacity: 1
            }}
          />
        ) : (
          <span className="text-lg">{icon}</span>
        )}
        {active && (
          <div className="absolute inset-0 rounded-lg ring-2 ring-white ring-opacity-50" />
        )}
      </button>
    </Tooltip>
  )
}
</file>

<file path="src/components/ui/ColorPicker.tsx">
import React, { useState, useEffect } from 'react'

/**
 * ColorPicker Component
 * Provides color selection with presets, hex input, opacity, recent colors, and eyedropper
 */

// TypeScript declarations for EyeDropper API
interface EyeDropperResult {
  sRGBHex: string
}

interface EyeDropperAPI {
  open: () => Promise<EyeDropperResult>
}

declare global {
  interface Window {
    EyeDropper?: new () => EyeDropperAPI
  }
}

interface ColorPickerProps {
  value: string // Current color value (RGBA hex format)
  onChange: (color: string) => void
  label: string // "Fill" or "Stroke"
  recentColors?: string[] // Recently used colors
  showOpacity?: boolean // Show opacity slider (default: true)
  onRequestCanvasSample?: () => void // Callback for fallback canvas sampling
}

// Expanded preset color palette (80 colors organized by hue)
const PRESET_COLORS = [
  // Row 1: Grays & Basics
  '#FFFFFFFF', '#F3F4F6FF', '#E5E7EBFF', '#D1D5DBFF', '#9CA3AFFF', 
  '#6B7280FF', '#4B5563FF', '#374151FF', '#1F2937FF', '#000000FF',
  
  // Row 2: Reds
  '#FEE2E2FF', '#FECACAFF', '#FCA5A5FF', '#F87171FF', '#EF4444FF',
  '#DC2626FF', '#B91C1CFF', '#991B1BFF', '#7F1D1DFF', '#450A0AFF',
  
  // Row 3: Oranges
  '#FFEDD5FF', '#FED7AAFF', '#FDBA74FF', '#FB923CFF', '#F97316FF',
  '#EA580CFF', '#C2410CFF', '#9A3412FF', '#7C2D12FF', '#431407FF',
  
  // Row 4: Yellows
  '#FEF3C7FF', '#FDE68AFF', '#FCD34DFF', '#FBBF24FF', '#F59E0BFF',
  '#D97706FF', '#B45309FF', '#92400EFF', '#78350FFF', '#451A03FF',
  
  // Row 5: Greens
  '#D1FAE5FF', '#A7F3D0FF', '#6EE7B7FF', '#34D399FF', '#10B981FF',
  '#059669FF', '#047857FF', '#065F46FF', '#064E3BFF', '#022C22FF',
  
  // Row 6: Blues
  '#DBEAFEFF', '#BFDBFEFF', '#93C5FDFF', '#60A5FAFF', '#3B82F6FF',
  '#2563EBFF', '#1D4ED8FF', '#1E40AFFF', '#1E3A8AFF', '#172554FF',
  
  // Row 7: Purples
  '#F3E8FFFF', '#E9D5FFFF', '#D8B4FEFF', '#C084FCFF', '#A855F7FF',
  '#9333EAFF', '#7E22CEFF', '#6B21A8FF', '#581C87FF', '#3B0764FF',
  
  // Row 8: Pinks
  '#FCE7F3FF', '#FBCFE8FF', '#F9A8D4FF', '#F472B6FF', '#EC4899FF',
  '#DB2777FF', '#BE185DFF', '#9D174DFF', '#831843FF', '#500724FF',
]

// Color names for tooltips
const COLOR_NAMES: Record<string, string> = {
  '#FFFFFFFF': 'White',
  '#F3F4F6FF': 'Gray 100',
  '#E5E7EBFF': 'Gray 200',
  '#D1D5DBFF': 'Gray 300',
  '#9CA3AFFF': 'Gray 400',
  '#6B7280FF': 'Gray 500',
  '#4B5563FF': 'Gray 600',
  '#374151FF': 'Gray 700',
  '#1F2937FF': 'Gray 800',
  '#000000FF': 'Black',
  '#FEE2E2FF': 'Red 100',
  '#EF4444FF': 'Red 500',
  '#450A0AFF': 'Red 950',
  '#FFEDD5FF': 'Orange 100',
  '#F97316FF': 'Orange 500',
  '#431407FF': 'Orange 950',
  '#FEF3C7FF': 'Yellow 100',
  '#F59E0BFF': 'Yellow 500',
  '#451A03FF': 'Yellow 950',
  '#D1FAE5FF': 'Green 100',
  '#10B981FF': 'Green 500',
  '#022C22FF': 'Green 950',
  '#DBEAFEFF': 'Blue 100',
  '#3B82F6FF': 'Blue 500',
  '#172554FF': 'Blue 950',
  '#F3E8FFFF': 'Purple 100',
  '#A855F7FF': 'Purple 500',
  '#3B0764FF': 'Purple 950',
  '#FCE7F3FF': 'Pink 100',
  '#EC4899FF': 'Pink 500',
  '#500724FF': 'Pink 950',
}

export const ColorPicker: React.FC<ColorPickerProps> = ({
  value,
  onChange,
  label,
  recentColors = [],
  showOpacity = true,
  onRequestCanvasSample,
}) => {
  const [hexInput, setHexInput] = useState(value.slice(0, 7)) // Remove alpha
  const [opacity, setOpacity] = useState(
    parseInt(value.slice(7, 9) || 'FF', 16) / 255
  )
  const [isPickingColor, setIsPickingColor] = useState(false)
  
  // Check if EyeDropper API is supported
  const supportsEyeDropper = typeof window !== 'undefined' && 'EyeDropper' in window

  // Update hex input when value changes externally
  useEffect(() => {
    setHexInput(value.slice(0, 7))
    setOpacity(parseInt(value.slice(7, 9) || 'FF', 16) / 255)
  }, [value])

  const handleHexInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let input = e.target.value
    setHexInput(input)

    // Validate hex color
    if (/^#[0-9A-Fa-f]{6}$/.test(input)) {
      const alpha = Math.round(opacity * 255)
        .toString(16)
        .padStart(2, '0')
        .toUpperCase()
      onChange(input + alpha)
    }
  }

  const handleOpacityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newOpacity = parseFloat(e.target.value)
    setOpacity(newOpacity)

    const alpha = Math.round(newOpacity * 255)
      .toString(16)
      .padStart(2, '0')
      .toUpperCase()
    onChange(hexInput + alpha)
  }

  const handlePresetClick = (color: string) => {
    setHexInput(color.slice(0, 7))
    setOpacity(parseInt(color.slice(7, 9) || 'FF', 16) / 255)
    onChange(color)
  }
  
  // Handle eyedropper tool
  const handleEyedropper = async () => {
    if (!window.EyeDropper) {
      // Fallback to canvas sampling
      if (onRequestCanvasSample) {
        onRequestCanvasSample()
      } else {
        alert('Eyedropper not supported in this browser. Try Chrome or Edge.')
      }
      return
    }
    
    try {
      setIsPickingColor(true)
      const eyeDropper = new window.EyeDropper()
      const result = await eyeDropper.open()
      
      // Convert picked color to uppercase and add current opacity
      const pickedHex = result.sRGBHex.toUpperCase()
      const alpha = Math.round(opacity * 255)
        .toString(16)
        .padStart(2, '0')
        .toUpperCase()
      
      const colorWithAlpha = pickedHex + alpha
      setHexInput(pickedHex)
      onChange(colorWithAlpha)
    } catch (error) {
      // User cancelled or error occurred
      console.log('Eyedropper cancelled:', error)
    } finally {
      setIsPickingColor(false)
    }
  }

  return (
    <div className="space-y-3">
      {/* Label */}
      <div className="text-sm font-medium text-gray-700">{label}</div>

      {/* Current Color Preview with Eyedropper */}
      <div className="flex items-center gap-2">
        <div
          className="w-12 h-12 rounded border-2 border-gray-300 shadow-sm"
          style={{
            backgroundColor: value,
            backgroundImage:
              'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',
            backgroundSize: '10px 10px',
            backgroundPosition: '0 0, 0 5px, 5px -5px, -5px 0px',
          }}
        />
        <div className="flex-1 flex gap-1">
          <input
            type="text"
            value={hexInput}
            onChange={handleHexInputChange}
            placeholder="#000000"
            className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            maxLength={7}
          />
          <button
            onClick={handleEyedropper}
            disabled={isPickingColor}
            className={`px-2 py-1 border rounded transition-colors ${
              isPickingColor
                ? 'bg-gray-100 text-gray-400 border-gray-300 cursor-wait'
                : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50 hover:border-blue-500'
            }`}
            title={
              supportsEyeDropper
                ? 'Pick color from screen'
                : 'Pick color from canvas (fallback)'
            }
          >
            {isPickingColor ? (
              <span className="text-sm">⏳</span>
            ) : (
              <svg
                className="w-4 h-4"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
                />
              </svg>
            )}
          </button>
        </div>
      </div>

      {/* Opacity Slider */}
      {showOpacity && (
        <div>
          <div className="flex justify-between text-xs text-gray-600 mb-1">
            <span>Opacity</span>
            <span>{Math.round(opacity * 100)}%</span>
          </div>
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={opacity}
            onChange={handleOpacityChange}
            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
      )}

      {/* Preset Colors - Scrollable Grid */}
      <div>
        <div className="text-xs text-gray-600 mb-2">Presets (80 colors)</div>
        <div 
          className="grid grid-cols-10 gap-1 max-h-60 overflow-y-auto pr-1"
          style={{ scrollbarWidth: 'thin' }}
        >
          {PRESET_COLORS.map((color, index) => (
            <button
              key={`${color}-${index}`}
              onClick={() => handlePresetClick(color)}
              className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 ${
                value.toUpperCase() === color.toUpperCase()
                  ? 'border-blue-500 ring-2 ring-blue-200'
                  : 'border-gray-300'
              }`}
              style={{
                backgroundColor: color,
              }}
              title={COLOR_NAMES[color] || color}
            />
          ))}
        </div>
      </div>

      {/* Recent Colors */}
      <div>
        <div className="text-xs text-gray-600 mb-2">Recent Colors</div>
        {recentColors.length > 0 ? (
          <div className="flex gap-1">
            {recentColors.map((color, index) => (
              <button
                key={`${color}-${index}`}
                onClick={() => handlePresetClick(color)}
                className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 ${
                  value.toUpperCase() === color.toUpperCase()
                    ? 'border-blue-500 ring-2 ring-blue-200'
                    : 'border-gray-300'
                }`}
                style={{
                  backgroundColor: color,
                  backgroundImage:
                    'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',
                  backgroundSize: '10px 10px',
                  backgroundPosition: '0 0, 0 5px, 5px -5px, -5px 0px',
                }}
                title={color}
              />
            ))}
          </div>
        ) : (
          <div className="text-xs text-gray-400 italic">No recent colors</div>
        )}</div>
    </div>
  )
}
</file>

<file path="src/components/ui/ContextMenu.tsx">
// ContextMenu Component - Right-click menu for shapes (PR-17, PR-18)

import { useEffect, useRef, useState } from 'react'
import type { AlignmentType } from '../../services/collaboration/alignment'

interface ContextMenuProps {
  x: number
  y: number
  visible: boolean
  onClose: () => void
  hasSelection: boolean
  canCopy: boolean
  canPaste: boolean
  selectedCount: number
  onBringToFront: () => void
  onBringForward: () => void
  onSendBackward: () => void
  onSendToBack: () => void
  onCopy?: () => void
  onPaste?: () => void
  onDuplicate?: () => void
  onDelete?: () => void
  // PR-18: Alignment operations
  onAlign?: (type: AlignmentType) => void
  onDistributeHorizontally?: () => void
  onDistributeVertically?: () => void
  onCenterInCanvas?: () => void
}

/**
 * Context menu component that appears on right-click
 * Provides z-index operations and clipboard operations
 */
export function ContextMenu({
  x,
  y,
  visible,
  onClose,
  hasSelection,
  canCopy,
  canPaste,
  selectedCount,
  onBringToFront,
  onBringForward,
  onSendBackward,
  onSendToBack,
  onCopy,
  onPaste,
  onDuplicate,
  onDelete,
  onAlign,
  onDistributeHorizontally,
  onDistributeVertically,
  onCenterInCanvas,
}: ContextMenuProps) {
  const menuRef = useRef<HTMLDivElement>(null)
  const [showAlignSubmenu, setShowAlignSubmenu] = useState(false)
  const [showDistributeSubmenu, setShowDistributeSubmenu] = useState(false)

  // Close menu when clicking outside
  useEffect(() => {
    if (!visible) return

    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        onClose()
      }
    }

    // Add slight delay to prevent immediate close from the right-click that opened it
    setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside)
    }, 0)

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [visible, onClose])

  // Close menu on Escape key
  useEffect(() => {
    if (!visible) return

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    document.addEventListener('keydown', handleEscape)
    return () => {
      document.removeEventListener('keydown', handleEscape)
    }
  }, [visible, onClose])

  if (!visible) return null

  const handleMenuAction = (action: () => void) => {
    action()
    onClose()
  }

  const canAlign = selectedCount >= 2
  const canDistribute = selectedCount >= 3

  return (
    <div
      ref={menuRef}
      className="fixed bg-white border border-gray-300 rounded-md py-0.5 z-[9999]"
      style={{
        left: x,
        top: y,
        boxShadow: '0 10px 40px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15)',
      }}
    >
      {/* Alignment Operations (PR-18) */}
      {canAlign && onAlign && (
        <>
          <div className="relative">
            <button
              className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
              onMouseEnter={() => setShowAlignSubmenu(true)}
              onMouseLeave={() => setShowAlignSubmenu(false)}
            >
              <span>Align</span>
              <span className="text-neutral-400">›</span>
            </button>
            {showAlignSubmenu && (
              <div
                className="absolute left-full top-0 bg-white border border-gray-300 rounded-md py-0.5 ml-1"
                style={{
                  boxShadow: '0 10px 40px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15)',
                }}
                onMouseEnter={() => setShowAlignSubmenu(true)}
                onMouseLeave={() => setShowAlignSubmenu(false)}
              >
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('left'))}
                >
                  Left
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('center'))}
                >
                  Center
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('right'))}
                >
                  Right
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('top'))}
                >
                  Top
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('middle'))}
                >
                  Middle
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('bottom'))}
                >
                  Bottom
                </button>
              </div>
            )}
          </div>
        </>
      )}

      {/* Distribution Operations (PR-18) */}
      {canDistribute && onDistributeHorizontally && onDistributeVertically && (
        <div className="relative">
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
            onMouseEnter={() => setShowDistributeSubmenu(true)}
            onMouseLeave={() => setShowDistributeSubmenu(false)}
          >
            <span>Distribute</span>
            <span className="text-neutral-400">›</span>
          </button>
          {showDistributeSubmenu && (
            <div
              className="absolute left-full top-0 bg-white border border-gray-300 rounded-md py-0.5 ml-1"
              style={{
                boxShadow: '0 10px 40px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15)',
              }}
              onMouseEnter={() => setShowDistributeSubmenu(true)}
              onMouseLeave={() => setShowDistributeSubmenu(false)}
            >
              <button
                className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                onClick={() => handleMenuAction(onDistributeHorizontally)}
              >
                Horizontally
              </button>
              <button
                className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                onClick={() => handleMenuAction(onDistributeVertically)}
              >
                Vertically
              </button>
            </div>
          )}
        </div>
      )}

      {/* Center in Canvas (PR-18) */}
      {hasSelection && onCenterInCanvas && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
          onClick={() => handleMenuAction(onCenterInCanvas)}
        >
          Center in Canvas
        </button>
      )}

      {/* Divider */}
      {(canAlign || canDistribute || (hasSelection && onCenterInCanvas)) && (
        <div className="border-t border-neutral-200" />
      )}

      {/* Z-Index Operations */}
      {hasSelection && (
        <>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onBringToFront)}
          >
            Bring to Front
          </button>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onBringForward)}
          >
            Bring Forward
          </button>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onSendBackward)}
          >
            Send Backward
          </button>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onSendToBack)}
          >
            Send to Back
          </button>
          <div className="border-t border-neutral-200" />
        </>
      )}

      {/* Clipboard Operations */}
      {canCopy && onCopy && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
          onClick={() => handleMenuAction(onCopy)}
        >
          <span>Copy</span>
          <span className="text-neutral-400">⌘C</span>
        </button>
      )}
      {canPaste && onPaste && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
          onClick={() => handleMenuAction(onPaste)}
        >
          <span>Paste</span>
          <span className="text-neutral-400">⌘V</span>
        </button>
      )}
      {canCopy && onDuplicate && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
          onClick={() => handleMenuAction(onDuplicate)}
        >
          <span>Duplicate</span>
          <span className="text-neutral-400">⌘D</span>
        </button>
      )}

      {/* Delete Operation */}
      {hasSelection && onDelete && (
        <>
          <div className="border-t border-neutral-200" />
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-red-50 text-red-600 flex items-center justify-between gap-2"
            onClick={() => handleMenuAction(onDelete)}
          >
            <span>Delete</span>
            <span className="text-red-400">⌫</span>
          </button>
        </>
      )}
    </div>
  )
}
</file>

<file path="src/components/ui/Skeleton.tsx">
interface SkeletonProps {
  width?: string | number
  height?: string | number
  className?: string
  circle?: boolean
  count?: number
}

/**
 * Skeleton - Reusable loading skeleton component (PR-20)
 * Shows animated placeholder while content is loading
 */
export function Skeleton({
  width,
  height,
  className = '',
  circle = false,
  count = 1,
}: SkeletonProps) {
  const skeletonStyle: React.CSSProperties = {
    width: typeof width === 'number' ? `${width}px` : width,
    height: typeof height === 'number' ? `${height}px` : height,
  }

  const baseClasses = `bg-neutral-200 animate-pulse ${circle ? 'rounded-full' : 'rounded'} ${className}`

  if (count > 1) {
    return (
      <>
        {Array.from({ length: count }).map((_, index) => (
          <div key={index} className={baseClasses} style={skeletonStyle} />
        ))}
      </>
    )
  }

  return <div className={baseClasses} style={skeletonStyle} />
}

/**
 * SkeletonText - Text line skeleton with multiple lines support
 */
export function SkeletonText({ lines = 1 }: { lines?: number }) {
  return (
    <div className="space-y-2">
      {Array.from({ length: lines }).map((_, index) => (
        <div
          key={index}
          className="h-4 bg-neutral-200 animate-pulse rounded"
          style={{
            width: index === lines - 1 ? '80%' : '100%',
          }}
        />
      ))}
    </div>
  )
}

/**
 * SkeletonCard - Card skeleton for dashboard grid items
 */
export function SkeletonCard() {
  return (
    <div className="bg-white rounded-lg border border-neutral-200 p-4 space-y-3">
      {/* Thumbnail */}
      <Skeleton height={180} className="w-full" />
      {/* Title */}
      <Skeleton height={20} width="70%" />
      {/* Subtitle */}
      <Skeleton height={16} width="50%" />
    </div>
  )
}

/**
 * SkeletonList - List item skeleton for layer panel
 */
export function SkeletonList({ count = 5 }: { count?: number }) {
  return (
    <div className="space-y-2">
      {Array.from({ length: count }).map((_, index) => (
        <div key={index} className="flex items-center gap-2 px-2 py-1.5">
          <Skeleton width={16} height={16} />
          <Skeleton height={20} className="flex-1" />
          <Skeleton width={16} height={16} />
        </div>
      ))}
    </div>
  )
}

/**
 * SkeletonCanvas - Full canvas loading skeleton
 */
export function SkeletonCanvas() {
  return (
    <div className="w-full h-full bg-neutral-100 flex items-center justify-center">
      <div className="text-center space-y-4">
        <div className="inline-block">
          <Skeleton width={64} height={64} circle />
        </div>
        <SkeletonText lines={2} />
      </div>
    </div>
  )
}

/**
 * LoadingSpinner - Simple spinner for inline loading states
 */
export function LoadingSpinner({ size = 24 }: { size?: number }) {
  return (
    <div
      className="inline-block animate-spin rounded-full border-2 border-neutral-300 border-t-primary-600"
      style={{ width: size, height: size }}
    />
  )
}
</file>

<file path="src/components/ui/Tooltip.tsx">
import { useState, useRef, useEffect, type ReactNode } from 'react'

interface TooltipProps {
  content: string
  children: ReactNode
  side?: 'top' | 'right' | 'bottom' | 'left'
  delay?: number
}

/**
 * Tooltip - Professional hover tooltip component (PR-20)
 * Shows helpful text on hover with customizable positioning
 */
export function Tooltip({ 
  content, 
  children, 
  side = 'right',
  delay = 300 
}: TooltipProps) {
  const [visible, setVisible] = useState(false)
  const [position, setPosition] = useState({ x: 0, y: 0 })
  const timeoutRef = useRef<number | undefined>(undefined)
  const triggerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    return () => {
      if (timeoutRef.current !== undefined) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [])

  const handleMouseEnter = () => {
    timeoutRef.current = window.setTimeout(() => {
      if (triggerRef.current) {
        const rect = triggerRef.current.getBoundingClientRect()
        
        // Calculate position based on side
        let x = 0
        let y = 0
        
        switch (side) {
          case 'right':
            x = rect.right + 8
            y = rect.top + rect.height / 2
            break
          case 'left':
            x = rect.left - 8
            y = rect.top + rect.height / 2
            break
          case 'top':
            x = rect.left + rect.width / 2
            y = rect.top - 8
            break
          case 'bottom':
            x = rect.left + rect.width / 2
            y = rect.bottom + 8
            break
        }
        
        setPosition({ x, y })
        setVisible(true)
      }
    }, delay)
  }

  const handleMouseLeave = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }
    setVisible(false)
  }

  return (
    <>
      <div
        ref={triggerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        style={{ display: 'inline-block' }}
      >
        {children}
      </div>
      
      {visible && (
        <div
          className="fixed z-[9999] pointer-events-none"
          style={{
            left: `${position.x}px`,
            top: `${position.y}px`,
            transform: side === 'right' || side === 'left' 
              ? 'translateY(-50%)'
              : 'translateX(-50%)',
          }}
        >
          <div className="bg-neutral-800 text-white text-xs px-2 py-1 rounded shadow-cursor whitespace-nowrap">
            {content}
          </div>
        </div>
      )}
    </>
  )
}
</file>

<file path="src/components/ui/ZoomControls.tsx">
import { Tooltip } from '../ui/Tooltip'

interface ZoomControlsProps {
  scale: number
  onZoomIn: () => void
  onZoomOut: () => void
  onZoomReset: () => void
  onZoomFit: () => void
  collabTheme?: { 
    primary: string
    secondary: string
    gradient: string
    displayName: string
    softBg: string
    softBorder: string
  } | null
}

/**
 * ZoomControls - Professional zoom controls for canvas (PR-20)
 * Shows current zoom percentage with +/- buttons and fit-to-screen
 */
export function ZoomControls({
  scale,
  onZoomIn,
  onZoomOut,
  onZoomReset,
  onZoomFit,
  collabTheme,
}: ZoomControlsProps) {
  const percentage = Math.round(scale * 100)

  return (
    <div className={`flex items-center gap-0.5 rounded px-1 h-7 ${
      collabTheme ? 'bg-white/60' : 'bg-neutral-100'
    }`}>
      {/* Zoom Out */}
      <Tooltip content="Zoom out" side="bottom">
        <button
          onClick={onZoomOut}
          className={`w-6 h-5 flex items-center justify-center rounded text-xs transition-colors ${
            collabTheme ? 'hover:bg-white/80 text-gray-900' : 'hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          <span>−</span>
        </button>
      </Tooltip>

      {/* Percentage Display - click to reset to 100% */}
      <Tooltip content="Reset zoom to 100%" side="bottom">
        <button
          onClick={onZoomReset}
          className={`min-w-[40px] h-5 px-1.5 flex items-center justify-center rounded transition-colors ${
            collabTheme ? 'hover:bg-white/80' : 'hover:bg-neutral-200'
          }`}
        >
          <span className={`text-[9px] font-medium ${
            collabTheme ? 'text-gray-900' : 'text-neutral-700'
          }`}>
            {percentage}%
          </span>
        </button>
      </Tooltip>

      {/* Zoom In */}
      <Tooltip content="Zoom in" side="bottom">
        <button
          onClick={onZoomIn}
          className={`w-6 h-5 flex items-center justify-center rounded text-xs transition-colors ${
            collabTheme ? 'hover:bg-white/80 text-gray-900' : 'hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          <span>+</span>
        </button>
      </Tooltip>

      {/* Divider */}
      <div className={`w-px h-3 mx-0.5 ${
        collabTheme ? 'bg-gray-400' : 'bg-neutral-300'
      }`} />

      {/* Fit to Screen */}
      <Tooltip content="Fit to screen" side="bottom">
        <button
          onClick={onZoomFit}
          className={`w-6 h-5 flex items-center justify-center rounded text-xs transition-colors ${
            collabTheme ? 'hover:bg-white/80 text-gray-900' : 'hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          <span className="text-xs">⊡</span>
        </button>
      </Tooltip>
    </div>
  )
}
</file>

<file path="src/hooks/useAssetLibrary.ts">
/**
 * Asset Library Hook (PR-31)
 * Manages asset library state, uploads, and organization
 */

import { useState, useCallback, useEffect, useMemo } from 'react'
import { ref as dbRef, onValue, off } from 'firebase/database'
import { db } from '../services/firebase'
import {
  uploadAsset,
  deleteAsset,
  updateAssetMetadata,
  getUserAssets
} from '../services/assets/assetUpload'
import type {
  Asset,
  AssetType,
  AssetFilter,
  AssetUploadProgress,
  TilesetMetadata,
  SpriteSheetMetadata
} from '../types/asset'

interface UseAssetLibraryOptions {
  userId: string
  enableSync?: boolean
}

interface UseAssetLibraryReturn {
  assets: Asset[]
  isLoading: boolean
  error: string | null
  selectedAssetId: string | null
  filter: AssetFilter
  uploadProgress: Map<string, AssetUploadProgress>
  // Asset operations
  uploadAsset: (
    file: File,
    options?: {
      name?: string
      type?: AssetType
      tags?: string[]
      folderId?: string
      tilesetMetadata?: TilesetMetadata
      spriteSheetMetadata?: SpriteSheetMetadata
    }
  ) => Promise<Asset>
  deleteAsset: (assetId: string) => Promise<void>
  updateAsset: (
    assetId: string,
    updates: Partial<Pick<Asset, 'name' | 'tags' | 'folderId' | 'tilesetMetadata' | 'spriteSheetMetadata'>>
  ) => Promise<void>
  // Selection
  selectAsset: (assetId: string | null) => void
  getSelectedAsset: () => Asset | null
  // Filtering
  setFilter: (filter: AssetFilter) => void
  clearFilter: () => void
  searchAssets: (query: string) => void
  filterByType: (type: AssetType | null) => void
  filterByTags: (tags: string[]) => void
  // Getters
  getFilteredAssets: () => Asset[]
  getAssetsByType: (type: AssetType) => Asset[]
  getAssetById: (assetId: string) => Asset | null
  // Tags
  getAllTags: () => string[]
  addTagToAsset: (assetId: string, tag: string) => Promise<void>
  removeTagFromAsset: (assetId: string, tag: string) => Promise<void>
}

export function useAssetLibrary(options: UseAssetLibraryOptions): UseAssetLibraryReturn {
  const { userId, enableSync = true } = options

  // State
  const [assets, setAssets] = useState<Asset[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [selectedAssetId, setSelectedAssetId] = useState<string | null>(null)
  const [filter, setFilterState] = useState<AssetFilter>({})
  const [uploadProgress, setUploadProgress] = useState<Map<string, AssetUploadProgress>>(new Map())

  // Load initial assets
  useEffect(() => {
    let unsubscribe: (() => void) | null = null

    const loadAssets = async () => {
      setIsLoading(true)
      setError(null)

      try {
        if (enableSync) {
          // Subscribe to real-time updates
          const assetsRef = dbRef(db, `assets/${userId}`)
          
          const handler = (snapshot: any) => {
            if (!snapshot.exists()) {
              setAssets([])
              setIsLoading(false)
              return
            }

            const assetsData = snapshot.val()
            const assetsList = Object.values(assetsData) as Asset[]
            setAssets(assetsList)
            setIsLoading(false)
          }

          onValue(assetsRef, handler)
          unsubscribe = () => off(assetsRef, 'value', handler)
        } else {
          // Load once without sync
          const assetsList = await getUserAssets(userId)
          setAssets(assetsList)
          setIsLoading(false)
        }
      } catch (err) {
        console.error('Failed to load assets:', err)
        setError(err instanceof Error ? err.message : 'Failed to load assets')
        setIsLoading(false)
      }
    }

    loadAssets()

    return () => {
      if (unsubscribe) {
        unsubscribe()
      }
    }
  }, [userId, enableSync])

  // Upload asset
  const handleUploadAsset = useCallback(
    async (
      file: File,
      uploadOptions?: {
        name?: string
        type?: AssetType
        tags?: string[]
        folderId?: string
        tilesetMetadata?: TilesetMetadata
        spriteSheetMetadata?: SpriteSheetMetadata
      }
    ): Promise<Asset> => {
      try {
        const asset = await uploadAsset(file, userId, {
          ...uploadOptions,
          onProgress: (progress) => {
            setUploadProgress(prev => new Map(prev).set(progress.assetId, progress))
          }
        })

        // Clear progress after completion
        setUploadProgress(prev => {
          const next = new Map(prev)
          next.delete(asset.id)
          return next
        })

        return asset
      } catch (err) {
        console.error('Failed to upload asset:', err)
        throw err
      }
    },
    [userId]
  )

  // Delete asset
  const handleDeleteAsset = useCallback(
    async (assetId: string): Promise<void> => {
      try {
        await deleteAsset(assetId, userId)
        
        // Clear selection if deleted asset was selected
        if (selectedAssetId === assetId) {
          setSelectedAssetId(null)
        }
      } catch (err) {
        console.error('Failed to delete asset:', err)
        throw err
      }
    },
    [userId, selectedAssetId]
  )

  // Update asset metadata
  const handleUpdateAsset = useCallback(
    async (
      assetId: string,
      updates: Partial<Pick<Asset, 'name' | 'tags' | 'folderId' | 'tilesetMetadata' | 'spriteSheetMetadata'>>
    ): Promise<void> => {
      try {
        await updateAssetMetadata(assetId, userId, updates)
      } catch (err) {
        console.error('Failed to update asset:', err)
        throw err
      }
    },
    [userId]
  )

  // Selection
  const selectAsset = useCallback((assetId: string | null) => {
    setSelectedAssetId(assetId)
  }, [])

  const getSelectedAsset = useCallback((): Asset | null => {
    if (!selectedAssetId) return null
    return assets?.find(a => a.id === selectedAssetId) || null
  }, [selectedAssetId, assets])

  // Filtering
  const setFilter = useCallback((newFilter: AssetFilter) => {
    setFilterState(newFilter)
  }, [])

  const clearFilter = useCallback(() => {
    setFilterState({})
  }, [])

  const searchAssets = useCallback((query: string) => {
    setFilterState(prev => ({
      ...prev,
      searchQuery: query.toLowerCase()
    }))
  }, [])

  const filterByType = useCallback((type: AssetType | null) => {
    setFilterState(prev => ({
      ...prev,
      type: type ? [type] : undefined
    }))
  }, [])

  const filterByTags = useCallback((tags: string[]) => {
    setFilterState(prev => ({
      ...prev,
      tags
    }))
  }, [])

  // Get filtered assets
  const getFilteredAssets = useCallback((): Asset[] => {
    let filtered = [...assets]

    // Filter by type
    if (filter.type && filter.type.length > 0) {
      filtered = filtered.filter(asset => filter.type!.includes(asset.type))
    }

    // Filter by tags
    if (filter.tags && filter.tags.length > 0) {
      filtered = filtered.filter(asset =>
        filter.tags!.some(tag => asset.tags.includes(tag))
      )
    }

    // Filter by folder
    if (filter.folderId !== undefined) {
      filtered = filtered.filter(asset => asset.folderId === filter.folderId)
    }

    // Filter by search query
    if (filter.searchQuery) {
      filtered = filtered.filter(asset =>
        asset.name.toLowerCase().includes(filter.searchQuery!) ||
        asset.tags.some(tag => tag.toLowerCase().includes(filter.searchQuery!))
      )
    }

    // Sort by upload date (newest first)
    filtered.sort((a, b) => b.uploadedAt - a.uploadedAt)

    return filtered
  }, [assets, filter])

  // Get assets by type
  const getAssetsByType = useCallback(
    (type: AssetType): Asset[] => {
      return assets?.filter(asset => asset.type === type) || []
    },
    [assets]
  )

  // Get asset by ID
  const getAssetById = useCallback(
    (assetId: string): Asset | null => {
      return assets?.find(asset => asset.id === assetId) || null
    },
    [assets]
  )

  // Get all unique tags
  const getAllTags = useCallback((): string[] => {
    const tagSet = new Set<string>()
    assets?.forEach(asset => {
      asset.tags?.forEach(tag => tagSet.add(tag))
    })
    return Array.from(tagSet).sort()
  }, [assets])

  // Add tag to asset
  const addTagToAsset = useCallback(
    async (assetId: string, tag: string): Promise<void> => {
      const asset = getAssetById(assetId)
      if (!asset) throw new Error('Asset not found')

      if (asset.tags.includes(tag)) return // Already has tag

      await handleUpdateAsset(assetId, {
        tags: [...asset.tags, tag]
      })
    },
    [getAssetById, handleUpdateAsset]
  )

  // Remove tag from asset
  const removeTagFromAsset = useCallback(
    async (assetId: string, tag: string): Promise<void> => {
      const asset = getAssetById(assetId)
      if (!asset) throw new Error('Asset not found')

      await handleUpdateAsset(assetId, {
        tags: asset.tags.filter(t => t !== tag)
      })
    },
    [getAssetById, handleUpdateAsset]
  )

  return {
    assets,
    isLoading,
    error,
    selectedAssetId,
    filter,
    uploadProgress,
    uploadAsset: handleUploadAsset,
    deleteAsset: handleDeleteAsset,
    updateAsset: handleUpdateAsset,
    selectAsset,
    getSelectedAsset,
    setFilter,
    clearFilter,
    searchAssets,
    filterByType,
    filterByTags,
    getFilteredAssets,
    getAssetsByType,
    getAssetById,
    getAllTags,
    addTagToAsset,
    removeTagFromAsset
  }
}
</file>

<file path="src/services/ai/ai.ts">
/**
 * AI Service - Client-side
 * Calls Firebase Functions for AI operations
 * PR-30: Task 1.2
 */

import { httpsCallable } from 'firebase/functions';
import { functions } from '../firebase';

export type AIRequest = {
  message: string;
  context: {
    canvasId: string;
    userId: string;
    selectedShapes: string[];
    viewport: {
      x: number;
      y: number;
      width: number;
      height: number;
      zoom: number;
    };
    mode: 'shapes' | 'tilemap';
    tilemapMeta?: any;
  };
}

export type AIResponse = {
  success: boolean;
  message: string;
  toolResults?: any[];
  error?: string;
}

/**
 * Send AI command to Firebase Function
 */
export async function sendAICommand(request: AIRequest): Promise<AIResponse> {
  try {
    const aiCanvasCommand = httpsCallable<AIRequest, AIResponse>(
      functions,
      'aiCanvasCommand'
    );

    const result = await aiCanvasCommand(request);
    return result.data;

  } catch (error: any) {
    console.error('AI service error:', error);
    
    // Parse Firebase errors
    if (error.code === 'functions/unauthenticated') {
      return {
        success: false,
        message: '',
        error: 'You must be logged in to use AI features',
      };
    }

    if (error.code === 'functions/resource-exhausted') {
      return {
        success: false,
        message: '',
        error: 'Rate limit exceeded. Please wait a moment and try again.',
      };
    }

    if (error.code === 'functions/invalid-argument') {
      return {
        success: false,
        message: '',
        error: error.message || 'Invalid request',
      };
    }

    // Generic error
    return {
      success: false,
      message: '',
      error: error.message || 'AI service is temporarily unavailable',
    };
  }
}

/**
 * Check if AI features are enabled
 */
export function isAIEnabled(): boolean {
  return import.meta.env.VITE_AI_ENABLED !== 'false';
}

/**
 * AI Asset Analysis Helpers (PR-32)
 * Functions to integrate AI with asset management pipeline
 */

/**
 * Get AI suggestion for slicing a sprite sheet
 */
export async function getAISlicingSuggestion(
  width: number,
  height: number,
  imageUrl?: string
): Promise<{
  recommendation: 'AUTO_DETECTION_RECOMMENDED' | 'AUTO_DETECTION_WITH_SPACING' | 'MANUAL_SELECTION_REQUIRED';
  suggestions: Array<{
    tileSize: string;
    grid: string;
    spacing?: number;
    totalTiles: number;
    confidence: 'high' | 'medium' | 'low';
    reason: string;
  }>;
  advice: string;
} | null> {
  try {
    // Create a minimal context (AI doesn't need full canvas context for this)
    const request: AIRequest = {
      message: `Analyze this sprite sheet: ${width}×${height}px. Suggest how to slice it.`,
      context: {
        canvasId: 'asset-upload',
        userId: 'system',
        selectedShapes: [],
        viewport: { x: 0, y: 0, width: 800, height: 600, zoom: 1 },
        mode: 'shapes'
      }
    };

    const response = await sendAICommand(request);

    if (response.success && response.toolResults) {
      // Find the suggestSlicing tool result
      const slicingResult = response.toolResults.find(r => r.tool === 'suggestSlicing');
      if (slicingResult?.result?.data) {
        return slicingResult.result.data;
      }
    }

    return null;
  } catch (error) {
    console.error('Failed to get AI slicing suggestion:', error);
    return null;
  }
}

/**
 * Get AI recommendation for which asset to use
 */
export async function getAIAssetRecommendation(
  userId: string,
  purpose: string,
  assetType: 'any' | 'tileset' | 'spritesheet' | 'image' = 'any'
): Promise<{
  recommendation: any;
  alternatives: any[];
  allAssets: any[];
} | null> {
  try {
    const request: AIRequest = {
      message: `Recommend asset for: ${purpose}`,
      context: {
        canvasId: 'asset-query',
        userId,
        selectedShapes: [],
        viewport: { x: 0, y: 0, width: 800, height: 600, zoom: 1 },
        mode: 'shapes'
      }
    };

    const response = await sendAICommand(request);

    if (response.success && response.toolResults) {
      const recommendResult = response.toolResults.find(r => r.tool === 'recommendAsset');
      if (recommendResult?.result?.data) {
        return recommendResult.result.data;
      }
    }

    return null;
  } catch (error) {
    console.error('Failed to get AI asset recommendation:', error);
    return null;
  }
}

/**
 * Notify AI that a new asset was uploaded
 * Returns AI's analysis and suggestions for using the asset
 */
export async function notifyAIAssetUploaded(
  userId: string,
  assetId: string,
  assetName: string,
  assetType: string
): Promise<string | null> {
  try {
    const request: AIRequest = {
      message: `A new ${assetType} called "${assetName}" was just uploaded (ID: ${assetId}). Analyze it and suggest how to use it.`,
      context: {
        canvasId: 'asset-notification',
        userId,
        selectedShapes: [],
        viewport: { x: 0, y: 0, width: 800, height: 600, zoom: 1 },
        mode: 'shapes'
      }
    };

    const response = await sendAICommand(request);

    if (response.success) {
      return response.message;
    }

    return null;
  } catch (error) {
    console.error('Failed to notify AI of asset upload:', error);
    return null;
  }
}
</file>

<file path="src/services/ai/gameTypeDetection.ts">
/**
 * Game Type Detection Service
 * Analyzes canvas content to detect game type and patterns
 * PR-32: AI Game-Aware Enhancement
 */

import type { Shape } from '../../types/canvas';

export type GameType = 'platformer' | 'top-down' | 'puzzle' | 'shooter' | 'unknown';

export interface GameTypeDetection {
  type: GameType;
  confidence: number; // 0-1
  reasoning: string[];
  features: string[];
}

export interface GameFeatures {
  commonAssets: string[];
  typicalObjects: string[];
  levelStructure: string;
  cameraStyle: string;
  controls: string;
}

/**
 * Detect game type from canvas objects and tilemap
 */
export function detectGameType(
  objects: Shape[],
  tilemapSize?: { width: number; height: number },
  tileCount?: number
): GameTypeDetection {
  const scores = {
    platformer: 0,
    'top-down': 0,
    puzzle: 0,
    shooter: 0,
    unknown: 0
  };

  const reasoning: string[] = [];
  const features: string[] = [];

  // Analyze object layout
  const { horizontalLayers, verticalDistribution, gridLike } = analyzeObjectLayout(objects);

  // Platformer detection
  if (horizontalLayers > 2) {
    scores.platformer += 30;
    reasoning.push('Objects arranged in horizontal layers');
    features.push('Platform layers detected');
  }

  if (verticalDistribution === 'bottom-heavy') {
    scores.platformer += 20;
    reasoning.push('Objects concentrated near bottom (gravity-implied)');
  }

  // Top-down detection
  if (gridLike) {
    scores['top-down'] += 25;
    scores.puzzle += 25;
    reasoning.push('Objects arranged in grid pattern');
    features.push('Grid-based layout');
  }

  if (tilemapSize && tilemapSize.width === tilemapSize.height) {
    scores['top-down'] += 15;
    reasoning.push('Square tilemap (common in top-down games)');
  }

  if (verticalDistribution === 'even') {
    scores['top-down'] += 20;
    reasoning.push('Even vertical distribution');
  }

  // Puzzle detection
  if (objects.length < 50 && gridLike) {
    scores.puzzle += 30;
    reasoning.push('Few objects in regular grid (puzzle-like)');
    features.push('Puzzle grid structure');
  }

  // Analyze tilemap
  if (tilemapSize && tileCount) {
    const density = tileCount / (tilemapSize.width * tilemapSize.height);
    
    if (density > 0.7) {
      scores['top-down'] += 15;
      scores.puzzle += 10;
      reasoning.push('Dense tilemap (walls/floors)');
    }

    if (density < 0.3 && density > 0.05) {
      scores.platformer += 20;
      reasoning.push('Sparse tilemap (platforms)');
      features.push('Platform-based level');
    }
  }

  // Analyze object types
  const objectTypes = countObjectTypes(objects);

  if (objectTypes.rectangles > objectTypes.circles * 2) {
    scores.platformer += 10;
    scores['top-down'] += 5;
    reasoning.push('Many rectangles (platforms/walls)');
  }

  if (objectTypes.circles > 5) {
    scores.shooter += 15;
    reasoning.push('Multiple circles (possibly projectiles/enemies)');
  }

  // Size analysis
  if (tilemapSize) {
    const aspectRatio = tilemapSize.width / tilemapSize.height;
    
    if (aspectRatio > 2) {
      scores.platformer += 15;
      reasoning.push('Wide aspect ratio (side-scrolling)');
      features.push('Side-scrolling layout');
    }

    if (aspectRatio >= 0.8 && aspectRatio <= 1.2) {
      scores['top-down'] += 10;
      reasoning.push('Nearly square layout');
    }
  }

  // Find winner
  let bestType: GameType = 'unknown';
  let bestScore = 0;

  for (const [type, score] of Object.entries(scores)) {
    if (score > bestScore) {
      bestScore = score;
      bestType = type as GameType;
    }
  }

  // Calculate confidence (normalize score to 0-1)
  const confidence = Math.min(bestScore / 100, 1.0);

  // If confidence too low, mark as unknown
  if (confidence < 0.3) {
    bestType = 'unknown';
    reasoning.push('Not enough evidence for specific game type');
  }

  return {
    type: bestType,
    confidence,
    reasoning,
    features
  };
}

/**
 * Analyze object layout patterns
 */
function analyzeObjectLayout(objects: Shape[]): {
  horizontalLayers: number;
  verticalDistribution: 'bottom-heavy' | 'top-heavy' | 'even';
  gridLike: boolean;
} {
  if (objects.length === 0) {
    return { horizontalLayers: 0, verticalDistribution: 'even', gridLike: false };
  }

  // Detect horizontal layers
  const yPositions = objects.map(obj => obj.y).sort((a, b) => a - b);
  const layerThreshold = 50; // pixels
  const layers = new Set<number>();
  
  for (const y of yPositions) {
    const layer = Math.floor(y / layerThreshold);
    layers.add(layer);
  }

  // Detect vertical distribution
  const minY = Math.min(...yPositions);
  const maxY = Math.max(...yPositions);
  const range = maxY - minY;
  const topThird = minY + range / 3;
  const bottomThird = maxY - range / 3;

  const topCount = objects.filter(obj => obj.y < topThird).length;
  const bottomCount = objects.filter(obj => obj.y > bottomThird).length;

  let verticalDistribution: 'bottom-heavy' | 'top-heavy' | 'even';
  if (bottomCount > topCount * 1.5) {
    verticalDistribution = 'bottom-heavy';
  } else if (topCount > bottomCount * 1.5) {
    verticalDistribution = 'top-heavy';
  } else {
    verticalDistribution = 'even';
  }

  // Detect grid-like arrangement
  const xPositions = objects.map(obj => obj.x).sort((a, b) => a - b);
  const gridLike = isGridLike(xPositions, yPositions);

  return {
    horizontalLayers: layers.size,
    verticalDistribution,
    gridLike
  };
}

/**
 * Check if positions form a grid
 */
function isGridLike(xPositions: number[], yPositions: number[]): boolean {
  if (xPositions.length < 9) return false; // Need at least 3x3 grid

  // Check for regular spacing
  const xSpacings = new Map<number, number>();
  for (let i = 1; i < xPositions.length; i++) {
    const spacing = Math.round((xPositions[i] - xPositions[i - 1]) / 10) * 10;
    xSpacings.set(spacing, (xSpacings.get(spacing) || 0) + 1);
  }

  const ySpacings = new Map<number, number>();
  for (let i = 1; i < yPositions.length; i++) {
    const spacing = Math.round((yPositions[i] - yPositions[i - 1]) / 10) * 10;
    ySpacings.set(spacing, (ySpacings.get(spacing) || 0) + 1);
  }

  // If one spacing dominates, it's grid-like
  const maxXSpacing = Math.max(...Array.from(xSpacings.values()));
  const maxYSpacing = Math.max(...Array.from(ySpacings.values()));

  return maxXSpacing > xPositions.length * 0.4 && maxYSpacing > yPositions.length * 0.4;
}

/**
 * Count object types
 */
function countObjectTypes(objects: Shape[]): {
  rectangles: number;
  circles: number;
  text: number;
  lines: number;
  other: number;
} {
  const counts = {
    rectangles: 0,
    circles: 0,
    text: 0,
    lines: 0,
    other: 0
  };

  for (const obj of objects) {
    switch (obj.type) {
      case 'rectangle':
      case 'roundRect':
        counts.rectangles++;
        break;
      case 'circle':
        counts.circles++;
        break;
      case 'text':
        counts.text++;
        break;
      case 'line':
        counts.lines++;
        break;
      default:
        counts.other++;
    }
  }

  return counts;
}

/**
 * Get typical features for a game type
 */
export function getGameTypeFeatures(type: GameType): GameFeatures {
  switch (type) {
    case 'platformer':
      return {
        commonAssets: ['platform sprites', 'character sprite', 'background layers', 'collectibles'],
        typicalObjects: ['platforms', 'player spawn', 'enemies', 'coins', 'hazards'],
        levelStructure: 'Horizontal layers with gaps, gravity-based movement',
        cameraStyle: 'Side-scrolling (horizontal follow)',
        controls: 'Left/Right movement, Jump, optional abilities'
      };

    case 'top-down':
      return {
        commonAssets: ['wall tiles', 'floor tiles', 'character sprite (4-8 directions)', 'objects'],
        typicalObjects: ['walls', 'doors', 'NPCs', 'items', 'decorations'],
        levelStructure: 'Room-based or open world, walls define boundaries',
        cameraStyle: 'Top-down (centered on player)',
        controls: '8-directional or 4-directional movement, interaction'
      };

    case 'puzzle':
      return {
        commonAssets: ['tile sprites', 'UI elements', 'particle effects'],
        typicalObjects: ['tiles', 'pieces', 'targets', 'obstacles'],
        levelStructure: 'Grid-based, discrete positions',
        cameraStyle: 'Static or gentle pan',
        controls: 'Point and click, or directional input for tile movement'
      };

    case 'shooter':
      return {
        commonAssets: ['ship/character sprite', 'enemy sprites', 'projectile sprites', 'effects'],
        typicalObjects: ['player', 'enemies', 'projectiles', 'power-ups'],
        levelStructure: 'Open space with waves of enemies',
        cameraStyle: 'Follow player or fixed camera',
        controls: 'Movement (4 or 8 directions), shoot, special abilities'
      };

    default:
      return {
        commonAssets: [],
        typicalObjects: [],
        levelStructure: 'Unknown',
        cameraStyle: 'Unknown',
        controls: 'Unknown'
      };
  }
}

/**
 * Get suggested next steps based on game type
 */
export function getSuggestedNextSteps(
  type: GameType,
  currentState: {
    hasPlayer?: boolean;
    hasEnemies?: boolean;
    hasTilemap?: boolean;
    hasAnimations?: boolean;
  }
): string[] {
  const suggestions: string[] = [];

  switch (type) {
    case 'platformer':
      if (!currentState.hasPlayer) {
        suggestions.push('Add player spawn point');
      }
      if (!currentState.hasTilemap) {
        suggestions.push('Generate platform terrain');
      }
      if (!currentState.hasEnemies) {
        suggestions.push('Place enemies on platforms');
      }
      suggestions.push('Add collectibles (coins, power-ups)');
      suggestions.push('Create parallax background layers');
      break;

    case 'top-down':
      if (!currentState.hasTilemap) {
        suggestions.push('Generate dungeon or room layout');
      }
      suggestions.push('Add walls and boundaries');
      suggestions.push('Place doors and transitions');
      if (!currentState.hasPlayer) {
        suggestions.push('Add player spawn point');
      }
      suggestions.push('Add NPCs or enemies');
      break;

    case 'puzzle':
      if (!currentState.hasTilemap) {
        suggestions.push('Create puzzle grid');
      }
      suggestions.push('Add puzzle pieces or tiles');
      suggestions.push('Define win condition areas');
      suggestions.push('Add UI elements (score, moves)');
      break;

    case 'shooter':
      if (!currentState.hasPlayer) {
        suggestions.push('Add player ship/character');
      }
      suggestions.push('Add enemy spawn points');
      suggestions.push('Create enemy wave patterns');
      suggestions.push('Add power-up spawners');
      suggestions.push('Create background with parallax');
      break;

    default:
      suggestions.push('Add more content to help detect game type');
      suggestions.push('Consider what kind of game you want to build');
  }

  return suggestions;
}

/**
 * Analyze game complexity
 */
export function analyzeGameComplexity(
  objectCount: number,
  tilemapSize?: { width: number; height: number },
  animationCount: number = 0
): 'low' | 'medium' | 'high' {
  let score = 0;

  // Object count
  if (objectCount > 200) score += 3;
  else if (objectCount > 100) score += 2;
  else if (objectCount > 30) score += 1;

  // Tilemap size
  if (tilemapSize) {
    const area = tilemapSize.width * tilemapSize.height;
    if (area > 10000) score += 3;
    else if (area > 2500) score += 2;
    else if (area > 400) score += 1;
  }

  // Animations
  if (animationCount > 10) score += 2;
  else if (animationCount > 3) score += 1;

  if (score >= 6) return 'high';
  if (score >= 3) return 'medium';
  return 'low';
}
</file>

<file path="src/services/ai/performanceProfiler.ts">
/**
 * Performance Profiler Service
 * Analyzes canvas performance and identifies bottlenecks
 * PR-32: AI Game-Aware Enhancement
 */

import type { Shape } from '../../types/canvas';

export interface PerformanceReport {
  fps: number;
  renderTime: number; // ms per frame
  objectCount: number;
  tilemapSize?: { width: number; height: number };
  tileCount: number;
  drawCalls: number;
  memoryUsage?: number; // MB (if available)
  score: number; // 0-100
  rating: 'excellent' | 'good' | 'fair' | 'poor';
  bottlenecks: string[];
}

export interface PerformanceMetrics {
  fps: number[];
  frameTime: number[];
  timestamp: number[];
}

/**
 * Performance profiler class
 */
export class PerformanceProfiler {
  private metrics: PerformanceMetrics = {
    fps: [],
    frameTime: [],
    timestamp: []
  };

  private lastFrameTime: number = 0;
  private maxSamples: number = 60; // Keep last 60 samples (1 second at 60fps)

  /**
   * Record a frame
   */
  recordFrame(): void {
    const now = performance.now();
    
    if (this.lastFrameTime > 0) {
      const frameTime = now - this.lastFrameTime;
      const fps = 1000 / frameTime;

      this.metrics.fps.push(fps);
      this.metrics.frameTime.push(frameTime);
      this.metrics.timestamp.push(now);

      // Keep only recent samples
      if (this.metrics.fps.length > this.maxSamples) {
        this.metrics.fps.shift();
        this.metrics.frameTime.shift();
        this.metrics.timestamp.shift();
      }
    }

    this.lastFrameTime = now;
  }

  /**
   * Get current metrics
   */
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  /**
   * Get average FPS
   */
  getAverageFPS(): number {
    if (this.metrics.fps.length === 0) return 60;
    return this.metrics.fps.reduce((sum, fps) => sum + fps, 0) / this.metrics.fps.length;
  }

  /**
   * Get average frame time
   */
  getAverageFrameTime(): number {
    if (this.metrics.frameTime.length === 0) return 16.67;
    return this.metrics.frameTime.reduce((sum, time) => sum + time, 0) / this.metrics.frameTime.length;
  }

  /**
   * Get minimum FPS (worst performance)
   */
  getMinFPS(): number {
    if (this.metrics.fps.length === 0) return 60;
    return Math.min(...this.metrics.fps);
  }

  /**
   * Reset metrics
   */
  reset(): void {
    this.metrics = {
      fps: [],
      frameTime: [],
      timestamp: []
    };
    this.lastFrameTime = 0;
  }
}

/**
 * Analyze canvas performance
 */
export function profileCanvas(
  objects: Shape[],
  tilemapSize?: { width: number; height: number },
  tileCount: number = 0,
  currentFPS?: number
): PerformanceReport {
  const objectCount = objects.length;
  const bottlenecks: string[] = [];

  // Estimate draw calls
  let drawCalls = objectCount;
  
  // Count objects by type
  const typeCount: Record<string, number> = {};
  const colorCount: Record<string, number> = {};
  
  for (const obj of objects) {
    typeCount[obj.type] = (typeCount[obj.type] || 0) + 1;
    if (obj.fill) {
      colorCount[obj.fill] = (colorCount[obj.fill] || 0) + 1;
    }
  }

  // Add tilemap draw calls (chunked)
  if (tileCount > 0) {
    drawCalls += Math.ceil(tileCount / 1000); // Assuming 1000 tiles per chunk
  }

  // FPS (use provided or assume based on load)
  const fps = currentFPS || estimateFPS(objectCount, tileCount);

  // Estimate render time
  const renderTime = 1000 / fps;

  // Identify bottlenecks
  if (objectCount > 1000) {
    bottlenecks.push(`High object count (${objectCount}). Consider using tilemap for repetitive elements.`);
  }

  if (objectCount > 500 && objectCount < 1000) {
    bottlenecks.push(`Moderate object count (${objectCount}). Monitor performance.`);
  }

  if (tileCount > 50000) {
    bottlenecks.push(`Large tilemap (${tileCount} tiles). May cause lag on lower-end devices.`);
  }

  // Check for many unique colors (prevents batching)
  const uniqueColors = Object.keys(colorCount).length;
  if (uniqueColors > 20 && objectCount > 100) {
    bottlenecks.push(`Many unique colors (${uniqueColors}). Reduce color palette for better batching.`);
  }

  // Check for complex shapes
  const complexShapes = (typeCount.polygon || 0) + (typeCount.star || 0);
  if (complexShapes > 50) {
    bottlenecks.push(`Many complex shapes (${complexShapes}). Consider caching or simplifying.`);
  }

  // Memory estimation (rough)
  const memoryUsage = estimateMemoryUsage(objectCount, tileCount);

  // Calculate performance score (0-100)
  let score = 100;

  // Deduct for high object count
  if (objectCount > 1000) score -= 30;
  else if (objectCount > 500) score -= 15;
  else if (objectCount > 200) score -= 5;

  // Deduct for large tilemap
  if (tileCount > 50000) score -= 25;
  else if (tileCount > 10000) score -= 10;

  // Deduct for FPS
  if (fps < 30) score -= 30;
  else if (fps < 45) score -= 15;
  else if (fps < 55) score -= 5;

  // Deduct for draw calls
  if (drawCalls > 2000) score -= 20;
  else if (drawCalls > 1000) score -= 10;

  score = Math.max(0, score);

  // Rating
  let rating: 'excellent' | 'good' | 'fair' | 'poor';
  if (score >= 80) rating = 'excellent';
  else if (score >= 60) rating = 'good';
  else if (score >= 40) rating = 'fair';
  else rating = 'poor';

  return {
    fps,
    renderTime,
    objectCount,
    tilemapSize,
    tileCount,
    drawCalls,
    memoryUsage,
    score,
    rating,
    bottlenecks
  };
}

/**
 * Estimate FPS based on load
 */
function estimateFPS(objectCount: number, tileCount: number): number {
  let fps = 60;

  // Reduce FPS estimate based on load
  if (objectCount > 1000) fps -= 20;
  else if (objectCount > 500) fps -= 10;
  else if (objectCount > 200) fps -= 5;

  if (tileCount > 50000) fps -= 15;
  else if (tileCount > 10000) fps -= 5;

  return Math.max(fps, 15);
}

/**
 * Estimate memory usage (MB)
 */
function estimateMemoryUsage(objectCount: number, tileCount: number): number {
  // Rough estimates
  const objectMemory = objectCount * 0.001; // ~1KB per object
  const tileMemory = tileCount * 0.0001; // ~0.1KB per tile
  return objectMemory + tileMemory;
}

/**
 * Identify bottlenecks
 */
export function identifyBottlenecks(
  report: PerformanceReport
): Array<{ issue: string; severity: 'low' | 'medium' | 'high'; suggestion: string }> {
  const issues: Array<{ issue: string; severity: 'low' | 'medium' | 'high'; suggestion: string }> = [];

  // FPS issues
  if (report.fps < 30) {
    issues.push({
      issue: `Low FPS (${report.fps.toFixed(1)})`,
      severity: 'high',
      suggestion: 'Reduce object count or enable viewport culling'
    });
  } else if (report.fps < 45) {
    issues.push({
      issue: `Moderate FPS (${report.fps.toFixed(1)})`,
      severity: 'medium',
      suggestion: 'Consider optimizations for smoother performance'
    });
  }

  // Object count
  if (report.objectCount > 1000) {
    issues.push({
      issue: `Too many objects (${report.objectCount})`,
      severity: 'high',
      suggestion: 'Use tilemap for terrain instead of individual shapes'
    });
  } else if (report.objectCount > 500) {
    issues.push({
      issue: `High object count (${report.objectCount})`,
      severity: 'medium',
      suggestion: 'Consider grouping or caching static objects'
    });
  }

  // Tilemap size
  if (report.tileCount > 50000) {
    issues.push({
      issue: `Very large tilemap (${report.tileCount} tiles)`,
      severity: 'high',
      suggestion: 'Reduce tilemap size or implement tile chunking'
    });
  }

  // Draw calls
  if (report.drawCalls > 2000) {
    issues.push({
      issue: `Excessive draw calls (${report.drawCalls})`,
      severity: 'high',
      suggestion: 'Batch objects with same properties or use instancing'
    });
  }

  // Memory
  if (report.memoryUsage && report.memoryUsage > 100) {
    issues.push({
      issue: `High memory usage (${report.memoryUsage.toFixed(1)} MB)`,
      severity: 'medium',
      suggestion: 'Reduce object count or compress assets'
    });
  }

  return issues;
}

/**
 * Generate optimization suggestions
 */
export function generateOptimizationSuggestions(report: PerformanceReport): string[] {
  const suggestions: string[] = [];

  // General optimizations
  if (report.objectCount > 200) {
    suggestions.push('Enable viewport culling to hide off-screen objects');
    suggestions.push('Cache static objects that don\'t change');
  }

  if (report.tileCount > 5000) {
    suggestions.push('Implement tile chunking to load only visible areas');
  }

  if (report.fps < 45) {
    suggestions.push('Reduce shadow/glow effects');
    suggestions.push('Lower animation frame rates');
    suggestions.push('Use simpler shapes where possible');
  }

  // Specific to content
  if (report.objectCount > 500) {
    suggestions.push('Consider using sprite sheets instead of individual objects');
    suggestions.push('Group static decorations into single cached layer');
  }

  if (report.drawCalls > 1000) {
    suggestions.push('Batch objects with same color/properties');
    suggestions.push('Use texture atlasing for sprites');
  }

  return suggestions;
}

/**
 * Compare performance against benchmarks
 */
export function compareAgainstBenchmarks(report: PerformanceReport): {
  vsTarget: string;
  vsTypical: string;
  recommendation: string;
} {
  // Target: 60 FPS with < 1000 objects
  const targetScore = 80;
  const vsTarget = report.score >= targetScore ? 'Above target' : 'Below target';

  // Typical: 45+ FPS with moderate content
  const typicalScore = 60;
  const vsTypical = report.score >= typicalScore ? 'Above typical' : 'Below typical';

  let recommendation: string;
  if (report.score >= 80) {
    recommendation = 'Performance is excellent. No optimizations needed.';
  } else if (report.score >= 60) {
    recommendation = 'Performance is good. Consider minor optimizations for smoother experience.';
  } else if (report.score >= 40) {
    recommendation = 'Performance is fair. Optimizations recommended.';
  } else {
    recommendation = 'Performance is poor. Significant optimizations required.';
  }

  return {
    vsTarget,
    vsTypical,
    recommendation
  };
}

// Global profiler instance
let globalProfiler: PerformanceProfiler | null = null;

/**
 * Get or create global profiler
 */
export function getProfiler(): PerformanceProfiler {
  if (!globalProfiler) {
    globalProfiler = new PerformanceProfiler();
  }
  return globalProfiler;
}

/**
 * Reset global profiler
 */
export function resetProfiler(): void {
  if (globalProfiler) {
    globalProfiler.reset();
  }
}
</file>

<file path="src/services/assets/animation.ts">
/**
 * Animation Service (PR-31)
 * Manages sprite animations - creation, storage, playback
 */

import { ref as dbRef, set, get, remove, update, push, onValue, off } from 'firebase/database'
import { db } from '../firebase'
import type {
  Animation,
  AnimationFrame,
  AnimationValidation,
  AnimationExport
} from '../../types/animation'
import type { Asset } from '../../types/asset'

/**
 * Generate unique animation ID
 */
function generateAnimationId(): string {
  return `anim-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}

/**
 * Validate animation data
 */
export function validateAnimation(
  animation: Partial<Animation>,
  spriteSheet?: Asset
): AnimationValidation {
  const errors: string[] = []
  const warnings: string[] = []
  const issues: Array<{ frameIndex: number; message: string }> = []

  // Check required fields
  if (!animation.name || animation.name.trim().length === 0) {
    errors.push('Animation name is required')
  }

  if (!animation.spriteSheetId) {
    errors.push('Sprite sheet ID is required')
  }

  if (!animation.frames || animation.frames.length === 0) {
    errors.push('Animation must have at least one frame')
  }

  if (animation.fps && (animation.fps < 1 || animation.fps > 60)) {
    errors.push('FPS must be between 1 and 60')
  }

  // Validate frames against sprite sheet bounds
  if (spriteSheet && animation.frames) {
    animation.frames.forEach((frame, index) => {
      if (frame.x < 0 || frame.y < 0) {
        issues.push({
          frameIndex: index,
          message: 'Frame coordinates cannot be negative'
        })
      }

      if (frame.x + frame.width > spriteSheet.metadata.width) {
        issues.push({
          frameIndex: index,
          message: 'Frame extends beyond sprite sheet width'
        })
      }

      if (frame.y + frame.height > spriteSheet.metadata.height) {
        issues.push({
          frameIndex: index,
          message: 'Frame extends beyond sprite sheet height'
        })
      }

      if (frame.duration && frame.duration < 16) {
        warnings.push(`Frame ${index} has very short duration (${frame.duration}ms)`)
      }
    })
  }

  // Warning for very long animations
  if (animation.frames && animation.frames.length > 100) {
    warnings.push('Animation has more than 100 frames, this may impact performance')
  }

  return {
    valid: errors.length === 0 && issues.length === 0,
    errors,
    warnings,
    issues: issues.length > 0 ? issues : undefined
  }
}

/**
 * Create a new animation
 */
export async function createAnimation(
  userId: string,
  data: {
    name: string
    spriteSheetId: string
    frames: AnimationFrame[]
    fps?: number
    loop?: boolean
    canvasId?: string
  }
): Promise<Animation> {
  const animationId = generateAnimationId()
  const now = Date.now()

  const animation: Animation = {
    id: animationId,
    userId,
    canvasId: data.canvasId,
    name: data.name,
    spriteSheetId: data.spriteSheetId,
    frames: data.frames,
    fps: data.fps || 12,
    loop: data.loop !== undefined ? data.loop : true,
    createdAt: now,
    updatedAt: now
  }

  // Validate before saving
  const validation = validateAnimation(animation)
  if (!validation.valid) {
    throw new Error(`Invalid animation: ${validation.errors.join(', ')}`)
  }

  // Save to Firebase
  const path = data.canvasId 
    ? `animations/${data.canvasId}/${animationId}`
    : `animations/${userId}/${animationId}`
  
  const animationRef = dbRef(db, path)
  await set(animationRef, animation)

  return animation
}

/**
 * Update an existing animation
 */
export async function updateAnimation(
  animationId: string,
  userId: string,
  updates: Partial<Pick<Animation, 'name' | 'frames' | 'fps' | 'loop'>>,
  canvasId?: string
): Promise<void> {
  const path = canvasId 
    ? `animations/${canvasId}/${animationId}`
    : `animations/${userId}/${animationId}`
  
  const animationRef = dbRef(db, path)
  
  // Check if exists
  const snapshot = await get(animationRef)
  if (!snapshot.exists()) {
    throw new Error('Animation not found')
  }

  const existingAnimation = snapshot.val() as Animation

  // Validate ownership
  if (existingAnimation.userId !== userId) {
    throw new Error('Permission denied')
  }

  // Merge updates and validate
  const updatedAnimation = { ...existingAnimation, ...updates }
  const validation = validateAnimation(updatedAnimation)
  if (!validation.valid) {
    throw new Error(`Invalid animation: ${validation.errors.join(', ')}`)
  }

  await update(animationRef, {
    ...updates,
    updatedAt: Date.now()
  })
}

/**
 * Delete an animation
 */
export async function deleteAnimation(
  animationId: string,
  userId: string,
  canvasId?: string
): Promise<void> {
  const path = canvasId 
    ? `animations/${canvasId}/${animationId}`
    : `animations/${userId}/${animationId}`
  
  const animationRef = dbRef(db, path)
  
  // Check ownership
  const snapshot = await get(animationRef)
  if (!snapshot.exists()) {
    throw new Error('Animation not found')
  }

  const animation = snapshot.val() as Animation
  if (animation.userId !== userId) {
    throw new Error('Permission denied')
  }

  await remove(animationRef)

  // TODO: Clean up any canvas objects using this animation
}

/**
 * Get animation by ID
 */
export async function getAnimation(
  animationId: string,
  userIdOrCanvasId: string,
  isCanvasId: boolean = false
): Promise<Animation | null> {
  const path = isCanvasId 
    ? `animations/${userIdOrCanvasId}/${animationId}`
    : `animations/${userIdOrCanvasId}/${animationId}`
  
  const animationRef = dbRef(db, path)
  const snapshot = await get(animationRef)
  
  if (!snapshot.exists()) {
    return null
  }

  return snapshot.val() as Animation
}

/**
 * Get all animations for a user
 */
export async function getUserAnimations(userId: string): Promise<Animation[]> {
  const animationsRef = dbRef(db, `animations/${userId}`)
  const snapshot = await get(animationsRef)
  
  if (!snapshot.exists()) {
    return []
  }

  const animationsData = snapshot.val()
  return Object.values(animationsData) as Animation[]
}

/**
 * Get all animations for a canvas
 */
export async function getCanvasAnimations(canvasId: string): Promise<Animation[]> {
  const animationsRef = dbRef(db, `animations/${canvasId}`)
  const snapshot = await get(animationsRef)
  
  if (!snapshot.exists()) {
    return []
  }

  const animationsData = snapshot.val()
  return Object.values(animationsData) as Animation[]
}

/**
 * Subscribe to animation changes
 */
export function subscribeToAnimations(
  userIdOrCanvasId: string,
  callback: (animations: Animation[]) => void,
  isCanvasId: boolean = false
): () => void {
  const path = `animations/${userIdOrCanvasId}`
  const animationsRef = dbRef(db, path)

  const handler = (snapshot: any) => {
    if (!snapshot.exists()) {
      callback([])
      return
    }

    const animationsData = snapshot.val()
    const animations = Object.values(animationsData) as Animation[]
    callback(animations)
  }

  onValue(animationsRef, handler)

  // Return unsubscribe function
  return () => off(animationsRef, 'value', handler)
}

/**
 * Duplicate an animation
 */
export async function duplicateAnimation(
  animationId: string,
  userId: string,
  newName: string,
  canvasId?: string
): Promise<Animation> {
  const path = canvasId 
    ? `animations/${canvasId}/${animationId}`
    : `animations/${userId}/${animationId}`
  
  const animationRef = dbRef(db, path)
  const snapshot = await get(animationRef)
  
  if (!snapshot.exists()) {
    throw new Error('Animation not found')
  }

  const originalAnimation = snapshot.val() as Animation

  // Create new animation with same data
  return createAnimation(userId, {
    name: newName,
    spriteSheetId: originalAnimation.spriteSheetId,
    frames: [...originalAnimation.frames],
    fps: originalAnimation.fps,
    loop: originalAnimation.loop,
    canvasId: canvasId
  })
}

/**
 * Export animation to game engine format
 */
export function exportAnimation(
  animation: Animation,
  spriteSheetUrl: string,
  format: 'godot' | 'unity' | 'phaser' | 'generic' = 'generic'
): AnimationExport {
  const baseExport: AnimationExport = {
    name: animation.name,
    spriteSheet: spriteSheetUrl,
    frames: animation.frames.map(f => ({
      x: f.x,
      y: f.y,
      w: f.width,
      h: f.height
    })),
    frameRate: animation.fps,
    loop: animation.loop
  }

  // Format-specific adjustments can be added here
  // For now, all formats use the same structure

  return baseExport
}

/**
 * Auto-generate animation from sprite sheet grid
 * Slices sprite sheet into frames based on grid dimensions
 */
export function autoGenerateFrames(
  spriteSheetWidth: number,
  spriteSheetHeight: number,
  frameWidth: number,
  frameHeight: number,
  options: {
    spacing?: number
    margin?: number
    maxFrames?: number
  } = {}
): AnimationFrame[] {
  const spacing = options.spacing || 0
  const margin = options.margin || 0
  const frames: AnimationFrame[] = []

  let y = margin
  while (y + frameHeight <= spriteSheetHeight) {
    let x = margin
    while (x + frameWidth <= spriteSheetWidth) {
      frames.push({
        x,
        y,
        width: frameWidth,
        height: frameHeight
      })

      if (options.maxFrames && frames.length >= options.maxFrames) {
        return frames
      }

      x += frameWidth + spacing
    }
    y += frameHeight + spacing
  }

  return frames
}

/**
 * Calculate animation duration in milliseconds
 */
export function calculateAnimationDuration(animation: Animation): number {
  const frameDuration = 1000 / animation.fps
  
  return animation.frames.reduce((total, frame) => {
    return total + (frame.duration || frameDuration)
  }, 0)
}

/**
 * Get frame at specific time
 */
export function getFrameAtTime(animation: Animation, timeMs: number): number {
  const frameDuration = 1000 / animation.fps
  let elapsed = 0
  
  for (let i = 0; i < animation.frames.length; i++) {
    const duration = animation.frames[i].duration || frameDuration
    elapsed += duration
    
    if (elapsed > timeMs) {
      return i
    }
  }

  // If looping, wrap around
  if (animation.loop) {
    const totalDuration = calculateAnimationDuration(animation)
    const wrappedTime = timeMs % totalDuration
    return getFrameAtTime(animation, wrappedTime)
  }

  // Return last frame if not looping
  return animation.frames.length - 1
}
</file>

<file path="src/services/assets/assetFolders.ts">
/**
 * Asset Folder System Service
 * Organize assets in folders with nested hierarchy
 * PR-31: Asset Organization
 */

import { ref, set, get, remove, query, orderByChild, equalTo, update } from 'firebase/database'
import { db } from '../firebase'

export interface AssetFolder {
  id: string
  userId: string
  name: string
  parentId: string | null // null = root level
  color?: string // optional color for visual organization
  icon?: string // optional icon emoji
  createdAt: number
  updatedAt: number
}

/**
 * Generate unique folder ID
 */
function generateFolderId(): string {
  return `folder-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}

/**
 * Create a new folder
 */
export async function createFolder(
  userId: string,
  name: string,
  parentId: string | null = null,
  options: { color?: string; icon?: string } = {}
): Promise<string> {
  const folderId = generateFolderId()
  const now = Date.now()

  const folder: AssetFolder = {
    id: folderId,
    userId,
    name,
    parentId,
    color: options.color,
    icon: options.icon,
    createdAt: now,
    updatedAt: now,
  }

  const folderRef = ref(db, `assetFolders/${folderId}`)
  await set(folderRef, folder)

  return folderId
}

/**
 * Get all folders for a user
 */
export async function getUserFolders(userId: string): Promise<AssetFolder[]> {
  const foldersRef = ref(db, 'assetFolders')
  const userQuery = query(foldersRef, orderByChild('userId'), equalTo(userId))
  
  const snapshot = await get(userQuery)
  
  if (!snapshot.exists()) {
    return []
  }

  const folders: AssetFolder[] = []
  snapshot.forEach((childSnapshot) => {
    folders.push(childSnapshot.val() as AssetFolder)
  })

  return folders
}

/**
 * Get folders by parent ID
 */
export async function getFoldersByParent(
  userId: string,
  parentId: string | null
): Promise<AssetFolder[]> {
  const folders = await getUserFolders(userId)
  return folders.filter((folder) => folder.parentId === parentId)
}

/**
 * Get folder by ID
 */
export async function getFolder(folderId: string): Promise<AssetFolder | null> {
  const folderRef = ref(db, `assetFolders/${folderId}`)
  const snapshot = await get(folderRef)
  
  if (!snapshot.exists()) {
    return null
  }

  return snapshot.val() as AssetFolder
}

/**
 * Update folder properties
 */
export async function updateFolder(
  folderId: string,
  updates: Partial<Omit<AssetFolder, 'id' | 'userId' | 'createdAt'>>
): Promise<void> {
  const folderRef = ref(db, `assetFolders/${folderId}`)
  
  const updatesWithTimestamp = {
    ...updates,
    updatedAt: Date.now(),
  }

  await update(folderRef, updatesWithTimestamp)
}

/**
 * Delete folder and move contents to parent or root
 */
export async function deleteFolder(
  folderId: string,
  userId: string
): Promise<void> {
  // Get folder to find its parent
  const folder = await getFolder(folderId)
  if (!folder) {
    throw new Error('Folder not found')
  }

  // Move all assets in this folder to parent or root
  const assetsRef = ref(db, 'assets')
  const assetsSnapshot = await get(assetsRef)
  
  if (assetsSnapshot.exists()) {
    const updates: Record<string, any> = {}
    
    assetsSnapshot.forEach((childSnapshot) => {
      const asset = childSnapshot.val()
      if (asset.userId === userId && asset.folderId === folderId) {
        // Move to parent folder or root
        updates[`assets/${childSnapshot.key}/folderId`] = folder.parentId || null
      }
    })

    if (Object.keys(updates).length > 0) {
      await Promise.all(
        Object.entries(updates).map(([path, value]) => 
          set(ref(db, path), value)
        )
      )
    }
  }

  // Move all subfolders to parent
  const subfolders = await getFoldersByParent(userId, folderId)
  await Promise.all(
    subfolders.map((subfolder) =>
      updateFolder(subfolder.id, { parentId: folder.parentId })
    )
  )

  // Delete the folder
  const folderRef = ref(db, `assetFolders/${folderId}`)
  await remove(folderRef)
}

/**
 * Move asset to a folder
 */
export async function moveAssetToFolder(
  assetId: string,
  folderId: string | null
): Promise<void> {
  const assetRef = ref(db, `assets/${assetId}`)
  await update(assetRef, { folderId: folderId || null })
}

/**
 * Get all assets in a folder
 */
export async function getAssetsInFolder(
  userId: string,
  folderId: string | null
): Promise<string[]> {
  const assetsRef = ref(db, 'assets')
  const snapshot = await get(assetsRef)
  
  if (!snapshot.exists()) {
    return []
  }

  const assetIds: string[] = []
  snapshot.forEach((childSnapshot) => {
    const asset = childSnapshot.val()
    if (asset.userId === userId) {
      const assetFolderId = asset.folderId || null
      if (assetFolderId === folderId) {
        assetIds.push(childSnapshot.key!)
      }
    }
  })

  return assetIds
}

/**
 * Get folder hierarchy path (for breadcrumbs)
 */
export async function getFolderPath(folderId: string): Promise<AssetFolder[]> {
  const path: AssetFolder[] = []
  let currentId: string | null = folderId

  while (currentId) {
    const folder = await getFolder(currentId)
    if (!folder) break
    
    path.unshift(folder) // Add to beginning
    currentId = folder.parentId
  }

  return path
}

/**
 * Check if folder name is unique within parent
 */
export async function isFolderNameUnique(
  userId: string,
  name: string,
  parentId: string | null,
  excludeFolderId?: string
): Promise<boolean> {
  const folders = await getFoldersByParent(userId, parentId)
  
  return !folders.some(
    (folder) =>
      folder.name.toLowerCase() === name.toLowerCase() &&
      folder.id !== excludeFolderId
  )
}

/**
 * Rename folder
 */
export async function renameFolder(
  folderId: string,
  newName: string,
  userId: string
): Promise<void> {
  const folder = await getFolder(folderId)
  if (!folder) {
    throw new Error('Folder not found')
  }

  // Check if name is unique
  const isUnique = await isFolderNameUnique(
    userId,
    newName,
    folder.parentId,
    folderId
  )

  if (!isUnique) {
    throw new Error('A folder with this name already exists in the same location')
  }

  await updateFolder(folderId, { name: newName })
}

/**
 * Move folder to new parent
 */
export async function moveFolder(
  folderId: string,
  newParentId: string | null
): Promise<void> {
  const folder = await getFolder(folderId)
  if (!folder) {
    throw new Error('Folder not found')
  }

  // Prevent circular references
  if (newParentId) {
    let checkParentId: string | null = newParentId
    while (checkParentId) {
      if (checkParentId === folderId) {
        throw new Error('Cannot move folder into itself or its descendant')
      }
      const parentFolder = await getFolder(checkParentId)
      checkParentId = parentFolder?.parentId || null
    }
  }

  await updateFolder(folderId, { parentId: newParentId })
}
</file>

<file path="src/services/assets/assetUpload.ts">
/**
 * Asset Upload Service (PR-31)
 * Handles uploading, storing, and managing game assets (sprite sheets, tilesets, etc.)
 */

import { ref as storageRef, uploadBytesResumable, getDownloadURL, deleteObject } from 'firebase/storage'
import { ref as dbRef, set, get, remove, update, query, orderByChild, equalTo } from 'firebase/database'
import { storage, db } from '../firebase'
import type {
  Asset,
  AssetType,
  AssetMetadata,
  AssetValidation,
  AssetUploadProgress,
  TilesetMetadata,
  SpriteSheetMetadata
} from '../../types/asset'

/**
 * Maximum file size for uploads (10MB)
 */
const MAX_FILE_SIZE = 10 * 1024 * 1024

/**
 * Allowed MIME types for assets
 */
const ALLOWED_MIME_TYPES = [
  'image/png',
  'image/jpeg',
  'image/jpg',
  'image/webp',
  'image/gif'
]

/**
 * Generate unique asset ID
 */
function generateAssetId(): string {
  return `asset-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}

/**
 * Validate file before upload
 */
export function validateAssetFile(file: File): AssetValidation {
  const errors: string[] = []
  const warnings: string[] = []

  // Check file size
  if (file.size > MAX_FILE_SIZE) {
    errors.push(`File size exceeds maximum of ${MAX_FILE_SIZE / 1024 / 1024}MB`)
  }

  // Check MIME type
  if (!ALLOWED_MIME_TYPES.includes(file.type)) {
    errors.push(`File type ${file.type} is not supported. Allowed types: PNG, JPG, WEBP, GIF`)
  }

  // Warning for large files
  if (file.size > 5 * 1024 * 1024) {
    warnings.push('Large files may take longer to load in your canvases')
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings
  }
}

/**
 * Extract image metadata from file
 */
export async function extractImageMetadata(file: File): Promise<AssetMetadata> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    const url = URL.createObjectURL(file)

    img.onload = () => {
      URL.revokeObjectURL(url)
      resolve({
        width: img.width,
        height: img.height,
        fileSize: file.size,
        mimeType: file.type
      })
    }

    img.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error('Failed to load image'))
    }

    img.src = url
  })
}

/**
 * Generate thumbnail from image file
 */
export async function generateThumbnail(file: File, maxSize: number = 200): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    const url = URL.createObjectURL(file)

    img.onload = () => {
      URL.revokeObjectURL(url)

      // Create canvas for thumbnail
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      if (!ctx) {
        reject(new Error('Failed to get canvas context'))
        return
      }

      // Calculate thumbnail size maintaining aspect ratio
      const scale = Math.min(maxSize / img.width, maxSize / img.height)
      canvas.width = img.width * scale
      canvas.height = img.height * scale

      // Draw and export
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
      resolve(canvas.toDataURL('image/png'))
    }

    img.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error('Failed to load image for thumbnail'))
    }

    img.src = url
  })
}

/**
 * Upload asset to Firebase Storage
 */
export async function uploadAsset(
  file: File,
  userId: string,
  options: {
    name?: string
    type?: AssetType
    tags?: string[]
    folderId?: string
    tilesetMetadata?: TilesetMetadata
    spriteSheetMetadata?: SpriteSheetMetadata
    onProgress?: (progress: AssetUploadProgress) => void
  } = {}
): Promise<Asset> {
  // Validate file
  const validation = validateAssetFile(file)
  if (!validation.valid) {
    throw new Error(validation.errors.join(', '))
  }

  const assetId = generateAssetId()
  const fileName = file.name
  const assetName = options.name || fileName.replace(/\.[^/.]+$/, '') // remove extension

  // Extract image metadata
  const metadata = await extractImageMetadata(file)

  // Generate thumbnail
  let thumbnailUrl: string | undefined
  try {
    thumbnailUrl = await generateThumbnail(file)
  } catch (error) {
    console.warn('Failed to generate thumbnail:', error)
  }

  // Upload to Firebase Storage
  const storagePath = `assets/${userId}/${assetId}`
  const fileRef = storageRef(storage, storagePath)

  return new Promise((resolve, reject) => {
    const uploadTask = uploadBytesResumable(fileRef, file, {
      contentType: file.type,
      customMetadata: {
        originalName: fileName,
        assetId: assetId
      }
    })

    uploadTask.on(
      'state_changed',
      (snapshot) => {
        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100
        options.onProgress?.({
          assetId,
          fileName,
          progress,
          status: 'uploading'
        })
      },
      (error) => {
        reject(new Error(`Upload failed: ${error.message}`))
      },
      async () => {
        try {
          // Get download URL
          const url = await getDownloadURL(fileRef)

          // Auto-detect asset type if not provided
          const assetType = options.type || detectAssetType(metadata, options)

          // Create asset document (filter out undefined values for Firebase)
          const asset: Asset = {
            id: assetId,
            userId,
            name: assetName,
            type: assetType,
            url,
            thumbnailUrl,
            metadata,
            uploadedAt: Date.now(),
            updatedAt: Date.now(),
            tags: options.tags || [],
            ...(options.tilesetMetadata && { tilesetMetadata: options.tilesetMetadata }),
            ...(options.spriteSheetMetadata && { spriteSheetMetadata: options.spriteSheetMetadata }),
            ...(options.folderId && { folderId: options.folderId })
          }

          // Save to Firebase Database
          const assetRef = dbRef(db, `assets/${userId}/${assetId}`)
          await set(assetRef, asset)

          options.onProgress?.({
            assetId,
            fileName,
            progress: 100,
            status: 'complete'
          })

          resolve(asset)
        } catch (error) {
          reject(error)
        }
      }
    )
  })
}

/**
 * Auto-detect asset type based on metadata
 */
function detectAssetType(
  metadata: AssetMetadata,
  options: { tilesetMetadata?: TilesetMetadata; spriteSheetMetadata?: SpriteSheetMetadata }
): AssetType {
  if (options.tilesetMetadata) return 'tileset'
  if (options.spriteSheetMetadata) return 'spritesheet'
  
  // Default to 'image' for now
  // Could add more sophisticated detection based on dimensions, patterns, etc.
  return 'image'
}

/**
 * Delete asset from storage and database
 */
export async function deleteAsset(assetId: string, userId: string): Promise<void> {
  try {
    // Get asset data first
    const assetRef = dbRef(db, `assets/${userId}/${assetId}`)
    const snapshot = await get(assetRef)
    
    if (!snapshot.exists()) {
      throw new Error('Asset not found')
    }

    const asset = snapshot.val() as Asset

    // Delete from Storage
    const fileRef = storageRef(storage, `assets/${userId}/${assetId}`)
    await deleteObject(fileRef)

    // Delete from Database
    await remove(assetRef)

    // TODO: Clean up references in canvases
    // This could be done in a separate cleanup service
  } catch (error) {
    throw new Error(`Failed to delete asset: ${error}`)
  }
}

/**
 * Update asset metadata
 */
export async function updateAssetMetadata(
  assetId: string,
  userId: string,
  updates: Partial<Pick<Asset, 'name' | 'tags' | 'folderId' | 'tilesetMetadata' | 'spriteSheetMetadata'>>
): Promise<void> {
  const assetRef = dbRef(db, `assets/${userId}/${assetId}`)
  
  // Check ownership
  const snapshot = await get(assetRef)
  if (!snapshot.exists()) {
    throw new Error('Asset not found')
  }

  await update(assetRef, {
    ...updates,
    updatedAt: Date.now()
  })
}

/**
 * Get asset by ID
 */
export async function getAsset(assetId: string, userId: string): Promise<Asset | null> {
  const assetRef = dbRef(db, `assets/${userId}/${assetId}`)
  const snapshot = await get(assetRef)
  
  if (!snapshot.exists()) {
    return null
  }

  return snapshot.val() as Asset
}

/**
 * Get all assets for a user
 */
export async function getUserAssets(userId: string): Promise<Asset[]> {
  const assetsRef = dbRef(db, `assets/${userId}`)
  const snapshot = await get(assetsRef)
  
  if (!snapshot.exists()) {
    return []
  }

  const assetsData = snapshot.val()
  return Object.values(assetsData) as Asset[]
}

/**
 * Replace asset file (keep metadata)
 */
export async function replaceAssetFile(
  assetId: string,
  userId: string,
  newFile: File,
  onProgress?: (progress: AssetUploadProgress) => void
): Promise<Asset> {
  // Get existing asset
  const existingAsset = await getAsset(assetId, userId)
  if (!existingAsset) {
    throw new Error('Asset not found')
  }

  // Validate new file
  const validation = validateAssetFile(newFile)
  if (!validation.valid) {
    throw new Error(validation.errors.join(', '))
  }

  // Extract new metadata
  const metadata = await extractImageMetadata(newFile)

  // Generate new thumbnail
  const thumbnailUrl = await generateThumbnail(newFile)

  // Upload new file to Storage
  const storagePath = `assets/${userId}/${assetId}`
  const fileRef = storageRef(storage, storagePath)

  return new Promise((resolve, reject) => {
    const uploadTask = uploadBytesResumable(fileRef, newFile, {
      contentType: newFile.type,
      customMetadata: {
        originalName: newFile.name,
        assetId: assetId
      }
    })

    uploadTask.on(
      'state_changed',
      (snapshot) => {
        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100
        onProgress?.({
          assetId,
          fileName: newFile.name,
          progress,
          status: 'uploading'
        })
      },
      (error) => {
        reject(new Error(`Upload failed: ${error.message}`))
      },
      async () => {
        try {
          const url = await getDownloadURL(fileRef)

          // Update asset in database
          const updatedAsset: Asset = {
            ...existingAsset,
            url,
            thumbnailUrl,
            metadata,
            updatedAt: Date.now()
          }

          const assetRef = dbRef(db, `assets/${userId}/${assetId}`)
          await set(assetRef, updatedAsset)

          onProgress?.({
            assetId,
            fileName: newFile.name,
            progress: 100,
            status: 'complete'
          })

          resolve(updatedAsset)
        } catch (error) {
          reject(error)
        }
      }
    )
  })
}
</file>

<file path="src/services/canvas/canvasManager.ts">
/**
 * Canvas Manager Service (PR-22)
 * Manages canvas CRUD operations, permissions, and thumbnails
 */

import { ref, set, get, remove, update } from 'firebase/database'
import { db } from '../firebase'
import type Konva from 'konva'

export interface CanvasMetadata {
  id: string
  name: string
  createdAt: number
  updatedAt: number
  thumbnail: string // base64 PNG
  ownerId: string
}

export interface CanvasPermission {
  role: 'owner' | 'editor' | 'viewer'
  grantedAt: number
}

/**
 * Generate unique canvas ID
 */
function generateCanvasId(): string {
  return `canvas-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}

/**
 * Create a new canvas with metadata and owner permission
 */
export async function createCanvas(
  name: string,
  userId: string
): Promise<CanvasMetadata> {
  const canvasId = generateCanvasId()
  const now = Date.now()

  const metadata: CanvasMetadata = {
    id: canvasId,
    name,
    createdAt: now,
    updatedAt: now,
    thumbnail: '',
    ownerId: userId,
  }

  try {
    // Create canvas metadata in users/{userId}/canvases/{canvasId}
    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)
    await set(userCanvasRef, metadata)

    // Create owner permission in canvases/{canvasId}/permissions/{userId}
    const permissionRef = ref(db, `canvases/${canvasId}/permissions/${userId}`)
    await set(permissionRef, {
      role: 'owner',
      grantedAt: now,
    } as CanvasPermission)

    console.log(`Canvas created: ${canvasId}`)
    return metadata
  } catch (error) {
    console.error('Error creating canvas:', error)
    throw error
  }
}

/**
 * Delete canvas and all associated data
 */
export async function deleteCanvas(
  canvasId: string,
  userId: string
): Promise<void> {
  try {
    // Remove canvas metadata from user's list
    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)
    await remove(userCanvasRef)

    // Remove all canvas data (objects, groups, permissions)
    const canvasRef = ref(db, `canvases/${canvasId}`)
    await remove(canvasRef)

    // Remove presence data for this canvas
    const presenceRef = ref(db, `presence/${canvasId}`)
    await remove(presenceRef)

    console.log(`Canvas deleted: ${canvasId}`)
  } catch (error) {
    console.error('Error deleting canvas:', error)
    throw error
  }
}

/**
 * Update canvas metadata (name, thumbnail)
 * Special handling for public-whiteboard
 */
export async function updateCanvas(
  canvasId: string,
  userId: string,
  updates: Partial<Pick<CanvasMetadata, 'name' | 'thumbnail'>>
): Promise<void> {
  try {
    // Collab Spaces: shared themed boards
    const collabSpaces = [
      'collab-art', 'collab-design', 'collab-education', 
      'collab-content', 'collab-gamedev', 
      'collab-architecture'
    ]
    
    if (collabSpaces.includes(canvasId)) {
      const publicRef = ref(db, `collab-spaces/${canvasId}/metadata`)
      await update(publicRef, {
        ...updates,
        updatedAt: Date.now(),
      })
      console.log(`Collab space ${canvasId} updated`)
      return
    }
    
    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)

    const updateData: any = {
      ...updates,
      updatedAt: Date.now(),
    }

    await update(userCanvasRef, updateData)
    console.log(`Canvas updated: ${canvasId}`)
  } catch (error) {
    console.error('Error updating canvas:', error)
    throw error
  }
}

/**
 * Get list of user's canvases (owned + shared)
 */
export async function getCanvasList(
  userId: string
): Promise<CanvasMetadata[]> {
  try {
    // Get canvases owned by user
    const userCanvasesRef = ref(db, `users/${userId}/canvases`)
    const snapshot = await get(userCanvasesRef)

    if (!snapshot.exists()) {
      return []
    }

    const canvasesData = snapshot.val()
    const canvases: CanvasMetadata[] = Object.values(canvasesData)

    // Sort by updatedAt (most recent first)
    canvases.sort((a, b) => b.updatedAt - a.updatedAt)

    return canvases
  } catch (error) {
    console.error('Error getting canvas list:', error)
    throw error
  }
}

/**
 * Duplicate canvas with all objects
 */
export async function duplicateCanvas(
  sourceCanvasId: string,
  userId: string
): Promise<CanvasMetadata> {
  try {
    // Get source canvas metadata
    const sourceMetadataRef = ref(db, `users/${userId}/canvases/${sourceCanvasId}`)
    const metadataSnapshot = await get(sourceMetadataRef)

    if (!metadataSnapshot.exists()) {
      throw new Error('Source canvas not found')
    }

    const sourceMetadata = metadataSnapshot.val() as CanvasMetadata

    // Create new canvas
    const newCanvas = await createCanvas(
      `${sourceMetadata.name} (Copy)`,
      userId
    )

    // Copy all objects
    const sourceObjectsRef = ref(db, `canvases/${sourceCanvasId}/objects`)
    const objectsSnapshot = await get(sourceObjectsRef)

    if (objectsSnapshot.exists()) {
      const objects = objectsSnapshot.val()
      const newObjectsRef = ref(db, `canvases/${newCanvas.id}/objects`)
      await set(newObjectsRef, objects)
      console.log(`Copied objects from ${sourceCanvasId} to ${newCanvas.id}`)
    }

    // Copy all groups (if any)
    const sourceGroupsRef = ref(db, `canvases/${sourceCanvasId}/groups`)
    const groupsSnapshot = await get(sourceGroupsRef)

    if (groupsSnapshot.exists()) {
      const groups = groupsSnapshot.val()
      const newGroupsRef = ref(db, `canvases/${newCanvas.id}/groups`)
      await set(newGroupsRef, groups)
      console.log(`Copied groups from ${sourceCanvasId} to ${newCanvas.id}`)
    }

    console.log(`Canvas duplicated: ${sourceCanvasId} → ${newCanvas.id}`)
    return newCanvas
  } catch (error) {
    console.error('Error duplicating canvas:', error)
    throw error
  }
}

/**
 * Generate thumbnail from Konva Stage (300x200 PNG)
 */
export function generateThumbnail(stage: Konva.Stage | null): string {
  if (!stage) {
    return ''
  }

  try {
    // Create thumbnail at 300x200 resolution
    const thumbnailWidth = 300
    const thumbnailHeight = 200

    // Calculate scale to fit canvas in thumbnail
    const stageWidth = stage.width()
    const stageHeight = stage.height()
    const scale = Math.min(
      thumbnailWidth / stageWidth,
      thumbnailHeight / stageHeight
    )

    // Generate base64 PNG
    const dataURL = stage.toDataURL({
      pixelRatio: scale,
      mimeType: 'image/png',
      quality: 0.8,
    })

    return dataURL
  } catch (error) {
    console.error('Error generating thumbnail:', error)
    return ''
  }
}

/**
 * Get canvas by ID (checks if user has permission)
 */
export async function getCanvas(
  canvasId: string,
  userId: string
): Promise<CanvasMetadata | null> {
  try {
    // Collab Spaces: shared themed boards for all users
    const collabSpaces = [
      'public-board', // Main public collaboration board
      'collab-art', 'collab-design', 'collab-education', 
      'collab-content', 'collab-gamedev', 
      'collab-architecture'
    ]
    
    if (collabSpaces.includes(canvasId)) {
      const publicRef = ref(db, `collab-spaces/${canvasId}/metadata`)
      const snapshot = await get(publicRef)
      
      if (!snapshot.exists()) {
        // Create themed board if it doesn't exist
        let name: string
        if (canvasId === 'public-board') {
          name = 'Public Collaboration Board'
        } else {
          const themeName = canvasId.replace('collab-', '')
          name = `${themeName.charAt(0).toUpperCase() + themeName.slice(1)} Collab Space`
        }
        
        const publicCanvas: CanvasMetadata = {
          id: canvasId,
          name,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          thumbnail: '',
          ownerId: 'system',
        }
        await set(publicRef, publicCanvas)
        return publicCanvas
      }
      
      return snapshot.val() as CanvasMetadata
    }
    
    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)
    const snapshot = await get(userCanvasRef)

    if (!snapshot.exists()) {
      return null
    }

    return snapshot.val() as CanvasMetadata
  } catch (error) {
    console.error('Error getting canvas:', error)
    throw error
  }
}

/**
 * Check if user has permission to access canvas
 */
export async function hasCanvasPermission(
  canvasId: string,
  userId: string
): Promise<boolean> {
  try {
    const permissionRef = ref(db, `canvases/${canvasId}/permissions/${userId}`)
    const snapshot = await get(permissionRef)

    return snapshot.exists()
  } catch (error) {
    console.error('Error checking canvas permission:', error)
    return false
  }
}

/**
 * Get user's permission role for canvas
 */
export async function getCanvasPermission(
  canvasId: string,
  userId: string
): Promise<CanvasPermission | null> {
  try {
    const permissionRef = ref(db, `canvases/${canvasId}/permissions/${userId}`)
    const snapshot = await get(permissionRef)

    if (!snapshot.exists()) {
      return null
    }

    return snapshot.val() as CanvasPermission
  } catch (error) {
    console.error('Error getting canvas permission:', error)
    return null
  }
}
</file>

<file path="src/services/canvas/canvasSync.ts">
import { ref, set, update, remove, onValue, off } from 'firebase/database'
import { db } from '../firebase'
import type { CanvasObject } from '../../types/firebase'
import type { Shape, ShapeType } from '../../types/canvas'

/**
 * Compress shape data for Firebase storage
 * Uses short keys to reduce bandwidth: t, x, y, w, h, txt, f, s, sw
 * Phase 3: Now includes color properties (fill, stroke, strokeWidth)
 */
function compressShape(shape: Shape): CanvasObject {
  // Determine type code (PR-16: Added new shape types, PR-21: Added path)
  let typeCode: 'r' | 'c' | 't' | 'l' | 'pg' | 'st' | 'rr' | 'p' = 'r'
  switch (shape.type) {
    case 'rectangle': typeCode = 'r'; break
    case 'circle': typeCode = 'c'; break
    case 'text': typeCode = 't'; break
    case 'line': typeCode = 'l'; break
    case 'polygon': typeCode = 'pg'; break
    case 'star': typeCode = 'st'; break
    case 'roundRect': typeCode = 'rr'; break
    case 'path': typeCode = 'p'; break
  }

  const compressed: CanvasObject = {
    t: typeCode,
    x: Math.round(shape.x),
    y: Math.round(shape.y),
    w: Math.round(shape.width),
    h: Math.round(shape.height),
    f: shape.fill, // fill color (RGBA hex)
  }

  // Add text content for text shapes
  if (shape.type === 'text' && shape.text) {
    compressed.txt = shape.text
    // PR-25: Add text formatting properties
    if (shape.fontFamily) compressed.ff = shape.fontFamily
    if (shape.fontSize) compressed.fs = shape.fontSize
    if (shape.fontWeight && shape.fontWeight !== 'normal') compressed.fw = shape.fontWeight
    if (shape.fontStyle && shape.fontStyle !== 'normal') compressed.fst = shape.fontStyle
    if (shape.textAlign && shape.textAlign !== 'left') compressed.ta = shape.textAlign
    if (shape.textDecoration) compressed.td = shape.textDecoration
  }

  // Add rotation if present (backward compatibility)
  if (shape.rotation !== undefined) {
    compressed.rot = Math.round(shape.rotation)
  }

  // Add stroke properties if present
  if (shape.stroke !== undefined) {
    compressed.s = shape.stroke
  }
  if (shape.strokeWidth !== undefined) {
    compressed.sw = Math.round(shape.strokeWidth)
  }

  // PR-16: Add line-specific properties
  if (shape.type === 'line') {
    if (shape.points) {
      compressed.pts = shape.points.map(Math.round)
    }
    if (shape.arrows) {
      compressed.arr = {
        s: shape.arrows.start,
        e: shape.arrows.end,
      }
    }
  }

  // PR-16: Add polygon/star sides
  if ((shape.type === 'polygon' || shape.type === 'star') && shape.sides !== undefined) {
    compressed.sides = shape.sides
  }

  // PR-16: Add rounded rect corner radius
  if (shape.type === 'roundRect' && shape.cornerRadius !== undefined) {
    compressed.cr = Math.round(shape.cornerRadius)
  }

  // PR-17: Add z-index
  if (shape.zIndex !== undefined) {
    compressed.z = shape.zIndex
  }

  // PR-21: Add path-specific properties
  if (shape.type === 'path') {
    if (shape.points) {
      compressed.pts = shape.points.map(Math.round)
    }
    if (shape.tension !== undefined) {
      compressed.ten = shape.tension
    }
    if (shape.closed !== undefined) {
      compressed.cls = shape.closed
    }
  }

  return compressed
}

/**
 * Decompress Firebase data to client Shape format
 * Converts short keys back to full property names
 * Phase 3: Includes color properties with defaults for backward compatibility
 */
function decompressShape(id: string, data: CanvasObject): Shape {
  // Determine type from code (PR-16: Added new shape types, PR-21: Added path)
  let type: ShapeType = 'rectangle'
  switch (data.t) {
    case 'r': type = 'rectangle'; break
    case 'c': type = 'circle'; break
    case 't': type = 'text'; break
    case 'p': type = 'path'; break
    case 'l': type = 'line'; break
    case 'pg': type = 'polygon'; break
    case 'st': type = 'star'; break
    case 'rr': type = 'roundRect'; break
  }

  const shape: Shape = {
    id,
    type,
    x: data.x,
    y: data.y,
    width: data.w,
    height: data.h,
    rotation: data.rot ?? 0, // default to 0 if not present (backward compatibility)
    fill: data.f ?? '#3B82F6FF', // default blue if not present (backward compatibility)
  }

  // Add text content for text shapes
  if (data.txt) {
    shape.text = data.txt
    // PR-25: Add text formatting properties with defaults
    shape.fontFamily = data.ff || 'Inter, sans-serif'
    shape.fontSize = data.fs || 20
    shape.fontWeight = data.fw || 'normal'
    shape.fontStyle = data.fst || 'normal'
    shape.textAlign = data.ta || 'left'
    shape.textDecoration = data.td || ''
  }

  // Add stroke properties if present
  if (data.s) {
    shape.stroke = data.s
  }
  if (data.sw !== undefined) {
    shape.strokeWidth = data.sw
  }

  // PR-16: Add line-specific properties
  if (data.pts) {
    shape.points = data.pts
  }
  if (data.arr) {
    shape.arrows = {
      start: data.arr.s,
      end: data.arr.e,
    }
  }

  // PR-16: Add polygon/star sides
  if (data.sides !== undefined) {
    shape.sides = data.sides
  }

  // PR-16: Add rounded rect corner radius
  if (data.cr !== undefined) {
    shape.cornerRadius = data.cr
  }

  // PR-17: Add z-index (default to current timestamp if not present)
  shape.zIndex = data.z ?? Date.now()

  // PR-21: Add path-specific properties
  if (data.ten !== undefined) {
    shape.tension = data.ten
  }
  if (data.cls !== undefined) {
    shape.closed = data.cls
  }

  return shape
}

/**
 * Sync shape creation to Firebase
 */
export async function syncCreateShape(
  canvasId: string,
  shapeId: string,
  shape: Shape
): Promise<void> {
  try {
    const shapeRef = ref(db, `canvas/${canvasId}/objects/${shapeId}`)
    const compressed = compressShape(shape)
    await set(shapeRef, compressed)
  } catch (error) {
    console.error('Failed to sync create shape:', error)
    throw error
  }
}

/**
 * Sync shape updates to Firebase with timestamp for conflict resolution
 * Supports position, dimensions, rotation, and color updates (Phase 3)
 */
export async function syncUpdateShape(
  canvasId: string,
  shapeId: string,
  updates: Partial<Shape>,
  userId?: string
): Promise<void> {
  try {
    const shapeRef = ref(db, `canvas/${canvasId}/objects/${shapeId}`)
    
    // Build update object with compressed keys
    const compressed: Partial<CanvasObject> & { _ts?: number; _uid?: string } = {}
    
    if (updates.x !== undefined) {
      compressed.x = Math.round(updates.x)
    }
    if (updates.y !== undefined) {
      compressed.y = Math.round(updates.y)
    }
    if (updates.width !== undefined) {
      compressed.w = Math.round(updates.width)
    }
    if (updates.height !== undefined) {
      compressed.h = Math.round(updates.height)
    }
    if (updates.rotation !== undefined) {
      compressed.rot = Math.round(updates.rotation)
    }
    // Phase 3: Color properties
    if (updates.fill !== undefined) {
      compressed.f = updates.fill
    }
    if (updates.stroke !== undefined) {
      compressed.s = updates.stroke
    }
    if (updates.strokeWidth !== undefined) {
      compressed.sw = Math.round(updates.strokeWidth)
    }
    // PR-17: Z-index
    if (updates.zIndex !== undefined) {
      compressed.z = updates.zIndex
    }
    
    // Add timestamp and user ID for conflict resolution
    compressed._ts = Date.now()
    if (userId) {
      compressed._uid = userId
    }
    
    await update(shapeRef, compressed)
  } catch (error) {
    console.error('Failed to sync update shape:', error)
    throw error
  }
}

/**
 * Sync shape deletion to Firebase
 */
export async function syncDeleteShape(
  canvasId: string,
  shapeId: string
): Promise<void> {
  try {
    const shapeRef = ref(db, `canvas/${canvasId}/objects/${shapeId}`)
    await remove(shapeRef)
  } catch (error) {
    console.error('Failed to sync delete shape:', error)
    throw error
  }
}

/**
 * Sync bulk move operation to Firebase
 * Updates multiple shapes' positions at once
 */
export async function syncBulkMove(
  canvasId: string,
  updates: Record<string, { x: number; y: number }>
): Promise<void> {
  try {
    // Build a flat update object for Firebase
    const firebaseUpdates: Record<string, number> = {}
    
    Object.entries(updates).forEach(([shapeId, position]) => {
      firebaseUpdates[`canvas/${canvasId}/objects/${shapeId}/x`] = Math.round(position.x)
      firebaseUpdates[`canvas/${canvasId}/objects/${shapeId}/y`] = Math.round(position.y)
    })
    
    // Perform atomic multi-path update
    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to sync bulk move:', error)
    throw error
  }
}

/**
 * Sync bulk delete operation to Firebase
 * Deletes multiple shapes at once
 */
export async function syncBulkDelete(
  canvasId: string,
  shapeIds: string[]
): Promise<void> {
  try {
    // Build a flat update object with null values (deletes in Firebase)
    const firebaseUpdates: Record<string, null> = {}
    
    shapeIds.forEach((shapeId) => {
      firebaseUpdates[`canvas/${canvasId}/objects/${shapeId}`] = null
    })
    
    // Perform atomic multi-path delete
    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to sync bulk delete:', error)
    throw error
  }
}

/**
 * Sync batch create operation to Firebase (PR-13)
 * Creates multiple shapes at once for paste/duplicate operations
 */
export async function syncBatchCreate(
  canvasId: string,
  shapes: Shape[]
): Promise<void> {
  try {
    // Build a flat update object for all shapes
    const firebaseUpdates: Record<string, CanvasObject> = {}
    
    shapes.forEach((shape) => {
      const compressed = compressShape(shape)
      firebaseUpdates[`canvas/${canvasId}/objects/${shape.id}`] = compressed
    })
    
    // Perform atomic multi-path create
    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to sync batch create:', error)
    throw error
  }
}

/**
 * Sync z-index change to Firebase (PR-17)
 * Updates z-index for a single shape
 */
export async function syncZIndex(
  canvasId: string,
  shapeId: string,
  zIndex: number
): Promise<void> {
  try {
    const zIndexRef = ref(db, `canvas/${canvasId}/objects/${shapeId}/z`)
    await set(zIndexRef, zIndex)
  } catch (error) {
    console.error('Failed to sync z-index:', error)
    throw error
  }
}

/**
 * Sync selection state to presence
 * Selection is stored per-user in presence/${userId}/sel as an array
 */
export async function syncSelection(
  userId: string,
  selectedIds: string[] | null
): Promise<void> {
  try {
    const selectionRef = ref(db, `presence/${userId}/sel`)
    await set(selectionRef, selectedIds)
  } catch (error) {
    console.error('Failed to sync selection:', error)
    throw error
  }
}

/**
 * Subscribe to canvas object changes
 * Calls onCreate, onUpdate, onDelete callbacks for respective operations
 */
export function subscribeToCanvas(
  canvasId: string,
  callbacks: {
    onCreate?: (shape: Shape) => void
    onUpdate?: (shapeId: string, updates: Partial<Shape>) => void
    onDelete?: (shapeId: string) => void
  }
): () => void {
  const objectsRef = ref(db, `canvas/${canvasId}/objects`)
  
  // Track previous state to detect changes
  let previousShapes = new Map<string, CanvasObject>()

  const handleValue = (snapshot: any) => {
    const data = snapshot.val() as { [key: string]: CanvasObject } | null
    const currentShapes = new Map<string, CanvasObject>()

    if (data) {
      Object.entries(data).forEach(([id, shapeData]) => {
        currentShapes.set(id, shapeData)
      })
    }

    // Detect creates and updates
    currentShapes.forEach((shapeData, id) => {
      if (!previousShapes.has(id)) {
        // New shape created
        if (callbacks.onCreate) {
          const shape = decompressShape(id, shapeData)
          callbacks.onCreate(shape)
        }
      } else {
        // Check if shape was updated
        const prevData = previousShapes.get(id)!
        const hasChanges =
          prevData.x !== shapeData.x ||
          prevData.y !== shapeData.y ||
          prevData.w !== shapeData.w ||
          prevData.h !== shapeData.h ||
          prevData.rot !== shapeData.rot ||
          prevData.f !== shapeData.f ||
          prevData.s !== shapeData.s ||
          prevData.sw !== shapeData.sw ||
          prevData.z !== shapeData.z
        
        if (hasChanges) {
          if (callbacks.onUpdate) {
            const updates: Partial<Shape> = {}
            if (prevData.x !== shapeData.x) updates.x = shapeData.x
            if (prevData.y !== shapeData.y) updates.y = shapeData.y
            if (prevData.w !== shapeData.w) updates.width = shapeData.w
            if (prevData.h !== shapeData.h) updates.height = shapeData.h
            if (prevData.rot !== shapeData.rot) updates.rotation = shapeData.rot ?? 0
            // Phase 3: Color changes
            if (prevData.f !== shapeData.f) updates.fill = shapeData.f
            if (prevData.s !== shapeData.s) updates.stroke = shapeData.s
            if (prevData.sw !== shapeData.sw) updates.strokeWidth = shapeData.sw
            // Phase 3 PR-17: Z-index changes
            if (prevData.z !== shapeData.z) updates.zIndex = shapeData.z ?? Date.now()
            callbacks.onUpdate(id, updates)
          }
        }
      }
    })

    // Detect deletes
    previousShapes.forEach((_, id) => {
      if (!currentShapes.has(id)) {
        // Shape was deleted
        if (callbacks.onDelete) {
          callbacks.onDelete(id)
        }
      }
    })

    previousShapes = currentShapes
  }

  onValue(objectsRef, handleValue)

  // Return unsubscribe function
  return () => {
    off(objectsRef, 'value', handleValue)
  }
}
</file>

<file path="src/services/canvas/clipboard.ts">
// Clipboard Service for Copy/Paste/Duplicate Operations
// In-memory clipboard only (no native clipboard integration)

import type { Shape } from '../../types/canvas'
import { v4 as uuidv4 } from 'uuid'

/**
 * In-memory clipboard storage
 */
let clipboardData: Shape[] = []

/**
 * Offset for pasted/duplicated shapes (pixels)
 */
const PASTE_OFFSET = 20

/**
 * Copy shapes to in-memory clipboard
 * @param shapes - Array of shapes to copy
 */
export const copyShapes = (shapes: Shape[]): void => {
  // Deep clone the shapes to avoid reference issues
  clipboardData = shapes.map((shape) => ({ ...shape }))
}

/**
 * Get copied shapes from clipboard with new IDs and offset positions
 * @returns Array of new shapes with updated IDs and positions
 */
export const pasteShapes = (): Shape[] => {
  if (clipboardData.length === 0) {
    return []
  }

  // Create new shapes with new IDs and offset positions
  return clipboardData.map((shape) => ({
    ...shape,
    id: uuidv4(), // Generate new UUID
    x: shape.x + PASTE_OFFSET, // Offset position
    y: shape.y + PASTE_OFFSET,
  }))
}

/**
 * Duplicate shapes with small offset
 * @param shapes - Array of shapes to duplicate
 * @returns Array of new shapes with updated IDs and positions
 */
export const duplicateShapes = (shapes: Shape[]): Shape[] => {
  if (shapes.length === 0) {
    return []
  }

  // Create duplicates with new IDs and offset positions
  return shapes.map((shape) => ({
    ...shape,
    id: uuidv4(), // Generate new UUID
    x: shape.x + PASTE_OFFSET, // Offset position
    y: shape.y + PASTE_OFFSET,
  }))
}

/**
 * Check if clipboard has data
 * @returns True if clipboard contains shapes
 */
export const hasClipboardData = (): boolean => {
  return clipboardData.length > 0
}

/**
 * Clear clipboard data
 */
export const clearClipboard = (): void => {
  clipboardData = []
}
</file>

<file path="src/services/canvas/colorStorage.ts">
// Color Storage Service - Recent colors persistence (PR-15)

const RECENT_COLORS_KEY = 'collabcanvas_recent_colors'
const MAX_RECENT_COLORS = 5

/**
 * Save recent colors to localStorage
 */
export function saveRecentColors(colors: string[]): void {
  try {
    const toSave = colors.slice(0, MAX_RECENT_COLORS)
    localStorage.setItem(RECENT_COLORS_KEY, JSON.stringify(toSave))
  } catch (error) {
    console.error('Failed to save recent colors:', error)
  }
}

/**
 * Load recent colors from localStorage
 * Returns empty array if no colors saved or error occurs
 */
export function loadRecentColors(): string[] {
  try {
    const saved = localStorage.getItem(RECENT_COLORS_KEY)
    if (!saved) {
      return []
    }
    
    const parsed = JSON.parse(saved)
    if (!Array.isArray(parsed)) {
      return []
    }
    
    // Validate that all items are strings
    return parsed.filter((item) => typeof item === 'string').slice(0, MAX_RECENT_COLORS)
  } catch (error) {
    console.error('Failed to load recent colors:', error)
    return []
  }
}

/**
 * Clear recent colors from localStorage
 */
export function clearRecentColors(): void {
  try {
    localStorage.removeItem(RECENT_COLORS_KEY)
  } catch (error) {
    console.error('Failed to clear recent colors:', error)
  }
}
</file>

<file path="src/services/canvas/commandHistory.ts">
// Command History Manager for Undo/Redo (PR-14)

import type { Command } from '../../types/command'

/**
 * Maximum number of commands to keep in history
 */
const MAX_HISTORY_SIZE = 50

/**
 * History Manager class for managing undo/redo stacks
 * Per-user history (not global)
 */
export class HistoryManager {
  private undoStack: Command[] = []
  private redoStack: Command[] = []

  /**
   * Execute a command and add it to the undo stack
   * Clears the redo stack when a new command is executed
   */
  executeCommand(command: Command): void {
    // Execute the command
    command.execute()

    // Add to undo stack
    this.undoStack.push(command)

    // Limit stack size
    if (this.undoStack.length > MAX_HISTORY_SIZE) {
      this.undoStack.shift() // Remove oldest command
    }

    // Clear redo stack (new action invalidates redo history)
    this.redoStack = []
  }

  /**
   * Undo the last command
   * Moves command from undo stack to redo stack
   */
  undo(): void {
    const command = this.undoStack.pop()
    if (command) {
      command.undo()
      this.redoStack.push(command)
    }
  }

  /**
   * Redo the last undone command
   * Moves command from redo stack to undo stack
   */
  redo(): void {
    const command = this.redoStack.pop()
    if (command) {
      command.redo()
      this.undoStack.push(command)
    }
  }

  /**
   * Check if undo is available
   */
  canUndo(): boolean {
    return this.undoStack.length > 0
  }

  /**
   * Check if redo is available
   */
  canRedo(): boolean {
    return this.redoStack.length > 0
  }

  /**
   * Clear both undo and redo stacks
   */
  clear(): void {
    this.undoStack = []
    this.redoStack = []
  }

  /**
   * Get the size of the undo stack
   */
  getUndoStackSize(): number {
    return this.undoStack.length
  }

  /**
   * Get the size of the redo stack
   */
  getRedoStackSize(): number {
    return this.redoStack.length
  }
}

/**
 * Create a new HistoryManager instance
 */
export function createHistoryManager(): HistoryManager {
  return new HistoryManager()
}
</file>

<file path="src/services/canvas/conflictResolution.ts">
/**
 * Conflict Resolution Service
 * Handles concurrent edits with Last-Write-Wins (LWW) strategy
 * Uses timestamps to determine the most recent update
 */

import type { Shape } from '../../types/canvas'

export interface TimestampedUpdate {
  timestamp: number
  userId: string
  data: Partial<Shape>
}

/**
 * Merges shape updates using Last-Write-Wins strategy
 * @param current Current shape state
 * @param incoming Incoming update with timestamp
 * @param localTimestamp Timestamp of local update (if any)
 * @returns Merged shape with most recent values
 */
export function mergeShapeUpdates(
  current: Shape,
  incoming: Partial<Shape> & { _ts?: number; _uid?: string },
  localTimestamp?: number
): Shape {
  // If incoming update is older than local, keep local
  if (localTimestamp && incoming._ts && incoming._ts < localTimestamp) {
    return current
  }

  // Merge updates, keeping most recent for each property
  return {
    ...current,
    ...incoming,
  }
}

/**
 * Creates a timestamped update for conflict resolution
 * @param updates Shape property updates
 * @param userId User making the update
 * @returns Update with timestamp and user ID
 */
export function createTimestampedUpdate(
  updates: Partial<Shape>,
  userId: string
): Partial<Shape> & { _ts: number; _uid: string } {
  return {
    ...updates,
    _ts: Date.now(),
    _uid: userId,
  }
}

/**
 * Determines if an incoming update should be applied
 * @param localTimestamp Timestamp of local update
 * @param incomingTimestamp Timestamp of incoming update
 * @returns true if incoming should be applied, false otherwise
 */
export function shouldApplyIncomingUpdate(
  localTimestamp: number | undefined,
  incomingTimestamp: number | undefined
): boolean {
  // If no local timestamp, always apply incoming
  if (!localTimestamp) return true
  
  // If no incoming timestamp, don't apply
  if (!incomingTimestamp) return false
  
  // Apply if incoming is newer
  return incomingTimestamp > localTimestamp
}
</file>

<file path="src/services/collaboration/alignment.ts">
// Alignment Service - Calculations for aligning and distributing shapes (PR-18)

import type { Shape } from '../../types/canvas'

/**
 * Alignment type for positioning shapes
 */
export type AlignmentType = 'left' | 'center' | 'right' | 'top' | 'middle' | 'bottom'

/**
 * Distribution type for spacing shapes
 */
export type DistributionType = 'horizontal' | 'vertical'

/**
 * Result of alignment operation
 * Returns map of shape IDs to new positions
 */
export interface AlignmentResult {
  [shapeId: string]: { x: number; y: number }
}

/**
 * Align shapes to the left (leftmost edge)
 */
export function alignLeft(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}

  // Find the leftmost x coordinate
  const minX = Math.min(...shapes.map(s => s.x))

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: minX, y: shape.y }
  })

  return updates
}

/**
 * Align shapes to horizontal center
 */
export function alignCenter(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}

  // Calculate the average center x
  const centerXs = shapes.map(s => s.x + s.width / 2)
  const avgCenterX = centerXs.reduce((sum, x) => sum + x, 0) / centerXs.length

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: avgCenterX - shape.width / 2, y: shape.y }
  })

  return updates
}

/**
 * Align shapes to the right (rightmost edge)
 */
export function alignRight(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}

  // Find the rightmost x coordinate
  const maxX = Math.max(...shapes.map(s => s.x + s.width))

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: maxX - shape.width, y: shape.y }
  })

  return updates
}

/**
 * Align shapes to the top (topmost edge)
 */
export function alignTop(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}

  // Find the topmost y coordinate
  const minY = Math.min(...shapes.map(s => s.y))

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: shape.x, y: minY }
  })

  return updates
}

/**
 * Align shapes to vertical middle
 */
export function alignMiddle(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}

  // Calculate the average center y
  const centerYs = shapes.map(s => s.y + s.height / 2)
  const avgCenterY = centerYs.reduce((sum, y) => sum + y, 0) / centerYs.length

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: shape.x, y: avgCenterY - shape.height / 2 }
  })

  return updates
}

/**
 * Align shapes to the bottom (bottommost edge)
 */
export function alignBottom(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}

  // Find the bottommost y coordinate
  const maxY = Math.max(...shapes.map(s => s.y + s.height))

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: shape.x, y: maxY - shape.height }
  })

  return updates
}

/**
 * Distribute shapes horizontally with equal spacing
 * Requires at least 3 shapes
 */
export function distributeHorizontally(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 3) return {}

  // Sort shapes by x position
  const sortedShapes = [...shapes].sort((a, b) => a.x - b.x)

  // Find leftmost and rightmost edges
  const leftmost = sortedShapes[0]
  const rightmost = sortedShapes[sortedShapes.length - 1]
  const leftEdge = leftmost.x
  const rightEdge = rightmost.x + rightmost.width

  // Calculate total space between shapes
  const totalWidth = sortedShapes.reduce((sum, s) => sum + s.width, 0)
  const availableSpace = rightEdge - leftEdge - totalWidth
  const spacing = availableSpace / (sortedShapes.length - 1)

  // Create updates for all shapes (except first and last which stay in place)
  const updates: AlignmentResult = {}
  let currentX = leftEdge

  sortedShapes.forEach((shape, index) => {
    if (index === 0) {
      // First shape stays in place
      currentX += shape.width + spacing
    } else if (index === sortedShapes.length - 1) {
      // Last shape stays in place
    } else {
      // Middle shapes get evenly distributed
      updates[shape.id] = { x: currentX, y: shape.y }
      currentX += shape.width + spacing
    }
  })

  return updates
}

/**
 * Distribute shapes vertically with equal spacing
 * Requires at least 3 shapes
 */
export function distributeVertically(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 3) return {}

  // Sort shapes by y position
  const sortedShapes = [...shapes].sort((a, b) => a.y - b.y)

  // Find topmost and bottommost edges
  const topmost = sortedShapes[0]
  const bottommost = sortedShapes[sortedShapes.length - 1]
  const topEdge = topmost.y
  const bottomEdge = bottommost.y + bottommost.height

  // Calculate total space between shapes
  const totalHeight = sortedShapes.reduce((sum, s) => sum + s.height, 0)
  const availableSpace = bottomEdge - topEdge - totalHeight
  const spacing = availableSpace / (sortedShapes.length - 1)

  // Create updates for all shapes (except first and last which stay in place)
  const updates: AlignmentResult = {}
  let currentY = topEdge

  sortedShapes.forEach((shape, index) => {
    if (index === 0) {
      // First shape stays in place
      currentY += shape.height + spacing
    } else if (index === sortedShapes.length - 1) {
      // Last shape stays in place
    } else {
      // Middle shapes get evenly distributed
      updates[shape.id] = { x: shape.x, y: currentY }
      currentY += shape.height + spacing
    }
  })

  return updates
}

/**
 * Center shapes in the canvas viewport
 */
export function centerInCanvas(
  shapes: Shape[],
  canvasWidth: number,
  canvasHeight: number
): AlignmentResult {
  if (shapes.length === 0) return {}

  // Calculate bounding box of all shapes
  const minX = Math.min(...shapes.map(s => s.x))
  const maxX = Math.max(...shapes.map(s => s.x + s.width))
  const minY = Math.min(...shapes.map(s => s.y))
  const maxY = Math.max(...shapes.map(s => s.y + s.height))

  const boundingWidth = maxX - minX
  const boundingHeight = maxY - minY

  // Calculate center offset
  const targetCenterX = canvasWidth / 2
  const targetCenterY = canvasHeight / 2
  const currentCenterX = minX + boundingWidth / 2
  const currentCenterY = minY + boundingHeight / 2

  const offsetX = targetCenterX - currentCenterX
  const offsetY = targetCenterY - currentCenterY

  // Create updates for all shapes
  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = {
      x: shape.x + offsetX,
      y: shape.y + offsetY,
    }
  })

  return updates
}

/**
 * Generic alignment function that calls the appropriate specific function
 */
export function alignShapes(shapes: Shape[], type: AlignmentType): AlignmentResult {
  switch (type) {
    case 'left':
      return alignLeft(shapes)
    case 'center':
      return alignCenter(shapes)
    case 'right':
      return alignRight(shapes)
    case 'top':
      return alignTop(shapes)
    case 'middle':
      return alignMiddle(shapes)
    case 'bottom':
      return alignBottom(shapes)
    default:
      return {}
  }
}
</file>

<file path="src/services/collaboration/groupSync.ts">
/**
 * Group Sync Service (PR-19)
 * Manages group operations with Firebase synchronization
 */

import { ref, set, get, remove, update } from 'firebase/database'
import { db } from '../firebase'
import type { Group } from '../../types/group'

/**
 * Generate unique group ID
 */
function generateGroupId(): string {
  return `group-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}

/**
 * Create a new group with member shapes
 */
export async function syncCreateGroup(
  canvasId: string,
  memberIds: string[],
  userId: string,
  name?: string
): Promise<Group> {
  if (memberIds.length < 2) {
    throw new Error('Group must contain at least 2 members')
  }

  const groupId = generateGroupId()
  const now = Date.now()

  const group: Group = {
    id: groupId,
    name: name || `Group ${groupId.slice(-4)}`,
    memberIds,
    x: 0, // Will be calculated by groupHelpers
    y: 0,
    width: 0,
    height: 0,
    rotation: 0,
    locked: false,
    visible: true,
    createdAt: now,
    updatedAt: now,
    createdBy: userId,
    zIndex: 0,
  }

  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    await set(groupRef, group)
    console.log(`Group created: ${groupId}`)
    return group
  } catch (error) {
    console.error('Error creating group:', error)
    throw error
  }
}

/**
 * Update group properties
 */
export async function syncUpdateGroup(
  canvasId: string,
  groupId: string,
  updates: Partial<Omit<Group, 'id' | 'createdAt' | 'createdBy'>>
): Promise<void> {
  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    
    const updateData = {
      ...updates,
      updatedAt: Date.now(),
    }

    await update(groupRef, updateData)
    console.log(`Group updated: ${groupId}`)
  } catch (error) {
    console.error('Error updating group:', error)
    throw error
  }
}

/**
 * Delete group (ungroup - keep members)
 */
export async function syncDeleteGroup(
  canvasId: string,
  groupId: string
): Promise<void> {
  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    await remove(groupRef)
    console.log(`Group deleted: ${groupId}`)
  } catch (error) {
    console.error('Error deleting group:', error)
    throw error
  }
}

/**
 * Add shape to existing group
 */
export async function syncAddToGroup(
  canvasId: string,
  groupId: string,
  shapeId: string
): Promise<void> {
  try {
    // Get current group
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    const snapshot = await get(groupRef)

    if (!snapshot.exists()) {
      throw new Error('Group not found')
    }

    const group = snapshot.val() as Group

    // Check if shape is already in group
    if (group.memberIds.includes(shapeId)) {
      console.log('Shape already in group')
      return
    }

    // Add shape to memberIds
    const updatedMemberIds = [...group.memberIds, shapeId]

    await syncUpdateGroup(canvasId, groupId, {
      memberIds: updatedMemberIds,
    })

    console.log(`Added ${shapeId} to group ${groupId}`)
  } catch (error) {
    console.error('Error adding to group:', error)
    throw error
  }
}

/**
 * Remove shape from group
 */
export async function syncRemoveFromGroup(
  canvasId: string,
  groupId: string,
  shapeId: string
): Promise<void> {
  try {
    // Get current group
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    const snapshot = await get(groupRef)

    if (!snapshot.exists()) {
      throw new Error('Group not found')
    }

    const group = snapshot.val() as Group

    // Remove shape from memberIds
    const updatedMemberIds = group.memberIds.filter((id) => id !== shapeId)

    // If group has less than 2 members after removal, delete the group
    if (updatedMemberIds.length < 2) {
      await syncDeleteGroup(canvasId, groupId)
      console.log(`Group ${groupId} dissolved (too few members)`)
      return
    }

    await syncUpdateGroup(canvasId, groupId, {
      memberIds: updatedMemberIds,
    })

    console.log(`Removed ${shapeId} from group ${groupId}`)
  } catch (error) {
    console.error('Error removing from group:', error)
    throw error
  }
}

/**
 * Get all groups for a canvas
 */
export async function syncGetGroups(canvasId: string): Promise<Group[]> {
  try {
    const groupsRef = ref(db, `canvases/${canvasId}/groups`)
    const snapshot = await get(groupsRef)

    if (!snapshot.exists()) {
      return []
    }

    const groupsData = snapshot.val()
    return Object.values(groupsData) as Group[]
  } catch (error) {
    console.error('Error getting groups:', error)
    throw error
  }
}

/**
 * Get single group by ID
 */
export async function syncGetGroup(
  canvasId: string,
  groupId: string
): Promise<Group | null> {
  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    const snapshot = await get(groupRef)

    if (!snapshot.exists()) {
      return null
    }

    return snapshot.val() as Group
  } catch (error) {
    console.error('Error getting group:', error)
    throw error
  }
}

/**
 * Check if shape is in any group
 */
export async function syncIsInGroup(
  canvasId: string,
  shapeId: string
): Promise<string | null> {
  try {
    const groups = await syncGetGroups(canvasId)
    
    for (const group of groups) {
      if (group.memberIds.includes(shapeId)) {
        return group.id
      }
    }

    return null
  } catch (error) {
    console.error('Error checking if in group:', error)
    return null
  }
}
</file>

<file path="src/services/tilemap/tileFill.ts">
/**
 * Tile Fill Service
 * Implements flood-fill algorithm for tilemap editor
 * Uses breadth-first search (BFS) for 4-directional fill
 */

import type { TileData } from '../../types/tilemap'
import { coordToKey } from '../../types/tilemap'

/**
 * Result of a flood fill operation
 */
export interface FillResult {
  tiles: Array<{ x: number; y: number; tile: TileData }>
  count: number
  limitReached: boolean
}

/**
 * Flood fill algorithm using BFS
 * Fills contiguous tiles of the same type with a new tile
 * 
 * @param tiles Current tilemap state
 * @param startX Starting X coordinate
 * @param startY Starting Y coordinate
 * @param fillTile Tile to fill with
 * @param maxWidth Maximum width of tilemap (bounds checking)
 * @param maxHeight Maximum height of tilemap (bounds checking)
 * @param maxTiles Safety limit to prevent infinite fills (default: 1000)
 * @returns Array of tiles to change and whether limit was reached
 */
export function floodFill(
  tiles: Map<string, TileData>,
  startX: number,
  startY: number,
  fillTile: TileData,
  maxWidth: number,
  maxHeight: number,
  maxTiles: number = 1000
): FillResult {
  // Get the tile at the starting position
  const startKey = coordToKey(startX, startY)
  const startTile = tiles.get(startKey)
  
  // If there's no tile at start position, treat it as empty
  const targetType = startTile?.type || 'empty'
  const targetColor = startTile?.color || ''
  
  // If trying to fill with the same type/color, return empty result
  if (targetType === fillTile.type && targetColor === fillTile.color) {
    return { tiles: [], count: 0, limitReached: false }
  }
  
  // BFS queue and visited set
  const queue: Array<{ x: number; y: number }> = [{ x: startX, y: startY }]
  const visited = new Set<string>()
  const result: Array<{ x: number; y: number; tile: TileData }> = []
  
  // 4-directional neighbors (up, down, left, right)
  const directions = [
    { dx: 0, dy: -1 },  // up
    { dx: 0, dy: 1 },   // down
    { dx: -1, dy: 0 },  // left
    { dx: 1, dy: 0 },   // right
  ]
  
  let limitReached = false
  
  // BFS loop
  while (queue.length > 0 && result.length < maxTiles) {
    const current = queue.shift()!
    const currentKey = coordToKey(current.x, current.y)
    
    // Skip if already visited
    if (visited.has(currentKey)) {
      continue
    }
    
    // Mark as visited
    visited.add(currentKey)
    
    // Check bounds
    if (current.x < 0 || current.x >= maxWidth || current.y < 0 || current.y >= maxHeight) {
      continue
    }
    
    // Check if this tile matches the target type/color
    const currentTile = tiles.get(currentKey)
    const currentType = currentTile?.type || 'empty'
    const currentColor = currentTile?.color || ''
    
    if (currentType !== targetType || currentColor !== targetColor) {
      continue
    }
    
    // Add this tile to the result
    result.push({
      x: current.x,
      y: current.y,
      tile: fillTile,
    })
    
    // Add neighbors to queue
    for (const dir of directions) {
      const nextX = current.x + dir.dx
      const nextY = current.y + dir.dy
      const nextKey = coordToKey(nextX, nextY)
      
      if (!visited.has(nextKey)) {
        queue.push({ x: nextX, y: nextY })
      }
    }
  }
  
  // Check if we hit the limit
  if (result.length >= maxTiles) {
    limitReached = true
  }
  
  return {
    tiles: result,
    count: result.length,
    limitReached,
  }
}

/**
 * Simple rectangular fill (for marquee fill tool in the future)
 * Fills a rectangular region with a tile
 * 
 * @param startX Starting X coordinate
 * @param startY Starting Y coordinate
 * @param endX Ending X coordinate
 * @param endY Ending Y coordinate
 * @param fillTile Tile to fill with
 * @returns Array of tiles to fill
 */
export function rectangularFill(
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  fillTile: TileData
): Array<{ x: number; y: number; tile: TileData }> {
  const result: Array<{ x: number; y: number; tile: TileData }> = []
  
  // Ensure start is top-left, end is bottom-right
  const minX = Math.min(startX, endX)
  const maxX = Math.max(startX, endX)
  const minY = Math.min(startY, endY)
  const maxY = Math.max(startY, endY)
  
  // Fill rectangle
  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      result.push({ x, y, tile: fillTile })
    }
  }
  
  return result
}
</file>

<file path="src/services/tilemap/tilemapExport.ts">
/**
 * Tilemap Export Service
 * Exports tilemap data to JSON format
 * Supports both sparse and dense formats
 */

import type { TileData, TilemapMeta, ExportedTilemap } from '../../types/tilemap'

/**
 * Export tilemap to JSON format
 * Uses sparse format by default (efficient for sparse maps)
 * 
 * @param tiles Map of tiles to export
 * @param meta Tilemap metadata
 * @param exportedBy User email/ID
 * @param format Export format ('sparse' or 'dense')
 * @returns Exported tilemap object
 */
export function exportTilemapJSON(
  tiles: Map<string, TileData>,
  meta: TilemapMeta,
  exportedBy: string,
  format: 'sparse' | 'dense' = 'sparse'
): ExportedTilemap {
  const exportedAt = new Date().toISOString()
  const tileCount = tiles.size
  
  if (format === 'sparse') {
    // Sparse format: { "x_y": tile, ... }
    const sparseTiles: Record<string, TileData> = {}
    tiles.forEach((tile, key) => {
      sparseTiles[key] = tile
    })
    
    return {
      version: 1,
      meta,
      format: 'sparse',
      tiles: sparseTiles,
      exported_at: exportedAt,
      exported_by: exportedBy,
      tile_count: tileCount,
    }
  } else {
    // Dense format: [[tile, tile, ...], [tile, tile, ...]]
    const denseTiles: (TileData | null)[][] = []
    
    // Initialize 2D array
    for (let y = 0; y < meta.height; y++) {
      denseTiles[y] = []
      for (let x = 0; x < meta.width; x++) {
        const key = `${x}_${y}`
        const tile = tiles.get(key)
        denseTiles[y][x] = tile || null
      }
    }
    
    return {
      version: 1,
      meta,
      format: 'dense',
      tiles: denseTiles as any, // TypeScript doesn't like the union type here
      exported_at: exportedAt,
      exported_by: exportedBy,
      tile_count: tileCount,
    }
  }
}

/**
 * Generate a filename for the export
 * @param canvasName Canvas name (optional)
 * @returns Filename with timestamp
 */
export function generateExportFilename(canvasName?: string): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)
  const name = canvasName ? `${canvasName}-tilemap` : 'tilemap'
  return `${name}-${timestamp}.json`
}

/**
 * Validate exported tilemap data
 * Checks for required fields and structure
 * 
 * @param data Exported tilemap data
 * @returns True if valid, false otherwise
 */
export function validateExportedData(data: any): data is ExportedTilemap {
  if (!data || typeof data !== 'object') {
    return false
  }
  
  // Check required fields
  if (typeof data.version !== 'number') return false
  if (!data.meta || typeof data.meta !== 'object') return false
  if (data.format !== 'sparse' && data.format !== 'dense') return false
  if (!data.tiles) return false
  
  // Check meta fields
  const meta = data.meta
  if (typeof meta.tileSize !== 'number') return false
  if (typeof meta.width !== 'number') return false
  if (typeof meta.height !== 'number') return false
  if (typeof meta.chunkSize !== 'number') return false
  if (!Array.isArray(meta.palette)) return false
  if (typeof meta.version !== 'number') return false
  
  return true
}
</file>

<file path="src/services/tilemap/tilemapImport.ts">
/**
 * Tilemap Import Service
 * Imports tilemap data from JSON format
 * Supports both sparse and dense formats with validation
 */

import type { TileData, TilemapMeta, ExportedTilemap } from '../../types/tilemap'
import { validateExportedData } from './tilemapExport'

/**
 * Result of tilemap import operation
 */
export interface ImportResult {
  success: boolean
  tiles: Map<string, TileData>
  meta: TilemapMeta
  tileCount: number
  error?: string
}

/**
 * Import tilemap from JSON string
 * Validates structure and converts to internal format
 * 
 * @param jsonString JSON string to parse
 * @returns Import result with tiles and metadata or error
 */
export function importTilemapJSON(jsonString: string): ImportResult {
  try {
    // Parse JSON
    const data = JSON.parse(jsonString) as ExportedTilemap
    
    // Validate structure
    if (!validateExportedData(data)) {
      const defaultMeta: TilemapMeta = { 
        tileSize: 32, 
        width: 0, 
        height: 0,
        chunkSize: 16,
        palette: [],
        version: 1
      }
      return {
        success: false,
        tiles: new Map(),
        meta: (data && typeof data === 'object' && 'meta' in data ? (data as ExportedTilemap).meta : defaultMeta),
        tileCount: 0,
        error: 'Invalid tilemap JSON structure',
      }
    }
    
    // Check version compatibility
    if (data.version !== 1) {
      return {
        success: false,
        tiles: new Map(),
        meta: data.meta,
        tileCount: 0,
        error: `Unsupported tilemap version: ${data.version}. Expected version 1.`,
      }
    }
    
    // Convert to internal format
    const tiles = new Map<string, TileData>()
    
    if (data.format === 'sparse') {
      // Sparse format: { "x_y": tile, ... }
      const sparseData = data.tiles as Record<string, TileData>
      Object.entries(sparseData).forEach(([key, tile]) => {
        tiles.set(key, tile)
      })
    } else if (data.format === 'dense') {
      // Dense format: [[tile, tile, ...], [tile, tile, ...]]
      const denseData = data.tiles as (TileData | null)[][]
      denseData.forEach((row, y) => {
        row.forEach((tile, x) => {
          if (tile !== null) {
            const key = `${x}_${y}`
            tiles.set(key, tile)
          }
        })
      })
    } else {
      return {
        success: false,
        tiles: new Map(),
        meta: data.meta,
        tileCount: 0,
        error: `Unknown tilemap format: ${data.format}`,
      }
    }
    
    return {
      success: true,
      tiles,
      meta: data.meta,
      tileCount: tiles.size,
    }
  } catch (error) {
    return {
      success: false,
      tiles: new Map(),
      meta: null as any, // Will cause error if accessed
      tileCount: 0,
      error: error instanceof Error ? error.message : 'Failed to parse JSON',
    }
  }
}

/**
 * Import tilemap from File object
 * Reads file and imports tilemap data
 * 
 * @param file File object to read
 * @returns Promise with import result
 */
export async function importTilemapFromFile(file: File): Promise<ImportResult> {
  try {
    const text = await file.text()
    return importTilemapJSON(text)
  } catch (error) {
    return {
      success: false,
      tiles: new Map(),
      meta: null as any,
      tileCount: 0,
      error: error instanceof Error ? error.message : 'Failed to read file',
    }
  }
}

/**
 * Validate tile data for import
 * Checks if tile has required fields
 * 
 * @param tile Tile data to validate
 * @returns True if valid
 */
export function validateTileData(tile: any): tile is TileData {
  if (!tile || typeof tile !== 'object') return false
  if (typeof tile.type !== 'string') return false
  if (typeof tile.color !== 'string') return false
  return true
}
</file>

<file path="src/services/tilemap/tilemapSync.ts">
/**
 * Tilemap Sync Service
 * Handles Firebase CRUD operations for tilemap data with chunked structure
 */

import { ref, set, update, remove, onValue, off, serverTimestamp } from 'firebase/database'
import { db } from '../firebase'
import type {
  TileData,
  TilemapMeta,
  FirebaseTileData,
  FirebaseTilemapMeta,
  ChunkCoordinate,
  coordToKey,
  chunkToKey,
  coordToChunk,
  keyToCoord,
} from '../../types/tilemap'
import {
  coordToKey as _coordToKey,
  chunkToKey as _chunkToKey,
  coordToChunk as _coordToChunk,
  keyToCoord as _keyToCoord,
} from '../../types/tilemap'

// Re-export coordinate helpers
export type { coordToKey, chunkToKey, coordToChunk, keyToCoord }

// ============================================================================
// Compression/Decompression
// ============================================================================

/**
 * Compress tile data for Firebase storage
 * Uses short keys to reduce bandwidth: t (type), c (color), v (variant), by (by user), ts (timestamp)
 */
function compressTile(tile: TileData, userId: string): FirebaseTileData {
  const compressed: FirebaseTileData = {
    t: tile.type,
    c: tile.color,
    by: userId,
    ts: Date.now(), // Will be replaced by serverTimestamp in actual write
  }
  
  // Add variant if present (auto-tiling)
  if (tile.variant !== undefined) {
    compressed.v = tile.variant
  }
  
  return compressed
}

/**
 * Decompress Firebase tile data to client format
 */
function decompressTile(data: FirebaseTileData): TileData {
  const tile: TileData = {
    type: data.t,
    color: data.c,
  }
  
  // Include variant if present (auto-tiling)
  if (data.v !== undefined) {
    tile.variant = data.v
  }
  
  // Include metadata if present
  if (data.by || data.ts) {
    tile.metadata = {}
    if (data.by) tile.metadata.lastEditedBy = data.by
    if (data.ts) tile.metadata.lastEditedAt = data.ts
  }
  
  return tile
}

// ============================================================================
// Metadata Operations
// ============================================================================

/**
 * Get tilemap metadata from Firebase
 */
export async function getMeta(canvasId: string): Promise<TilemapMeta | null> {
  try {
    const metaRef = ref(db, `tilemaps/${canvasId}/meta`)
    
    return new Promise((resolve) => {
      onValue(
        metaRef,
        (snapshot) => {
          const data = snapshot.val() as FirebaseTilemapMeta | null
          resolve(data)
        },
        { onlyOnce: true }
      )
    })
  } catch (error) {
    console.error('Failed to get tilemap meta:', error)
    return null
  }
}

/**
 * Set or update tilemap metadata in Firebase
 */
export async function setMeta(canvasId: string, meta: Partial<TilemapMeta>): Promise<void> {
  try {
    const metaRef = ref(db, `tilemaps/${canvasId}/meta`)
    await update(metaRef, meta)
  } catch (error) {
    console.error('Failed to set tilemap meta:', error)
    throw error
  }
}

/**
 * Initialize tilemap with default metadata
 */
export async function initializeTilemap(canvasId: string, meta: TilemapMeta): Promise<void> {
  try {
    const metaRef = ref(db, `tilemaps/${canvasId}/meta`)
    await set(metaRef, meta)
  } catch (error) {
    console.error('Failed to initialize tilemap:', error)
    throw error
  }
}

// ============================================================================
// Tile Operations
// ============================================================================

/**
 * Set a single tile in Firebase with chunk routing
 */
export async function setTile(
  canvasId: string,
  x: number,
  y: number,
  tile: TileData,
  userId: string,
  chunkSize: number = 16
): Promise<void> {
  try {
    // Calculate chunk coordinates
    const chunk = _coordToChunk(x, y, chunkSize)
    const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
    const tileKey = _coordToKey(chunk.lx, chunk.ly)
    
    // Build Firebase path
    const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`
    const tileRef = ref(db, tilePath)
    
    // Compress and write
    const compressed = compressTile(tile, userId)
    // Use server timestamp for consistency
    const tileData = {
      ...compressed,
      ts: serverTimestamp() as any,
    }
    
    await set(tileRef, tileData)
  } catch (error) {
    console.error('Failed to set tile:', error)
    throw error
  }
}

/**
 * Set multiple tiles in a single atomic operation (for fill tool)
 */
export async function setTiles(
  canvasId: string,
  tiles: Array<{ x: number; y: number; tile: TileData }>,
  userId: string,
  chunkSize: number = 16
): Promise<void> {
  try {
    // Build flat update object for atomic write
    const firebaseUpdates: Record<string, FirebaseTileData> = {}
    
    tiles.forEach(({ x, y, tile }) => {
      const chunk = _coordToChunk(x, y, chunkSize)
      const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
      const tileKey = _coordToKey(chunk.lx, chunk.ly)
      const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`
      
      const compressed = compressTile(tile, userId)
      firebaseUpdates[tilePath] = {
        ...compressed,
        ts: Date.now(), // Use local timestamp for bulk operations
      }
    })
    
    // Perform atomic multi-path update
    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to set tiles:', error)
    throw error
  }
}

/**
 * Delete a single tile from Firebase
 */
export async function deleteTile(
  canvasId: string,
  x: number,
  y: number,
  chunkSize: number = 16
): Promise<void> {
  try {
    // Calculate chunk coordinates
    const chunk = _coordToChunk(x, y, chunkSize)
    const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
    const tileKey = _coordToKey(chunk.lx, chunk.ly)
    
    // Build Firebase path and delete
    const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`
    const tileRef = ref(db, tilePath)
    
    await remove(tileRef)
  } catch (error) {
    console.error('Failed to delete tile:', error)
    throw error
  }
}

/**
 * Delete multiple tiles in a single atomic operation
 */
export async function deleteTiles(
  canvasId: string,
  tiles: Array<{ x: number; y: number }>,
  chunkSize: number = 16
): Promise<void> {
  try {
    // Build flat update object with null values (deletes in Firebase)
    const firebaseUpdates: Record<string, null> = {}
    
    tiles.forEach(({ x, y }) => {
      const chunk = _coordToChunk(x, y, chunkSize)
      const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
      const tileKey = _coordToKey(chunk.lx, chunk.ly)
      const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`
      
      firebaseUpdates[tilePath] = null
    })
    
    // Perform atomic multi-path delete
    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to delete tiles:', error)
    throw error
  }
}

/**
 * Clear all tiles in a tilemap (preserves metadata)
 */
export async function clearAllTiles(canvasId: string): Promise<void> {
  try {
    const chunksRef = ref(db, `tilemaps/${canvasId}/chunks`)
    await remove(chunksRef)
  } catch (error) {
    console.error('Failed to clear all tiles:', error)
    throw error
  }
}

// ============================================================================
// Subscription Operations
// ============================================================================

/**
 * Subscribe to a single chunk of tiles
 * Returns unsubscribe function
 */
export function subscribeToChunk(
  canvasId: string,
  chunkX: number,
  chunkY: number,
  callbacks: {
    onTile?: (x: number, y: number, tile: TileData) => void
    onRemove?: (x: number, y: number) => void
  },
  chunkSize: number = 16
): () => void {
  const chunkKey = _chunkToKey(chunkX, chunkY)
  const chunkRef = ref(db, `tilemaps/${canvasId}/chunks/${chunkKey}/tiles`)
  
  // Track previous state to detect changes
  let previousTiles = new Map<string, FirebaseTileData>()
  
  const handleValue = (snapshot: any) => {
    const data = snapshot.val() as { [key: string]: FirebaseTileData } | null
    const currentTiles = new Map<string, FirebaseTileData>()
    
    if (data) {
      Object.entries(data).forEach(([tileKey, tileData]) => {
        currentTiles.set(tileKey, tileData)
      })
    }
    
    // Detect creates and updates
    currentTiles.forEach((tileData, tileKey) => {
      const { x: lx, y: ly } = _keyToCoord(tileKey)
      const x = chunkX * chunkSize + lx
      const y = chunkY * chunkSize + ly
      
      if (!previousTiles.has(tileKey) || 
          JSON.stringify(previousTiles.get(tileKey)) !== JSON.stringify(tileData)) {
        // New tile or tile updated
        if (callbacks.onTile) {
          const tile = decompressTile(tileData)
          callbacks.onTile(x, y, tile)
        }
      }
    })
    
    // Detect deletes
    previousTiles.forEach((_, tileKey) => {
      if (!currentTiles.has(tileKey)) {
        // Tile was deleted
        const { x: lx, y: ly } = _keyToCoord(tileKey)
        const x = chunkX * chunkSize + lx
        const y = chunkY * chunkSize + ly
        
        if (callbacks.onRemove) {
          callbacks.onRemove(x, y)
        }
      }
    })
    
    previousTiles = currentTiles
  }
  
  onValue(chunkRef, handleValue)
  
  // Return unsubscribe function
  return () => {
    off(chunkRef, 'value', handleValue)
  }
}

/**
 * Subscribe to multiple chunks
 * Returns map of chunk keys to unsubscribe functions
 */
export function subscribeToChunks(
  canvasId: string,
  chunkKeys: string[],
  callbacks: {
    onTile?: (x: number, y: number, tile: TileData) => void
    onRemove?: (x: number, y: number) => void
  },
  chunkSize: number = 16
): Map<string, () => void> {
  const unsubscribes = new Map<string, () => void>()
  
  chunkKeys.forEach((chunkKey) => {
    // Parse chunk key "cx_cy"
    const [cx, cy] = chunkKey.split('_').map(Number)
    const unsub = subscribeToChunk(canvasId, cx, cy, callbacks, chunkSize)
    unsubscribes.set(chunkKey, unsub)
  })
  
  return unsubscribes
}

/**
 * Subscribe to tilemap metadata changes
 */
export function subscribeToMeta(
  canvasId: string,
  onMetaChange: (meta: TilemapMeta) => void
): () => void {
  const metaRef = ref(db, `tilemaps/${canvasId}/meta`)
  
  const handleValue = (snapshot: any) => {
    const data = snapshot.val() as FirebaseTilemapMeta | null
    if (data) {
      onMetaChange(data)
    }
  }
  
  onValue(metaRef, handleValue)
  
  // Return unsubscribe function
  return () => {
    off(metaRef, 'value', handleValue)
  }
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Get all tiles in a specific chunk (one-time read)
 */
export async function getChunkTiles(
  canvasId: string,
  chunkX: number,
  chunkY: number,
  chunkSize: number = 16
): Promise<Map<string, TileData>> {
  try {
    const chunkKey = _chunkToKey(chunkX, chunkY)
    const chunkRef = ref(db, `tilemaps/${canvasId}/chunks/${chunkKey}/tiles`)
    
    return new Promise((resolve) => {
      onValue(
        chunkRef,
        (snapshot) => {
          const data = snapshot.val() as { [key: string]: FirebaseTileData } | null
          const tiles = new Map<string, TileData>()
          
          if (data) {
            Object.entries(data).forEach(([tileKey, tileData]) => {
              const { x: lx, y: ly } = _keyToCoord(tileKey)
              const x = chunkX * chunkSize + lx
              const y = chunkY * chunkSize + ly
              const globalKey = _coordToKey(x, y)
              
              tiles.set(globalKey, decompressTile(tileData))
            })
          }
          
          resolve(tiles)
        },
        { onlyOnce: true }
      )
    })
  } catch (error) {
    console.error('Failed to get chunk tiles:', error)
    return new Map()
  }
}

/**
 * Check if a tilemap exists for a canvas
 */
export async function tilemapExists(canvasId: string): Promise<boolean> {
  const meta = await getMeta(canvasId)
  return meta !== null
}
</file>

<file path="src/types/animation.ts">
/**
 * Animation Types for Sprite Animation System
 */

/**
 * Single animation frame
 * Defines which region of a sprite sheet to display
 */
export interface AnimationFrame {
  x: number // crop x coordinate in sprite sheet
  y: number // crop y coordinate in sprite sheet
  width: number // frame width
  height: number // frame height
  duration?: number // optional frame-specific duration in ms (overrides global fps)
}

/**
 * Animation definition
 */
export interface Animation {
  id: string // unique animation identifier
  userId: string // owner user ID
  canvasId?: string // optional canvas scope (null = global to user)
  name: string // user-friendly name (e.g., "walk_left", "attack")
  spriteSheetId: string // reference to the sprite sheet asset
  frames: AnimationFrame[] // ordered list of frames
  fps: number // frames per second (1-60, default: 12)
  loop: boolean // whether to loop the animation
  createdAt: number // timestamp
  updatedAt: number // timestamp
}

/**
 * Animation playback state (client-side only)
 */
export interface AnimationPlaybackState {
  animationId: string
  currentFrameIndex: number // 0-based index of current frame
  isPlaying: boolean // whether animation is playing
  elapsedTime: number // time elapsed in current frame (ms)
  loopCount: number // number of times animation has looped
}

/**
 * Animation preset template
 * Pre-defined animation layouts for common sprite sheet formats
 */
export interface AnimationPreset {
  id: string
  name: string // e.g., "8-Direction Walk Cycle"
  description: string
  frameLayout: {
    columns: number
    rows: number
    framesPerAnimation: number
  }
  animations: Array<{
    name: string // e.g., "walk_up"
    startFrame: number
    frameCount: number
  }>
}

/**
 * Animated sprite object for canvas
 * Extends the base Shape type
 */
export interface AnimatedSprite {
  id: string
  type: 'animatedSprite' // special type for animated objects
  x: number
  y: number
  width: number // display width (can scale)
  height: number // display height (can scale)
  rotation?: number
  animationId: string // reference to animation
  playbackState: AnimationPlaybackState
  scale?: number // sprite scaling factor (1 = original size)
  flipX?: boolean // flip horizontally
  flipY?: boolean // flip vertically
  visible?: boolean
  opacity?: number // 0-1
  zIndex?: number
  layerId?: string
}

/**
 * Animation timeline state (for editor UI)
 */
export interface AnimationTimelineState {
  selectedFrameIndex: number | null
  playheadPosition: number // current playback position (0-1)
  isPlaying: boolean
  zoom: number // timeline zoom level (1 = normal)
  snapToGrid: boolean
}

/**
 * Frame selection in sprite sheet selector
 */
export interface FrameSelection {
  x: number
  y: number
  width: number
  height: number
  spriteSheetId: string
}

/**
 * Animation export format
 * For exporting to game engines
 */
export interface AnimationExport {
  name: string
  spriteSheet: string // file path or URL
  frames: Array<{
    x: number
    y: number
    w: number
    h: number
  }>
  frameRate: number
  loop: boolean
}

/**
 * Animation validation result
 */
export interface AnimationValidation {
  valid: boolean
  errors: string[]
  warnings: string[]
  issues?: Array<{
    frameIndex: number
    message: string
  }>
}

/**
 * Common animation presets
 */
export const ANIMATION_PRESETS: AnimationPreset[] = [
  {
    id: 'single_row',
    name: 'Single Row Animation',
    description: 'All frames in a single horizontal row',
    frameLayout: { columns: 8, rows: 1, framesPerAnimation: 8 },
    animations: [{ name: 'default', startFrame: 0, frameCount: 8 }]
  },
  {
    id: 'four_direction',
    name: '4-Direction Walk Cycle',
    description: 'Up, Left, Down, Right (4 frames each)',
    frameLayout: { columns: 4, rows: 4, framesPerAnimation: 4 },
    animations: [
      { name: 'walk_up', startFrame: 0, frameCount: 4 },
      { name: 'walk_left', startFrame: 4, frameCount: 4 },
      { name: 'walk_down', startFrame: 8, frameCount: 4 },
      { name: 'walk_right', startFrame: 12, frameCount: 4 }
    ]
  },
  {
    id: 'eight_direction',
    name: '8-Direction Walk Cycle',
    description: 'Up, UpRight, Right, DownRight, Down, DownLeft, Left, UpLeft',
    frameLayout: { columns: 4, rows: 8, framesPerAnimation: 4 },
    animations: [
      { name: 'walk_up', startFrame: 0, frameCount: 4 },
      { name: 'walk_up_right', startFrame: 4, frameCount: 4 },
      { name: 'walk_right', startFrame: 8, frameCount: 4 },
      { name: 'walk_down_right', startFrame: 12, frameCount: 4 },
      { name: 'walk_down', startFrame: 16, frameCount: 4 },
      { name: 'walk_down_left', startFrame: 20, frameCount: 4 },
      { name: 'walk_left', startFrame: 24, frameCount: 4 },
      { name: 'walk_up_left', startFrame: 28, frameCount: 4 }
    ]
  }
]
</file>

<file path="src/types/asset.ts">
/**
 * Asset Types for Game Development Tools
 * Handles sprite sheets, tilesets, and other game assets
 */

/**
 * Asset type classifications
 */
export type AssetType = 'spritesheet' | 'tileset' | 'image' | 'audio' | 'font'

/**
 * Auto-tiling bitmask values (16 possible combinations)
 * Based on Moore neighborhood (8 surrounding tiles)
 */
export type AutoTileBitmask = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15

/**
 * Auto-tile variant mapping
 * Maps bitmask values to tile indices in the sprite sheet
 */
export interface AutoTileMapping {
  [bitmask: number]: number // bitmask -> tile index
}

/**
 * Tileset-specific metadata
 */
export interface TilesetMetadata {
  tileWidth: number // width of each tile in pixels
  tileHeight: number // height of each tile in pixels
  spacing?: number // spacing between tiles (default: 0)
  margin?: number // margin around the tileset (default: 0)
  columns: number // number of columns in the grid
  rows: number // number of rows in the grid
  tileCount: number // total number of tiles
  autoTileMapping?: AutoTileMapping // optional auto-tiling configuration
}

/**
 * Manual sprite selection (for irregular sprite sheets)
 * PR-31: Enhanced for non-uniform sprite collections
 */
export interface SpriteSelection {
  id: string // unique identifier
  name: string // user-defined sprite name
  x: number // x coordinate in source image
  y: number // y coordinate in source image
  width: number // sprite width
  height: number // sprite height
}

/**
 * Sprite sheet-specific metadata
 */
export interface SpriteSheetMetadata {
  // Uniform grid (auto-detected)
  frameWidth?: number // width of each frame
  frameHeight?: number // height of each frame
  frameCount?: number // total number of frames
  columns?: number // number of columns
  rows?: number // number of rows
  spacing?: number // spacing between frames
  margin?: number // margin around the sprite sheet
  
  // Manual selections (for irregular sprites)
  spriteSelections?: SpriteSelection[] // manually defined sprite bounds
  selectionMode?: 'grid' | 'manual' // how sprites were defined
}

/**
 * Base asset metadata (common to all asset types)
 */
export interface AssetMetadata {
  width: number // image width in pixels
  height: number // image height in pixels
  fileSize: number // file size in bytes
  mimeType: string // e.g., 'image/png'
}

/**
 * Asset document stored in Firebase
 */
export interface Asset {
  id: string // unique asset identifier
  userId: string // owner user ID
  name: string // user-friendly name
  type: AssetType // asset classification
  url: string // Firebase Storage download URL
  thumbnailUrl?: string // optional thumbnail URL (for grid view)
  metadata: AssetMetadata // base metadata
  tilesetMetadata?: TilesetMetadata // only if type === 'tileset'
  spriteSheetMetadata?: SpriteSheetMetadata // only if type === 'spritesheet'
  uploadedAt: number // timestamp (Date.now())
  updatedAt: number // timestamp (Date.now())
  tags: string[] // user-defined tags for organization
  folderId?: string // optional folder organization
}

/**
 * Asset upload progress tracking
 */
export interface AssetUploadProgress {
  assetId: string
  fileName: string
  progress: number // 0-100
  status: 'uploading' | 'processing' | 'complete' | 'error'
  error?: string
}

/**
 * Asset folder for organization
 */
export interface AssetFolder {
  id: string
  userId: string
  name: string
  parentId?: string // for nested folders
  color?: string // optional folder color
  icon?: string // optional folder icon
  createdAt: number
}

/**
 * Asset filter/search options
 */
export interface AssetFilter {
  type?: AssetType[]
  tags?: string[]
  folderId?: string
  searchQuery?: string
}

/**
 * Tileset slicing result
 */
export interface TileSliceResult {
  tiles: TileSlice[]
  metadata: TilesetMetadata
}

/**
 * Individual tile from a sliced tileset
 */
export interface TileSlice {
  index: number // tile index (0-based)
  x: number // x coordinate in the source image
  y: number // y coordinate in the source image
  width: number // tile width
  height: number // tile height
  imageData?: ImageData // optional extracted tile image data
}

/**
 * Auto-tile detection suggestion
 */
export interface AutoTileSuggestion {
  tileIndices: number[] // indices of tiles that might form an auto-tile set
  confidence: number // 0-1, how confident the detection is
  mapping?: AutoTileMapping // suggested bitmask mapping
}

/**
 * Asset validation result
 */
export interface AssetValidation {
  valid: boolean
  errors: string[]
  warnings: string[]
}

/**
 * Client-side asset state (for React components)
 */
export interface AssetLibraryState {
  assets: Map<string, Asset>
  folders: Map<string, AssetFolder>
  selectedAssetId: string | null
  filter: AssetFilter
  uploadProgress: Map<string, AssetUploadProgress>
  isLoading: boolean
  error: string | null
}

/**
 * Asset usage tracking (where is this asset used?)
 */
export interface AssetUsage {
  assetId: string
  canvasIds: string[] // canvases using this asset
  usageCount: number // total times used across all canvases
}
</file>

<file path="src/types/export.ts">
/**
 * Export Types for Game Engine Export System
 * Supports multiple export formats: Godot, Unity, Phaser, Generic JSON
 */

/**
 * Supported export formats
 */
export type ExportFormat = 'generic' | 'godot' | 'unity' | 'phaser'

/**
 * Export file (part of export result)
 */
export interface ExportFile {
  name: string // file name (e.g., 'scene.tscn', 'tilemap.json')
  content: string | Blob // file content
  mimeType: string // e.g., 'text/plain', 'application/json', 'image/png'
  path?: string // optional path within export (for nested files)
}

/**
 * Export validation result
 */
export interface ExportValidation {
  valid: boolean
  errors: string[]
  warnings: string[]
  unsupportedFeatures: string[] // features that won't be exported
}

/**
 * Export result returned by exporters
 */
export interface ExportResult {
  success: boolean
  files: ExportFile[]
  warnings: string[]
  instructions: string // markdown instructions for importing in target engine
  metadata: ExportMetadata
}

/**
 * Export metadata
 */
export interface ExportMetadata {
  format: ExportFormat
  exportedAt: number
  canvasId: string
  canvasName: string
  version: string
  objectCount: number
  hasAnimations: boolean
  hasTilemap: boolean
  exportOptions: ExportOptions
}

/**
 * Base export options (common to all formats)
 */
export interface ExportOptions {
  format: ExportFormat
  includeAssets: boolean // include referenced assets
  prettyPrint: boolean // format JSON output
  includeDocumentation: boolean // include README/instructions
}

/**
 * Godot-specific export options
 */
export interface GodotExportOptions extends ExportOptions {
  format: 'godot'
  targetVersion: '3.x' | '4.x'
  includePhysics: boolean // add collision shapes
  nodeNamingScheme: 'descriptive' | 'simple' // e.g., "PlayerSprite" vs "Sprite2D"
  pixelsPerUnit: number // scaling factor
  includeAutoTiles: boolean // export tilemap auto-tiling config
}

/**
 * Unity-specific export options
 */
export interface UnityExportOptions extends ExportOptions {
  format: 'unity'
  targetVersion: string // e.g., '2021.3', '2022.3'
  pixelsPerUnit: number // Unity sprite import setting
  includeColliders: boolean // add BoxCollider2D, etc.
  generateMaterials: boolean // create material assets
  sortingLayerName: string // default sorting layer
}

/**
 * Phaser-specific export options
 */
export interface PhaserExportOptions extends ExportOptions {
  format: 'phaser'
  physicsEngine: 'arcade' | 'matter' | 'none'
  includeLoaders: boolean // add Phaser.Scene preload code
  minifyJSON: boolean // minify JSON output
  generateAtlas: boolean // create texture atlas
}

/**
 * Generic JSON export options
 */
export interface GenericExportOptions extends ExportOptions {
  format: 'generic'
  includeSchema: boolean // include JSON schema definition
  exportPNGLayers: boolean // export each layer as PNG
  exportResolution: number // scale factor for PNG export (1 = original, 2 = 2x)
  coordinateSystem: 'top-left' | 'center' // coordinate origin
}

/**
 * Generic JSON export format (engine-agnostic)
 */
export interface GenericCanvasExport {
  version: string // export format version
  metadata: {
    canvasId: string
    canvasName: string
    width: number
    height: number
    exportedAt: string // ISO timestamp
    exportedBy: string // user ID
    coordinateSystem: 'top-left' | 'center'
  }
  layers: GenericLayer[]
  tilemap?: GenericTilemap
  assets: GenericAsset[]
  animations: GenericAnimation[]
}

/**
 * Generic layer export
 */
export interface GenericLayer {
  id: string
  name: string
  zIndex: number
  visible: boolean
  opacity: number
  objects: GenericObject[]
}

/**
 * Generic object export
 */
export interface GenericObject {
  id: string
  type: string // 'rectangle', 'circle', 'sprite', etc.
  x: number
  y: number
  width: number
  height: number
  rotation: number // degrees
  fill?: string // RGBA hex
  stroke?: string // RGBA hex
  strokeWidth?: number
  // Shape-specific properties
  text?: string
  fontFamily?: string
  fontSize?: number
  // Sprite-specific
  spriteSheetId?: string
  animationId?: string
  flipX?: boolean
  flipY?: boolean
  // Path/polygon
  points?: number[]
  closed?: boolean
  // Custom properties
  [key: string]: any
}

/**
 * Generic tilemap export
 */
export interface GenericTilemap {
  width: number // in tiles
  height: number // in tiles
  tileWidth: number // in pixels
  tileHeight: number // in pixels
  layers: GenericTilemapLayer[]
  tilesets: GenericTileset[]
}

/**
 * Generic tilemap layer
 */
export interface GenericTilemapLayer {
  id: string
  name: string
  data: (number | null)[][] // 2D array: data[y][x] = tile index (null = empty)
  visible: boolean
  opacity: number
}

/**
 * Generic tileset export
 */
export interface GenericTileset {
  id: string
  name: string
  imageUrl: string // relative path or data URL
  tileWidth: number
  tileHeight: number
  tileCount: number
  columns: number
  spacing: number
  margin: number
  autoTileMapping?: { [bitmask: number]: number }
}

/**
 * Generic asset reference
 */
export interface GenericAsset {
  id: string
  name: string
  type: 'image' | 'spritesheet' | 'tileset'
  url: string // relative path or data URL
  width: number
  height: number
  metadata?: {
    frameWidth?: number
    frameHeight?: number
    frameCount?: number
    tileWidth?: number
    tileHeight?: number
    [key: string]: any
  }
}

/**
 * Generic animation export
 */
export interface GenericAnimation {
  id: string
  name: string
  spriteSheetId: string
  fps: number
  loop: boolean
  frames: GenericAnimationFrame[]
}

/**
 * Generic animation frame
 */
export interface GenericAnimationFrame {
  x: number // crop x
  y: number // crop y
  width: number
  height: number
  duration?: number // ms, overrides fps
}

/**
 * Export progress tracking
 */
export interface ExportProgress {
  stage: 'validating' | 'collecting' | 'converting' | 'packaging' | 'complete' | 'error'
  progress: number // 0-100
  message: string
  warnings: string[]
  errors: string[]
}

/**
 * Exporter interface (implemented by each format exporter)
 */
export interface Exporter {
  format: ExportFormat
  name: string
  description: string
  
  /**
   * Validate canvas before export
   */
  validate(canvasId: string): Promise<ExportValidation>
  
  /**
   * Export canvas to target format
   */
  export(canvasId: string, options: ExportOptions, onProgress?: (progress: ExportProgress) => void): Promise<ExportResult>
  
  /**
   * Get supported features for this exporter
   */
  getSupportedFeatures(): string[]
  
  /**
   * Get default options for this exporter
   */
  getDefaultOptions(): ExportOptions
}
</file>

<file path="src/utils/canvas/groupHelpers.ts">
/**
 * Group Helper Utilities (PR-19)
 * Functions for calculating group bounds and managing group membership
 */

import type { Shape } from '../../types/canvas'
import type { Group, GroupBounds } from '../../types/group'

/**
 * Calculate bounding box for a group based on member positions
 */
export function calculateGroupBounds(
  members: Shape[],
  groups?: Group[]
): GroupBounds {
  if (members.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 }
  }

  // Initialize with first member bounds
  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  members.forEach((member) => {
    // For shapes, use their position and dimensions
    const memberMinX = member.x
    const memberMinY = member.y
    const memberMaxX = member.x + member.width
    const memberMaxY = member.y + member.height

    minX = Math.min(minX, memberMinX)
    minY = Math.min(minY, memberMinY)
    maxX = Math.max(maxX, memberMaxX)
    maxY = Math.max(maxY, memberMaxY)
  })

  // Also consider nested groups if provided
  if (groups && groups.length > 0) {
    groups.forEach((group) => {
      minX = Math.min(minX, group.x)
      minY = Math.min(minY, group.y)
      maxX = Math.max(maxX, group.x + group.width)
      maxY = Math.max(maxY, group.y + group.height)
    })
  }

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY,
  }
}

/**
 * Check if a shape is a member of a specific group
 */
export function isInGroup(shapeId: string, groupId: string, groups: Group[]): boolean {
  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return false
  }
  return group.memberIds.includes(shapeId)
}

/**
 * Check if a shape is in any group
 */
export function isInAnyGroup(shapeId: string, groups: Group[]): string | null {
  for (const group of groups) {
    if (group.memberIds.includes(shapeId)) {
      return group.id
    }
  }
  return null
}

/**
 * Get all member IDs of a group, including nested groups (recursive)
 * @param maxDepth Maximum nesting depth to prevent infinite loops (default: 10)
 */
export function getAllGroupMembers(
  groupId: string,
  groups: Group[],
  maxDepth: number = 10,
  currentDepth: number = 0
): string[] {
  if (currentDepth >= maxDepth) {
    console.warn(`Maximum group nesting depth (${maxDepth}) reached`)
    return []
  }

  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return []
  }

  const allMembers: string[] = []

  for (const memberId of group.memberIds) {
    allMembers.push(memberId)

    // Check if this member is itself a group (nested group)
    const nestedGroup = groups.find((g) => g.id === memberId)
    if (nestedGroup) {
      // Recursively get members of nested group
      const nestedMembers = getAllGroupMembers(
        memberId,
        groups,
        maxDepth,
        currentDepth + 1
      )
      allMembers.push(...nestedMembers)
    }
  }

  return allMembers
}

/**
 * Get all shapes that are members of a group (including nested groups)
 */
export function getGroupShapes(
  groupId: string,
  groups: Group[],
  allShapes: Shape[]
): Shape[] {
  const memberIds = getAllGroupMembers(groupId, groups)
  return allShapes.filter((shape) => memberIds.includes(shape.id))
}

/**
 * Calculate the center point of a group
 */
export function getGroupCenter(bounds: GroupBounds): { x: number; y: number } {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2,
  }
}

/**
 * Check if groups form a circular dependency
 */
export function hasCircularDependency(
  groupId: string,
  potentialMemberId: string,
  groups: Group[]
): boolean {
  // If we're adding the group itself as a member, that's circular
  if (groupId === potentialMemberId) {
    return true
  }

  // Check if the potential member is a group that contains our group
  const allMembers = getAllGroupMembers(potentialMemberId, groups)
  return allMembers.includes(groupId)
}

/**
 * Get the depth level of a group in the hierarchy
 */
export function getGroupDepth(groupId: string, groups: Group[]): number {
  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return 0
  }

  let maxChildDepth = 0
  for (const memberId of group.memberIds) {
    const childGroup = groups.find((g) => g.id === memberId)
    if (childGroup) {
      const childDepth = getGroupDepth(memberId, groups)
      maxChildDepth = Math.max(maxChildDepth, childDepth)
    }
  }

  return maxChildDepth + 1
}

/**
 * Get all top-level groups (groups that are not members of other groups)
 */
export function getTopLevelGroups(groups: Group[]): Group[] {
  return groups.filter((group) => {
    // Check if this group is a member of any other group
    return !groups.some((otherGroup) =>
      otherGroup.memberIds.includes(group.id)
    )
  })
}

/**
 * Get child groups of a specific group
 */
export function getChildGroups(groupId: string, groups: Group[]): Group[] {
  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return []
  }

  return groups.filter((g) => group.memberIds.includes(g.id))
}

/**
 * Update group bounds based on member shapes
 */
export function updateGroupBounds(
  group: Group,
  shapes: Shape[],
  groups: Group[]
): GroupBounds {
  const memberShapes = shapes.filter((shape) =>
    group.memberIds.includes(shape.id)
  )
  // Get groups that are members of this group
  const memberGroups = groups.filter((g) =>
    group.memberIds.includes(g.id)
  )
  
  return calculateGroupBounds(memberShapes, memberGroups)
}
</file>

<file path="src/utils/canvas/pathHelpers.ts">
/**
 * Path Helper Utilities (PR-21)
 * Functions for path simplification and smoothing for freehand drawing
 */

/**
 * Calculate perpendicular distance from a point to a line segment
 */
function perpendicularDistance(
  point: { x: number; y: number },
  lineStart: { x: number; y: number },
  lineEnd: { x: number; y: number }
): number {
  const dx = lineEnd.x - lineStart.x
  const dy = lineEnd.y - lineStart.y

  // Normalize
  const mag = Math.sqrt(dx * dx + dy * dy)
  if (mag > 0) {
    const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag)
    const closest = {
      x: lineStart.x + u * dx,
      y: lineStart.y + u * dy,
    }
    return Math.sqrt(
      (point.x - closest.x) ** 2 + (point.y - closest.y) ** 2
    )
  } else {
    return Math.sqrt(
      (point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2
    )
  }
}

/**
 * Douglas-Peucker algorithm for path simplification
 * Reduces the number of points while maintaining the shape
 * @param points Flat array of coordinates [x1, y1, x2, y2, ...]
 * @param tolerance Maximum distance a point can be from the simplified line
 * @returns Simplified flat array of coordinates
 */
export function simplifyPath(points: number[], tolerance: number = 2): number[] {
  if (points.length <= 4) {
    // Less than 2 points, can't simplify
    return points
  }

  // Convert flat array to point objects
  const pointObjects: { x: number; y: number }[] = []
  for (let i = 0; i < points.length; i += 2) {
    pointObjects.push({ x: points[i], y: points[i + 1] })
  }

  // Recursive Douglas-Peucker
  function douglasPeucker(
    pts: { x: number; y: number }[],
    startIndex: number,
    endIndex: number
  ): { x: number; y: number }[] {
    if (endIndex <= startIndex + 1) {
      return []
    }

    // Find the point with the maximum distance from the line segment
    let maxDistance = 0
    let maxIndex = startIndex

    for (let i = startIndex + 1; i < endIndex; i++) {
      const distance = perpendicularDistance(
        pts[i],
        pts[startIndex],
        pts[endIndex]
      )
      if (distance > maxDistance) {
        maxDistance = distance
        maxIndex = i
      }
    }

    // If max distance is greater than tolerance, recursively simplify
    if (maxDistance > tolerance) {
      const left = douglasPeucker(pts, startIndex, maxIndex)
      const right = douglasPeucker(pts, maxIndex, endIndex)
      return [...left, pts[maxIndex], ...right]
    } else {
      return []
    }
  }

  const simplified = [
    pointObjects[0],
    ...douglasPeucker(pointObjects, 0, pointObjects.length - 1),
    pointObjects[pointObjects.length - 1],
  ]

  // Convert back to flat array
  const result: number[] = []
  for (const point of simplified) {
    result.push(point.x, point.y)
  }

  return result
}

/**
 * Smooth a path using Catmull-Rom spline interpolation
 * Note: This is a simplified version that doesn't actually interpolate,
 * but returns the original points for use with Konva's tension parameter
 * @param points Flat array of coordinates [x1, y1, x2, y2, ...]
 * @returns Smoothed flat array of coordinates
 */
export function smoothPath(points: number[]): number[] {
  // For Konva, smoothing is handled by the tension parameter
  // This function mainly ensures the path has enough points
  // and removes duplicate consecutive points
  
  if (points.length <= 4) {
    return points
  }

  const smoothed: number[] = []
  let lastX: number | null = null
  let lastY: number | null = null

  for (let i = 0; i < points.length; i += 2) {
    const x = points[i]
    const y = points[i + 1]

    // Skip duplicate consecutive points
    if (x !== lastX || y !== lastY) {
      smoothed.push(x, y)
      lastX = x
      lastY = y
    }
  }

  return smoothed
}

/**
 * Calculate bounding box for a path (for selection)
 * @param points Flat array of coordinates [x1, y1, x2, y2, ...]
 * @returns Bounding box with min/max x/y coordinates
 */
export function calculatePathBounds(points: number[]): {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
} {
  if (points.length < 2) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }
  }

  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  for (let i = 0; i < points.length; i += 2) {
    const x = points[i]
    const y = points[i + 1]

    minX = Math.min(minX, x)
    minY = Math.min(minY, y)
    maxX = Math.max(maxX, x)
    maxY = Math.max(maxY, y)
  }

  return {
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY,
  }
}

/**
 * Calculate distance between two consecutive points
 */
export function getDistance(x1: number, y1: number, x2: number, y2: number): number {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
}

/**
 * Sample points along a path to ensure minimum spacing
 * Used for pen tool to create smoother, fewer points
 * @param points Flat array of coordinates [x1, y1, x2, y2, ...]
 * @param minSpacing Minimum distance between points
 * @returns Filtered flat array of coordinates
 */
export function samplePathPoints(points: number[], minSpacing: number = 5): number[] {
  if (points.length <= 2) {
    return points
  }

  const sampled: number[] = [points[0], points[1]] // Always include first point

  let lastX = points[0]
  let lastY = points[1]

  for (let i = 2; i < points.length; i += 2) {
    const x = points[i]
    const y = points[i + 1]

    const distance = getDistance(lastX, lastY, x, y)
    
    if (distance >= minSpacing) {
      sampled.push(x, y)
      lastX = x
      lastY = y
    }
  }

  // Always include last point if it's not already there
  const lastPointX = points[points.length - 2]
  const lastPointY = points[points.length - 1]
  if (lastX !== lastPointX || lastY !== lastPointY) {
    sampled.push(lastPointX, lastPointY)
  }

  return sampled
}
</file>

<file path="src/utils/common/downloadHelper.ts">
/**
 * Download Helper Utilities
 * Functions for triggering file downloads in the browser
 */

/**
 * Download data as JSON file
 * Creates a blob and triggers browser download
 * 
 * @param data Data to download (will be JSON.stringify'd)
 * @param filename Filename for download
 */
export function downloadJSON(data: any, filename: string): void {
  try {
    // Convert to JSON string with pretty formatting
    const jsonString = JSON.stringify(data, null, 2)
    
    // Create blob
    const blob = new Blob([jsonString], {
      type: 'application/json',
    })
    
    // Create download URL
    const url = URL.createObjectURL(blob)
    
    // Create temporary link element
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    
    // Trigger download
    document.body.appendChild(a)
    a.click()
    
    // Cleanup
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('Failed to download JSON:', error)
    throw error
  }
}

/**
 * Download text content as file
 * 
 * @param content Text content to download
 * @param filename Filename for download
 * @param mimeType MIME type (default: text/plain)
 */
export function downloadText(
  content: string,
  filename: string,
  mimeType: string = 'text/plain'
): void {
  try {
    // Create blob
    const blob = new Blob([content], { type: mimeType })
    
    // Create download URL
    const url = URL.createObjectURL(blob)
    
    // Create temporary link element
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    
    // Trigger download
    document.body.appendChild(a)
    a.click()
    
    // Cleanup
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('Failed to download text:', error)
    throw error
  }
}

/**
 * Trigger file picker for upload
 * Returns a promise that resolves with the selected file
 * 
 * @param accept File types to accept (e.g., '.json')
 * @returns Promise that resolves with selected File or null
 */
export function selectFile(accept: string = '*'): Promise<File | null> {
  return new Promise((resolve) => {
    // Create input element
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = accept
    
    // Handle file selection
    input.onchange = (e) => {
      const target = e.target as HTMLInputElement
      const file = target.files?.[0] || null
      resolve(file)
      
      // Cleanup
      document.body.removeChild(input)
    }
    
    // Handle cancel
    input.oncancel = () => {
      resolve(null)
      document.body.removeChild(input)
    }
    
    // Trigger file picker
    document.body.appendChild(input)
    input.click()
  })
}
</file>

<file path="src/utils/common/throttle.ts">
/**
 * Throttle function to limit execution rate
 * @param fn Function to throttle
 * @param delay Minimum time between executions in milliseconds
 * @returns Throttled function
 */
export function throttle<T extends (...args: any[]) => void>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let lastCall = 0

  return function (...args: Parameters<T>) {
    const now = Date.now()

    if (now - lastCall >= delay) {
      lastCall = now
      fn(...args)
    }
  }
}
</file>

<file path="src/utils/exporters/baseExporter.ts">
/**
 * Base Exporter Utilities
 * Common functions used by all exporters
 */

import type { Shape } from '../../types/canvas'
import type { Asset } from '../../types/asset'
import type { Animation } from '../../types/animation'
import type { ExportFile, ExportValidation } from '../../types/export'
import { firestore, storage } from '../../services/firebase'
import { collection, getDocs, query, where } from 'firebase/firestore'
import { ref, getBlob } from 'firebase/storage'

/**
 * Fetch all objects from a canvas
 */
export async function fetchCanvasObjects(canvasId: string): Promise<Shape[]> {
  const objectsRef = collection(firestore, 'canvases', canvasId, 'objects')
  const snapshot = await getDocs(objectsRef)
  
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  })) as Shape[]
}

/**
 * Fetch tilemap data from a canvas
 */
export async function fetchTilemapData(canvasId: string) {
  try {
    const tilesRef = collection(firestore, 'tilemaps', canvasId, 'tiles')
    const snapshot = await getDocs(tilesRef)
    
    if (snapshot.empty) {
      return null
    }

    const tiles: any[] = []
    snapshot.forEach(doc => {
      tiles.push({
        id: doc.id,
        ...doc.data()
      })
    })

    return tiles
  } catch (error) {
    console.warn('No tilemap data found:', error)
    return null
  }
}

/**
 * Fetch assets referenced by canvas objects
 */
export async function fetchReferencedAssets(
  objects: Shape[],
  userId: string
): Promise<Map<string, Asset>> {
  const assetIds = new Set<string>()
  
  // Collect asset IDs from objects
  objects.forEach(obj => {
    if (obj.spriteSheetId) assetIds.add(obj.spriteSheetId)
    if (obj.animationId) {
      // We'll need to fetch animations to get their sprite sheet IDs
    }
  })

  const assets = new Map<string, Asset>()

  // Fetch each asset
  for (const assetId of assetIds) {
    try {
      const assetsRef = collection(firestore, 'assets')
      const q = query(assetsRef, where('userId', '==', userId), where('id', '==', assetId))
      const snapshot = await getDocs(q)
      
      if (!snapshot.empty) {
        const assetData = { ...snapshot.docs[0].data(), id: snapshot.docs[0].id } as Asset
        assets.set(assetId, assetData)
      }
    } catch (error) {
      console.warn(`Failed to fetch asset ${assetId}:`, error)
    }
  }

  return assets
}

/**
 * Fetch animations from canvas
 */
export async function fetchAnimations(canvasId: string): Promise<Map<string, Animation>> {
  try {
    const animationsRef = collection(firestore, 'animations', canvasId, 'items')
    const snapshot = await getDocs(animationsRef)
    
    const animations = new Map<string, Animation>()
    snapshot.forEach(doc => {
      animations.set(doc.id, {
        id: doc.id,
        ...doc.data()
      } as Animation)
    })

    return animations
  } catch (error) {
    console.warn('Failed to fetch animations:', error)
    return new Map()
  }
}

/**
 * Download asset as blob
 */
export async function downloadAsset(asset: Asset): Promise<Blob> {
  try {
    const assetRef = ref(storage, asset.url)
    const blob = await getBlob(assetRef)
    return blob
  } catch (error) {
    console.error('Failed to download asset:', error)
    throw new Error(`Failed to download asset: ${asset.name}`)
  }
}

/**
 * Convert blob to data URL
 */
export async function blobToDataURL(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(reader.result as string)
    reader.onerror = reject
    reader.readAsDataURL(blob)
  })
}

/**
 * Create a ZIP file from export files
 */
export async function createZipFromFiles(files: ExportFile[]): Promise<Blob> {
  // Dynamically import JSZip (we'll need to install this)
  const JSZip = (await import('jszip')).default
  
  const zip = new JSZip()
  
  for (const file of files) {
    const path = file.path ? `${file.path}/${file.name}` : file.name
    
    if (typeof file.content === 'string') {
      zip.file(path, file.content)
    } else {
      zip.file(path, file.content)
    }
  }

  return await zip.generateAsync({ type: 'blob' })
}

/**
 * Download blob as file
 */
export function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

/**
 * Validate canvas has required data
 */
export async function validateCanvasForExport(canvasId: string): Promise<ExportValidation> {
  const errors: string[] = []
  const warnings: string[] = []
  const unsupportedFeatures: string[] = []

  try {
    // Check if canvas exists
    const objects = await fetchCanvasObjects(canvasId)
    
    if (objects.length === 0) {
      warnings.push('Canvas is empty - no objects to export')
    }

    // Check for unsupported features
    objects.forEach(obj => {
      if (obj.type === 'path') {
        unsupportedFeatures.push('Freehand paths (will be exported as generic objects)')
      }
      if (obj.type === 'roundRect') {
        unsupportedFeatures.push('Rounded rectangles (may appear as regular rectangles in some engines)')
      }
    })

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      unsupportedFeatures: Array.from(new Set(unsupportedFeatures))
    }
  } catch (error) {
    return {
      valid: false,
      errors: [error instanceof Error ? error.message : 'Unknown error during validation'],
      warnings,
      unsupportedFeatures
    }
  }
}

/**
 * Convert RGBA hex to RGB array [0-255, 0-255, 0-255]
 */
export function hexToRgb(hex: string): [number, number, number] {
  // Remove # if present
  hex = hex.replace(/^#/, '')
  
  // Parse hex (can be RRGGBB or RRGGBBAA)
  const r = parseInt(hex.substring(0, 2), 16)
  const g = parseInt(hex.substring(2, 4), 16)
  const b = parseInt(hex.substring(4, 6), 16)
  
  return [r, g, b]
}

/**
 * Convert RGBA hex to normalized RGBA [0-1, 0-1, 0-1, 0-1]
 */
export function hexToRgbaNormalized(hex: string): [number, number, number, number] {
  // Remove # if present
  hex = hex.replace(/^#/, '')
  
  const r = parseInt(hex.substring(0, 2), 16) / 255
  const g = parseInt(hex.substring(2, 4), 16) / 255
  const b = parseInt(hex.substring(4, 6), 16) / 255
  const a = hex.length === 8 ? parseInt(hex.substring(6, 8), 16) / 255 : 1.0
  
  return [r, g, b, a]
}

/**
 * Sanitize name for use as identifier (remove special characters)
 */
export function sanitizeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^[0-9]/, '_$&') // Don't start with number
    .replace(/_+/g, '_') // Remove duplicate underscores
    .substring(0, 64) // Limit length
}

/**
 * Generate unique object name
 */
export function generateObjectName(shape: Shape, index: number): string {
  const baseName = shape.type.charAt(0).toUpperCase() + shape.type.slice(1)
  return `${baseName}_${index}`
}

/**
 * Create README file with import instructions
 */
export function createReadme(format: string, instructions: string): ExportFile {
  return {
    name: 'README.md',
    content: `# Canvas Export - ${format}\n\n${instructions}\n\nExported at: ${new Date().toISOString()}\n`,
    mimeType: 'text/markdown'
  }
}

/**
 * Create JSON schema file
 */
export function createSchemaFile(schema: object): ExportFile {
  return {
    name: 'schema.json',
    content: JSON.stringify(schema, null, 2),
    mimeType: 'application/json'
  }
}

/**
 * Convert canvas coordinate system
 * CollabCanva uses top-left origin, some engines use center origin
 */
export function convertCoordinates(
  x: number,
  y: number,
  canvasWidth: number,
  canvasHeight: number,
  targetSystem: 'top-left' | 'center'
): { x: number; y: number } {
  if (targetSystem === 'center') {
    return {
      x: x - canvasWidth / 2,
      y: y - canvasHeight / 2
    }
  }
  return { x, y }
}

/**
 * Round number to N decimal places
 */
export function roundTo(value: number, decimals: number = 2): number {
  const multiplier = Math.pow(10, decimals)
  return Math.round(value * multiplier) / multiplier
}
</file>

<file path="src/utils/exporters/genericExporter.ts">
/**
 * Generic JSON Exporter
 * Engine-agnostic export format with complete canvas data
 * Most important exporter - works with any game engine
 */

import type {
  Exporter,
  ExportResult,
  ExportValidation,
  ExportOptions,
  GenericExportOptions,
  ExportFile,
  ExportProgress,
  GenericCanvasExport,
  GenericLayer,
  GenericObject,
  GenericTilemap,
  GenericTilemapLayer,
  GenericTileset,
  GenericAsset,
  GenericAnimation,
  GenericAnimationFrame,
  ExportMetadata
} from '../../types/export'
import {
  fetchCanvasObjects,
  fetchTilemapData,
  fetchReferencedAssets,
  fetchAnimations,
  validateCanvasForExport,
  downloadAsset,
  blobToDataURL,
  createReadme,
  createSchemaFile,
  convertCoordinates,
  roundTo
} from './baseExporter'
import type { Shape } from '../../types/canvas'
import { DEFAULT_CANVAS_CONFIG } from '../../types/canvas'
import { doc, getDoc } from 'firebase/firestore'
import { firestore } from '../../services/firebase'

export class GenericExporter implements Exporter {
  format: 'generic' = 'generic'
  name = 'Generic JSON'
  description = 'Engine-agnostic JSON export with complete canvas data'

  /**
   * Get default export options
   */
  getDefaultOptions(): GenericExportOptions {
    return {
      format: 'generic',
      includeAssets: true,
      prettyPrint: true,
      includeDocumentation: true,
      includeSchema: true,
      exportPNGLayers: false,
      exportResolution: 1,
      coordinateSystem: 'top-left'
    }
  }

  /**
   * Get supported features
   */
  getSupportedFeatures(): string[] {
    return [
      'All shape types',
      'Tilemaps with auto-tiling',
      'Sprite animations',
      'Layers and z-ordering',
      'Color and stroke properties',
      'Transformations (rotation, scale)',
      'Custom properties',
      'Asset embedding (data URLs)',
      'JSON schema documentation'
    ]
  }

  /**
   * Validate canvas before export
   */
  async validate(canvasId: string): Promise<ExportValidation> {
    return await validateCanvasForExport(canvasId)
  }

  /**
   * Export canvas to generic JSON format
   */
  async export(
    canvasId: string,
    options: ExportOptions,
    onProgress?: (progress: ExportProgress) => void
  ): Promise<ExportResult> {
    const opts = options as GenericExportOptions
    const files: ExportFile[] = []
    const warnings: string[] = []

    try {
      // Stage 1: Validating
      onProgress?.({
        stage: 'validating',
        progress: 10,
        message: 'Validating canvas data...',
        warnings: [],
        errors: []
      })

      const validation = await this.validate(canvasId)
      warnings.push(...validation.warnings)

      if (!validation.valid) {
        return {
          success: false,
          files: [],
          warnings,
          instructions: '',
          metadata: {} as ExportMetadata
        }
      }

      // Stage 2: Collecting data
      onProgress?.({
        stage: 'collecting',
        progress: 30,
        message: 'Collecting canvas objects and assets...',
        warnings,
        errors: []
      })

      const [canvasDoc, objects, tilemapData, animations] = await Promise.all([
        getDoc(doc(firestore, 'canvases', canvasId)),
        fetchCanvasObjects(canvasId),
        fetchTilemapData(canvasId),
        fetchAnimations(canvasId)
      ])

      if (!canvasDoc.exists()) {
        throw new Error('Canvas not found')
      }

      const canvasData = canvasDoc.data()
      const userId = canvasData.ownerId || canvasData.userId

      // Fetch referenced assets
      const assetsMap = await fetchReferencedAssets(objects, userId)

      // Stage 3: Converting
      onProgress?.({
        stage: 'converting',
        progress: 50,
        message: 'Converting to generic format...',
        warnings,
        errors: []
      })

      // Build generic export structure
      const genericExport = await this.buildGenericExport(
        canvasId,
        canvasData,
        objects,
        tilemapData,
        assetsMap,
        animations,
        opts
      )

      // Stage 4: Packaging
      onProgress?.({
        stage: 'packaging',
        progress: 70,
        message: 'Creating export files...',
        warnings,
        errors: []
      })

      // Create main JSON file
      const jsonContent = opts.prettyPrint
        ? JSON.stringify(genericExport, null, 2)
        : JSON.stringify(genericExport)

      files.push({
        name: 'canvas.json',
        content: jsonContent,
        mimeType: 'application/json'
      })

      // Include JSON schema
      if (opts.includeSchema) {
        const schema = this.generateJSONSchema()
        files.push(createSchemaFile(schema))
      }

      // Include documentation
      if (opts.includeDocumentation) {
        const readme = createReadme('Generic JSON', this.generateInstructions())
        files.push(readme)
      }

      // Include assets folder with embedded images
      if (opts.includeAssets && assetsMap.size > 0) {
        onProgress?.({
          stage: 'packaging',
          progress: 80,
          message: 'Embedding asset images...',
          warnings,
          errors: []
        })

        for (const [assetId, asset] of assetsMap) {
          try {
            const blob = await downloadAsset(asset)
            const dataUrl = await blobToDataURL(blob)
            
            // Update asset URL in export to use data URL
            const assetInExport = genericExport.assets.find(a => a.id === assetId)
            if (assetInExport) {
              assetInExport.url = dataUrl
            }
          } catch (error) {
            warnings.push(`Failed to embed asset: ${asset.name}`)
          }
        }
      }

      // Export PNG layers if requested
      if (opts.exportPNGLayers) {
        warnings.push('PNG layer export not yet implemented')
      }

      // Complete
      onProgress?.({
        stage: 'complete',
        progress: 100,
        message: 'Export complete!',
        warnings,
        errors: []
      })

      return {
        success: true,
        files,
        warnings,
        instructions: this.generateInstructions(),
        metadata: {
          format: 'generic',
          exportedAt: Date.now(),
          canvasId,
          canvasName: canvasData.name || 'Untitled Canvas',
          version: '1.0.0',
          objectCount: objects.length,
          hasAnimations: animations.size > 0,
          hasTilemap: !!tilemapData,
          exportOptions: opts
        }
      }
    } catch (error) {
      onProgress?.({
        stage: 'error',
        progress: 0,
        message: 'Export failed',
        warnings,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      })

      return {
        success: false,
        files: [],
        warnings,
        instructions: '',
        metadata: {} as ExportMetadata
      }
    }
  }

  /**
   * Build generic export structure
   */
  private async buildGenericExport(
    canvasId: string,
    canvasData: any,
    objects: Shape[],
    tilemapData: any[] | null,
    assetsMap: Map<string, any>,
    animations: Map<string, any>,
    options: GenericExportOptions
  ): Promise<GenericCanvasExport> {
    const canvasWidth = DEFAULT_CANVAS_CONFIG.width
    const canvasHeight = DEFAULT_CANVAS_CONFIG.height

    // Group objects by z-index into layers
    const layers = this.groupObjectsIntoLayers(objects, canvasWidth, canvasHeight, options)

    // Convert tilemap if exists
    const tilemap = tilemapData ? this.convertTilemap(tilemapData, assetsMap) : undefined

    // Convert assets
    const assets = this.convertAssets(assetsMap)

    // Convert animations
    const exportAnimations = this.convertAnimations(animations)

    return {
      version: '1.0.0',
      metadata: {
        canvasId,
        canvasName: canvasData.name || 'Untitled Canvas',
        width: canvasWidth,
        height: canvasHeight,
        exportedAt: new Date().toISOString(),
        exportedBy: canvasData.ownerId || canvasData.userId || 'unknown',
        coordinateSystem: options.coordinateSystem
      },
      layers,
      tilemap,
      assets,
      animations: exportAnimations
    }
  }

  /**
   * Group objects into layers by z-index
   */
  private groupObjectsIntoLayers(
    objects: Shape[],
    canvasWidth: number,
    canvasHeight: number,
    options: GenericExportOptions
  ): GenericLayer[] {
    // Sort objects by z-index
    const sortedObjects = [...objects].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0))

    // Group into layers (every 1000 z-index units = 1 layer)
    const layerMap = new Map<number, Shape[]>()
    
    sortedObjects.forEach(obj => {
      const layerIndex = Math.floor((obj.zIndex || 0) / 1000)
      if (!layerMap.has(layerIndex)) {
        layerMap.set(layerIndex, [])
      }
      layerMap.get(layerIndex)!.push(obj)
    })

    // Convert to generic layers
    const layers: GenericLayer[] = []
    
    layerMap.forEach((layerObjects, layerIndex) => {
      layers.push({
        id: `layer_${layerIndex}`,
        name: `Layer ${layerIndex}`,
        zIndex: layerIndex,
        visible: true,
        opacity: 1,
        objects: layerObjects.map(obj => this.convertObject(obj, canvasWidth, canvasHeight, options))
      })
    })

    return layers
  }

  /**
   * Convert shape to generic object
   */
  private convertObject(
    shape: Shape,
    canvasWidth: number,
    canvasHeight: number,
    options: GenericExportOptions
  ): GenericObject {
    const { x, y } = convertCoordinates(
      shape.x,
      shape.y,
      canvasWidth,
      canvasHeight,
      options.coordinateSystem
    )

    const obj: GenericObject = {
      id: shape.id,
      type: shape.type,
      x: roundTo(x),
      y: roundTo(y),
      width: roundTo(shape.width),
      height: roundTo(shape.height),
      rotation: roundTo(shape.rotation || 0)
    }

    // Add colors
    if (shape.fill) obj.fill = shape.fill
    if (shape.stroke) obj.stroke = shape.stroke
    if (shape.strokeWidth) obj.strokeWidth = shape.strokeWidth

    // Add text properties
    if (shape.type === 'text') {
      obj.text = shape.text
      obj.fontFamily = shape.fontFamily
      obj.fontSize = shape.fontSize
      obj.fontWeight = shape.fontWeight
      obj.fontStyle = shape.fontStyle
      obj.textAlign = shape.textAlign
      obj.textDecoration = shape.textDecoration
    }

    // Add sprite properties
    if (shape.type === 'animatedSprite') {
      obj.spriteSheetId = shape.spriteSheetId
      obj.animationId = shape.animationId
      obj.flipX = shape.flipX
      obj.flipY = shape.flipY
    }

    // Add path properties
    if (shape.type === 'path' || shape.type === 'line' || shape.type === 'polygon') {
      obj.points = shape.points
      obj.closed = shape.closed
    }

    // Add shape-specific properties
    if (shape.type === 'star') {
      obj.sides = shape.sides
    }
    if (shape.type === 'roundRect') {
      obj.cornerRadius = shape.cornerRadius
    }

    return obj
  }

  /**
   * Convert tilemap data
   */
  private convertTilemap(tilemapData: any[], assetsMap: Map<string, any>): GenericTilemap | undefined {
    if (!tilemapData || tilemapData.length === 0) return undefined

    // Find tilemap bounds
    let maxX = 0, maxY = 0
    const tileSize = 32 // Default, should come from tilemap metadata

    tilemapData.forEach(tile => {
      const coords = tile.id.split('_').map(Number)
      maxX = Math.max(maxX, coords[0])
      maxY = Math.max(maxY, coords[1])
    })

    // Create 2D array
    const data: (number | null)[][] = Array(maxY + 1).fill(null).map(() => Array(maxX + 1).fill(null))

    tilemapData.forEach(tile => {
      const coords = tile.id.split('_').map(Number)
      data[coords[1]][coords[0]] = tile.tileIndex || 0
    })

    // Convert tilesets
    const tilesets = this.convertTilesets(assetsMap)

    return {
      width: maxX + 1,
      height: maxY + 1,
      tileWidth: tileSize,
      tileHeight: tileSize,
      layers: [{
        id: 'tilemap_layer_0',
        name: 'Tilemap Layer',
        data,
        visible: true,
        opacity: 1
      }],
      tilesets
    }
  }

  /**
   * Convert tilesets
   */
  private convertTilesets(assetsMap: Map<string, any>): GenericTileset[] {
    const tilesets: GenericTileset[] = []

    assetsMap.forEach((asset, id) => {
      if (asset.type === 'tileset' && asset.tilesetMetadata) {
        tilesets.push({
          id,
          name: asset.name,
          imageUrl: asset.url,
          tileWidth: asset.tilesetMetadata.tileWidth,
          tileHeight: asset.tilesetMetadata.tileHeight,
          tileCount: asset.tilesetMetadata.tileCount,
          columns: asset.tilesetMetadata.columns,
          spacing: asset.tilesetMetadata.spacing || 0,
          margin: asset.tilesetMetadata.margin || 0,
          autoTileMapping: asset.tilesetMetadata.autoTileMapping
        })
      }
    })

    return tilesets
  }

  /**
   * Convert assets
   */
  private convertAssets(assetsMap: Map<string, any>): GenericAsset[] {
    const assets: GenericAsset[] = []

    assetsMap.forEach((asset, id) => {
      assets.push({
        id,
        name: asset.name,
        type: asset.type,
        url: asset.url, // Will be replaced with data URL if includeAssets is true
        width: asset.metadata.width,
        height: asset.metadata.height,
        metadata: asset.spriteSheetMetadata || asset.tilesetMetadata
      })
    })

    return assets
  }

  /**
   * Convert animations
   */
  private convertAnimations(animations: Map<string, any>): GenericAnimation[] {
    const result: GenericAnimation[] = []

    animations.forEach((anim, id) => {
      result.push({
        id,
        name: anim.name,
        spriteSheetId: anim.spriteSheetId,
        fps: anim.fps || 12,
        loop: anim.loop !== false,
        frames: anim.frames.map((f: any) => ({
          x: f.x,
          y: f.y,
          width: f.width,
          height: f.height,
          duration: f.duration
        }))
      })
    })

    return result
  }

  /**
   * Generate JSON schema
   */
  private generateJSONSchema(): object {
    return {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CollabCanva Generic Export Format",
      "version": "1.0.0",
      "description": "Engine-agnostic canvas export format",
      "type": "object",
      "properties": {
        "version": { "type": "string" },
        "metadata": { "type": "object" },
        "layers": { "type": "array" },
        "tilemap": { "type": "object" },
        "assets": { "type": "array" },
        "animations": { "type": "array" }
      },
      "required": ["version", "metadata", "layers", "assets"]
    }
  }

  /**
   * Generate import instructions
   */
  private generateInstructions(): string {
    return `## Generic JSON Export - Import Instructions

This export contains a complete, engine-agnostic representation of your canvas.

### File Structure
- \`canvas.json\` - Main canvas data
- \`schema.json\` - JSON schema definition
- \`README.md\` - This file

### Format Overview
The JSON file contains:
- **Metadata**: Canvas dimensions, export info
- **Layers**: Objects organized by z-index
- **Objects**: All shapes, sprites, text with complete properties
- **Tilemap**: 2D tile data (if present)
- **Assets**: Referenced images as data URLs or paths
- **Animations**: Frame-by-frame animation definitions

### Coordinate System
By default, coordinates use **top-left origin** (0,0 = top-left corner).
You can configure this to use center origin during export.

### Importing into Game Engines

#### **Godot**
1. Parse the JSON in a GDScript
2. Create Node2D/Sprite2D for each object
3. Use TileMap for tilemap data
4. Load textures from data URLs or external files

#### **Unity**
1. Use JsonUtility or Newtonsoft.Json to parse
2. Create GameObjects with SpriteRenderer for each object
3. Use Tilemap component for tilemap data
4. Convert data URLs to Texture2D

#### **Phaser**
1. Load JSON in scene \`preload()\`
2. Create sprites in \`create()\`
3. Use Phaser.Tilemaps for tilemap data
4. Load images from data URLs

#### **Custom Engine**
This format is designed to be self-documenting and easy to parse.
All measurements are in pixels, colors are in RGBA hex format.

### Color Format
Colors are represented as RGBA hex strings:
- \`#FF0000FF\` = Red, fully opaque
- \`#00FF0080\` = Green, 50% transparent

### Asset Embedding
Assets can be embedded as data URLs (base64) or external file paths.
Data URLs allow single-file exports but increase file size.

### Need Help?
Visit https://collabcanva.dev/docs/export for more examples and tutorials.
`
  }
}

// Export singleton instance
export const genericExporter = new GenericExporter()
</file>

<file path="src/utils/exporters/godotExporter.ts">
/**
 * Godot Engine Exporter
 * Exports canvas to Godot .tscn scene format (text-based scene file)
 * Supports Godot 3.x and 4.x
 */

import type {
  Exporter,
  ExportResult,
  ExportValidation,
  ExportOptions,
  GodotExportOptions,
  ExportFile,
  ExportProgress,
  ExportMetadata
} from '../../types/export'
import {
  fetchCanvasObjects,
  fetchTilemapData,
  fetchReferencedAssets,
  fetchAnimations,
  validateCanvasForExport,
  downloadAsset,
  hexToRgbaNormalized,
  sanitizeName,
  generateObjectName,
  createReadme,
  roundTo
} from './baseExporter'
import type { Shape } from '../../types/canvas'
import { doc, getDoc } from 'firebase/firestore'
import { firestore } from '../../services/firebase'

export class GodotExporter implements Exporter {
  format: 'godot' = 'godot'
  name = 'Godot Engine'
  description = 'Export to Godot .tscn scene format'

  /**
   * Get default export options
   */
  getDefaultOptions(): GodotExportOptions {
    return {
      format: 'godot',
      targetVersion: '4.x',
      includeAssets: true,
      prettyPrint: true,
      includeDocumentation: true,
      includePhysics: false,
      nodeNamingScheme: 'descriptive',
      pixelsPerUnit: 1,
      includeAutoTiles: true
    }
  }

  /**
   * Get supported features
   */
  getSupportedFeatures(): string[] {
    return [
      'Rectangles → ColorRect/Sprite2D',
      'Circles → Sprite2D with circle texture',
      'Text → Label nodes',
      'Sprites → Sprite2D',
      'Tilemaps → TileMap with auto-tiling',
      'Animations → AnimatedSprite2D',
      'Layers → Node hierarchy',
      'Colors and transformations',
      'Collision shapes (if enabled)'
    ]
  }

  /**
   * Validate canvas before export
   */
  async validate(canvasId: string): Promise<ExportValidation> {
    const baseValidation = await validateCanvasForExport(canvasId)
    
    // Add Godot-specific warnings
    const objects = await fetchCanvasObjects(canvasId)
    const warnings = [...baseValidation.warnings]
    const unsupportedFeatures = [...baseValidation.unsupportedFeatures]

    objects.forEach(obj => {
      if (obj.type === 'path') {
        unsupportedFeatures.push('Freehand paths (will be converted to Line2D)')
      }
      if (obj.type === 'polygon' || obj.type === 'star') {
        unsupportedFeatures.push('Polygons/stars (will be converted to Polygon2D)')
      }
    })

    return {
      ...baseValidation,
      warnings,
      unsupportedFeatures: Array.from(new Set(unsupportedFeatures))
    }
  }

  /**
   * Export canvas to Godot format
   */
  async export(
    canvasId: string,
    options: ExportOptions,
    onProgress?: (progress: ExportProgress) => void
  ): Promise<ExportResult> {
    const opts = options as GodotExportOptions
    const files: ExportFile[] = []
    const warnings: string[] = []

    try {
      // Stage 1: Validating
      onProgress?.({
        stage: 'validating',
        progress: 10,
        message: 'Validating canvas for Godot export...',
        warnings: [],
        errors: []
      })

      const validation = await this.validate(canvasId)
      warnings.push(...validation.warnings)

      if (!validation.valid) {
        return {
          success: false,
          files: [],
          warnings,
          instructions: '',
          metadata: {} as ExportMetadata
        }
      }

      // Stage 2: Collecting data
      onProgress?.({
        stage: 'collecting',
        progress: 30,
        message: 'Collecting scene data...',
        warnings,
        errors: []
      })

      const [canvasDoc, objects, tilemapData, animations] = await Promise.all([
        getDoc(doc(firestore, 'canvases', canvasId)),
        fetchCanvasObjects(canvasId),
        fetchTilemapData(canvasId),
        fetchAnimations(canvasId)
      ])

      if (!canvasDoc.exists()) {
        throw new Error('Canvas not found')
      }

      const canvasData = canvasDoc.data()
      const userId = canvasData.ownerId || canvasData.userId
      const canvasName = sanitizeName(canvasData.name || 'Scene')

      // Fetch assets
      const assetsMap = await fetchReferencedAssets(objects, userId)

      // Stage 3: Converting
      onProgress?.({
        stage: 'converting',
        progress: 50,
        message: 'Converting to Godot scene...',
        warnings,
        errors: []
      })

      // Generate .tscn file
      const tscnContent = this.generateTSCN(
        canvasName,
        objects,
        tilemapData,
        assetsMap,
        animations,
        opts
      )

      files.push({
        name: `${canvasName}.tscn`,
        content: tscnContent,
        mimeType: 'text/plain'
      })

      // Stage 4: Packaging
      onProgress?.({
        stage: 'packaging',
        progress: 70,
        message: 'Packaging assets...',
        warnings,
        errors: []
      })

      // Export assets to separate files
      if (opts.includeAssets && assetsMap.size > 0) {
        for (const [assetId, asset] of assetsMap) {
          try {
            const blob = await downloadAsset(asset)
            const fileName = sanitizeName(asset.name) + '.png'
            
            files.push({
              name: fileName,
              content: blob,
              mimeType: 'image/png',
              path: 'assets'
            })
          } catch (error) {
            warnings.push(`Failed to export asset: ${asset.name}`)
          }
        }
      }

      // Include documentation
      if (opts.includeDocumentation) {
        const readme = createReadme('Godot', this.generateInstructions(opts))
        files.push(readme)
      }

      // Complete
      onProgress?.({
        stage: 'complete',
        progress: 100,
        message: 'Godot export complete!',
        warnings,
        errors: []
      })

      return {
        success: true,
        files,
        warnings,
        instructions: this.generateInstructions(opts),
        metadata: {
          format: 'godot',
          exportedAt: Date.now(),
          canvasId,
          canvasName: canvasData.name || 'Untitled Canvas',
          version: opts.targetVersion,
          objectCount: objects.length,
          hasAnimations: animations.size > 0,
          hasTilemap: !!tilemapData,
          exportOptions: opts
        }
      }
    } catch (error) {
      onProgress?.({
        stage: 'error',
        progress: 0,
        message: 'Export failed',
        warnings,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      })

      return {
        success: false,
        files: [],
        warnings,
        instructions: '',
        metadata: {} as ExportMetadata
      }
    }
  }

  /**
   * Generate .tscn file content
   */
  private generateTSCN(
    sceneName: string,
    objects: Shape[],
    tilemapData: any[] | null,
    assetsMap: Map<string, any>,
    animations: Map<string, any>,
    options: GodotExportOptions
  ): string {
    const lines: string[] = []
    const version = options.targetVersion === '4.x' ? 4 : 3

    // Header
    lines.push(`[gd_scene load_steps=2 format=${version}]`)
    lines.push('')

    // Root node
    lines.push(`[node name="${sceneName}" type="Node2D"]`)
    lines.push('')

    // Sort objects by z-index
    const sortedObjects = [...objects].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0))

    // Add objects as child nodes
    sortedObjects.forEach((obj, index) => {
      const nodeDef = this.createNode(obj, index, options)
      lines.push(...nodeDef)
      lines.push('')
    })

    // Add tilemap if exists
    if (tilemapData && tilemapData.length > 0) {
      const tilemapDef = this.createTileMapNode(tilemapData, assetsMap, options)
      lines.push(...tilemapDef)
      lines.push('')
    }

    return lines.join('\n')
  }

  /**
   * Create Godot node definition from shape
   */
  private createNode(shape: Shape, index: number, options: GodotExportOptions): string[] {
    const lines: string[] = []
    const nodeName = this.generateNodeName(shape, index, options)
    const pos = this.convertPosition(shape.x, shape.y, options)
    const scale = options.pixelsPerUnit !== 1 ? options.pixelsPerUnit : 1

    switch (shape.type) {
      case 'rectangle':
        // Use ColorRect for solid rectangles
        lines.push(`[node name="${nodeName}" type="ColorRect" parent="."]`)
        lines.push(`position = Vector2(${pos.x}, ${pos.y})`)
        lines.push(`size = Vector2(${roundTo(shape.width * scale)}, ${roundTo(shape.height * scale)})`)
        
        if (shape.rotation) {
          lines.push(`rotation = ${roundTo((shape.rotation * Math.PI) / 180, 4)}`)
        }
        
        if (shape.fill) {
          const [r, g, b, a] = hexToRgbaNormalized(shape.fill)
          lines.push(`color = Color(${roundTo(r, 3)}, ${roundTo(g, 3)}, ${roundTo(b, 3)}, ${roundTo(a, 3)})`)
        }
        break

      case 'circle':
        // Create as Sprite2D with circle texture (user needs to provide texture)
        lines.push(`[node name="${nodeName}" type="Sprite2D" parent="."]`)
        lines.push(`position = Vector2(${pos.x}, ${pos.y})`)
        lines.push(`scale = Vector2(${roundTo(shape.width / 100 * scale, 3)}, ${roundTo(shape.height / 100 * scale, 3)})`)
        
        if (shape.rotation) {
          lines.push(`rotation = ${roundTo((shape.rotation * Math.PI) / 180, 4)}`)
        }
        
        // Note: User needs to assign texture manually
        lines.push(`# TODO: Assign circle texture`)
        
        if (shape.fill) {
          const [r, g, b, a] = hexToRgbaNormalized(shape.fill)
          lines.push(`modulate = Color(${roundTo(r, 3)}, ${roundTo(g, 3)}, ${roundTo(b, 3)}, ${roundTo(a, 3)})`)
        }
        break

      case 'text':
        lines.push(`[node name="${nodeName}" type="Label" parent="."]`)
        lines.push(`position = Vector2(${pos.x}, ${pos.y})`)
        lines.push(`text = "${(shape.text || '').replace(/"/g, '\\"')}"`)
        
        if (shape.fontSize) {
          // Note: Godot 4.x uses theme overrides differently
          lines.push(`# Font size: ${shape.fontSize}px (configure in theme)`)
        }
        
        if (shape.fill) {
          const [r, g, b, a] = hexToRgbaNormalized(shape.fill)
          lines.push(`modulate = Color(${roundTo(r, 3)}, ${roundTo(g, 3)}, ${roundTo(b, 3)}, ${roundTo(a, 3)})`)
        }
        break

      case 'animatedSprite':
        lines.push(`[node name="${nodeName}" type="AnimatedSprite2D" parent="."]`)
        lines.push(`position = Vector2(${pos.x}, ${pos.y})`)
        lines.push(`scale = Vector2(${roundTo(scale, 3)}, ${roundTo(scale, 3)})`)
        
        if (shape.rotation) {
          lines.push(`rotation = ${roundTo((shape.rotation * Math.PI) / 180, 4)}`)
        }
        
        if (shape.flipX) lines.push(`flip_h = true`)
        if (shape.flipY) lines.push(`flip_v = true`)
        
        lines.push(`# TODO: Configure SpriteFrames resource for animation`)
        break

      case 'line':
        lines.push(`[node name="${nodeName}" type="Line2D" parent="."]`)
        if (shape.points && shape.points.length >= 4) {
          const points = []
          for (let i = 0; i < shape.points.length; i += 2) {
            points.push(`Vector2(${roundTo(shape.points[i])}, ${roundTo(shape.points[i + 1])})`)
          }
          lines.push(`points = PackedVector2Array([${points.join(', ')}])`)
        }
        
        if (shape.stroke) {
          const [r, g, b, a] = hexToRgbaNormalized(shape.stroke)
          lines.push(`default_color = Color(${roundTo(r, 3)}, ${roundTo(g, 3)}, ${roundTo(b, 3)}, ${roundTo(a, 3)})`)
        }
        
        if (shape.strokeWidth) {
          lines.push(`width = ${shape.strokeWidth}`)
        }
        break

      case 'polygon':
      case 'star':
        lines.push(`[node name="${nodeName}" type="Polygon2D" parent="."]`)
        lines.push(`position = Vector2(${pos.x}, ${pos.y})`)
        
        if (shape.points && shape.points.length >= 6) {
          const points = []
          for (let i = 0; i < shape.points.length; i += 2) {
            points.push(`Vector2(${roundTo(shape.points[i])}, ${roundTo(shape.points[i + 1])})`)
          }
          lines.push(`polygon = PackedVector2Array([${points.join(', ')}])`)
        }
        
        if (shape.fill) {
          const [r, g, b, a] = hexToRgbaNormalized(shape.fill)
          lines.push(`color = Color(${roundTo(r, 3)}, ${roundTo(g, 3)}, ${roundTo(b, 3)}, ${roundTo(a, 3)})`)
        }
        break

      default:
        // Fallback to Node2D
        lines.push(`[node name="${nodeName}" type="Node2D" parent="."]`)
        lines.push(`position = Vector2(${pos.x}, ${pos.y})`)
        lines.push(`# Unsupported shape type: ${shape.type}`)
    }

    // Add collision shape if physics enabled
    if (options.includePhysics) {
      lines.push('')
      lines.push(`[node name="CollisionShape2D" type="CollisionShape2D" parent="${nodeName}"]`)
      lines.push(`# TODO: Configure collision shape`)
    }

    return lines
  }

  /**
   * Create TileMap node
   */
  private createTileMapNode(
    tilemapData: any[],
    assetsMap: Map<string, any>,
    options: GodotExportOptions
  ): string[] {
    const lines: string[] = []
    
    lines.push(`[node name="TileMap" type="TileMap" parent="."]`)
    lines.push(`tile_set = null  # TODO: Create TileSet resource`)
    lines.push(`format = 2`)
    
    // Add tile data
    lines.push('')
    lines.push(`# Tile data:`)
    tilemapData.forEach(tile => {
      const coords = tile.id.split('_')
      lines.push(`# Tile at (${coords[0]}, ${coords[1]}): index ${tile.tileIndex || 0}`)
    })
    
    lines.push('')
    lines.push(`# Note: Import tileset assets and configure TileSet resource manually`)
    lines.push(`# See README for instructions`)

    return lines
  }

  /**
   * Generate node name
   */
  private generateNodeName(shape: Shape, index: number, options: GodotExportOptions): string {
    if (options.nodeNamingScheme === 'simple') {
      return generateObjectName(shape, index)
    }
    
    // Descriptive names
    const type = shape.type.charAt(0).toUpperCase() + shape.type.slice(1)
    if (shape.type === 'text' && shape.text) {
      return sanitizeName(`${type}_${shape.text.substring(0, 20)}`)
    }
    return sanitizeName(`${type}_${index}`)
  }

  /**
   * Convert position (Godot uses center of objects, CollabCanva uses top-left)
   */
  private convertPosition(x: number, y: number, options: GodotExportOptions): { x: number; y: number } {
    const scale = options.pixelsPerUnit
    return {
      x: roundTo(x * scale),
      y: roundTo(y * scale)
    }
  }

  /**
   * Generate import instructions
   */
  private generateInstructions(options: GodotExportOptions): string {
    return `## Godot ${options.targetVersion} Export - Import Instructions

Your canvas has been exported to Godot scene format.

### Files Included
- \`Scene.tscn\` - Main scene file
- \`assets/\` - Sprite and tileset images
- \`README.md\` - This file

### Import Steps

1. **Create Godot Project**
   - Open Godot ${options.targetVersion}
   - Create new project or open existing

2. **Copy Files**
   - Copy all exported files into your project folder
   - Place assets in \`res://assets/\` directory

3. **Open Scene**
   - In Godot FileSystem dock, double-click the .tscn file
   - Scene will open in 2D editor

4. **Configure Textures**
   - Circles and sprites need textures assigned
   - Select node → Inspector → Texture property → Load texture
   - Assign appropriate image from assets folder

5. **Configure TileMap (if present)**
   - Create TileSet resource: Scene → New TileSet
   - Add tileset image from assets folder
   - Configure tile regions and auto-tiling
   - Assign TileSet to TileMap node
   - Paint tiles using TileMap editor

6. **Configure Animations (if present)**
   - Select AnimatedSprite2D nodes
   - Create SpriteFrames resource
   - Add frames from sprite sheet
   - Configure animation speed

### Coordinate System
- Objects are positioned in pixels
- Origin is top-left corner (Godot default for 2D)
- Scaling factor: ${options.pixelsPerUnit}x

### Physics (if enabled)
- CollisionShape2D nodes added to objects
- Configure shape type (Rectangle, Circle, Capsule)
- Add StaticBody2D, RigidBody2D, or Area2D as needed

### Next Steps
- Add scripts for game logic
- Configure collision layers and masks
- Set up camera and viewport
- Add lighting and effects

### Troubleshooting
- **Missing textures**: Assign textures manually in Inspector
- **TileMap not showing**: Create and configure TileSet resource
- **Objects wrong size**: Adjust pixel-per-unit scale in export options

### Resources
- Godot 2D Documentation: https://docs.godotengine.org/en/stable/tutorials/2d/
- TileMap Tutorial: https://docs.godotengine.org/en/stable/tutorials/2d/using_tilemaps.html

Enjoy building your game in Godot! 🎮
`
  }
}

// Export singleton instance
export const godotExporter = new GodotExporter()
</file>

<file path="src/utils/migration/migrateToAutoTiles.ts">
/**
 * Auto-Tiles Migration Utility
 * Upgrades existing tilemaps to include auto-tile variants
 */

import { ref, get, update } from 'firebase/database'
import { db } from '../../services/firebase'
import { calculateTileVariant } from '../tilemap/autoTile'
import { hasSpriteAsset } from '../../constants/tilemapDefaults'
import type { TileData, FirebaseTileData } from '../../types/tilemap'
import { coordToKey, keyToCoord, coordToChunk, chunkToKey } from '../../types/tilemap'

/**
 * Migration progress callback
 */
export interface MigrationProgress {
  phase: 'scanning' | 'calculating' | 'writing' | 'complete' | 'error'
  tilesProcessed: number
  totalTiles: number
  chunksProcessed: number
  totalChunks: number
  message: string
}

/**
 * Migration result
 */
export interface MigrationResult {
  success: boolean
  tilesUpdated: number
  chunksUpdated: number
  tilesSkipped: number
  errors: string[]
  durationMs: number
}

/**
 * Check if a tilemap needs migration
 * 
 * @param canvasId Canvas/tilemap ID
 * @returns True if migration needed (has tiles without variants)
 */
export async function needsMigration(canvasId: string): Promise<boolean> {
  try {
    // Check first chunk for tiles without variants
    const chunksRef = ref(db, `tilemaps/${canvasId}/chunks`)
    const snapshot = await get(chunksRef)
    
    if (!snapshot.exists()) {
      return false // No tiles at all
    }
    
    const chunks = snapshot.val()
    
    // Sample first few chunks
    const chunkKeys = Object.keys(chunks).slice(0, 3)
    
    for (const chunkKey of chunkKeys) {
      const tiles = chunks[chunkKey].tiles
      
      if (!tiles) continue
      
      // Check if any tiles are missing variants
      for (const tileKey in tiles) {
        const tile: FirebaseTileData = tiles[tileKey]
        
        // If tile type has sprite assets but no variant, needs migration
        if (hasSpriteAsset(tile.t) && tile.v === undefined) {
          return true
        }
      }
    }
    
    return false
  } catch (error) {
    console.error('Failed to check migration status:', error)
    return false
  }
}

/**
 * Migrate a tilemap to auto-tiles (add variants to all tiles)
 * 
 * @param canvasId Canvas/tilemap ID
 * @param chunkSize Chunk size (default: 16)
 * @param onProgress Progress callback
 * @param dryRun If true, calculate but don't write changes
 * @returns Migration result
 */
export async function migrateCanvas(
  canvasId: string,
  chunkSize: number = 16,
  onProgress?: (progress: MigrationProgress) => void,
  dryRun: boolean = false
): Promise<MigrationResult> {
  const startTime = Date.now()
  const errors: string[] = []
  
  try {
    // Phase 1: Load all tiles from Firebase
    onProgress?.({
      phase: 'scanning',
      tilesProcessed: 0,
      totalTiles: 0,
      chunksProcessed: 0,
      totalChunks: 0,
      message: 'Loading tilemap data...',
    })
    
    const chunksRef = ref(db, `tilemaps/${canvasId}/chunks`)
    const snapshot = await get(chunksRef)
    
    if (!snapshot.exists()) {
      return {
        success: true,
        tilesUpdated: 0,
        chunksUpdated: 0,
        tilesSkipped: 0,
        errors: ['No tiles found'],
        durationMs: Date.now() - startTime,
      }
    }
    
    const chunks = snapshot.val()
    const chunkKeys = Object.keys(chunks)
    
    // Phase 2: Build tile map for variant calculation
    onProgress?.({
      phase: 'calculating',
      tilesProcessed: 0,
      totalTiles: 0,
      chunksProcessed: 0,
      totalChunks: chunkKeys.length,
      message: 'Building tile map...',
    })
    
    const tileMap = new Map<string, TileData>()
    let totalTileCount = 0
    
    // Load all tiles into memory map
    chunkKeys.forEach((chunkKey) => {
      const tiles = chunks[chunkKey].tiles
      if (!tiles) return
      
      const { cx, cy } = (() => {
        const [x, y] = chunkKey.split('_').map(Number)
        return { cx: x, cy: y }
      })()
      
      Object.keys(tiles).forEach((tileKey) => {
        const firebaseTile: FirebaseTileData = tiles[tileKey]
        const { x: lx, y: ly } = keyToCoord(tileKey)
        
        // Convert to global coordinates
        const globalX = cx * chunkSize + lx
        const globalY = cy * chunkSize + ly
        const globalKey = coordToKey(globalX, globalY)
        
        // Decompress tile
        const tile: TileData = {
          type: firebaseTile.t,
          color: firebaseTile.c,
          variant: firebaseTile.v,
        }
        
        tileMap.set(globalKey, tile)
        totalTileCount++
      })
    })
    
    // Phase 3: Calculate variants for all tiles
    onProgress?.({
      phase: 'calculating',
      tilesProcessed: 0,
      totalTiles: totalTileCount,
      chunksProcessed: 0,
      totalChunks: chunkKeys.length,
      message: 'Calculating variants...',
    })
    
    const variantUpdates: Record<string, number> = {}
    let tilesProcessed = 0
    let tilesUpdated = 0
    let tilesSkipped = 0
    
    tileMap.forEach((tile, key) => {
      const { x, y } = keyToCoord(key)
      
      // Only update tiles that:
      // 1. Have sprite assets available
      // 2. Don't already have a variant
      if (hasSpriteAsset(tile.type) && tile.variant === undefined) {
        const variant = calculateTileVariant(x, y, tileMap, tile.type)
        
        // Build Firebase path
        const chunk = coordToChunk(x, y, chunkSize)
        const chunkKey = chunkToKey(chunk.cx, chunk.cy)
        const tileKey = coordToKey(chunk.lx, chunk.ly)
        const firebasePath = `chunks/${chunkKey}/tiles/${tileKey}/v`
        
        variantUpdates[firebasePath] = variant
        tilesUpdated++
      } else {
        tilesSkipped++
      }
      
      tilesProcessed++
      
      if (tilesProcessed % 100 === 0) {
        onProgress?.({
          phase: 'calculating',
          tilesProcessed,
          totalTiles: totalTileCount,
          chunksProcessed: 0,
          totalChunks: chunkKeys.length,
          message: `Calculated variants for ${tilesProcessed}/${totalTileCount} tiles...`,
        })
      }
    })
    
    // Phase 4: Write variants to Firebase
    if (!dryRun && tilesUpdated > 0) {
      onProgress?.({
        phase: 'writing',
        tilesProcessed: totalTileCount,
        totalTiles: totalTileCount,
        chunksProcessed: 0,
        totalChunks: chunkKeys.length,
        message: 'Writing variants to Firebase...',
      })
      
      const tilemapRef = ref(db, `tilemaps/${canvasId}`)
      await update(tilemapRef, variantUpdates)
    }
    
    // Complete
    const durationMs = Date.now() - startTime
    
    onProgress?.({
      phase: 'complete',
      tilesProcessed: totalTileCount,
      totalTiles: totalTileCount,
      chunksProcessed: chunkKeys.length,
      totalChunks: chunkKeys.length,
      message: `Migration complete! Updated ${tilesUpdated} tiles in ${(durationMs / 1000).toFixed(1)}s`,
    })
    
    return {
      success: true,
      tilesUpdated,
      chunksUpdated: chunkKeys.length,
      tilesSkipped,
      errors,
      durationMs,
    }
    
  } catch (error) {
    const errorMsg = `Migration failed: ${error}`
    console.error(errorMsg)
    errors.push(errorMsg)
    
    onProgress?.({
      phase: 'error',
      tilesProcessed: 0,
      totalTiles: 0,
      chunksProcessed: 0,
      totalChunks: 0,
      message: errorMsg,
    })
    
    return {
      success: false,
      tilesUpdated: 0,
      chunksUpdated: 0,
      tilesSkipped: 0,
      errors,
      durationMs: Date.now() - startTime,
    }
  }
}

/**
 * Get migration preview (dry run)
 */
export async function getMigrationPreview(
  canvasId: string,
  chunkSize: number = 16
): Promise<{ tilesNeedingMigration: number; totalTiles: number }> {
  const result = await migrateCanvas(canvasId, chunkSize, undefined, true)
  
  return {
    tilesNeedingMigration: result.tilesUpdated,
    totalTiles: result.tilesUpdated + result.tilesSkipped,
  }
}
</file>

<file path="src/utils/migration/migrationScript.ts">
/**
 * Migration Script - Move data from old structure to new multi-canvas structure (PR-22)
 * 
 * OLD STRUCTURE:
 * canvas/objects/{objectId}
 * presence/{userId}
 * 
 * NEW STRUCTURE:
 * users/{userId}/canvases/{canvasId}/ - canvas metadata
 * canvases/{canvasId}/objects/{objectId}/ - canvas objects
 * canvases/{canvasId}/permissions/{userId}/ - permissions
 * presence/{canvasId}/{userId}/ - presence per canvas
 */

import { ref, get, set } from 'firebase/database'
import { db } from '../../services/firebase'

const OLD_CANVAS_PATH = 'canvas/objects'
const DEFAULT_CANVAS_ID = 'default-canvas'

interface MigrationResult {
  success: boolean
  canvasId: string
  objectsMigrated: number
  errors: string[]
}

/**
 * Migrate existing canvas data to new multi-canvas structure
 * Creates a default canvas for the user and moves all objects to it
 */
export async function migrateToMultiCanvas(userId: string): Promise<MigrationResult> {
  const result: MigrationResult = {
    success: false,
    canvasId: DEFAULT_CANVAS_ID,
    objectsMigrated: 0,
    errors: [],
  }

  try {
    // Check if migration already done (user has canvases entry)
    const userCanvasesRef = ref(db, `users/${userId}/canvases`)
    const userCanvasesSnapshot = await get(userCanvasesRef)
    
    if (userCanvasesSnapshot.exists()) {
      console.log('Migration already completed for this user')
      result.success = true
      return result
    }

    // Step 1: Read all objects from old structure
    const oldObjectsRef = ref(db, OLD_CANVAS_PATH)
    const oldObjectsSnapshot = await get(oldObjectsRef)

    if (!oldObjectsSnapshot.exists()) {
      console.log('No objects to migrate')
      
      // Create default canvas anyway (empty)
      await createDefaultCanvas(userId)
      result.success = true
      return result
    }

    const oldObjects = oldObjectsSnapshot.val()
    const objectIds = Object.keys(oldObjects)

    console.log(`Found ${objectIds.length} objects to migrate`)

    // Step 2: Create default canvas in new structure
    await createDefaultCanvas(userId)

    // Step 3: Migrate each object to new structure
    for (const objectId of objectIds) {
      try {
        const objectData = oldObjects[objectId]
        
        // Write to new location: canvases/{canvasId}/objects/{objectId}
        const newObjectRef = ref(db, `canvases/${DEFAULT_CANVAS_ID}/objects/${objectId}`)
        await set(newObjectRef, objectData)
        
        result.objectsMigrated++
      } catch (error) {
        const errorMsg = `Failed to migrate object ${objectId}: ${error}`
        console.error(errorMsg)
        result.errors.push(errorMsg)
      }
    }

    // Step 4: Remove old data (optional - comment out if you want to keep backup)
    // await remove(oldObjectsRef)
    // console.log('Old data removed')

    result.success = result.errors.length === 0
    console.log(`Migration complete: ${result.objectsMigrated} objects migrated`)
    
    return result
  } catch (error) {
    const errorMsg = `Migration failed: ${error}`
    console.error(errorMsg)
    result.errors.push(errorMsg)
    return result
  }
}

/**
 * Create default canvas for user
 */
async function createDefaultCanvas(userId: string): Promise<void> {
  const now = Date.now()
  
  // Create canvas metadata in users/{userId}/canvases/{canvasId}
  const canvasMetadata = {
    name: 'My First Canvas',
    createdAt: now,
    updatedAt: now,
    thumbnail: '', // Empty for now
    ownerId: userId,
  }
  
  const userCanvasRef = ref(db, `users/${userId}/canvases/${DEFAULT_CANVAS_ID}`)
  await set(userCanvasRef, canvasMetadata)
  
  // Create owner permission in canvases/{canvasId}/permissions/{userId}
  const permissionRef = ref(db, `canvases/${DEFAULT_CANVAS_ID}/permissions/${userId}`)
  await set(permissionRef, {
    role: 'owner',
    grantedAt: now,
  })
  
  console.log(`Created default canvas for user ${userId}`)
}

/**
 * Check if user needs migration
 */
export async function needsMigration(userId: string): Promise<boolean> {
  try {
    const userCanvasesRef = ref(db, `users/${userId}/canvases`)
    const snapshot = await get(userCanvasesRef)
    
    // If user has no canvases entry, they need migration
    return !snapshot.exists()
  } catch (error) {
    console.error('Error checking migration status:', error)
    return false
  }
}

/**
 * Auto-migrate on first login (call from App.tsx or CanvasPage)
 */
export async function autoMigrateIfNeeded(userId: string): Promise<void> {
  try {
    const needs = await needsMigration(userId)
    
    if (needs) {
      console.log('Starting automatic migration...')
      const result = await migrateToMultiCanvas(userId)
      
      if (result.success) {
        console.log(`✅ Migration successful: ${result.objectsMigrated} objects migrated`)
      } else {
        console.error('❌ Migration completed with errors:', result.errors)
      }
    }
  } catch (error) {
    console.error('Auto-migration failed:', error)
  }
}
</file>

<file path="src/utils/tilemap/autoTile.ts">
/**
 * Auto-Tiling Utilities
 * 4-Neighbor Bitmask Algorithm for tile variant selection
 * 
 * Performance: All operations are O(1) constant time
 */

import type { TileData } from '../../types/tilemap'
import { coordToKey } from '../../types/tilemap'

/**
 * Neighbor check result for 4-directional neighbors
 */
export interface Neighbors {
  north: boolean
  east: boolean
  south: boolean
  west: boolean
}

/**
 * Tile update instruction with coordinates and variant
 */
export interface TileUpdate {
  x: number
  y: number
  variant: number
}

/**
 * Get neighboring tiles and check if they match the target type
 * 
 * @param x Tile X coordinate
 * @param y Tile Y coordinate
 * @param tiles Map of all tiles (keyed by "x_y")
 * @param targetType The tile type to match against
 * @returns Boolean flags for each cardinal direction
 * 
 * @performance O(1) - Constant time (4 map lookups)
 */
export function getNeighbors(
  x: number,
  y: number,
  tiles: Map<string, TileData>,
  targetType: string
): Neighbors {
  // Check all 4 cardinal directions
  const northKey = coordToKey(x, y - 1)
  const eastKey = coordToKey(x + 1, y)
  const southKey = coordToKey(x, y + 1)
  const westKey = coordToKey(x - 1, y)
  
  const northTile = tiles.get(northKey)
  const eastTile = tiles.get(eastKey)
  const southTile = tiles.get(southKey)
  const westTile = tiles.get(westKey)
  
  return {
    north: northTile?.type === targetType,
    east: eastTile?.type === targetType,
    south: southTile?.type === targetType,
    west: westTile?.type === targetType,
  }
}

/**
 * Calculate 4-bit bitmask from neighbor flags
 * 
 * Bit positions: NESW (North, East, South, West)
 * - North (bit 3): weight 8
 * - East  (bit 2): weight 4
 * - South (bit 1): weight 2
 * - West  (bit 0): weight 1
 * 
 * @param neighbors Boolean flags for each direction
 * @returns Bitmask value (0-15)
 * 
 * @performance O(1) - Constant time arithmetic
 * 
 * @example
 * // Tile with north and south neighbors (vertical corridor)
 * calculateBitmask({ north: true, east: false, south: true, west: false })
 * // Returns: 10 (binary: 1010)
 */
export function calculateBitmask(neighbors: Neighbors): number {
  const n = neighbors.north ? 8 : 0  // Bit 3
  const e = neighbors.east ? 4 : 0   // Bit 2
  const s = neighbors.south ? 2 : 0  // Bit 1
  const w = neighbors.west ? 1 : 0   // Bit 0
  
  return n + e + s + w
}

/**
 * Map 4-neighbor bitmask (0-15) to 3×3 grid position (0-8)
 * 
 * 3×3 Grid Layout:
 * [0:TL] [1:TC] [2:TR]
 * [3:ML] [4:MC] [5:MR]
 * [6:BL] [7:BC] [8:BR]
 * 
 * Bitmask: NESW (North=8, East=4, South=2, West=1)
 */
const BITMASK_TO_3X3_MAP: number[] = [
  4, // 0000 (no neighbors) -> center
  5, // 0001 (W) -> middle-right
  1, // 0010 (S) -> top-center
  2, // 0011 (S+W) -> top-right
  3, // 0100 (E) -> middle-left
  4, // 0101 (E+W) -> center
  0, // 0110 (E+S) -> top-left
  1, // 0111 (E+S+W) -> top-center
  7, // 1000 (N) -> bottom-center
  8, // 1001 (N+W) -> bottom-right
  4, // 1010 (N+S) -> center (vertical)
  5, // 1011 (N+S+W) -> middle-right
  6, // 1100 (N+E) -> bottom-left
  7, // 1101 (N+E+W) -> bottom-center
  3, // 1110 (N+E+S) -> middle-left
  4, // 1111 (all neighbors) -> center
]

/**
 * Get sprite variant index from bitmask (mapped to 3×3 grid)
 * 
 * @param bitmask The 4-neighbor bitmask (0-15)
 * @returns Sprite variant index (0-8 for 3×3 grid)
 * 
 * @performance O(1) - Array index lookup
 */
export function getVariantForBitmask(bitmask: number): number {
  // Clamp bitmask to valid range
  const clampedBitmask = Math.max(0, Math.min(15, bitmask))
  
  // Map to 3×3 grid position
  return BITMASK_TO_3X3_MAP[clampedBitmask]
}

/**
 * Calculate auto-tile variant for a single tile
 * 
 * @param x Tile X coordinate
 * @param y Tile Y coordinate
 * @param tiles Map of all tiles
 * @param tileType Type of the tile to calculate for
 * @returns Variant number (0-15 bitmask value)
 * 
 * @performance O(1) - Combines O(1) operations
 */
export function calculateTileVariant(
  x: number,
  y: number,
  tiles: Map<string, TileData>,
  tileType: string
): number {
  const neighbors = getNeighbors(x, y, tiles, tileType)
  const bitmask = calculateBitmask(neighbors)
  
  // Return bitmask directly as variant (0-15)
  // This allows direct indexing into sprite sheets with 16 tile variants
  return bitmask
}

/**
 * Calculate auto-tile updates for a tile and its neighbors
 * 
 * When a tile is placed or removed, this tile AND its 4 neighbors
 * may need their variants recalculated.
 * 
 * @param x Tile X coordinate (center tile)
 * @param y Tile Y coordinate (center tile)
 * @param tiles Current tile map
 * @param newType Type being placed (or null if removing)
 * @returns Array of tile updates with new variants
 * 
 * @performance O(1) - Fixed 5 tiles maximum (center + 4 neighbors)
 */
export function calculateAutoTileUpdates(
  x: number,
  y: number,
  tiles: Map<string, TileData>,
  newType: string | null
): TileUpdate[] {
  const updates: TileUpdate[] = []
  
  // If placing a tile, calculate its variant
  if (newType !== null) {
    const variant = calculateTileVariant(x, y, tiles, newType)
    updates.push({ x, y, variant })
  }
  
  // Check all 4 neighbors and recalculate their variants if they exist
  const neighborPositions = [
    { x: x, y: y - 1 },  // North
    { x: x + 1, y: y },  // East
    { x: x, y: y + 1 },  // South
    { x: x - 1, y: y },  // West
  ]
  
  neighborPositions.forEach((pos) => {
    const key = coordToKey(pos.x, pos.y)
    const neighborTile = tiles.get(key)
    
    if (neighborTile) {
      // Recalculate variant for this neighbor
      const variant = calculateTileVariant(pos.x, pos.y, tiles, neighborTile.type)
      updates.push({ x: pos.x, y: pos.y, variant })
    }
  })
  
  return updates
}

/**
 * Calculate auto-tile updates for multiple tiles (batch operation)
 * 
 * Used for bulk operations like fill tool or paint strokes.
 * Ensures each tile is only updated once even if it's a neighbor
 * of multiple changed tiles.
 * 
 * @param changedTiles Array of tiles that changed
 * @param tiles Current tile map
 * @returns Deduplicated array of tile updates
 * 
 * @performance O(n) where n is number of changed tiles + their neighbors
 */
export function calculateBatchAutoTileUpdates(
  changedTiles: Array<{ x: number; y: number; type: string | null }>,
  tiles: Map<string, TileData>
): TileUpdate[] {
  const updateMap = new Map<string, TileUpdate>()
  
  // Calculate updates for each changed tile and its neighbors
  changedTiles.forEach(({ x, y, type }) => {
    const tileUpdates = calculateAutoTileUpdates(x, y, tiles, type)
    
    // Merge into update map (deduplicates)
    tileUpdates.forEach((update) => {
      const key = coordToKey(update.x, update.y)
      updateMap.set(key, update)
    })
  })
  
  return Array.from(updateMap.values())
}

/**
 * Get all 16 bitmask combinations with descriptions
 * Useful for debugging and visualization
 */
export const BITMASK_DESCRIPTIONS: Record<number, string> = {
  0:  'Island (no neighbors)',
  1:  'West edge',
  2:  'South edge',
  3:  'Southwest corner',
  4:  'East edge',
  5:  'Vertical corridor (E+W)',
  6:  'Southeast corner',
  7:  'South T-junction',
  8:  'North edge',
  9:  'Northwest corner',
  10: 'Horizontal corridor (N+S)',
  11: 'West T-junction',
  12: 'Northeast corner',
  13: 'North T-junction',
  14: 'East T-junction',
  15: 'Center (all neighbors)',
}

/**
 * Get human-readable description for a bitmask
 */
export function getBitmaskDescription(bitmask: number): string {
  return BITMASK_DESCRIPTIONS[bitmask] || 'Unknown'
}

/**
 * Debug: Get bitmask as binary string (NESW format)
 * 
 * @example
 * formatBitmask(10) // Returns: "1010" (N=1, E=0, S=1, W=0)
 */
export function formatBitmask(bitmask: number): string {
  return bitmask.toString(2).padStart(4, '0')
}

/**
 * Debug: Get detailed info about a tile's auto-tiling state
 */
export interface TileAutoTileInfo {
  neighbors: Neighbors
  bitmask: number
  bitmaskBinary: string
  variant: number
  description: string
}

/**
 * Get detailed auto-tiling information for debugging
 */
export function getTileAutoTileInfo(
  x: number,
  y: number,
  tiles: Map<string, TileData>,
  tileType: string
): TileAutoTileInfo {
  const neighbors = getNeighbors(x, y, tiles, tileType)
  const bitmask = calculateBitmask(neighbors)
  
  return {
    neighbors,
    bitmask,
    bitmaskBinary: formatBitmask(bitmask),
    variant: bitmask, // Sequential mapping
    description: getBitmaskDescription(bitmask),
  }
}
</file>

<file path="src/utils/tilemap/spriteDetection.ts">
/**
 * Visual Sprite Detection
 * Uses computer vision to detect individual sprites in a sprite sheet
 * Analyzes transparency, edges, and connected components
 */

export interface DetectedSprite {
  x: number;
  y: number;
  width: number;
  height: number;
  area: number;
  confidence: number;
}

export interface SpriteDetectionResult {
  sprites: DetectedSprite[];
  gridDetected: boolean;
  suggestedTileSize?: { width: number; height: number };
  method: 'grid' | 'transparency' | 'edge-detection';
}

/**
 * Detect individual sprites by analyzing transparency (alpha channel)
 * This works for sprite sheets with transparent backgrounds
 */
export async function detectSpritesByTransparency(
  imageUrl: string,
  minSpriteSize: number = 8,
  mergePadding: number = 2
): Promise<SpriteDetectionResult> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = () => {
      try {
        // Create canvas to analyze pixels
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
          reject(new Error('Failed to get canvas context'));
          return;
        }
        
        // Draw image to canvas
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        
        // Create occupancy map (which pixels are non-transparent)
        const occupancyMap: boolean[][] = [];
        for (let y = 0; y < canvas.height; y++) {
          occupancyMap[y] = [];
          for (let x = 0; x < canvas.width; x++) {
            const idx = (y * canvas.width + x) * 4;
            const alpha = pixels[idx + 3];
            occupancyMap[y][x] = alpha > 10; // Consider pixels with alpha > 10 as occupied
          }
        }
        
        // Find connected components (individual sprites)
        const visited: boolean[][] = Array(canvas.height).fill(null).map(() => 
          Array(canvas.width).fill(false)
        );
        
        const sprites: DetectedSprite[] = [];
        
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            if (occupancyMap[y][x] && !visited[y][x]) {
              // Found a new sprite - flood fill to find its bounds
              const bounds = floodFill(occupancyMap, visited, x, y, canvas.width, canvas.height);
              
              // Only include if sprite is large enough
              if (bounds.width >= minSpriteSize && bounds.height >= minSpriteSize) {
                sprites.push({
                  x: bounds.x,
                  y: bounds.y,
                  width: bounds.width,
                  height: bounds.height,
                  area: bounds.width * bounds.height,
                  confidence: 0.8 // High confidence for transparency-based detection
                });
              }
            }
          }
        }
        
        // Merge nearby sprites (helps with multi-part sprites)
        const mergedSprites = mergeNearbySprites(sprites, mergePadding);
        
        // Snap sprites to 8px grid for game-friendly dimensions
        const snappedSprites = snapSpritesToGrid(mergedSprites, 8);
        
        // Check if sprites form a grid pattern
        const gridInfo = detectGridPattern(snappedSprites);
        
        resolve({
          sprites: snappedSprites,
          gridDetected: gridInfo.isGrid,
          suggestedTileSize: gridInfo.tileSize,
          method: 'transparency'
        });
      } catch (error) {
        reject(error);
      }
    };
    
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = imageUrl;
  });
}

/**
 * Flood fill algorithm to find connected component bounds
 */
function floodFill(
  occupancyMap: boolean[][],
  visited: boolean[][],
  startX: number,
  startY: number,
  width: number,
  height: number
): { x: number; y: number; width: number; height: number } {
  const stack: [number, number][] = [[startX, startY]];
  let minX = startX;
  let maxX = startX;
  let minY = startY;
  let maxY = startY;
  
  while (stack.length > 0) {
    const [x, y] = stack.pop()!;
    
    if (x < 0 || x >= width || y < 0 || y >= height) continue;
    if (visited[y][x] || !occupancyMap[y][x]) continue;
    
    visited[y][x] = true;
    
    // Update bounds
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
    
    // Check 4-connected neighbors
    stack.push([x + 1, y]);
    stack.push([x - 1, y]);
    stack.push([x, y + 1]);
    stack.push([x, y - 1]);
    
    // Also check 8-connected (diagonals) for better sprite detection
    stack.push([x + 1, y + 1]);
    stack.push([x + 1, y - 1]);
    stack.push([x - 1, y + 1]);
    stack.push([x - 1, y - 1]);
  }
  
  return {
    x: minX,
    y: minY,
    width: maxX - minX + 1,
    height: maxY - minY + 1
  };
}

/**
 * Merge sprites that are very close together
 * (handles multi-part sprites or sprites with small gaps)
 */
function mergeNearbySprites(sprites: DetectedSprite[], padding: number): DetectedSprite[] {
  if (sprites.length === 0) return [];
  
  const merged: DetectedSprite[] = [];
  const used = new Set<number>();
  
  for (let i = 0; i < sprites.length; i++) {
    if (used.has(i)) continue;
    
    let currentBounds = { ...sprites[i] };
    let merged_any = true;
    
    while (merged_any) {
      merged_any = false;
      
      for (let j = 0; j < sprites.length; j++) {
        if (i === j || used.has(j)) continue;
        
        const other = sprites[j];
        
        // Check if sprites are close enough to merge
        if (
          !(currentBounds.x + currentBounds.width + padding < other.x ||
            other.x + other.width + padding < currentBounds.x ||
            currentBounds.y + currentBounds.height + padding < other.y ||
            other.y + other.height + padding < currentBounds.y)
        ) {
          // Merge bounding boxes
          const newX = Math.min(currentBounds.x, other.x);
          const newY = Math.min(currentBounds.y, other.y);
          const newMaxX = Math.max(currentBounds.x + currentBounds.width, other.x + other.width);
          const newMaxY = Math.max(currentBounds.y + currentBounds.height, other.y + other.height);
          
          currentBounds = {
            x: newX,
            y: newY,
            width: newMaxX - newX,
            height: newMaxY - newY,
            area: (newMaxX - newX) * (newMaxY - newY),
            confidence: Math.max(currentBounds.confidence, other.confidence)
          };
          
          used.add(j);
          merged_any = true;
        }
      }
    }
    
    merged.push(currentBounds);
    used.add(i);
  }
  
  return merged;
}

/**
 * Detect if sprites form a grid pattern
 */
function detectGridPattern(sprites: DetectedSprite[]): {
  isGrid: boolean;
  tileSize?: { width: number; height: number };
  rows?: number;
  cols?: number;
} {
  if (sprites.length < 4) {
    return { isGrid: false };
  }
  
  // Sort sprites by position
  const sortedByY = [...sprites].sort((a, b) => a.y - b.y);
  const sortedByX = [...sprites].sort((a, b) => a.x - b.x);
  
  // Check if sprites have consistent sizes
  const widths = sprites.map(s => s.width);
  const heights = sprites.map(s => s.height);
  
  const avgWidth = widths.reduce((a, b) => a + b, 0) / widths.length;
  const avgHeight = heights.reduce((a, b) => a + b, 0) / heights.length;
  
  const widthVariance = widths.reduce((sum, w) => sum + Math.abs(w - avgWidth), 0) / widths.length;
  const heightVariance = heights.reduce((sum, h) => sum + Math.abs(h - avgHeight), 0) / heights.length;
  
  // If variance is low, it's likely a grid
  const isConsistentSize = widthVariance < avgWidth * 0.15 && heightVariance < avgHeight * 0.15;
  
  if (!isConsistentSize) {
    return { isGrid: false };
  }
  
  // Check for consistent spacing
  const xPositions = [...new Set(sprites.map(s => s.x))].sort((a, b) => a - b);
  const yPositions = [...new Set(sprites.map(s => s.y))].sort((a, b) => a - b);
  
  const cols = xPositions.length;
  const rows = yPositions.length;
  
  // Check if number of sprites matches grid
  const expectedSprites = rows * cols;
  const actualSprites = sprites.length;
  
  const isGrid = actualSprites >= expectedSprites * 0.8; // Allow some missing sprites
  
  return {
    isGrid,
    tileSize: isGrid ? { 
      width: Math.round(avgWidth), 
      height: Math.round(avgHeight) 
    } : undefined,
    rows,
    cols
  };
}

/**
 * Snap detected sprites to common tile sizes (multiples of 8)
 * Ensures x, y, width, height are all divisible by 8
 */
export function snapSpritesToGrid(
  sprites: DetectedSprite[],
  gridSize: number = 8
): DetectedSprite[] {
  return sprites.map(sprite => {
    // Snap x and y down to nearest grid point
    const snappedX = Math.floor(sprite.x / gridSize) * gridSize;
    const snappedY = Math.floor(sprite.y / gridSize) * gridSize;
    
    // Calculate right and bottom edges
    const right = sprite.x + sprite.width;
    const bottom = sprite.y + sprite.height;
    
    // Snap right and bottom up to nearest grid point
    const snappedRight = Math.ceil(right / gridSize) * gridSize;
    const snappedBottom = Math.ceil(bottom / gridSize) * gridSize;
    
    // Calculate snapped dimensions
    const snappedWidth = snappedRight - snappedX;
    const snappedHeight = snappedBottom - snappedY;
    
    return {
      ...sprite,
      x: snappedX,
      y: snappedY,
      width: snappedWidth,
      height: snappedHeight
    };
  });
}

/**
 * Convert detected sprites to sprite selections
 */
export function detectedSpritesToSelections(sprites: DetectedSprite[]) {
  return sprites.map((sprite, index) => ({
    id: `detected_${Date.now()}_${index}`,
    name: `Sprite ${index + 1}`,
    x: sprite.x,
    y: sprite.y,
    width: sprite.width,
    height: sprite.height
  }));
}
</file>

<file path="src/utils/tilemap/tilesetSlicer.ts">
/**
 * Tileset Slicer Utility (PR-31)
 * Auto-detects and slices sprite sheets/tilesets into individual tiles
 */

import type {
  TileSliceResult,
  TileSlice,
  TilesetMetadata,
  AutoTileSuggestion,
  AutoTileMapping
} from '../../types/asset'

/**
 * Common tile sizes to check when auto-detecting
 */
const COMMON_TILE_SIZES = [8, 16, 24, 32, 48, 64, 128]

/**
 * Load image from URL
 */
export async function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.onload = () => resolve(img)
    img.onerror = () => reject(new Error('Failed to load image'))
    img.src = url
  })
}

/**
 * Get image data from image element
 */
export function getImageData(img: HTMLImageElement): ImageData {
  const canvas = document.createElement('canvas')
  canvas.width = img.width
  canvas.height = img.height
  const ctx = canvas.getContext('2d')
  if (!ctx) {
    throw new Error('Failed to get canvas context')
  }
  ctx.drawImage(img, 0, 0)
  return ctx.getImageData(0, 0, img.width, img.height)
}

/**
 * Auto-detect tile size from image
 * Looks for grid patterns and common tile sizes
 */
export function autoDetectTileSize(imageData: ImageData): {
  tileWidth: number
  tileHeight: number
  spacing: number
  margin: number
  confidence: number
} {
  const { width, height, data } = imageData
  let bestMatch = {
    tileWidth: 32,
    tileHeight: 32,
    spacing: 0,
    margin: 0,
    confidence: 0
  }

  // Try each common tile size
  for (const tileSize of COMMON_TILE_SIZES) {
    // Skip if image is smaller than tile size
    if (width < tileSize || height < tileSize) continue

    // Try with no spacing
    const noSpacingScore = calculateGridScore(imageData, tileSize, tileSize, 0, 0)
    if (noSpacingScore > bestMatch.confidence) {
      bestMatch = {
        tileWidth: tileSize,
        tileHeight: tileSize,
        spacing: 0,
        margin: 0,
        confidence: noSpacingScore
      }
    }

    // Try with 1px spacing
    const onePixelSpacingScore = calculateGridScore(imageData, tileSize, tileSize, 1, 0)
    if (onePixelSpacingScore > bestMatch.confidence) {
      bestMatch = {
        tileWidth: tileSize,
        tileHeight: tileSize,
        spacing: 1,
        margin: 0,
        confidence: onePixelSpacingScore
      }
    }

    // Try with 2px spacing
    const twoPixelSpacingScore = calculateGridScore(imageData, tileSize, tileSize, 2, 0)
    if (twoPixelSpacingScore > bestMatch.confidence) {
      bestMatch = {
        tileWidth: tileSize,
        tileHeight: tileSize,
        spacing: 2,
        margin: 0,
        confidence: twoPixelSpacingScore
      }
    }

    // Try with 1px margin
    const onePixelMarginScore = calculateGridScore(imageData, tileSize, tileSize, 0, 1)
    if (onePixelMarginScore > bestMatch.confidence) {
      bestMatch = {
        tileWidth: tileSize,
        tileHeight: tileSize,
        spacing: 0,
        margin: 1,
        confidence: onePixelMarginScore
      }
    }
  }

  // If no good match found, try to find divisors
  if (bestMatch.confidence < 0.5) {
    const divisorResult = findBestDivisors(width, height)
    return {
      ...divisorResult,
      confidence: 0.3
    }
  }

  return bestMatch
}

/**
 * Calculate how well a tile size fits the image grid
 */
function calculateGridScore(
  imageData: ImageData,
  tileWidth: number,
  tileHeight: number,
  spacing: number,
  margin: number
): number {
  const { width, height } = imageData

  // Calculate how many complete tiles fit
  const tilesX = Math.floor((width - 2 * margin + spacing) / (tileWidth + spacing))
  const tilesY = Math.floor((height - 2 * margin + spacing) / (tileHeight + spacing))

  if (tilesX < 1 || tilesY < 1) return 0

  // Calculate how much of the image is covered
  const usedWidth = margin * 2 + tilesX * tileWidth + (tilesX - 1) * spacing
  const usedHeight = margin * 2 + tilesY * tileHeight + (tilesY - 1) * spacing
  
  const coverageX = usedWidth / width
  const coverageY = usedHeight / height
  
  // Perfect coverage (100%) = score of 1.0
  // We want coverage close to 1.0
  const coverage = (coverageX + coverageY) / 2
  
  // Bonus for covering more of the image
  const remainderX = width - usedWidth
  const remainderY = height - usedHeight
  const remainderScore = 1 - ((remainderX + remainderY) / (width + height))

  // Check for grid separator lines (darker pixels)
  let separatorScore = 0
  if (spacing > 0) {
    separatorScore = checkForSeparatorLines(imageData, tileWidth, tileHeight, spacing, margin)
  }

  // Combine scores
  return (coverage * 0.6) + (remainderScore * 0.3) + (separatorScore * 0.1)
}

/**
 * Check if there are separator lines between tiles
 */
function checkForSeparatorLines(
  imageData: ImageData,
  tileWidth: number,
  tileHeight: number,
  spacing: number,
  margin: number
): number {
  const { width, height, data } = imageData
  let separatorPixels = 0
  let totalSeparatorPixels = 0

  // Check vertical separators
  for (let col = 0; col < Math.floor((width - margin) / (tileWidth + spacing)); col++) {
    const x = margin + col * (tileWidth + spacing) + tileWidth
    if (x >= width) break

    for (let y = margin; y < height - margin; y++) {
      const idx = (y * width + x) * 4
      const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3
      totalSeparatorPixels++
      
      // Dark pixels (likely separators)
      if (brightness < 100) {
        separatorPixels++
      }
    }
  }

  // Check horizontal separators
  for (let row = 0; row < Math.floor((height - margin) / (tileHeight + spacing)); row++) {
    const y = margin + row * (tileHeight + spacing) + tileHeight
    if (y >= height) break

    for (let x = margin; x < width - margin; x++) {
      const idx = (y * width + x) * 4
      const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3
      totalSeparatorPixels++
      
      if (brightness < 100) {
        separatorPixels++
      }
    }
  }

  if (totalSeparatorPixels === 0) return 0
  return separatorPixels / totalSeparatorPixels
}

/**
 * Find best divisors for image dimensions
 */
function findBestDivisors(width: number, height: number): {
  tileWidth: number
  tileHeight: number
  spacing: number
  margin: number
} {
  // Find common divisors
  const divisorsW: number[] = []
  const divisorsH: number[] = []

  for (let i = 8; i <= Math.min(width / 2, 128); i++) {
    if (width % i === 0) divisorsW.push(i)
    if (height % i === 0) divisorsH.push(i)
  }

  // Prefer square tiles
  const commonDivisors = divisorsW.filter(d => divisorsH.includes(d))
  if (commonDivisors.length > 0) {
    // Pick middle divisor (not too small, not too large)
    const middleIndex = Math.floor(commonDivisors.length / 2)
    return {
      tileWidth: commonDivisors[middleIndex],
      tileHeight: commonDivisors[middleIndex],
      spacing: 0,
      margin: 0
    }
  }

  // Fallback to 32x32
  return {
    tileWidth: 32,
    tileHeight: 32,
    spacing: 0,
    margin: 0
  }
}

/**
 * Slice tileset into individual tiles
 */
export function sliceTileset(
  imageData: ImageData,
  tileWidth: number,
  tileHeight: number,
  spacing: number = 0,
  margin: number = 0
): TileSliceResult {
  const { width, height } = imageData
  const tiles: TileSlice[] = []

  const columns = Math.floor((width - 2 * margin + spacing) / (tileWidth + spacing))
  const rows = Math.floor((height - 2 * margin + spacing) / (tileHeight + spacing))
  const tileCount = columns * rows

  let index = 0
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < columns; col++) {
      const x = margin + col * (tileWidth + spacing)
      const y = margin + row * (tileHeight + spacing)

      tiles.push({
        index,
        x,
        y,
        width: tileWidth,
        height: tileHeight
      })

      index++
    }
  }

  const metadata: TilesetMetadata = {
    tileWidth,
    tileHeight,
    spacing,
    margin,
    columns,
    rows,
    tileCount
  }

  return {
    tiles,
    metadata
  }
}

/**
 * Extract tile image data from tileset
 */
export function extractTileImageData(
  imageData: ImageData,
  tile: TileSlice
): ImageData {
  const canvas = document.createElement('canvas')
  canvas.width = tile.width
  canvas.height = tile.height
  const ctx = canvas.getContext('2d')
  if (!ctx) {
    throw new Error('Failed to get canvas context')
  }

  // Create a temporary canvas with the full image
  const tempCanvas = document.createElement('canvas')
  tempCanvas.width = imageData.width
  tempCanvas.height = imageData.height
  const tempCtx = tempCanvas.getContext('2d')
  if (!tempCtx) {
    throw new Error('Failed to get temp canvas context')
  }
  tempCtx.putImageData(imageData, 0, 0)

  // Draw the tile region
  ctx.drawImage(
    tempCanvas,
    tile.x, tile.y, tile.width, tile.height,
    0, 0, tile.width, tile.height
  )

  return ctx.getImageData(0, 0, tile.width, tile.height)
}

/**
 * Detect auto-tile variants using image similarity
 * Groups similar tiles that might form auto-tile sets
 */
export function detectAutoTileVariants(
  imageData: ImageData,
  tiles: TileSlice[]
): AutoTileSuggestion[] {
  const suggestions: AutoTileSuggestion[] = []

  // Standard 16-tile auto-tile set
  if (tiles.length >= 16) {
    // Check if first 16 tiles look like an auto-tile set
    const firstSetTiles = tiles.slice(0, 16)
    const similarity = calculateTileSetSimilarity(imageData, firstSetTiles)
    
    if (similarity > 0.6) {
      const mapping: AutoTileMapping = {}
      for (let i = 0; i < 16; i++) {
        mapping[i] = i
      }
      
      suggestions.push({
        tileIndices: firstSetTiles.map(t => t.index),
        confidence: similarity,
        mapping
      })
    }
  }

  // Look for 4-tile mini sets (corners)
  for (let i = 0; i <= tiles.length - 4; i += 4) {
    const miniSet = tiles.slice(i, i + 4)
    const similarity = calculateTileSetSimilarity(imageData, miniSet)
    
    if (similarity > 0.7) {
      suggestions.push({
        tileIndices: miniSet.map(t => t.index),
        confidence: similarity
      })
    }
  }

  return suggestions.sort((a, b) => b.confidence - a.confidence)
}

/**
 * Calculate similarity between tiles in a set
 * Higher values mean tiles are more likely to be variants
 */
function calculateTileSetSimilarity(
  imageData: ImageData,
  tiles: TileSlice[]
): number {
  if (tiles.length < 2) return 0

  // Extract color palette from all tiles
  const palettes = tiles.map(tile => {
    const tileData = extractTileImageData(imageData, tile)
    return extractColorPalette(tileData)
  })

  // Check if tiles share similar color palettes
  let totalSimilarity = 0
  let comparisons = 0

  for (let i = 0; i < palettes.length - 1; i++) {
    for (let j = i + 1; j < palettes.length; j++) {
      totalSimilarity += comparePalettes(palettes[i], palettes[j])
      comparisons++
    }
  }

  return comparisons > 0 ? totalSimilarity / comparisons : 0
}

/**
 * Extract dominant colors from tile
 */
function extractColorPalette(imageData: ImageData, maxColors: number = 8): string[] {
  const { data } = imageData
  const colorCounts = new Map<string, number>()

  for (let i = 0; i < data.length; i += 4) {
    // Skip transparent pixels
    if (data[i + 3] < 128) continue

    const color = `${data[i]},${data[i + 1]},${data[i + 2]}`
    colorCounts.set(color, (colorCounts.get(color) || 0) + 1)
  }

  // Sort by frequency and take top colors
  return Array.from(colorCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, maxColors)
    .map(([color]) => color)
}

/**
 * Compare two color palettes
 */
function comparePalettes(palette1: string[], palette2: string[]): number {
  const set1 = new Set(palette1)
  const set2 = new Set(palette2)
  
  let matches = 0
  for (const color of set1) {
    if (set2.has(color)) matches++
  }

  const union = new Set([...set1, ...set2])
  return matches / union.size
}

/**
 * Generate standard 16-tile auto-tile mapping
 * Based on blob tileset layout
 */
export function generateStandardAutoTileMapping(startIndex: number = 0): AutoTileMapping {
  // Standard 16-tile layout (4x4 grid)
  // Bitmask order: [0-15]
  const mapping: AutoTileMapping = {}
  
  for (let i = 0; i < 16; i++) {
    mapping[i] = startIndex + i
  }
  
  return mapping
}

/**
 * Validate tileset configuration
 */
export function validateTilesetConfig(
  imageWidth: number,
  imageHeight: number,
  tileWidth: number,
  tileHeight: number,
  spacing: number,
  margin: number
): { valid: boolean; errors: string[] } {
  const errors: string[] = []

  if (tileWidth < 1 || tileHeight < 1) {
    errors.push('Tile dimensions must be at least 1x1 pixels')
  }

  if (tileWidth > imageWidth || tileHeight > imageHeight) {
    errors.push('Tile dimensions cannot exceed image dimensions')
  }

  if (spacing < 0 || margin < 0) {
    errors.push('Spacing and margin cannot be negative')
  }

  const columns = Math.floor((imageWidth - 2 * margin + spacing) / (tileWidth + spacing))
  const rows = Math.floor((imageHeight - 2 * margin + spacing) / (tileHeight + spacing))

  if (columns < 1 || rows < 1) {
    errors.push('Configuration does not produce any complete tiles')
  }

  return {
    valid: errors.length === 0,
    errors
  }
}
</file>

<file path="storage.rules">
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
    // Assets: User-uploaded sprite sheets, tilesets, etc.
    match /assets/{userId}/{assetId} {
      // Users can read their own assets
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Users can write their own assets
      allow write: if request.auth != null && request.auth.uid == userId
        && request.resource.size < 10 * 1024 * 1024  // Max 10MB
        && request.resource.contentType.matches('image/.*');  // Images only
      
      // Users can delete their own assets
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Public assets (shared community assets) - read-only for now
    match /public-assets/{assetId} {
      allow read: if request.auth != null;
      allow write: if false;  // Admin only (via Functions)
    }
    
    // Exported files (temporary, expire after 24h)
    match /exports/{userId}/{exportId}/{allPaths=**} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId
        && request.resource.size < 50 * 1024 * 1024;  // Max 50MB for exports
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
  }
}
</file>

<file path=".cursorignore">
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
</file>

<file path=".env.example">
# Firebase Configuration
# Copy this file to .env and fill in your Firebase project credentials
# Get these values from Firebase Console > Project Settings > General > Your apps

VITE_FIREBASE_API_KEY=your-api-key-here
VITE_FIREBASE_AUTH_DOMAIN=your-project-id.firebaseapp.com
VITE_FIREBASE_DATABASE_URL=https://your-project-id-default-rtdb.firebaseio.com
VITE_FIREBASE_PROJECT_ID=your-project-id

# Canvas ID (optional, defaults to 'default-canvas')
VITE_CANVAS_ID=default-canvas
</file>

<file path=".repomixignore">
readme.md
.readme.md
docs/*
.docs/*
</file>

<file path="database.rules.json">
{
  "rules": {
    "users": {
      "$userId": {
        "canvases": {
          ".read": "$userId === auth.uid",
          ".write": "$userId === auth.uid"
        }
      }
    },
    "canvases": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "canvas": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "collab-spaces": {
      "$spaceId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "presence": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null",
        "$userId": {
          ".write": "$userId === auth.uid"
        }
      }
    },
    "collab-presence": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null",
        "$userId": {
          ".write": "$userId === auth.uid"
        }
      }
    },
    "tilemaps": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "assets": {
      "$userId": {
        ".read": "$userId === auth.uid",
        ".write": "$userId === auth.uid"
      }
    },
    "animations": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    }
  }
}
</file>

<file path="functions/.gitignore">
# Compiled JavaScript files
lib/
*.js
*.js.map

# TypeScript cache
*.tsbuildinfo

# Node.js
node_modules/

# Environment
.env
.env.local

# Logs
*.log
npm-debug.log*
</file>

<file path="functions/ENV_SETUP.md">
# Firebase Functions Environment Setup

## Required Environment Variables

The AI Canvas Agent requires an OpenAI API key to function. Follow these steps to configure it:

### 1. Get an OpenAI API Key

1. Go to [OpenAI Platform](https://platform.openai.com/)
2. Sign up or log in
3. Navigate to API Keys section
4. Create a new secret key
5. Copy the key (starts with `sk-...`)

### 2. Set Environment Variables (Development)

Create a `.env` file in the `functions/` directory:

```bash
cd functions
touch .env
```

Add the following to `functions/.env`:

```env
OPENAI_API_KEY=sk-your-actual-api-key-here
OPENAI_MODEL=gpt-4-turbo-preview
OPENAI_MAX_TOKENS=2000
OPENAI_TEMPERATURE=0.2
```

**Important:** Never commit the `.env` file to git! It's already in `.gitignore`.

### 3. Set Environment Variables (Production)

For production deployment, use Firebase Functions config:

```bash
firebase functions:config:set openai.key="sk-your-actual-api-key-here"
firebase functions:config:set openai.model="gpt-4-turbo-preview"
firebase functions:config:set openai.max_tokens="2000"
firebase functions:config:set openai.temperature="0.2"
```

### 4. Enable AI Features (Client-Side)

Create or update `.env` in the project root:

```env
VITE_AI_ENABLED=true
```

## Configuration Options

### OPENAI_API_KEY (Required)
Your OpenAI API key. Get it from [OpenAI Platform](https://platform.openai.com/).

### OPENAI_MODEL (Optional)
Default: `gpt-4-turbo-preview`

Available models:
- `gpt-4-turbo-preview`: Most capable, recommended
- `gpt-4`: Stable, reliable
- `gpt-3.5-turbo`: Faster, cheaper (not recommended for complex operations)

### OPENAI_MAX_TOKENS (Optional)
Default: `2000`

Maximum tokens in AI response. Adjust based on complexity:
- `1000`: Simple operations
- `2000`: Standard (recommended)
- `4000`: Complex multi-step operations

### OPENAI_TEMPERATURE (Optional)
Default: `0.2`

Controls AI creativity:
- `0.0`: Deterministic, precise
- `0.2`: Recommended balance
- `0.5`: More creative, less predictable

## Testing Configuration

Test your configuration:

```bash
# Build functions
cd functions
npm run build

# Start emulator
firebase emulators:start --only functions

# In another terminal, test the function
curl -X POST http://localhost:5001/YOUR-PROJECT-ID/us-central1/aiCanvasCommand \
  -H "Content-Type: application/json" \
  -d '{
    "data": {
      "message": "Create a red circle",
      "context": {
        "canvasId": "test",
        "userId": "test-user",
        "selectedShapes": [],
        "viewport": {"x": 0, "y": 0, "width": 1000, "height": 1000, "zoom": 1},
        "mode": "shapes"
      }
    }
  }'
```

## Troubleshooting

### "OpenAI API key not configured"
- Check that `.env` file exists in `functions/` directory
- Verify `OPENAI_API_KEY` is set correctly
- Restart the emulator after changing `.env`

### "Invalid API key"
- Verify your API key is correct and active
- Check if you have credits in your OpenAI account
- Try regenerating the API key

### "Rate limit exceeded"
- Check your OpenAI account usage limits
- Wait a few minutes before trying again
- Consider upgrading your OpenAI plan

### Functions not loading environment variables
In development, use `.env` file.
In production, use `firebase functions:config:set`.

For local emulation with production config:
```bash
firebase functions:config:get > .runtimeconfig.json
```

## Security Best Practices

1. **Never commit API keys to git**
2. **Rotate keys regularly** (every 90 days)
3. **Set usage limits** in OpenAI dashboard
4. **Monitor usage** to detect anomalies
5. **Use separate keys** for dev/prod environments

## Cost Estimation

OpenAI API costs for typical usage:
- **Small canvas** (10-20 shapes): ~$0.002 per command
- **Medium canvas** (50-100 shapes): ~$0.005 per command
- **Large canvas** (500+ shapes): ~$0.01 per command
- **Tilemap generation**: ~$0.003-$0.008 per generation

Rate limiting (10 commands/min/user) helps control costs.

For a team of 10 users:
- Light use (50 commands/day): ~$5-10/month
- Medium use (200 commands/day): ~$20-40/month
- Heavy use (500 commands/day): ~$50-100/month

## Support

For issues with environment setup:
1. Check Firebase Functions logs: `firebase functions:log`
2. Check browser console for client-side errors
3. Verify all dependencies are installed: `npm install`
4. Ensure Node.js version is 18+ (Firebase Functions requirement)
</file>

<file path="functions/package.json">
{
  "name": "functions",
  "version": "1.0.0",
  "description": "Firebase Functions for CollabCanvas AI Agent",
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^12.0.0",
    "firebase-functions": "^5.0.0",
    "openai": "^4.20.1",
    "simplex-noise": "^4.0.1"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "typescript": "^5.3.0"
  },
  "private": true
}
</file>

<file path="functions/src/ai-proxy.ts">
/**
 * AI Canvas Agent Proxy
 * Handles OpenAI API calls securely on server-side
 * PR-30: Task 1.1
 */

import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import OpenAI from 'openai';
import { ToolRegistry } from './ai/toolRegistry';
import { buildSystemPrompt } from './ai/contextBuilder.js';
import { executeToolChain } from './ai/toolExecutor.js';

// OpenAI client - initialized lazily
let openaiClient: OpenAI | null = null;

function getOpenAIClient(): OpenAI {
  if (!openaiClient) {
    const apiKey = process.env.OPENAI_API_KEY || functions.config().openai?.key;
    if (!apiKey) {
      throw new Error('OpenAI API key not configured. Set OPENAI_API_KEY environment variable.');
    }
    openaiClient = new OpenAI({ apiKey });
  }
  return openaiClient;
}

const MODEL = process.env.OPENAI_MODEL || 'gpt-4-turbo-preview';
const MAX_TOKENS = parseInt(process.env.OPENAI_MAX_TOKENS || '2000');
const TEMPERATURE = parseFloat(process.env.OPENAI_TEMPERATURE || '0.2');

// Rate limiting: 10 requests per minute per user
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute
const RATE_LIMIT_MAX = 10;

interface CanvasContext {
  canvasId: string;
  userId: string;
  selectedShapes: string[];
  viewport: { x: number; y: number; width: number; height: number; zoom: number };
  mode: 'shapes' | 'tilemap';
  tilemapMeta?: any;
}

interface AIRequest {
  message: string;
  context: CanvasContext;
}

interface AIResponse {
  success: boolean;
  message: string;
  toolResults?: any[];
  error?: string;
}

/**
 * Check rate limit for user
 */
async function checkRateLimit(userId: string): Promise<boolean> {
  const db = admin.database();
  const now = Date.now();
  const windowStart = now - RATE_LIMIT_WINDOW;
  
  const rateLimitRef = db.ref(`rateLimits/ai/${userId}`);
  const snapshot = await rateLimitRef.once('value');
  const requests = snapshot.val() || [];
  
  // Filter requests within current window
  const recentRequests = requests.filter((timestamp: number) => timestamp > windowStart);
  
  if (recentRequests.length >= RATE_LIMIT_MAX) {
    return false; // Rate limit exceeded
  }
  
  // Add current request
  recentRequests.push(now);
  await rateLimitRef.set(recentRequests);
  
  return true;
}

/**
 * Main AI Canvas Command Function
 * Callable HTTPS function that proxies OpenAI requests
 */
export const aiCanvasCommand = functions.https.onCall(
  async (data: AIRequest, context): Promise<AIResponse> => {
    try {
      // 1. Validate authentication
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'User must be authenticated to use AI features'
        );
      }

      const userId = context.auth.uid;
      
      // 2. Check rate limiting
      const allowed = await checkRateLimit(userId);
      if (!allowed) {
        throw new functions.https.HttpsError(
          'resource-exhausted',
          'Rate limit exceeded. Please wait 60 seconds before trying again.'
        );
      }

      // 3. Validate request data
      if (!data.message || typeof data.message !== 'string') {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Message is required and must be a string'
        );
      }

      if (!data.context || !data.context.canvasId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Canvas context is required'
        );
      }

      functions.logger.info('AI request received', {
        userId,
        canvasId: data.context.canvasId,
        messageLength: data.message.length,
      });

      // 4. Initialize tool registry and register all tools
      const toolRegistry = new ToolRegistry();
      
      // Import all tools
      const { createShapeTool, deleteShapesTool, modifyShapeTool } = await import('./ai/tools/shapeTools');
      const { moveShapesTool, resizeShapeTool, rotateShapesTool } = await import('./ai/tools/transformTools');
      const { arrangeShapesTool, distributeShapesTool, alignShapesTool } = await import('./ai/tools/layoutTools');
      const { getCanvasStateTool, getSelectedShapesTool } = await import('./ai/tools/queryTools');
      const { paintTileRegionTool, eraseTileRegionTool, eraseAllTilesTool, generateTilemapTool } = await import('./ai/tools/tilemapTools');
      
      // Register all tools
      toolRegistry.register(createShapeTool);
      toolRegistry.register(deleteShapesTool);
      toolRegistry.register(modifyShapeTool);
      toolRegistry.register(moveShapesTool);
      toolRegistry.register(resizeShapeTool);
      toolRegistry.register(rotateShapesTool);
      toolRegistry.register(arrangeShapesTool);
      toolRegistry.register(distributeShapesTool);
      toolRegistry.register(alignShapesTool);
      toolRegistry.register(getCanvasStateTool);
      toolRegistry.register(getSelectedShapesTool);
      toolRegistry.register(paintTileRegionTool);
      toolRegistry.register(eraseTileRegionTool);
      toolRegistry.register(eraseAllTilesTool);
      toolRegistry.register(generateTilemapTool);
      
      // PR-32: Analysis and optimization tools
      const { analyzeTilemapTool, detectPatternsTool, suggestImprovementTool } = await import('./ai/tools/analysisTools');
      const { analyzePerformanceTool, estimateExportSizeTool } = await import('./ai/tools/optimizationTools');
      
      toolRegistry.register(analyzeTilemapTool);
      toolRegistry.register(detectPatternsTool);
      toolRegistry.register(suggestImprovementTool);
      toolRegistry.register(analyzePerformanceTool);
      toolRegistry.register(estimateExportSizeTool);
      
      // PR-32: Asset management tools
      const { listAssetsTool, analyzeAssetTool, suggestSlicingTool, recommendAssetTool, createAnimationTool, exportCanvasTool } = await import('./ai/tools/assetTools');
      
      toolRegistry.register(listAssetsTool);
      toolRegistry.register(analyzeAssetTool);
      toolRegistry.register(suggestSlicingTool);
      toolRegistry.register(recommendAssetTool);
      toolRegistry.register(createAnimationTool);
      toolRegistry.register(exportCanvasTool);
      
      // 5. Build system prompt with canvas context
      const systemPrompt = buildSystemPrompt(data.context);
      
      // 6. Call OpenAI API with function calling
      const response = await callOpenAIWithRetry(
        data.message,
        systemPrompt,
        toolRegistry.toOpenAIFunctions()
      );

      // 7. Execute any function calls from OpenAI
      let toolResults: any[] = [];
      if (response.function_calls && response.function_calls.length > 0) {
        toolResults = await executeToolChain(
          response.function_calls,
          data.context,
          toolRegistry
        );
      }

      // 8. Return response
      return {
        success: true,
        message: response.message,
        toolResults,
      };

    } catch (error: any) {
      functions.logger.error('AI request failed', {
        error: error.message,
        stack: error.stack,
      });

      // Return user-friendly error
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }

      throw new functions.https.HttpsError(
        'internal',
        'AI service temporarily unavailable. Please try again.'
      );
    }
  }
);

/**
 * Call OpenAI API with retry logic
 */
async function callOpenAIWithRetry(
  userMessage: string,
  systemPrompt: string,
  toolFunctions: any[],
  maxRetries = 3
): Promise<{ message: string; function_calls: any[] }> {
  let lastError: Error | null = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const openai = getOpenAIClient();
      
      // Convert functions to tools format (supports parallel function calling)
      const tools = toolFunctions.length > 0 
        ? toolFunctions.map(fn => ({ type: 'function' as const, function: fn }))
        : undefined;

      const completion = await openai.chat.completions.create({
        model: MODEL,
        max_tokens: MAX_TOKENS,
        temperature: TEMPERATURE,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userMessage },
        ],
        tools,
        tool_choice: tools ? 'auto' : undefined,
        parallel_tool_calls: true, // Enable parallel function calling
      });

      const choice = completion.choices[0];
      const message = choice.message;

      // Extract tool calls (supports multiple parallel calls)
      const function_calls: any[] = [];
      if (message.tool_calls && message.tool_calls.length > 0) {
        for (const toolCall of message.tool_calls) {
          if (toolCall.type === 'function') {
            function_calls.push({
              name: toolCall.function.name,
              arguments: JSON.parse(toolCall.function.arguments),
            });
          }
        }
      }

      functions.logger.info('OpenAI response', {
        toolCallsCount: function_calls.length,
        toolNames: function_calls.map(fc => fc.name),
      });

      return {
        message: message.content || 'Done.',
        function_calls,
      };

    } catch (error: any) {
      lastError = error;
      functions.logger.warn(`OpenAI API call failed (attempt ${attempt + 1})`, error.message);

      // Exponential backoff
      if (attempt < maxRetries - 1) {
        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError || new Error('OpenAI API call failed after retries');
}
</file>

<file path="functions/src/ai/contextBuilder.ts">
/**
 * AI Context Builder
 * Builds system prompts with canvas context
 * PR-30: Task 1.4
 * PR-32: Enhanced with game type detection, assets, and performance stats
 */

interface CanvasContext {
  canvasId: string;
  userId: string;
  selectedShapes: string[];
  viewport: { x: number; y: number; width: number; height: number; zoom: number };
  mode: 'shapes' | 'tilemap';
  tilemapMeta?: any;
  // PR-32: Enhanced context
  gameType?: 'platformer' | 'top-down' | 'puzzle' | 'shooter' | 'unknown';
  gameTypeConfidence?: number;
  objectCount?: number;
  tileCount?: number;
  availableAssets?: {
    spritesheets: number;
    tilesets: number;
    animations: number;
  };
  performanceScore?: number;
  performanceRating?: 'excellent' | 'good' | 'fair' | 'poor';
}

/**
 * Build system prompt with canvas context
 * Describes capabilities and constraints to the AI
 */
export function buildSystemPrompt(context: CanvasContext): string {
  const mode = context.mode || 'shapes';
  const selectionInfo = context.selectedShapes.length > 0
    ? `${context.selectedShapes.length} shape(s) currently selected`
    : 'no shapes currently selected';

  // Calculate visible bounds (what the user can actually see)
  const visibleLeft = Math.round(-context.viewport.x / context.viewport.zoom);
  const visibleTop = Math.round(-context.viewport.y / context.viewport.zoom);
  const visibleRight = Math.round((-context.viewport.x + context.viewport.width) / context.viewport.zoom);
  const visibleBottom = Math.round((-context.viewport.y + context.viewport.height) / context.viewport.zoom);
  const visibleCenterX = Math.round((visibleLeft + visibleRight) / 2);
  const visibleCenterY = Math.round((visibleTop + visibleBottom) / 2);

  // For tilemap mode, calculate visible tile range
  const tileSize = context.tilemapMeta?.tileSize || 32;
  const visibleTileLeft = Math.floor(visibleLeft / tileSize);
  const visibleTileTop = Math.floor(visibleTop / tileSize);
  const visibleTileRight = Math.ceil(visibleRight / tileSize);
  const visibleTileBottom = Math.ceil(visibleBottom / tileSize);
  const visibleTileCenterCol = Math.round((visibleTileLeft + visibleTileRight) / 2);
  const visibleTileCenterRow = Math.round((visibleTileTop + visibleTileBottom) / 2);

  // Build game development context (PR-32)
  let gameDevContext = '';
  if (context.gameType && context.gameType !== 'unknown') {
    gameDevContext = `

GAME DEVELOPMENT CONTEXT:
- Detected Game Type: ${context.gameType} (${Math.round((context.gameTypeConfidence || 0) * 100)}% confidence)
- Content: ${context.objectCount || 0} objects, ${context.tileCount || 0} tiles`;
    
    if (context.availableAssets) {
      gameDevContext += `
- Available Assets: ${context.availableAssets.spritesheets} sprite sheets, ${context.availableAssets.tilesets} tilesets, ${context.availableAssets.animations} animations`;
    }
    
    if (context.performanceRating) {
      gameDevContext += `
- Performance: ${context.performanceRating} (score: ${context.performanceScore}/100)`;
      
      if (context.performanceRating === 'poor' || context.performanceRating === 'fair') {
        gameDevContext += ' ⚠️ Consider optimizations';
      }
    }
  }

  return `You are an AI assistant for CollabCanvas, a real-time collaborative game development and design tool with advanced procedural generation capabilities.

CURRENT CANVAS STATE:
- Mode: ${mode} (${mode === 'shapes' ? 'vector shape editing' : 'tilemap editing'})
- Canvas ID: ${context.canvasId}
- Selection: ${selectionInfo}
- Zoom: ${context.viewport.zoom}x${gameDevContext}

VISIBLE AREA (what the user can see):
${mode === 'shapes' ? `- Canvas coordinates: X from ${visibleLeft} to ${visibleRight}, Y from ${visibleTop} to ${visibleBottom}
- Visible center: (${visibleCenterX}, ${visibleCenterY})
- Visible dimensions: ${visibleRight - visibleLeft}x${visibleBottom - visibleTop} pixels` : `- Tile coordinates: Column ${visibleTileLeft} to ${visibleTileRight}, Row ${visibleTileTop} to ${visibleTileBottom}
- Visible center tile: Column ${visibleTileCenterCol}, Row ${visibleTileCenterRow}
- Tile size: ${tileSize}x${tileSize} pixels`}

YOUR CAPABILITIES:
You can manipulate the canvas using the following categories of functions:

1. **Shape Tools**: Create, delete, and modify shapes (rectangles, circles, polygons, stars, etc.)
2. **Transform Tools**: Move, resize, and rotate shapes
3. **Layout Tools**: Arrange shapes in grids/rows/columns, align shapes, distribute spacing
4. **Tilemap Tools**: Paint tile regions, erase tiles, generate procedural tilemaps with advanced algorithms:
   - **perlin-noise**: Natural terrain with hills and valleys (best for outdoor landscapes)
   - **cellular-automata**: Organic cave systems and dungeons (best for underground levels)
   - **wave-function-collapse**: Constraint-based generation with valid tile placement
   - **random-walk**: Winding paths and rivers
5. **Query Tools**: Get canvas state and selected shape information
6. **Analysis Tools** (PR-32 NEW):
   - **analyzeTilemap**: Get tile distribution, density, and suggestions
   - **detectPatterns**: Identify game type (platformer, top-down, puzzle, etc.)
   - **suggestImprovement**: Get specific recommendations for the current canvas
7. **Optimization Tools** (PR-32 NEW):
   - **analyzePerformance**: Check FPS, object count, draw calls, and bottlenecks
   - **estimateExportSize**: Calculate export file size for different game engines
8. **Asset Management Tools** (PR-32 NEW):
   - **listAssets**: See all available sprites, tilesets, and assets that can be used
   - **analyzeAsset**: Examine a specific asset's properties and how to use it
   - **suggestSlicing**: AI suggests how to slice/split a sprite sheet based on dimensions
   - **recommendAsset**: Ask AI which asset to use for a specific purpose (e.g., "grass tiles")

CONSTRAINTS & SAFETY:
- Maximum 100 shapes per command
- Maximum 10,000 tiles per command  
- Canvas bounds: 0-5000 pixels in both X and Y
- Valid tile types: grass, dirt, water, stone, flower
- Always confirm before deleting more than 10 shapes
- Batch operations are preferred for better performance

BEHAVIOR GUIDELINES:
- Be concise in your responses
- Execute functions immediately when the user's intent is clear
- Ask clarifying questions if the request is ambiguous
- Confirm successful actions briefly
- If an error occurs, explain what went wrong in simple terms
- When working with selected shapes, operate on those instead of creating new ones unless specified

GAME DEVELOPMENT GUIDELINES (PR-32):
- When generating terrain, suggest appropriate algorithms based on game type
- For platformers: Use perlin-noise or simple noise for varied terrain
- For dungeons/caves: Use cellular-automata for organic layouts
- For paths/rivers: Use random-walk with smooth option
- Always consider performance: warn if object count > 500 or tilemap > 10,000 tiles
- Suggest using analyzeTilemap after generation to check quality
- Recommend detectPatterns if game type is unclear
- For large projects, proactively suggest analyzePerformance

ASSET MANAGEMENT GUIDELINES (PR-32 NEW):
- When user asks about available tiles/sprites, use **listAssets** to show what they have
- Before creating tilemaps, check if appropriate tilesets exist with **recommendAsset**
- When user uploads a sprite sheet, offer to help analyze it with **suggestSlicing**
- If user mentions specific game elements (grass, water, enemies), use **recommendAsset** to find matching assets
- Use **analyzeAsset** to help users understand complex tilesets (auto-tiles, sprite counts, etc.)
- Proactively suggest listing assets if user seems unsure what visual resources are available
- When user asks "what should I add?", use detectPatterns + suggestImprovement

**DEFAULT POSITIONING (CRITICAL):**
${mode === 'shapes' ? `- ALWAYS place new shapes within the VISIBLE AREA unless user specifies coordinates
- Default to visible center (${visibleCenterX}, ${visibleCenterY}) for single shapes
- For multiple shapes, distribute them within the visible bounds
- NEVER default to (0, 0) or top-left corner unless explicitly requested
- Use getCanvasState tool first to check what already exists in the visible area
- Avoid overlapping existing shapes when possible - offset new shapes to empty space` : `- ALWAYS place tiles within the VISIBLE TILE RANGE unless user specifies coordinates
- Default to visible center tile (Col ${visibleTileCenterCol}, Row ${visibleTileCenterRow})
- For painting regions, stay within visible bounds or ask for clarification
- NEVER default to tile (0, 0) unless explicitly requested
- When generating tilemaps, consider the visible area size as a guide for dimensions`}

**CONFLICT AVOIDANCE:**
- Before creating shapes/tiles, call getCanvasState to see what exists in the target area
- If the visible area is crowded, suggest an empty region or ask user for placement preference
- For multiple items, space them appropriately to avoid overlap (at least 50px apart for shapes, 1 tile apart for tiles)

**MULTIPLE ITEMS:**
- When creating multiple shapes (e.g., "7 colored squares"), call createShape MULTIPLE TIMES, once for each
- For shapes: space horizontally (e.g., center-200, center-100, center, center+100, center+200)
- For tiles: space in a grid pattern within visible bounds

**SPECIAL PATTERNS:**
- RAINBOW COLORS: red (#FF0000), orange (#FF7F00), yellow (#FFFF00), green (#00FF00), blue (#0000FF), indigo (#4B0082), violet (#9400D3)

Current mode is **${mode}**, so prioritize ${mode === 'shapes' ? 'shape manipulation' : 'tilemap'} functions.`;
}

/**
 * Compress canvas state for context
 * Summarizes large canvas states to fit token limits
 */
export function compressCanvasState(shapes: any[]): string {
  if (shapes.length === 0) {
    return 'Canvas is empty';
  }

  if (shapes.length <= 50) {
    // Full details for small canvases
    return shapes
      .map((s, i) => `${i + 1}. ${s.type} at (${s.x}, ${s.y}), ${s.width}x${s.height}`)
      .join('\n');
  }

  // Summarize large canvases
  const typeCounts: Record<string, number> = {};
  shapes.forEach(shape => {
    typeCounts[shape.type] = (typeCounts[shape.type] || 0) + 1;
  });

  const summary = Object.entries(typeCounts)
    .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
    .join(', ');

  return `Canvas has ${shapes.length} shapes total: ${summary}`;
}

/**
 * Format tool execution result for display
 */
export function formatToolResult(result: any): string {
  if (!result.success) {
    return `❌ ${result.error || 'Operation failed'}`;
  }

  return `✓ ${result.message}`;
}
</file>

<file path="functions/src/ai/safety.ts">
/**
 * Safety Constraints
 * Enforces limits and prevents abuse
 * PR-30: Task 8.2
 */

import * as admin from 'firebase-admin';

// Limits
export const LIMITS = {
  MAX_SHAPES_PER_COMMAND: 100,
  MAX_TILES_PER_COMMAND: 10000,
  MAX_SHAPES_ON_CANVAS: 1000,
  MAX_TILES_ON_CANVAS: 100000,
  MAX_TILEMAP_WIDTH: 500,
  MAX_TILEMAP_HEIGHT: 500,
  COMMAND_TIMEOUT_MS: 25000,
  CANVAS_MIN_X: 0,
  CANVAS_MAX_X: 5000,
  CANVAS_MIN_Y: 0,
  CANVAS_MAX_Y: 5000,
};

interface SafetyCheckResult {
  allowed: boolean;
  reason?: string;
}

/**
 * Check if adding N shapes would exceed canvas limit
 */
export async function checkShapeLimit(
  canvasId: string,
  additionalShapes: number
): Promise<SafetyCheckResult> {
  const db = admin.database();
  const shapesRef = db.ref(`canvases/${canvasId}/shapes`);
  const snapshot = await shapesRef.once('value');
  const currentShapes = snapshot.exists() ? Object.keys(snapshot.val()).length : 0;
  
  const totalShapes = currentShapes + additionalShapes;
  
  if (totalShapes > LIMITS.MAX_SHAPES_ON_CANVAS) {
    return {
      allowed: false,
      reason: `Canvas would exceed maximum of ${LIMITS.MAX_SHAPES_ON_CANVAS} shapes (currently ${currentShapes}, attempting to add ${additionalShapes})`,
    };
  }
  
  return { allowed: true };
}

/**
 * Check if operation would create too many shapes at once
 */
export function checkBulkShapeLimit(count: number): SafetyCheckResult {
  if (count > LIMITS.MAX_SHAPES_PER_COMMAND) {
    return {
      allowed: false,
      reason: `Cannot create more than ${LIMITS.MAX_SHAPES_PER_COMMAND} shapes in a single command (attempted ${count})`,
    };
  }
  
  return { allowed: true };
}

/**
 * Check if tile operation is within limits
 */
export function checkTileOperationLimit(tileCount: number): SafetyCheckResult {
  if (tileCount > LIMITS.MAX_TILES_PER_COMMAND) {
    return {
      allowed: false,
      reason: `Cannot modify more than ${LIMITS.MAX_TILES_PER_COMMAND} tiles in a single command (attempted ${tileCount})`,
    };
  }
  
  return { allowed: true };
}

/**
 * Check if tilemap dimensions are within limits
 */
export function checkTilemapDimensions(width: number, height: number): SafetyCheckResult {
  if (width > LIMITS.MAX_TILEMAP_WIDTH) {
    return {
      allowed: false,
      reason: `Tilemap width cannot exceed ${LIMITS.MAX_TILEMAP_WIDTH} tiles (attempted ${width})`,
    };
  }
  
  if (height > LIMITS.MAX_TILEMAP_HEIGHT) {
    return {
      allowed: false,
      reason: `Tilemap height cannot exceed ${LIMITS.MAX_TILEMAP_HEIGHT} tiles (attempted ${height})`,
    };
  }
  
  const totalTiles = width * height;
  if (totalTiles > LIMITS.MAX_TILES_ON_CANVAS) {
    return {
      allowed: false,
      reason: `Tilemap would exceed maximum of ${LIMITS.MAX_TILES_ON_CANVAS} tiles (${width}x${height} = ${totalTiles})`,
    };
  }
  
  return { allowed: true };
}

/**
 * Clamp value to canvas bounds
 */
export function clampToCanvas(x: number, y: number): { x: number; y: number } {
  return {
    x: Math.max(LIMITS.CANVAS_MIN_X, Math.min(LIMITS.CANVAS_MAX_X, x)),
    y: Math.max(LIMITS.CANVAS_MIN_Y, Math.min(LIMITS.CANVAS_MAX_Y, y)),
  };
}

/**
 * Check if user can perform operation (basic permission check)
 */
export async function checkUserPermission(
  userId: string,
  canvasId: string
): Promise<SafetyCheckResult> {
  const db = admin.database();
  
  // Check if canvas exists
  const canvasRef = db.ref(`canvases/${canvasId}`);
  const snapshot = await canvasRef.once('value');
  
  if (!snapshot.exists()) {
    return {
      allowed: false,
      reason: 'Canvas not found',
    };
  }
  
  // For now, allow all authenticated users
  // TODO: Add proper access control when implemented
  return { allowed: true };
}

/**
 * Estimate Firebase write cost for operation
 * Returns estimated number of database writes
 */
export function estimateWriteCost(operation: {
  type: 'create' | 'update' | 'delete' | 'tile';
  count: number;
}): number {
  switch (operation.type) {
    case 'create':
      // Each shape creation = 1 write to shapes + 1 to layerOrder
      return operation.count * 2;
    
    case 'update':
      // Each shape update = 1 write
      return operation.count;
    
    case 'delete':
      // Each shape deletion = 1 write to shapes + 1 to layerOrder
      return operation.count * 2;
    
    case 'tile':
      // Batch tile operations use 1 write per batch (up to 100 tiles)
      return Math.ceil(operation.count / 100);
    
    default:
      return operation.count;
  }
}
</file>

<file path="functions/src/ai/tilemapGenerators.ts">
/**
 * Tilemap Generators
 * Server-side wrappers for procedural tilemap generation algorithms
 * PR-32: Advanced procedural generation for game development
 */

/**
 * Perlin Noise Generator (Server-side)
 * Generates natural-looking terrain using Perlin noise
 */
export function generatePerlinTilemap(
  width: number,
  height: number,
  params: {
    scale: number;
    octaves: number;
    persistence: number;
    lacunarity: number;
    seed?: number;
  }
): Map<string, string> {
  // Implement Perlin noise on server
  const tiles = new Map<string, string>();
  const seed = params.seed || Date.now();
  
  // Simplified Perlin-like noise using sine waves
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      let amplitude = 1;
      let frequency = params.scale;
      let maxValue = 0;

      // Generate octaves
      for (let i = 0; i < params.octaves; i++) {
        const nx = x * frequency + seed;
        const ny = y * frequency + seed;
        
        // Simple noise using sine
        const noise = 
          Math.sin(nx * 0.1) * Math.cos(ny * 0.1) +
          Math.sin(ny * 0.1) * Math.cos(nx * 0.1);
        
        value += noise * amplitude;
        maxValue += amplitude;

        amplitude *= params.persistence;
        frequency *= params.lacunarity;
      }

      // Normalize to 0-1
      const normalized = (value / maxValue + 1) / 2;

      // Map to tile types
      let tileType: string;
      if (normalized < 0.3) {
        tileType = 'water';
      } else if (normalized < 0.4) {
        tileType = 'dirt';
      } else if (normalized < 0.6) {
        tileType = 'grass';
      } else if (normalized < 0.75) {
        tileType = 'dirt';
      } else {
        tileType = 'stone';
      }

      tiles.set(`${x}_${y}`, tileType);
    }
  }

  return tiles;
}

/**
 * Cellular Automata Generator (Server-side)
 * Generates cave-like structures
 */
export function generateCellularTilemap(
  width: number,
  height: number,
  params: {
    initialDensity: number;
    birthLimit: number;
    deathLimit: number;
    iterations: number;
    seed?: number;
  },
  options: {
    connectRegions?: boolean;
    removeIslands?: boolean;
  } = {}
): Map<string, string> {
  const seed = params.seed || Date.now();
  let random = seed;
  
  // Seeded random
  const rand = () => {
    const x = Math.sin(random++) * 10000;
    return x - Math.floor(x);
  };

  // Initialize grid
  let grid: boolean[][] = [];
  for (let y = 0; y < height; y++) {
    const row: boolean[] = [];
    for (let x = 0; x < width; x++) {
      // Edges are walls
      if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
        row.push(true);
      } else {
        row.push(rand() < params.initialDensity);
      }
    }
    grid.push(row);
  }

  // Count neighbors
  const countNeighbors = (x: number, y: number): number => {
    let count = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
          count++;
        } else if (grid[ny][nx]) {
          count++;
        }
      }
    }
    return count;
  };

  // Apply cellular automata rules
  for (let iter = 0; iter < params.iterations; iter++) {
    const newGrid: boolean[][] = [];
    for (let y = 0; y < height; y++) {
      const row: boolean[] = [];
      for (let x = 0; x < width; x++) {
        const neighbors = countNeighbors(x, y);
        const isAlive = grid[y][x];

        // Edges stay as walls
        if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
          row.push(true);
        }
        // Apply birth/death rules
        else if (isAlive) {
          row.push(neighbors >= params.deathLimit);
        } else {
          row.push(neighbors >= params.birthLimit);
        }
      }
      newGrid.push(row);
    }
    grid = newGrid;
  }

  // Remove islands if requested
  if (options.removeIslands) {
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const neighbors = countNeighbors(x, y);
        // Fill isolated floors
        if (!grid[y][x] && neighbors >= 7) {
          grid[y][x] = true;
        }
        // Remove isolated walls
        if (grid[y][x] && neighbors <= 1) {
          grid[y][x] = false;
        }
      }
    }
  }

  // Convert to tilemap
  const tiles = new Map<string, string>();
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const tileType = grid[y][x] ? 'stone' : 'dirt';
      tiles.set(`${x}_${y}`, tileType);
    }
  }

  return tiles;
}

/**
 * Wave Function Collapse Generator (Server-side)
 * Generates tilemaps using constraint-based generation
 */
export function generateWFCTilemap(
  width: number,
  height: number,
  tilesetType: 'platform' | 'dungeon' | 'terrain',
  seed?: number
): Map<string, string> | null {
  const tiles = new Map<string, string>();
  const random = seed || Date.now();
  let rng = random;
  
  const rand = () => {
    const x = Math.sin(rng++) * 10000;
    return x - Math.floor(x);
  };

  // Simple constraint-based generation
  // This is a simplified version - the full WFC is complex
  
  const getTileSet = (): { tiles: string[]; constraints: any } => {
    switch (tilesetType) {
      case 'platform':
        return {
          tiles: ['air', 'grass', 'dirt', 'stone'],
          constraints: {
            air: { below: ['grass', 'air'] },
            grass: { below: ['dirt', 'grass'], above: ['air', 'grass'] },
            dirt: { below: ['dirt', 'stone'], above: ['grass', 'dirt'] },
            stone: { above: ['dirt', 'stone'] }
          }
        };
      case 'dungeon':
        return {
          tiles: ['floor', 'wall'],
          constraints: {
            floor: { adjacent: ['floor', 'wall'] },
            wall: { adjacent: ['floor', 'wall'] }
          }
        };
      case 'terrain':
      default:
        return {
          tiles: ['water', 'grass', 'dirt', 'stone'],
          constraints: {
            water: { adjacent: ['water', 'grass'] },
            grass: { adjacent: ['grass', 'water', 'dirt'] },
            dirt: { adjacent: ['dirt', 'grass', 'stone'] },
            stone: { adjacent: ['stone', 'dirt'] }
          }
        };
    }
  };

  const { tiles: tileSet } = getTileSet();

  // Generate grid
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      // Simple weighted selection
      const choice = Math.floor(rand() * tileSet.length);
      tiles.set(`${x}_${y}`, tileSet[choice]);
    }
  }

  return tiles;
}

/**
 * Random Walk Generator (Server-side)
 * Generates paths or rivers using random walk
 */
export function generateRandomWalkTilemap(
  width: number,
  height: number,
  params: {
    steps: number;
    turnProbability: number;
    branchProbability: number;
    width: number;
    seed?: number;
  },
  options: {
    smooth?: boolean;
  } = {}
): Map<string, string> {
  const tiles = new Map<string, string>();
  const seed = params.seed || Date.now();
  let random = seed;
  
  const rand = () => {
    const x = Math.sin(random++) * 10000;
    return x - Math.floor(x);
  };

  // Fill with grass
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      tiles.set(`${x}_${y}`, 'grass');
    }
  }

  // Random walk
  let x = Math.floor(width / 2);
  let y = Math.floor(height / 2);
  let direction = Math.floor(rand() * 4); // 0=N, 1=E, 2=S, 3=W

  const path: Array<{ x: number; y: number }> = [];

  for (let step = 0; step < params.steps; step++) {
    // Add current position to path
    path.push({ x, y });

    // Turn?
    if (rand() < params.turnProbability) {
      direction = Math.floor(rand() * 4);
    }

    // Move
    switch (direction) {
      case 0: y = Math.max(0, y - 1); break; // North
      case 1: x = Math.min(width - 1, x + 1); break; // East
      case 2: y = Math.min(height - 1, y + 1); break; // South
      case 3: x = Math.max(0, x - 1); break; // West
    }
  }

  // Apply width to path
  const radius = Math.floor(params.width / 2);
  for (const pos of path) {
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        // Circular shape
        if (dx * dx + dy * dy <= radius * radius) {
          const nx = pos.x + dx;
          const ny = pos.y + dy;
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            tiles.set(`${nx}_${ny}`, 'water');
          }
        }
      }
    }
  }

  return tiles;
}

/**
 * Legacy: Simple noise terrain
 */
export function generateNoiseTerrain(
  width: number,
  height: number,
  params: { scale: number }
): Map<string, string> {
  return generatePerlinTilemap(width, height, {
    scale: params.scale,
    octaves: 3,
    persistence: 0.5,
    lacunarity: 2.0
  });
}

/**
 * Legacy: Cellular caves
 */
export function generateCellularCaves(
  width: number,
  height: number,
  params: { fillProbability: number }
): Map<string, string> {
  return generateCellularTilemap(width, height, {
    initialDensity: params.fillProbability,
    birthLimit: 4,
    deathLimit: 3,
    iterations: 5
  });
}

/**
 * Legacy: Random walk
 */
export function generateRandomWalk(
  width: number,
  height: number,
  params: { pathWidth: number }
): Map<string, string> {
  return generateRandomWalkTilemap(width, height, {
    steps: 100,
    turnProbability: 0.2,
    branchProbability: 0.05,
    width: params.pathWidth
  });
}

/**
 * Legacy: Island generation
 */
export function generateIsland(width: number, height: number): Map<string, string> {
  const tiles = new Map<string, string>();
  const centerX = width / 2;
  const centerY = height / 2;
  const maxRadius = Math.min(width, height) / 2 * 0.8;

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const normalized = distance / maxRadius;

      let tileType: string;
      if (normalized > 1.0) {
        tileType = 'water';
      } else if (normalized > 0.8) {
        tileType = 'grass';
      } else if (normalized > 0.5) {
        tileType = 'grass';
      } else {
        tileType = 'dirt';
      }

      tiles.set(`${x}_${y}`, tileType);
    }
  }

  return tiles;
}
</file>

<file path="functions/src/ai/toolExecutor.ts">
/**
 * Tool Executor
 * Executes AI tool function calls from OpenAI
 * PR-30: Task 6.1
 */

import * as functions from 'firebase-functions';
import { ToolRegistry, ToolResult } from './toolRegistry';

interface FunctionCall {
  name: string;
  arguments: Record<string, any>;
}

interface CanvasContext {
  canvasId: string;
  userId: string;
  selectedShapes: string[];
  viewport: any;
  mode: 'shapes' | 'tilemap';
  tilemapMeta?: any;
}

interface ExecutionResult {
  success: boolean;
  toolName: string;
  result?: ToolResult;
  error?: string;
  duration: number;
}

/**
 * Execute a single tool
 */
export async function executeTool(
  name: string,
  params: Record<string, any>,
  context: CanvasContext,
  registry: ToolRegistry
): Promise<ExecutionResult> {
  const startTime = Date.now();

  try {
    // 1. Check if tool exists
    const tool = registry.get(name);
    if (!tool) {
      return {
        success: false,
        toolName: name,
        error: `Tool "${name}" not found`,
        duration: Date.now() - startTime,
      };
    }

    // 2. Validate parameters
    const validation = registry.validateParameters(name, params);
    if (!validation.valid) {
      return {
        success: false,
        toolName: name,
        error: `Invalid parameters: ${validation.errors.join(', ')}`,
        duration: Date.now() - startTime,
      };
    }

    // 3. Execute tool with timeout (25 seconds)
    const result = await Promise.race([
      tool.execute(params, context),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Tool execution timeout')), 25000)
      ),
    ]);

    const duration = Date.now() - startTime;

    functions.logger.info('Tool executed successfully', {
      tool: name,
      duration,
      success: result.success,
    });

    return {
      success: true,
      toolName: name,
      result,
      duration,
    };

  } catch (error: any) {
    const duration = Date.now() - startTime;

    functions.logger.error('Tool execution failed', {
      tool: name,
      error: error.message,
      duration,
    });

    return {
      success: false,
      toolName: name,
      error: error.message || 'Unknown error occurred',
      duration,
    };
  }
}

/**
 * Execute multiple tools in sequence
 * Continues on error and collects all results
 */
export async function executeToolChain(
  functionCalls: FunctionCall[],
  context: CanvasContext,
  registry: ToolRegistry
): Promise<ExecutionResult[]> {
  const results: ExecutionResult[] = [];

  functions.logger.info('Executing tool chain', {
    toolCount: functionCalls.length,
    tools: functionCalls.map(fc => fc.name),
  });

  for (const call of functionCalls) {
    const result = await executeTool(
      call.name,
      call.arguments,
      context,
      registry
    );
    results.push(result);

    // Continue even if one fails (collect all results for debugging)
  }

  return results;
}
</file>

<file path="functions/src/ai/toolRegistry.ts">
/**
 * Tool Registry
 * Manages AI tools/functions that OpenAI can call
 * PR-30: Task 1.3
 */

export interface ToolDefinition {
  name: string;
  description: string;
  parameters: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
  };
  execute: (params: any, context: any) => Promise<ToolResult>;
}

export interface ToolResult {
  success: boolean;
  message?: string;
  data?: any;
  error?: string;
}

/**
 * Tool Registry Class
 * Manages registration and execution of AI tools
 */
export class ToolRegistry {
  private tools: Map<string, ToolDefinition> = new Map();

  /**
   * Register a new tool
   */
  register(tool: ToolDefinition): void {
    if (this.tools.has(tool.name)) {
      throw new Error(`Tool "${tool.name}" is already registered`);
    }
    
    this.tools.set(tool.name, tool);
  }

  /**
   * Get a tool by name
   */
  get(name: string): ToolDefinition | undefined {
    return this.tools.get(name);
  }

  /**
   * List all registered tools
   */
  list(): ToolDefinition[] {
    return Array.from(this.tools.values());
  }

  /**
   * Check if a tool exists
   */
  has(name: string): boolean {
    return this.tools.has(name);
  }

  /**
   * Convert tools to OpenAI function format
   */
  toOpenAIFunctions(): any[] {
    return this.list().map(tool => ({
      name: tool.name,
      description: tool.description,
      parameters: tool.parameters,
    }));
  }

  /**
   * Validate tool parameters against schema
   */
  validateParameters(toolName: string, params: any): { valid: boolean; errors: string[] } {
    const tool = this.get(toolName);
    if (!tool) {
      return { valid: false, errors: [`Tool "${toolName}" not found`] };
    }

    const errors: string[] = [];
    const schema = tool.parameters;

    // Check required parameters
    if (schema.required) {
      for (const required of schema.required) {
        if (params[required] === undefined) {
          errors.push(`Missing required parameter: ${required}`);
        }
      }
    }

    // Validate parameter types (basic validation)
    for (const [key, value] of Object.entries(params)) {
      const propSchema = schema.properties[key];
      if (!propSchema) {
        errors.push(`Unknown parameter: ${key}`);
        continue;
      }

      const actualType = Array.isArray(value) ? 'array' : typeof value;
      if (propSchema.type && propSchema.type !== actualType) {
        errors.push(`Parameter "${key}" must be of type ${propSchema.type}, got ${actualType}`);
      }
    }

    return { valid: errors.length === 0, errors };
  }
}
</file>

<file path="functions/src/ai/tools/layoutTools.ts">
/**
 * Layout Tools
 * Arrange, distribute, and align shapes
 * PR-30: Task 2.3
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import { validateShapeIds, validateArrayLength } from '../validation';
import { checkUserPermission } from '../safety';

/**
 * Arrange Shapes Tool
 * Arranges shapes in a grid, row, or column
 */
export const arrangeShapesTool: ToolDefinition = {
  name: 'arrangeShapes',
  description: 'Arrange shapes in a grid, row, or column with consistent spacing',
  parameters: {
    type: 'object',
    properties: {
      shapeIds: {
        type: 'array',
        description: 'Array of shape IDs to arrange',
        items: { type: 'string' },
      },
      layout: {
        type: 'string',
        description: 'Layout type',
        enum: ['grid', 'row', 'column'],
      },
      spacing: {
        type: 'number',
        description: 'Space between shapes in pixels (default: 20)',
      },
      columns: {
        type: 'number',
        description: 'Number of columns (only for grid layout)',
      },
      startX: {
        type: 'number',
        description: 'Starting X coordinate (default: 100)',
      },
      startY: {
        type: 'number',
        description: 'Starting Y coordinate (default: 100)',
      },
    },
    required: ['shapeIds', 'layout'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape IDs
      const idsCheck = validateShapeIds(params.shapeIds);
      if (!idsCheck.valid) {
        return { success: false, error: idsCheck.error };
      }

      const db = admin.database();
      const spacing = params.spacing || 20;
      const startX = params.startX || 100;
      const startY = params.startY || 100;

      // Fetch all shapes
      const shapes: any[] = [];
      for (const shapeId of params.shapeIds) {
        const snapshot = await db.ref(`canvas/${context.canvasId}/objects/${shapeId}`).once('value');
        if (snapshot.exists()) {
          shapes.push({ id: shapeId, ...snapshot.val() });
        }
      }

      if (shapes.length === 0) {
        return { success: false, error: 'No valid shapes found to arrange' };
      }

      const updates: any = {};
      let currentX = startX;
      let currentY = startY;
      let maxRowHeight = 0;

      // Arrange based on layout type
      switch (params.layout) {
        case 'row':
          for (const shape of shapes) {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = currentX;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = startY;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
            currentX += shape.width + spacing;
          }
          break;

        case 'column':
          for (const shape of shapes) {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = startX;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = currentY;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
            currentY += shape.height + spacing;
          }
          break;

        case 'grid':
          const columns = params.columns || Math.ceil(Math.sqrt(shapes.length));
          let col = 0;
          
          for (const shape of shapes) {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = currentX;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = currentY;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
            
            maxRowHeight = Math.max(maxRowHeight, shape.height);
            currentX += shape.width + spacing;
            col++;

            // Move to next row
            if (col >= columns) {
              col = 0;
              currentX = startX;
              currentY += maxRowHeight + spacing;
              maxRowHeight = 0;
            }
          }
          break;
      }

      await db.ref().update(updates);

      return {
        success: true,
        message: `Arranged ${shapes.length} shapes in ${params.layout}`,
        data: { arrangedCount: shapes.length, layout: params.layout },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to arrange shapes: ${error.message}`,
      };
    }
  },
};

/**
 * Distribute Shapes Tool
 * Distributes shapes with equal spacing
 */
export const distributeShapesTool: ToolDefinition = {
  name: 'distributeShapes',
  description: 'Distribute shapes with equal spacing horizontally or vertically',
  parameters: {
    type: 'object',
    properties: {
      shapeIds: {
        type: 'array',
        description: 'Array of shape IDs to distribute',
        items: { type: 'string' },
      },
      direction: {
        type: 'string',
        description: 'Distribution direction',
        enum: ['horizontal', 'vertical'],
      },
    },
    required: ['shapeIds', 'direction'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape IDs (need at least 3 for distribution)
      const arrayCheck = validateArrayLength(params.shapeIds, 3, 100, 'shapeIds');
      if (!arrayCheck.valid) {
        return { success: false, error: arrayCheck.error || 'Need at least 3 shapes to distribute' };
      }

      const db = admin.database();

      // Fetch all shapes
      const shapes: any[] = [];
      for (const shapeId of params.shapeIds) {
        const snapshot = await db.ref(`canvas/${context.canvasId}/objects/${shapeId}`).once('value');
        if (snapshot.exists()) {
          shapes.push({ id: shapeId, ...snapshot.val() });
        }
      }

      if (shapes.length < 3) {
        return { success: false, error: 'Need at least 3 shapes to distribute' };
      }

      // Sort shapes by position
      if (params.direction === 'horizontal') {
        shapes.sort((a, b) => a.x - b.x);
      } else {
        shapes.sort((a, b) => a.y - b.y);
      }

      // Calculate total space and distribute
      const first = shapes[0];
      const last = shapes[shapes.length - 1];
      let totalSpace: number;
      
      if (params.direction === 'horizontal') {
        totalSpace = (last.x + last.width) - first.x;
      } else {
        totalSpace = (last.y + last.height) - first.y;
      }

      // Calculate spacing
      const totalShapeSize = shapes.reduce((sum, s) => 
        sum + (params.direction === 'horizontal' ? s.width : s.height), 0
      );
      const spacing = (totalSpace - totalShapeSize) / (shapes.length - 1);

      // Update positions
      const updates: any = {};
      let currentPos = params.direction === 'horizontal' ? first.x : first.y;

      for (let i = 0; i < shapes.length; i++) {
        const shape = shapes[i];
        
        if (i === 0 || i === shapes.length - 1) {
          // Keep first and last in place
          currentPos += (params.direction === 'horizontal' ? shape.width : shape.height) + spacing;
          continue;
        }

        // Update middle shapes
        if (params.direction === 'horizontal') {
          updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = currentPos;
          currentPos += shape.width + spacing;
        } else {
          updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = currentPos;
          currentPos += shape.height + spacing;
        }

        updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
        updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
      }

      await db.ref().update(updates);

      return {
        success: true,
        message: `Distributed ${shapes.length} shapes ${params.direction}ly`,
        data: { distributedCount: shapes.length, direction: params.direction },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to distribute shapes: ${error.message}`,
      };
    }
  },
};

/**
 * Align Shapes Tool
 * Aligns shapes to a common edge or center
 */
export const alignShapesTool: ToolDefinition = {
  name: 'alignShapes',
  description: 'Align shapes to left, right, top, bottom, or center',
  parameters: {
    type: 'object',
    properties: {
      shapeIds: {
        type: 'array',
        description: 'Array of shape IDs to align',
        items: { type: 'string' },
      },
      alignment: {
        type: 'string',
        description: 'Alignment type',
        enum: ['left', 'right', 'top', 'bottom', 'center-horizontal', 'center-vertical'],
      },
    },
    required: ['shapeIds', 'alignment'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape IDs
      const idsCheck = validateShapeIds(params.shapeIds);
      if (!idsCheck.valid) {
        return { success: false, error: idsCheck.error };
      }

      const db = admin.database();

      // Fetch all shapes
      const shapes: any[] = [];
      for (const shapeId of params.shapeIds) {
        const snapshot = await db.ref(`canvas/${context.canvasId}/objects/${shapeId}`).once('value');
        if (snapshot.exists()) {
          shapes.push({ id: shapeId, ...snapshot.val() });
        }
      }

      if (shapes.length === 0) {
        return { success: false, error: 'No valid shapes found to align' };
      }

      // Calculate alignment reference
      let referenceValue: number;
      const updates: any = {};

      switch (params.alignment) {
        case 'left':
          referenceValue = Math.min(...shapes.map(s => s.x));
          shapes.forEach(shape => {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = referenceValue;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
          });
          break;

        case 'right':
          referenceValue = Math.max(...shapes.map(s => s.x + s.width));
          shapes.forEach(shape => {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = referenceValue - shape.width;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
          });
          break;

        case 'top':
          referenceValue = Math.min(...shapes.map(s => s.y));
          shapes.forEach(shape => {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = referenceValue;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
          });
          break;

        case 'bottom':
          referenceValue = Math.max(...shapes.map(s => s.y + s.height));
          shapes.forEach(shape => {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = referenceValue - shape.height;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
          });
          break;

        case 'center-horizontal':
          const avgCenterX = shapes.reduce((sum, s) => sum + (s.x + s.width / 2), 0) / shapes.length;
          shapes.forEach(shape => {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/x`] = avgCenterX - shape.width / 2;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
          });
          break;

        case 'center-vertical':
          const avgCenterY = shapes.reduce((sum, s) => sum + (s.y + s.height / 2), 0) / shapes.length;
          shapes.forEach(shape => {
            updates[`canvas/${context.canvasId}/objects/${shape.id}/y`] = avgCenterY - shape.height / 2;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedBy`] = context.userId;
            updates[`canvas/${context.canvasId}/objects/${shape.id}/modifiedAt`] = Date.now();
          });
          break;
      }

      await db.ref().update(updates);

      return {
        success: true,
        message: `Aligned ${shapes.length} shapes to ${params.alignment}`,
        data: { alignedCount: shapes.length, alignment: params.alignment },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to align shapes: ${error.message}`,
      };
    }
  },
};
</file>

<file path="functions/src/ai/tools/queryTools.ts">
/**
 * Query Tools
 * Get canvas state and information
 * PR-30: Task 3.1
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import { checkUserPermission } from '../safety';
import { compressCanvasState } from '../contextBuilder';

/**
 * Get Canvas State Tool
 * Returns information about the current canvas
 */
export const getCanvasStateTool: ToolDefinition = {
  name: 'getCanvasState',
  description: 'Get current canvas state including shapes in visible area, tilemap info, and metadata. Use this to check for existing content before placing new shapes/tiles.',
  parameters: {
    type: 'object',
    properties: {
      includeShapes: {
        type: 'boolean',
        description: 'Include detailed shape information (default: true)',
      },
      includeTilemap: {
        type: 'boolean',
        description: 'Include tilemap information (default: true)',
      },
      visibleOnly: {
        type: 'boolean',
        description: 'Only return shapes/tiles in the visible viewport (default: true)',
      },
    },
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      const db = admin.database();
      const canvasRef = db.ref(`canvases/${context.canvasId}`);
      const snapshot = await canvasRef.once('value');

      if (!snapshot.exists()) {
        return { success: false, error: 'Canvas not found' };
      }

      const canvas = snapshot.val();
      const includeShapes = params.includeShapes !== false;
      const includeTilemap = params.includeTilemap !== false;
      const visibleOnly = params.visibleOnly !== false;

      // Calculate visible bounds if filtering by visibility
      const viewport = context.viewport || { x: 0, y: 0, width: 1920, height: 1080, zoom: 1 };
      const visibleLeft = -viewport.x / viewport.zoom;
      const visibleTop = -viewport.y / viewport.zoom;
      const visibleRight = (-viewport.x + viewport.width) / viewport.zoom;
      const visibleBottom = (-viewport.y + viewport.height) / viewport.zoom;

      // Build response data
      const data: any = {
        canvasId: context.canvasId,
        name: canvas.name || 'Untitled Canvas',
        createdAt: canvas.createdAt,
        mode: context.mode,
        viewport: visibleOnly ? {
          left: Math.round(visibleLeft),
          top: Math.round(visibleTop),
          right: Math.round(visibleRight),
          bottom: Math.round(visibleBottom),
        } : undefined,
      };

      // Add shape information
      if (includeShapes && canvas.shapes) {
        let shapes = Object.values(canvas.shapes);
        
        // Filter to visible area if requested
        if (visibleOnly) {
          shapes = shapes.filter((shape: any) => {
            // Check if shape overlaps with visible area
            const shapeLeft = shape.x;
            const shapeTop = shape.y;
            const shapeRight = shape.x + (shape.width || 100);
            const shapeBottom = shape.y + (shape.height || 100);
            
            return !(shapeRight < visibleLeft || shapeLeft > visibleRight ||
                     shapeBottom < visibleTop || shapeTop > visibleBottom);
          });
          
          data.visibleShapeCount = shapes.length;
          data.totalShapeCount = Object.keys(canvas.shapes).length;
        } else {
          data.shapeCount = shapes.length;
        }
        
        data.shapesSummary = compressCanvasState(shapes as any[]);
        
        // Include type breakdown
        const typeCounts: Record<string, number> = {};
        shapes.forEach((shape: any) => {
          typeCounts[shape.type] = (typeCounts[shape.type] || 0) + 1;
        });
        data.shapeTypes = typeCounts;
        
        // Add detailed visible shapes info for positioning
        if (visibleOnly && shapes.length > 0 && shapes.length <= 20) {
          data.visibleShapes = shapes.map((s: any) => ({
            type: s.type,
            x: s.x,
            y: s.y,
            width: s.width || 100,
            height: s.height || 100,
          }));
        }
      } else {
        data.shapeCount = 0;
      }

      // Add tilemap information
      if (includeTilemap && canvas.tilemap) {
        const tilemap = canvas.tilemap;
        data.tilemap = {
          width: tilemap.width || 0,
          height: tilemap.height || 0,
          tileSize: tilemap.tileSize || 32,
          totalTiles: (tilemap.width || 0) * (tilemap.height || 0),
          tileCount: tilemap.tiles ? Object.keys(tilemap.tiles).length : 0,
        };
      }

      // Add layer information
      if (canvas.layerOrder) {
        data.layerCount = canvas.layerOrder.length;
      }

      const message = visibleOnly && data.visibleShapeCount !== undefined
        ? `${data.visibleShapeCount} shape(s) visible in viewport (${data.totalShapeCount} total on canvas)`
        : `Canvas has ${data.shapeCount || 0} shape(s)`;

      return {
        success: true,
        message,
        data,
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to get canvas state: ${error.message}`,
      };
    }
  },
};

/**
 * Get Selected Shapes Tool
 * Returns detailed information about selected shapes
 */
export const getSelectedShapesTool: ToolDefinition = {
  name: 'getSelectedShapes',
  description: 'Get detailed information about currently selected shapes',
  parameters: {
    type: 'object',
    properties: {},
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      if (!context.selectedShapes || context.selectedShapes.length === 0) {
        return {
          success: true,
          message: 'No shapes currently selected',
          data: { selectedCount: 0, shapes: [] },
        };
      }

      const db = admin.database();
      const shapes: any[] = [];

      // Fetch each selected shape
      for (const shapeId of context.selectedShapes) {
        const snapshot = await db.ref(`canvas/${context.canvasId}/objects/${shapeId}`).once('value');
        if (snapshot.exists()) {
          shapes.push(snapshot.val());
        }
      }

      // Build summary
      const summary = shapes.map(s => ({
        id: s.id,
        type: s.type,
        position: { x: s.x, y: s.y },
        size: { width: s.width, height: s.height },
        fill: s.fill,
        rotation: s.rotation || 0,
        text: s.text,
      }));

      return {
        success: true,
        message: `${shapes.length} shape(s) selected`,
        data: {
          selectedCount: shapes.length,
          shapes: summary,
        },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to get selected shapes: ${error.message}`,
      };
    }
  },
};
</file>

<file path="functions/src/ai/tools/shapeTools.ts">
/**
 * Shape Tools
 * Create, delete, and modify shapes
 * PR-30: Task 2.1
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import {
  validateShapeType,
  validateColor,
  validateCoordinates,
  validateDimensions,
  validateShapeIds,
  sanitizeString,
} from '../validation';
import { checkShapeLimit, checkUserPermission } from '../safety';

/**
 * Generate unique shape ID
 */
function generateShapeId(): string {
  return `shape-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Create Shape Tool
 * Creates one or more shapes on the canvas
 */
export const createShapeTool: ToolDefinition = {
  name: 'createShape',
  description: 'Create a new shape on the canvas. Can create rectangles, circles, ellipses, polygons, stars, lines, and text.',
  parameters: {
    type: 'object',
    properties: {
      type: {
        type: 'string',
        description: 'Shape type',
        enum: ['rectangle', 'circle', 'ellipse', 'polygon', 'star', 'line', 'text', 'rounded-rect'],
      },
      x: {
        type: 'number',
        description: 'X coordinate (0-5000)',
      },
      y: {
        type: 'number',
        description: 'Y coordinate (0-5000)',
      },
      width: {
        type: 'number',
        description: 'Width in pixels (1-2000)',
      },
      height: {
        type: 'number',
        description: 'Height in pixels (1-2000)',
      },
      color: {
        type: 'string',
        description: 'Fill color (hex like #FF0000 or named like "red")',
      },
      strokeColor: {
        type: 'string',
        description: 'Stroke/border color (optional)',
      },
      strokeWidth: {
        type: 'number',
        description: 'Stroke width in pixels (optional)',
      },
      text: {
        type: 'string',
        description: 'Text content (only for text shapes)',
      },
      rotation: {
        type: 'number',
        description: 'Rotation angle in degrees (optional)',
      },
    },
    required: ['type', 'x', 'y'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape limit
      const limitCheck = await checkShapeLimit(context.canvasId, 1);
      if (!limitCheck.allowed) {
        return { success: false, error: limitCheck.reason };
      }

      // Validate type
      if (!validateShapeType(params.type)) {
        return { success: false, error: `Invalid shape type: ${params.type}` };
      }

      // Validate coordinates
      const coordCheck = validateCoordinates(params.x, params.y);
      if (!coordCheck.valid) {
        return { success: false, error: coordCheck.error };
      }

      // Set default dimensions if not provided
      const width = params.width || (params.type === 'circle' ? 100 : 150);
      const height = params.height || (params.type === 'circle' ? 100 : 100);

      // Validate dimensions
      const dimCheck = validateDimensions(width, height);
      if (!dimCheck.valid) {
        return { success: false, error: dimCheck.error };
      }

      // Validate color if provided
      if (params.color && !validateColor(params.color)) {
        return { success: false, error: `Invalid color: ${params.color}` };
      }

      // Build compressed shape data (matches client format)
      const shapeId = generateShapeId();
      
      // Map type to type code
      let typeCode: 'r' | 'c' | 't' | 'l' | 'pg' | 'st' | 'rr' = 'r';
      switch (params.type) {
        case 'rectangle': typeCode = 'r'; break;
        case 'circle': typeCode = 'c'; break;
        case 'text': typeCode = 't'; break;
        case 'line': typeCode = 'l'; break;
        case 'polygon': typeCode = 'pg'; break;
        case 'star': typeCode = 'st'; break;
        case 'rounded-rect': typeCode = 'rr'; break;
      }

      const shapeData: any = {
        t: typeCode,
        x: Math.round(params.x),
        y: Math.round(params.y),
        w: Math.round(width),
        h: Math.round(height),
        f: params.color || '#3B82F6FF', // Default blue with alpha
        z: Date.now(), // z-index
      };

      // Add rotation if present
      if (params.rotation) {
        shapeData.rot = Math.round(params.rotation);
      }

      // Add stroke properties if present
      if (params.strokeColor) {
        shapeData.s = params.strokeColor;
      }
      if (params.strokeWidth) {
        shapeData.sw = Math.round(params.strokeWidth);
      }

      // Add type-specific properties
      if (params.type === 'text') {
        shapeData.txt = sanitizeString(params.text || 'Text', 500);
        shapeData.fs = 24; // fontSize
        shapeData.ff = 'Inter, sans-serif'; // fontFamily
      }

      if (params.type === 'rounded-rect') {
        shapeData.cr = 10; // cornerRadius
      }

      if (params.type === 'star') {
        shapeData.pts = 5; // points
      }

      if (params.type === 'polygon') {
        shapeData.sides = 6;
      }

      // Write to Firebase (canvas/objects path to match client)
      const db = admin.database();
      await db.ref(`canvas/${context.canvasId}/objects/${shapeId}`).set(shapeData);

      return {
        success: true,
        message: `Created ${params.type} at (${params.x}, ${params.y})`,
        data: { shapeId, type: params.type },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to create shape: ${error.message}`,
      };
    }
  },
};

/**
 * Delete Shapes Tool
 * Deletes one or more shapes from the canvas
 */
export const deleteShapesTool: ToolDefinition = {
  name: 'deleteShapes',
  description: 'Delete one or more shapes from the canvas. Requires shape IDs.',
  parameters: {
    type: 'object',
    properties: {
      shapeIds: {
        type: 'array',
        description: 'Array of shape IDs to delete',
        items: { type: 'string' },
      },
      confirm: {
        type: 'boolean',
        description: 'Set to true to confirm deletion (required if deleting >10 shapes)',
      },
    },
    required: ['shapeIds'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape IDs
      const idsCheck = validateShapeIds(params.shapeIds);
      if (!idsCheck.valid) {
        return { success: false, error: idsCheck.error };
      }

      // Require confirmation for large deletions
      if (params.shapeIds.length > 10 && !params.confirm) {
        return {
          success: false,
          error: `Deleting ${params.shapeIds.length} shapes requires confirmation. Add confirm=true to proceed.`,
        };
      }

      const db = admin.database();
      const updates: any = {};

      // Delete each shape from canvas/objects
      for (const shapeId of params.shapeIds) {
        updates[`canvas/${context.canvasId}/objects/${shapeId}`] = null;
      }

      await db.ref().update(updates);

      return {
        success: true,
        message: `Deleted ${params.shapeIds.length} shape(s)`,
        data: { deletedCount: params.shapeIds.length },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to delete shapes: ${error.message}`,
      };
    }
  },
};

/**
 * Modify Shape Tool
 * Modifies properties of an existing shape
 */
export const modifyShapeTool: ToolDefinition = {
  name: 'modifyShape',
  description: 'Modify properties of an existing shape (color, size, position, etc.)',
  parameters: {
    type: 'object',
    properties: {
      shapeId: {
        type: 'string',
        description: 'ID of the shape to modify',
      },
      properties: {
        type: 'object',
        description: 'Properties to modify',
        properties: {
          x: { type: 'number' },
          y: { type: 'number' },
          width: { type: 'number' },
          height: { type: 'number' },
          fill: { type: 'string' },
          stroke: { type: 'string' },
          strokeWidth: { type: 'number' },
          rotation: { type: 'number' },
          opacity: { type: 'number' },
          text: { type: 'string' },
        },
      },
    },
    required: ['shapeId', 'properties'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape exists
      const db = admin.database();
      const shapeRef = db.ref(`canvas/${context.canvasId}/objects/${params.shapeId}`);
      const snapshot = await shapeRef.once('value');
      
      if (!snapshot.exists()) {
        return { success: false, error: `Shape ${params.shapeId} not found` };
      }

      // Validate modifications
      const updates: any = {};
      const props = params.properties;

      if (props.x !== undefined || props.y !== undefined) {
        const x = props.x ?? snapshot.val().x;
        const y = props.y ?? snapshot.val().y;
        const coordCheck = validateCoordinates(x, y);
        if (!coordCheck.valid) {
          return { success: false, error: coordCheck.error };
        }
        if (props.x !== undefined) updates.x = props.x;
        if (props.y !== undefined) updates.y = props.y;
      }

      if (props.width !== undefined || props.height !== undefined) {
        const width = props.width ?? snapshot.val().width;
        const height = props.height ?? snapshot.val().height;
        const dimCheck = validateDimensions(width, height);
        if (!dimCheck.valid) {
          return { success: false, error: dimCheck.error };
        }
        if (props.width !== undefined) updates.width = props.width;
        if (props.height !== undefined) updates.height = props.height;
      }

      if (props.fill && !validateColor(props.fill)) {
        return { success: false, error: `Invalid fill color: ${props.fill}` };
      }

      if (props.stroke && !validateColor(props.stroke)) {
        return { success: false, error: `Invalid stroke color: ${props.stroke}` };
      }

      // Apply allowed modifications
      const allowedProps = ['fill', 'stroke', 'strokeWidth', 'rotation', 'opacity', 'text'];
      for (const key of allowedProps) {
        if (props[key] !== undefined) {
          if (key === 'text') {
            updates[key] = sanitizeString(props[key], 500);
          } else {
            updates[key] = props[key];
          }
        }
      }

      // Add metadata
      updates.modifiedBy = context.userId;
      updates.modifiedAt = Date.now();

      // Apply updates
      await shapeRef.update(updates);

      return {
        success: true,
        message: `Modified shape ${params.shapeId}`,
        data: { shapeId: params.shapeId, modifications: Object.keys(updates) },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to modify shape: ${error.message}`,
      };
    }
  },
};
</file>

<file path="functions/src/ai/tools/tilemapTools.ts">
/**
 * Tilemap Tools
 * Paint, erase, and generate tilemaps
 * PR-30: Task 4.3
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import { validateTileType, validateTileCoords } from '../validation';
import {
  checkUserPermission,
  checkTileOperationLimit,
  checkTilemapDimensions,
} from '../safety';
import {
  fillRegion,
  clearRegion,
  clearAllTiles,
  getTileCountInRegion,
} from '../../services/tilemapBatch';
import {
  generateNoiseTerrain,
  generateCellularCaves,
  generateRandomWalk,
  generateIsland,
} from '../tilemapGenerators';

/**
 * Paint Tile Region Tool
 * Paints a rectangular region with tiles
 */
export const paintTileRegionTool: ToolDefinition = {
  name: 'paintTileRegion',
  description: 'Paint a rectangular region of tiles on the tilemap',
  parameters: {
    type: 'object',
    properties: {
      startRow: {
        type: 'number',
        description: 'Starting row coordinate (0-1000)',
      },
      startCol: {
        type: 'number',
        description: 'Starting column coordinate (0-1000)',
      },
      endRow: {
        type: 'number',
        description: 'Ending row coordinate (0-1000)',
      },
      endCol: {
        type: 'number',
        description: 'Ending column coordinate (0-1000)',
      },
      tileType: {
        type: 'string',
        description: 'Tile type to paint',
        enum: ['grass', 'dirt', 'water', 'stone', 'flower'],
      },
    },
    required: ['startRow', 'startCol', 'endRow', 'endCol', 'tileType'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate coordinates
      const startCheck = validateTileCoords(params.startRow, params.startCol);
      if (!startCheck.valid) {
        return { success: false, error: startCheck.error };
      }

      const endCheck = validateTileCoords(params.endRow, params.endCol);
      if (!endCheck.valid) {
        return { success: false, error: endCheck.error };
      }

      // Validate tile type
      if (!validateTileType(params.tileType)) {
        return { success: false, error: `Invalid tile type: ${params.tileType}` };
      }

      // Check tile operation limit
      const tileCount = getTileCountInRegion(
        params.startRow,
        params.startCol,
        params.endRow,
        params.endCol
      );
      const limitCheck = checkTileOperationLimit(tileCount);
      if (!limitCheck.allowed) {
        return { success: false, error: limitCheck.reason };
      }

      // Execute batch fill
      const result = await fillRegion(
        context.canvasId,
        params.startRow,
        params.startCol,
        params.endRow,
        params.endCol,
        params.tileType
      );

      if (!result.success) {
        return { success: false, error: result.error };
      }

      return {
        success: true,
        message: `Painted ${result.tileCount} ${params.tileType} tiles in ${result.batchCount} batch(es)`,
        data: { tileCount: result.tileCount, batchCount: result.batchCount },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to paint tile region: ${error.message}`,
      };
    }
  },
};

/**
 * Erase Tile Region Tool
 * Erases tiles in a rectangular region (only painted tiles, not empty space)
 */
export const eraseTileRegionTool: ToolDefinition = {
  name: 'eraseTileRegion',
  description: 'Erase painted tiles in a specific rectangular region. Only erases tiles that actually exist in that region, not empty space.',
  parameters: {
    type: 'object',
    properties: {
      startRow: {
        type: 'number',
        description: 'Starting row coordinate (0-1000)',
      },
      startCol: {
        type: 'number',
        description: 'Starting column coordinate (0-1000)',
      },
      endRow: {
        type: 'number',
        description: 'Ending row coordinate (0-1000)',
      },
      endCol: {
        type: 'number',
        description: 'Ending column coordinate (0-1000)',
      },
    },
    required: ['startRow', 'startCol', 'endRow', 'endCol'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate coordinates
      const startCheck = validateTileCoords(params.startRow, params.startCol);
      if (!startCheck.valid) {
        return { success: false, error: startCheck.error };
      }

      const endCheck = validateTileCoords(params.endRow, params.endCol);
      if (!endCheck.valid) {
        return { success: false, error: endCheck.error };
      }

      // Check tile operation limit
      const tileCount = getTileCountInRegion(
        params.startRow,
        params.startCol,
        params.endRow,
        params.endCol
      );
      const limitCheck = checkTileOperationLimit(tileCount);
      if (!limitCheck.allowed) {
        return { success: false, error: limitCheck.reason };
      }

      // Execute batch clear
      const result = await clearRegion(
        context.canvasId,
        params.startRow,
        params.startCol,
        params.endRow,
        params.endCol
      );

      if (!result.success) {
        return { success: false, error: result.error };
      }

      return {
        success: true,
        message: `Erased ${result.tileCount} tiles in ${result.batchCount} batch(es)`,
        data: { tileCount: result.tileCount, batchCount: result.batchCount },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to erase tile region: ${error.message}`,
      };
    }
  },
};

/**
 * Erase All Painted Tiles Tool
 * Erases all existing tiles on the tilemap (only painted tiles, not empty space)
 */
export const eraseAllTilesTool: ToolDefinition = {
  name: 'eraseAllTiles',
  description: 'Erase all painted tiles on the tilemap. Only erases tiles that actually exist, not empty space.',
  parameters: {
    type: 'object',
    properties: {},
    required: [],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Execute clear all tiles
      const result = await clearAllTiles(context.canvasId);

      if (!result.success) {
        return { success: false, error: result.error };
      }

      if (result.tileCount === 0) {
        return {
          success: true,
          message: 'No tiles to erase - tilemap is already empty',
          data: { tileCount: 0 },
        };
      }

      return {
        success: true,
        message: `Erased ${result.tileCount} painted tiles in ${result.batchCount} batch(es)`,
        data: { tileCount: result.tileCount, batchCount: result.batchCount },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to erase all tiles: ${error.message}`,
      };
    }
  },
};

/**
 * Generate Tilemap Tool
 * Generates procedural tilemaps using various advanced algorithms
 * PR-32: Enhanced with Perlin Noise, Cellular Automata, WFC, Random Walk
 */
export const generateTilemapTool: ToolDefinition = {
  name: 'generateTilemap',
  description: 'Generate a procedural tilemap using advanced algorithms: perlin-noise (natural terrain), cellular-automata (caves/dungeons), wave-function-collapse (constrained generation), random-walk (paths/rivers), or simple noise/island',
  parameters: {
    type: 'object',
    properties: {
      width: {
        type: 'number',
        description: 'Tilemap width in tiles (1-500)',
      },
      height: {
        type: 'number',
        description: 'Tilemap height in tiles (1-500)',
      },
      algorithm: {
        type: 'string',
        description: 'Generation algorithm',
        enum: ['perlin-noise', 'cellular-automata', 'wave-function-collapse', 'random-walk', 'noise', 'caves', 'paths', 'island'],
      },
      // Perlin Noise parameters
      scale: {
        type: 'number',
        description: 'Noise scale - controls feature size (0.01-1.0, default: 0.1). Smaller = larger features',
      },
      octaves: {
        type: 'number',
        description: 'Number of noise layers for detail (1-8, default: 4). Higher = more detail',
      },
      persistence: {
        type: 'number',
        description: 'Amplitude decay per octave (0-1, default: 0.5). Higher = rougher terrain',
      },
      // Cellular Automata parameters
      initialDensity: {
        type: 'number',
        description: 'Starting fill ratio for caves (0-1, default: 0.45). Higher = more walls',
      },
      iterations: {
        type: 'number',
        description: 'Number of simulation steps for caves (1-10, default: 5)',
      },
      connectRegions: {
        type: 'boolean',
        description: 'Connect disconnected cave regions with corridors (default: true)',
      },
      // WFC parameters
      wfcTileset: {
        type: 'string',
        description: 'Tileset for wave function collapse',
        enum: ['platform', 'dungeon', 'terrain'],
      },
      // Random Walk parameters
      pathWidth: {
        type: 'number',
        description: 'Path width for random walk (1-10, default: 2)',
      },
      pathSteps: {
        type: 'number',
        description: 'Number of steps in path (default: 100)',
      },
      smooth: {
        type: 'boolean',
        description: 'Smooth path with curves (default: false)',
      },
      // Legacy parameters
      fillProbability: {
        type: 'number',
        description: 'Fill probability for legacy caves algorithm (default: 0.45)',
      },
      // Common parameters
      seed: {
        type: 'number',
        description: 'Random seed for reproducible generation',
      },
    },
    required: ['width', 'height', 'algorithm'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate dimensions
      const dimCheck = checkTilemapDimensions(params.width, params.height);
      if (!dimCheck.allowed) {
        return { success: false, error: dimCheck.reason };
      }

      // Generate tiles based on algorithm
      let tiles;
      let algorithmDetails = '';
      
      switch (params.algorithm) {
        case 'perlin-noise': {
          const { generatePerlinTilemap } = await import('../tilemapGenerators');
          tiles = generatePerlinTilemap(params.width, params.height, {
            scale: params.scale || 0.1,
            octaves: params.octaves || 4,
            persistence: params.persistence || 0.5,
            lacunarity: 2.0,
            seed: params.seed,
          });
          algorithmDetails = `scale=${params.scale || 0.1}, octaves=${params.octaves || 4}`;
          break;
        }

        case 'cellular-automata': {
          const { generateCellularTilemap } = await import('../tilemapGenerators');
          tiles = generateCellularTilemap(params.width, params.height, {
            initialDensity: params.initialDensity || 0.45,
            birthLimit: 4,
            deathLimit: 3,
            iterations: params.iterations || 5,
            seed: params.seed,
          }, {
            connectRegions: params.connectRegions !== false,
            removeIslands: true,
          });
          algorithmDetails = `density=${params.initialDensity || 0.45}, iterations=${params.iterations || 5}`;
          break;
        }

        case 'wave-function-collapse': {
          const { generateWFCTilemap } = await import('../tilemapGenerators');
          const tileset = params.wfcTileset || 'terrain';
          tiles = generateWFCTilemap(params.width, params.height, tileset, params.seed);
          
          if (!tiles) {
            return { 
              success: false, 
              error: 'Wave Function Collapse failed to generate a valid tilemap. Try a smaller size or different tileset.' 
            };
          }
          algorithmDetails = `tileset=${tileset}`;
          break;
        }

        case 'random-walk': {
          const { generateRandomWalkTilemap } = await import('../tilemapGenerators');
          tiles = generateRandomWalkTilemap(params.width, params.height, {
            steps: params.pathSteps || 100,
            turnProbability: 0.2,
            branchProbability: 0.05,
            width: params.pathWidth || 2,
            seed: params.seed,
          }, {
            smooth: params.smooth || false,
          });
          algorithmDetails = `width=${params.pathWidth || 2}, steps=${params.pathSteps || 100}`;
          break;
        }

        // Legacy algorithms
        case 'noise':
          tiles = generateNoiseTerrain(params.width, params.height, {
            scale: params.scale || 0.1,
          });
          algorithmDetails = 'legacy noise';
          break;

        case 'caves':
          tiles = generateCellularCaves(params.width, params.height, {
            fillProbability: params.fillProbability || 0.45,
          });
          algorithmDetails = 'legacy caves';
          break;

        case 'paths':
          tiles = generateRandomWalk(params.width, params.height, {
            pathWidth: params.pathWidth || 1,
          });
          algorithmDetails = 'legacy paths';
          break;

        case 'island':
          tiles = generateIsland(params.width, params.height);
          algorithmDetails = 'island';
          break;

        default:
          return { success: false, error: `Unknown algorithm: ${params.algorithm}` };
      }

      // Update tilemap metadata
      const db = admin.database();
      await db.ref(`canvases/${context.canvasId}/tilemap`).update({
        width: params.width,
        height: params.height,
        tileSize: 32,
        updatedAt: Date.now(),
        updatedBy: context.userId,
        generationAlgorithm: params.algorithm,
        generationParams: algorithmDetails,
      });

      // Batch set tiles
      const { batchSetTiles } = await import('../../services/tilemapBatch');
      const result = await batchSetTiles(context.canvasId, tiles);

      if (!result.success) {
        return { success: false, error: result.error };
      }

      return {
        success: true,
        message: `Generated ${params.width}x${params.height} tilemap using ${params.algorithm} algorithm (${algorithmDetails}). Placed ${result.tileCount} tiles in ${result.batchCount} batches.`,
        data: {
          width: params.width,
          height: params.height,
          algorithm: params.algorithm,
          algorithmDetails,
          tileCount: result.tileCount,
          batchCount: result.batchCount,
        },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to generate tilemap: ${error.message}`,
      };
    }
  },
};
</file>

<file path="functions/src/ai/tools/transformTools.ts">
/**
 * Transform Tools
 * Move, resize, and rotate shapes
 * PR-30: Task 2.2
 */

import * as admin from 'firebase-admin';
import { ToolDefinition, ToolResult } from '../toolRegistry';
import {
  validateShapeIds,
  validateCoordinates,
  validateDimensions,
  validateRotation,
} from '../validation';
import { checkUserPermission, clampToCanvas } from '../safety';

/**
 * Move Shapes Tool
 * Moves one or more shapes to a new position or by an offset
 */
export const moveShapesTool: ToolDefinition = {
  name: 'moveShapes',
  description: 'Move one or more shapes. Can move to absolute position or by relative offset.',
  parameters: {
    type: 'object',
    properties: {
      shapeIds: {
        type: 'array',
        description: 'Array of shape IDs to move',
        items: { type: 'string' },
      },
      mode: {
        type: 'string',
        description: 'Move mode: "absolute" (to specific position) or "relative" (by offset)',
        enum: ['absolute', 'relative'],
      },
      x: {
        type: 'number',
        description: 'Target X coordinate or X offset',
      },
      y: {
        type: 'number',
        description: 'Target Y coordinate or Y offset',
      },
    },
    required: ['shapeIds', 'mode', 'x', 'y'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape IDs
      const idsCheck = validateShapeIds(params.shapeIds);
      if (!idsCheck.valid) {
        return { success: false, error: idsCheck.error };
      }

      const db = admin.database();
      const updates: any = {};
      let movedCount = 0;

      // Process each shape
      for (const shapeId of params.shapeIds) {
        const shapeRef = db.ref(`canvas/${context.canvasId}/objects/${shapeId}`);
        const snapshot = await shapeRef.once('value');
        
        if (!snapshot.exists()) {
          continue; // Skip non-existent shapes
        }

        const shape = snapshot.val();
        let newX: number;
        let newY: number;

        if (params.mode === 'absolute') {
          newX = params.x;
          newY = params.y;
        } else {
          // Relative movement
          newX = shape.x + params.x;
          newY = shape.y + params.y;
        }

        // Validate and clamp coordinates
        const coordCheck = validateCoordinates(newX, newY);
        if (!coordCheck.valid) {
          // Clamp to safe bounds instead of failing
          const clamped = clampToCanvas(newX, newY);
          newX = clamped.x;
          newY = clamped.y;
        }

        updates[`canvas/${context.canvasId}/objects/${shapeId}/x`] = newX;
        updates[`canvas/${context.canvasId}/objects/${shapeId}/y`] = newY;
        updates[`canvas/${context.canvasId}/objects/${shapeId}/modifiedBy`] = context.userId;
        updates[`canvas/${context.canvasId}/objects/${shapeId}/modifiedAt`] = Date.now();
        movedCount++;
      }

      if (movedCount === 0) {
        return { success: false, error: 'No valid shapes found to move' };
      }

      // Apply all updates in batch
      await db.ref().update(updates);

      const mode = params.mode === 'absolute' ? `to (${params.x}, ${params.y})` : `by (${params.x}, ${params.y})`;
      return {
        success: true,
        message: `Moved ${movedCount} shape(s) ${mode}`,
        data: { movedCount },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to move shapes: ${error.message}`,
      };
    }
  },
};

/**
 * Resize Shape Tool
 * Resizes a single shape
 */
export const resizeShapeTool: ToolDefinition = {
  name: 'resizeShape',
  description: 'Resize a shape to new dimensions',
  parameters: {
    type: 'object',
    properties: {
      shapeId: {
        type: 'string',
        description: 'ID of the shape to resize',
      },
      width: {
        type: 'number',
        description: 'New width in pixels (1-2000)',
      },
      height: {
        type: 'number',
        description: 'New height in pixels (1-2000)',
      },
      maintainAspectRatio: {
        type: 'boolean',
        description: 'If true, scale proportionally (optional)',
      },
    },
    required: ['shapeId'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Get current shape
      const db = admin.database();
      const shapeRef = db.ref(`canvas/${context.canvasId}/objects/${params.shapeId}`);
      const snapshot = await shapeRef.once('value');
      
      if (!snapshot.exists()) {
        return { success: false, error: `Shape ${params.shapeId} not found` };
      }

      const shape = snapshot.val();
      let newWidth = params.width || shape.width;
      let newHeight = params.height || shape.height;

      // Maintain aspect ratio if requested
      if (params.maintainAspectRatio && params.width && !params.height) {
        const aspectRatio = shape.height / shape.width;
        newHeight = newWidth * aspectRatio;
      } else if (params.maintainAspectRatio && params.height && !params.width) {
        const aspectRatio = shape.width / shape.height;
        newWidth = newHeight * aspectRatio;
      }

      // Validate dimensions
      const dimCheck = validateDimensions(newWidth, newHeight);
      if (!dimCheck.valid) {
        return { success: false, error: dimCheck.error };
      }

      // Apply resize
      await shapeRef.update({
        width: newWidth,
        height: newHeight,
        modifiedBy: context.userId,
        modifiedAt: Date.now(),
      });

      return {
        success: true,
        message: `Resized shape to ${Math.round(newWidth)}x${Math.round(newHeight)}`,
        data: { shapeId: params.shapeId, width: newWidth, height: newHeight },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to resize shape: ${error.message}`,
      };
    }
  },
};

/**
 * Rotate Shapes Tool
 * Rotates one or more shapes
 */
export const rotateShapesTool: ToolDefinition = {
  name: 'rotateShapes',
  description: 'Rotate one or more shapes by an angle',
  parameters: {
    type: 'object',
    properties: {
      shapeIds: {
        type: 'array',
        description: 'Array of shape IDs to rotate',
        items: { type: 'string' },
      },
      mode: {
        type: 'string',
        description: 'Rotation mode: "absolute" (set to angle) or "relative" (rotate by angle)',
        enum: ['absolute', 'relative'],
      },
      angle: {
        type: 'number',
        description: 'Rotation angle in degrees',
      },
    },
    required: ['shapeIds', 'mode', 'angle'],
  },
  execute: async (params, context): Promise<ToolResult> => {
    try {
      // Validate permissions
      const permCheck = await checkUserPermission(context.userId, context.canvasId);
      if (!permCheck.allowed) {
        return { success: false, error: permCheck.reason };
      }

      // Validate shape IDs
      const idsCheck = validateShapeIds(params.shapeIds);
      if (!idsCheck.valid) {
        return { success: false, error: idsCheck.error };
      }

      // Validate angle
      const angleCheck = validateRotation(params.angle);
      if (!angleCheck.valid) {
        return { success: false, error: angleCheck.error };
      }

      const db = admin.database();
      const updates: any = {};
      let rotatedCount = 0;

      // Process each shape
      for (const shapeId of params.shapeIds) {
        const shapeRef = db.ref(`canvas/${context.canvasId}/objects/${shapeId}`);
        const snapshot = await shapeRef.once('value');
        
        if (!snapshot.exists()) {
          continue;
        }

        const shape = snapshot.val();
        let newRotation: number;

        if (params.mode === 'absolute') {
          newRotation = params.angle;
        } else {
          // Relative rotation
          newRotation = (shape.rotation || 0) + params.angle;
        }

        // Normalize to 0-360
        newRotation = ((newRotation % 360) + 360) % 360;

        updates[`canvas/${context.canvasId}/objects/${shapeId}/rotation`] = newRotation;
        updates[`canvas/${context.canvasId}/objects/${shapeId}/modifiedBy`] = context.userId;
        updates[`canvas/${context.canvasId}/objects/${shapeId}/modifiedAt`] = Date.now();
        rotatedCount++;
      }

      if (rotatedCount === 0) {
        return { success: false, error: 'No valid shapes found to rotate' };
      }

      // Apply all updates in batch
      await db.ref().update(updates);

      const mode = params.mode === 'absolute' ? `to ${params.angle}°` : `by ${params.angle}°`;
      return {
        success: true,
        message: `Rotated ${rotatedCount} shape(s) ${mode}`,
        data: { rotatedCount },
      };

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to rotate shapes: ${error.message}`,
      };
    }
  },
};
</file>

<file path="functions/src/ai/validation.ts">
/**
 * Parameter Validation
 * Validates and sanitizes tool parameters
 * PR-30: Task 8.1
 */

/**
 * Validate shape type
 */
export function validateShapeType(type: string): boolean {
  const validTypes = ['rectangle', 'circle', 'ellipse', 'polygon', 'star', 'line', 'path', 'text', 'rounded-rect'];
  return validTypes.includes(type.toLowerCase());
}

/**
 * Validate tile type
 */
export function validateTileType(type: string): boolean {
  const validTypes = ['grass', 'dirt', 'water', 'stone', 'flower'];
  return validTypes.includes(type.toLowerCase());
}

/**
 * Validate color format
 * Accepts hex colors (#RGB, #RRGGBB) and named colors
 */
export function validateColor(color: string): boolean {
  // Hex colors
  if (/^#([0-9A-F]{3}|[0-9A-F]{6})$/i.test(color)) {
    return true;
  }
  
  // Named colors (basic set)
  const namedColors = [
    'red', 'blue', 'green', 'yellow', 'orange', 'purple', 'pink',
    'black', 'white', 'gray', 'brown', 'cyan', 'magenta',
  ];
  return namedColors.includes(color.toLowerCase());
}

/**
 * Validate coordinates are within canvas bounds
 */
export function validateCoordinates(x: number, y: number): { valid: boolean; error?: string } {
  const MIN = 0;
  const MAX = 5000;
  
  if (typeof x !== 'number' || typeof y !== 'number') {
    return { valid: false, error: 'Coordinates must be numbers' };
  }
  
  if (isNaN(x) || isNaN(y)) {
    return { valid: false, error: 'Coordinates cannot be NaN' };
  }
  
  if (x < MIN || x > MAX) {
    return { valid: false, error: `X coordinate must be between ${MIN} and ${MAX}` };
  }
  
  if (y < MIN || y > MAX) {
    return { valid: false, error: `Y coordinate must be between ${MIN} and ${MAX}` };
  }
  
  return { valid: true };
}

/**
 * Validate dimensions (width/height)
 */
export function validateDimensions(width: number, height: number): { valid: boolean; error?: string } {
  const MIN = 1;
  const MAX = 2000;
  
  if (typeof width !== 'number' || typeof height !== 'number') {
    return { valid: false, error: 'Dimensions must be numbers' };
  }
  
  if (isNaN(width) || isNaN(height)) {
    return { valid: false, error: 'Dimensions cannot be NaN' };
  }
  
  if (width < MIN || width > MAX) {
    return { valid: false, error: `Width must be between ${MIN} and ${MAX}` };
  }
  
  if (height < MIN || height > MAX) {
    return { valid: false, error: `Height must be between ${MIN} and ${MAX}` };
  }
  
  return { valid: true };
}

/**
 * Validate rotation angle
 */
export function validateRotation(rotation: number): { valid: boolean; error?: string } {
  if (typeof rotation !== 'number' || isNaN(rotation)) {
    return { valid: false, error: 'Rotation must be a number' };
  }
  
  // Normalize to 0-360
  return { valid: true };
}

/**
 * Validate shape IDs array
 */
export function validateShapeIds(ids: any): { valid: boolean; error?: string } {
  if (!Array.isArray(ids)) {
    return { valid: false, error: 'Shape IDs must be an array' };
  }
  
  if (ids.length === 0) {
    return { valid: false, error: 'At least one shape ID is required' };
  }
  
  if (ids.length > 100) {
    return { valid: false, error: 'Cannot operate on more than 100 shapes at once' };
  }
  
  // Check all IDs are strings
  const allStrings = ids.every(id => typeof id === 'string' && id.length > 0);
  if (!allStrings) {
    return { valid: false, error: 'All shape IDs must be non-empty strings' };
  }
  
  return { valid: true };
}

/**
 * Validate tile coordinates
 */
export function validateTileCoords(row: number, col: number): { valid: boolean; error?: string } {
  const MIN = 0;
  const MAX = 1000;
  
  if (typeof row !== 'number' || typeof col !== 'number') {
    return { valid: false, error: 'Tile coordinates must be numbers' };
  }
  
  if (!Number.isInteger(row) || !Number.isInteger(col)) {
    return { valid: false, error: 'Tile coordinates must be integers' };
  }
  
  if (row < MIN || row > MAX || col < MIN || col > MAX) {
    return { valid: false, error: `Tile coordinates must be between ${MIN} and ${MAX}` };
  }
  
  return { valid: true };
}

/**
 * Sanitize string input
 * Removes potentially harmful characters
 */
export function sanitizeString(input: string, maxLength = 1000): string {
  if (typeof input !== 'string') {
    return '';
  }
  
  // Trim and limit length
  let sanitized = input.trim().slice(0, maxLength);
  
  // Remove control characters except newlines and tabs
  sanitized = sanitized.replace(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/g, '');
  
  return sanitized;
}

/**
 * Validate array length
 */
export function validateArrayLength(
  arr: any[],
  minLength: number,
  maxLength: number,
  name: string
): { valid: boolean; error?: string } {
  if (!Array.isArray(arr)) {
    return { valid: false, error: `${name} must be an array` };
  }
  
  if (arr.length < minLength) {
    return { valid: false, error: `${name} must have at least ${minLength} item(s)` };
  }
  
  if (arr.length > maxLength) {
    return { valid: false, error: `${name} cannot have more than ${maxLength} items` };
  }
  
  return { valid: true };
}
</file>

<file path="functions/src/index.ts">
/**
 * Firebase Functions - Main Entry Point
 * PR-30: AI Canvas Agent
 */

import * as admin from 'firebase-admin';
import { aiCanvasCommand } from './ai-proxy';

// Initialize Firebase Admin SDK
admin.initializeApp();

// Export Cloud Functions
export { aiCanvasCommand };
</file>

<file path="functions/src/services/tilemapBatch.ts">
/**
 * Tilemap Batch Operations
 * Efficient batch updates for tilemap tiles
 * PR-30: Task 4.1
 */

import * as admin from 'firebase-admin';

export interface TileData {
  row: number;
  col: number;
  type: string;
  variant?: number;
}

export interface BatchResult {
  success: boolean;
  tileCount: number;
  batchCount: number;
  error?: string;
}

/**
 * Batch set tiles
 * Groups tiles into batches of 100 for efficient Firebase updates
 * Uses chunked storage system for better performance
 */
export async function batchSetTiles(
  canvasId: string,
  tiles: TileData[]
): Promise<BatchResult> {
  try {
    const db = admin.database();
    const BATCH_SIZE = 100;
    const CHUNK_SIZE = 16;
    const batches = Math.ceil(tiles.length / BATCH_SIZE);

    // Helper to convert global coords to chunk/local coords
    const coordToChunk = (row: number, col: number) => {
      const chunkX = Math.floor(col / CHUNK_SIZE);
      const chunkY = Math.floor(row / CHUNK_SIZE);
      const localX = col % CHUNK_SIZE;
      const localY = row % CHUNK_SIZE;
      return { chunkX, chunkY, localX, localY };
    };

    // Process tiles in batches
    for (let i = 0; i < batches; i++) {
      const batchStart = i * BATCH_SIZE;
      const batchEnd = Math.min((i + 1) * BATCH_SIZE, tiles.length);
      const batchTiles = tiles.slice(batchStart, batchEnd);

      // Build update object for this batch
      const updates: any = {};
      
      for (const tile of batchTiles) {
        const { chunkX, chunkY, localX, localY } = coordToChunk(tile.row, tile.col);
        const chunkKey = `${chunkX}_${chunkY}`;
        const tileKey = `${localX}_${localY}`;
        const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`;
        
        // Match frontend's compressed format (t = type, c = color, v = variant)
        updates[tilePath] = {
          t: tile.type,
          c: '#ffffff', // Default color
          v: tile.variant || 0,
          by: 'ai', // Updated by AI
          ts: Date.now(),
        };
      }

      // Apply batch update
      await db.ref().update(updates);
    }

    return {
      success: true,
      tileCount: tiles.length,
      batchCount: batches,
    };

  } catch (error: any) {
    return {
      success: false,
      tileCount: 0,
      batchCount: 0,
      error: error.message,
    };
  }
}

/**
 * Batch erase tiles
 * Removes tiles in batches using chunked storage
 */
export async function batchEraseTiles(
  canvasId: string,
  positions: Array<{ row: number; col: number }>
): Promise<BatchResult> {
  try {
    const db = admin.database();
    const BATCH_SIZE = 100;
    const CHUNK_SIZE = 16;
    const batches = Math.ceil(positions.length / BATCH_SIZE);

    // Helper to convert global coords to chunk/local coords
    const coordToChunk = (row: number, col: number) => {
      const chunkX = Math.floor(col / CHUNK_SIZE);
      const chunkY = Math.floor(row / CHUNK_SIZE);
      const localX = col % CHUNK_SIZE;
      const localY = row % CHUNK_SIZE;
      return { chunkX, chunkY, localX, localY };
    };

    // Process positions in batches
    for (let i = 0; i < batches; i++) {
      const batchStart = i * BATCH_SIZE;
      const batchEnd = Math.min((i + 1) * BATCH_SIZE, positions.length);
      const batchPositions = positions.slice(batchStart, batchEnd);

      // Build update object for this batch (set to null to delete)
      const updates: any = {};
      
      for (const pos of batchPositions) {
        const { chunkX, chunkY, localX, localY } = coordToChunk(pos.row, pos.col);
        const chunkKey = `${chunkX}_${chunkY}`;
        const tileKey = `${localX}_${localY}`;
        const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`;
        updates[tilePath] = null;
      }

      // Apply batch update
      await db.ref().update(updates);
    }

    return {
      success: true,
      tileCount: positions.length,
      batchCount: batches,
    };

  } catch (error: any) {
    return {
      success: false,
      tileCount: 0,
      batchCount: 0,
      error: error.message,
    };
  }
}

/**
 * Fill rectangular region with tiles
 * Optimized for filling large areas
 */
export async function fillRegion(
  canvasId: string,
  startRow: number,
  startCol: number,
  endRow: number,
  endCol: number,
  tileType: string
): Promise<BatchResult> {
  const tiles: TileData[] = [];

  // Generate all tiles in the region
  for (let row = startRow; row <= endRow; row++) {
    for (let col = startCol; col <= endCol; col++) {
      tiles.push({
        row,
        col,
        type: tileType,
        variant: Math.floor(Math.random() * 9), // Random variant 0-8
      });
    }
  }

  return batchSetTiles(canvasId, tiles);
}

/**
 * Clear rectangular region (only erases existing tiles)
 * Queries existing tiles first, then erases only those that exist
 * Uses chunked storage path: tilemaps/${canvasId}/chunks
 */
export async function clearRegion(
  canvasId: string,
  startRow: number,
  startCol: number,
  endRow: number,
  endCol: number
): Promise<BatchResult> {
  try {
    const db = admin.database();
    const CHUNK_SIZE = 16;
    
    // Query all chunks (chunked storage system)
    const chunksSnapshot = await db.ref(`tilemaps/${canvasId}/chunks`).once('value');
    const chunks = chunksSnapshot.val();
    
    if (!chunks) {
      return {
        success: true,
        tileCount: 0,
        batchCount: 0,
      };
    }

    // Collect tiles within the region from all chunks
    const positions: Array<{ row: number; col: number }> = [];
    
    for (const [chunkKey, chunkData] of Object.entries(chunks)) {
      const chunk = chunkData as any;
      if (!chunk.tiles) continue;
      
      // Parse chunk coordinates from key (format: "cx_cy")
      const [chunkX, chunkY] = chunkKey.split('_').map(Number);
      
      for (const [tileKey, _tileData] of Object.entries(chunk.tiles)) {
        // Parse local tile coordinates from key (format: "lx_ly")
        const [localX, localY] = tileKey.split('_').map(Number);
        
        // Calculate global tile coordinates
        const row = chunkY * CHUNK_SIZE + localY;
        const col = chunkX * CHUNK_SIZE + localX;
        
        if (row >= startRow && row <= endRow && col >= startCol && col <= endCol) {
          positions.push({ row, col });
        }
      }
    }

    if (positions.length === 0) {
      return {
        success: true,
        tileCount: 0,
        batchCount: 0,
      };
    }

    return batchEraseTiles(canvasId, positions);
  } catch (error: any) {
    return {
      success: false,
      tileCount: 0,
      batchCount: 0,
      error: error.message,
    };
  }
}

/**
 * Clear all painted tiles on the tilemap
 * Only erases tiles that actually exist
 * Uses chunked storage path: tilemaps/${canvasId}/chunks
 */
export async function clearAllTiles(
  canvasId: string
): Promise<BatchResult> {
  try {
    const db = admin.database();
    const CHUNK_SIZE = 16;
    
    // Query all chunks (chunked storage system)
    const chunksSnapshot = await db.ref(`tilemaps/${canvasId}/chunks`).once('value');
    const chunks = chunksSnapshot.val();
    
    if (!chunks) {
      return {
        success: true,
        tileCount: 0,
        batchCount: 0,
      };
    }

    // Collect all tile positions from all chunks
    const positions: Array<{ row: number; col: number }> = [];
    
    for (const [chunkKey, chunkData] of Object.entries(chunks)) {
      const chunk = chunkData as any;
      if (!chunk.tiles) continue;
      
      // Parse chunk coordinates from key (format: "cx_cy")
      const [chunkX, chunkY] = chunkKey.split('_').map(Number);
      
      for (const [tileKey, _tileData] of Object.entries(chunk.tiles)) {
        // Parse local tile coordinates from key (format: "lx_ly")
        const [localX, localY] = tileKey.split('_').map(Number);
        
        // Calculate global tile coordinates
        const row = chunkY * CHUNK_SIZE + localY;
        const col = chunkX * CHUNK_SIZE + localX;
        
        positions.push({ row, col });
      }
    }

    if (positions.length === 0) {
      return {
        success: true,
        tileCount: 0,
        batchCount: 0,
      };
    }

    return batchEraseTiles(canvasId, positions);
  } catch (error: any) {
    return {
      success: false,
      tileCount: 0,
      batchCount: 0,
      error: error.message,
    };
  }
}

/**
 * Get tile count in a region (for safety checks)
 */
export function getTileCountInRegion(
  startRow: number,
  startCol: number,
  endRow: number,
  endCol: number
): number {
  const width = Math.abs(endCol - startCol) + 1;
  const height = Math.abs(endRow - startRow) + 1;
  return width * height;
}

/**
 * Get actual painted tile count in a region (queries Firebase using chunked storage)
 */
export async function getPaintedTileCountInRegion(
  canvasId: string,
  startRow: number,
  startCol: number,
  endRow: number,
  endCol: number
): Promise<number> {
  try {
    const db = admin.database();
    const CHUNK_SIZE = 16;
    
    // Query all chunks
    const chunksSnapshot = await db.ref(`tilemaps/${canvasId}/chunks`).once('value');
    const chunks = chunksSnapshot.val();
    
    if (!chunks) {
      return 0;
    }

    let count = 0;
    for (const [chunkKey, chunkData] of Object.entries(chunks)) {
      const chunk = chunkData as any;
      if (!chunk.tiles) continue;
      
      // Parse chunk coordinates
      const [chunkX, chunkY] = chunkKey.split('_').map(Number);
      
      for (const [tileKey, _tileData] of Object.entries(chunk.tiles)) {
        // Parse local tile coordinates
        const [localX, localY] = tileKey.split('_').map(Number);
        
        // Calculate global coordinates
        const row = chunkY * CHUNK_SIZE + localY;
        const col = chunkX * CHUNK_SIZE + localX;
        
        if (row >= startRow && row <= endRow && col >= startCol && col <= endCol) {
          count++;
        }
      }
    }

    return count;
  } catch (error) {
    return 0;
  }
}
</file>

<file path="functions/tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <title>CollabCanvas - Real-time Collaborative Design</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "collabcanvas",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "deploy": "npm run build && firebase deploy --only hosting"
  },
  "dependencies": {
    "@tailwindcss/postcss": "^4.1.14",
    "firebase": "^12.4.0",
    "jszip": "^3.10.1",
    "konva": "^10.0.2",
    "lodash-es": "^4.17.21",
    "lucide-react": "^0.468.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-konva": "^19.0.10",
    "react-router-dom": "^7.9.4",
    "use-image": "^1.1.4",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/lodash-es": "^4.17.12",
    "@types/node": "^24.7.2",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@types/react-router-dom": "^5.3.3",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/coverage-v8": "^3.2.4",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.21",
    "canvas": "^3.2.0",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "jsdom": "^27.0.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.14",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    "@tailwindcss/postcss": {},
    autoprefixer: {},
  },
}
</file>

<file path="pr32_ai_game_aware.md">
# PR-32: AI Game-Aware Enhancement (Phase 4)

## Overview
**Duration:** 3-4 days  
**Priority:** P1 - AI Enhancement  
**Dependencies:** PR-28, PR-29, PR-30, PR-31  
**Enables:** Professional game development with AI assistance

## Objective
Enhance AI capabilities with game development expertise. Add procedural generation algorithms for tilemaps, AI-powered sprite animation suggestions, game design pattern recognition, performance optimization recommendations, and intelligent asset management. Transform Claude into a game development co-pilot.

---

## Technical Specifications

### Enhanced AI Capabilities
1. **Procedural Tilemap Generation:** Advanced algorithms (Perlin noise, cellular automata, Wave Function Collapse)
2. **Smart Asset Suggestions:** Recommend sprites/tiles based on context
3. **Game Pattern Recognition:** Identify common patterns (platformer level, top-down dungeon, etc.)
4. **Animation Assistance:** Suggest animation parameters, auto-generate walk cycles
5. **Performance Analysis:** Identify bottlenecks, suggest optimizations
6. **Export Guidance:** Recommend best export target based on canvas content

### New AI Context Elements
```typescript
interface GameDevContext extends CanvasContext {
  gameType?: "platformer" | "top-down" | "puzzle" | "unknown"
  assets: {
    spritesheets: Asset[]
    tilesets: Asset[]
    animations: Animation[]
  }
  statistics: {
    totalObjects: number
    animatedSprites: number
    tilemapSize: { width, height }
    complexity: "low" | "medium" | "high"
  }
  performance: {
    fps: number
    renderTime: number
    objectCount: number
  }
}
```

---

## Detailed Task List

### **Task Group 1: Procedural Generation Algorithms (Day 1 Morning)**

#### Task 1.1: Implement Perlin Noise Generator
**File:** `src/algorithms/perlinNoise.ts` (NEW)
- [ ] Implement classic Perlin noise algorithm
- [ ] Add parameters:
  - `scale`: Controls terrain feature size (0.01-1.0)
  - `octaves`: Number of noise layers (1-8)
  - `persistence`: Amplitude multiplier per octave
  - `lacunarity`: Frequency multiplier per octave
- [ ] Implement `generateHeightMap(width, height, params)`:
  - Returns 2D array of normalized values (0-1)
- [ ] Implement `heightMapToTilemap(heightMap, thresholds)`:
  - Maps height values to tile types
  - Example: <0.3 = water, 0.3-0.6 = grass, >0.6 = mountain
- [ ] Add seed parameter for reproducible generation
- [ ] Optimize for large maps (1000x1000)

#### Task 1.2: Implement Cellular Automata
**File:** `src/algorithms/cellularAutomata.ts` (NEW)
- [ ] Implement cave/dungeon generator
- [ ] Parameters:
  - `initialDensity`: Starting fill ratio (0-1)
  - `birthLimit`: Neighbors needed for cell birth
  - `deathLimit`: Neighbors needed to stay alive
  - `iterations`: Simulation steps
- [ ] Implement `generateCave(width, height, params)`:
  - Initialize random grid
  - Apply cellular automata rules
  - Return tilemap data
- [ ] Add `smoothing` pass (remove single-tile islands)
- [ ] Add `connectRegions` (ensure all caves connected)

#### Task 1.3: Implement Wave Function Collapse
**File:** `src/algorithms/waveFunctionCollapse.ts` (NEW)
- [ ] Implement WFC algorithm for constraint-based generation
- [ ] Parameters:
  - `tileset`: Available tiles with adjacency rules
  - `constraints`: Which tiles can be neighbors
  - `width`, `height`: Output dimensions
- [ ] Implement `collapse(width, height, tileset, constraints)`:
  - Initialize superposition grid
  - Iteratively collapse lowest entropy cells
  - Propagate constraints
  - Backtrack on contradictions
- [ ] Add preset constraint sets:
  - "Platform edges" (grass connects to dirt, not water)
  - "Wall corners" (walls form proper corners)
- [ ] Handle failure gracefully (restart with different seed)

#### Task 1.4: Implement Random Walk
**File:** `src/algorithms/randomWalk.ts` (NEW)
- [ ] Implement path/river generator
- [ ] Parameters:
  - `steps`: Length of walk
  - `turnProbability`: Chance to change direction
  - `branchProbability`: Chance to split path
  - `width`: Path thickness
- [ ] Implement `generatePath(startX, startY, params)`:
  - Random walk with occasional turns
  - Can branch into multiple paths
  - Returns list of tile coordinates
- [ ] Add `smoothPath` option (Catmull-Rom spline)
- [ ] Add `widthVariation` (organic-looking paths)

---

### **Task Group 2: AI Tool Enhancements (Day 1 Afternoon)**

#### Task 2.1: Enhance Generate Tilemap Tool
**File:** `src/ai/tools/tilemapTools.ts` (EDIT)
- [ ] Update `generateTilemap` tool with new algorithms:
  - Add `perlin-noise` algorithm
  - Add `cellular-automata` algorithm
  - Add `wave-function-collapse` algorithm
  - Add `random-walk` algorithm
- [ ] Add algorithm-specific parameters to tool schema
- [ ] Implement smart parameter defaults:
  - Detect game type → suggest appropriate algorithm
  - Detect canvas size → adjust scale parameters
- [ ] Add `preview` mode (generate small sample first)
- [ ] Add `layered` generation (terrain + decoration layers)

#### Task 2.2: Create Tilemap Analysis Tool
**File:** `src/ai/tools/analysisTools.ts` (NEW)
- [ ] Implement `analyzeTilemap` tool:
  - Parameters: None (analyzes current tilemap)
  - Returns:
    - Tile type distribution (% water, grass, etc.)
    - Connected regions count
    - Empty spaces
    - Suggestions for improvement
- [ ] Implement `detectPatterns` tool:
  - Identifies common game patterns:
    - Platform levels (horizontal layers)
    - Dungeons (rooms + corridors)
    - Open world (large connected space)
  - Returns detected pattern + confidence
- [ ] Implement `suggestImprovement` tool:
  - Analyzes current layout
  - Suggests additions: "Add more platforms", "Connect isolated areas"

#### Task 2.3: Create Asset Recommendation Tool
**File:** `src/ai/tools/assetTools.ts` (NEW)
- [ ] Implement `suggestAssets` tool:
  - Parameters: `context` (what user is building)
  - Returns: Recommended assets from library
  - Logic:
    - If building platformer → suggest platform sprites
    - If building dungeon → suggest wall/floor tiles
    - If has grass → suggest trees, flowers
- [ ] Implement `findSimilarAssets` tool:
  - Parameters: `assetId`
  - Uses basic color/dimension similarity
  - Returns: Assets that might work together
- [ ] Implement `suggestTileVariants` tool:
  - Analyzes tilemap
  - Suggests which tiles need more variants
  - Example: "Your grass tile has no corner variants"

---

### **Task Group 3: Game Type Detection (Day 1 Evening)**

#### Task 3.1: Create Pattern Detection Service
**File:** `src/services/gameTypeDetection.ts` (NEW)
- [ ] Implement `detectGameType(canvas)`:
  - Analyzes canvas objects and tilemap
  - Returns: Game type + confidence score
  - Detection rules:
    - Platformer: Horizontal platforms, gravity-implied layout
    - Top-down: Square/diamond grid, walls
    - Puzzle: Regular grid, few object types
    - Shooter: Projectile objects, enemies
- [ ] Implement `getGameTypeFeatures(type)`:
  - Returns common features for each game type
  - Used to suggest appropriate tools/assets
- [ ] Add confidence threshold (min 70% to suggest)

#### Task 3.2: Create Context Enhancement
**File:** `src/ai/contextBuilder.ts` (EDIT)
- [ ] Add game type to AI context:
  - Detect game type on each AI request
  - Include in system prompt
  - Adjust tool suggestions based on type
- [ ] Add asset inventory to context:
  - List available sprite sheets (by name)
  - List available animations
  - List custom tilesets
- [ ] Add performance stats:
  - Current FPS
  - Object count
  - Render time
  - Flag performance warnings

---

### **Task Group 4: Animation Intelligence (Day 2 Morning)**

#### Task 4.1: Create Animation Analyzer
**File:** `src/utils/animationAnalyzer.ts` (NEW)
- [ ] Implement `analyzeFrames(frames)`:
  - Detect frame dimensions
  - Detect frame count
  - Suggest FPS based on frame count (walk cycle: 8-12fps, idle: 4-6fps)
- [ ] Implement `detectAnimationType(frames)`:
  - Analyze frame changes
  - Detect: idle (small changes), walk (cyclical), attack (fast burst)
  - Return suggested type
- [ ] Implement `suggestMissingFrames(animation)`:
  - Check if animation is complete
  - Suggest: "Add return-to-idle frames", "Add anticipation frame"

#### Task 4.2: Create Auto-Animation Tool
**File:** `src/ai/tools/animationTools.ts` (EDIT)
- [ ] Implement `autoCreateAnimation` tool:
  - Parameters: `spriteSheetId`, `animationType`, `frameCount`
  - Auto-detects frame layout in sprite sheet
  - Creates animation with sensible defaults:
    - Walk cycle: 12fps, looping
    - Idle: 6fps, looping
    - Attack: 24fps, no loop
  - Returns animation ID
- [ ] Implement `suggestAnimationParams` tool:
  - Analyzes sprite sheet
  - Returns recommended: fps, frame order, loop setting

---

### **Task Group 5: Performance Optimization (Day 2 Afternoon)**

#### Task 5.1: Create Performance Profiler
**File:** `src/services/performanceProfiler.ts` (NEW)
- [ ] Implement `profileCanvas()`:
  - Measure render time per frame
  - Count objects by type
  - Calculate draw calls
  - Measure Firebase sync latency
  - Return performance report
- [ ] Implement `identifyBottlenecks()`:
  - Returns list of issues:
    - Too many objects (>1000)
    - Large sprites without caching
    - Excessive Firebase listeners
    - Unoptimized animations
- [ ] Add performance benchmarking (compare to standards)

#### Task 5.2: Create Optimization Tool
**File:** `src/ai/tools/optimizationTools.ts` (NEW)
- [ ] Implement `analyzePerformance` tool:
  - Runs performance profiler
  - Returns human-readable report
  - Suggests specific optimizations
- [ ] Implement `autoOptimize` tool:
  - Parameters: `aggressive` (boolean)
  - Automatic optimizations:
    - Enable viewport culling
    - Cache static objects
    - Batch Firebase writes
    - Reduce animation complexity
  - Returns: Changes made + performance delta
- [ ] Implement `estimateExportSize` tool:
  - Calculates final export file size
  - Warns if too large for target engine
  - Suggests compression options

---

### **Task Group 6: Smart Export Guidance (Day 2 Evening)**

#### Task 6.1: Create Export Recommender
**File:** `src/services/exportRecommender.ts` (NEW)
- [ ] Implement `checkExportCompatibility(canvas, target)`:
  - Checks if all features are supported by target engine
  - Returns: Compatibility score + warnings
  - Warns about:
    - Unsupported features
    - Performance concerns
    - Manual steps needed after import
- [ ] Implement `suggestExportOptions(canvas, target)`:
  - Returns optimal export settings for canvas
  - Example: "Use 32 pixels per unit for this sprite size"

#### Task 6.2: Create Export Guidance Tool
**File:** `src/ai/tools/exportTools.ts` (EDIT)
- [ ] Implement `recommendExport` tool:
  - No parameters (analyzes current canvas)
  - Returns:
    - Best export target(s)
    - Reasoning for recommendation
    - Expected compatibility issues
    - Next steps
- [ ] Implement `checkExportReadiness` tool:
  - Validates canvas is ready for export
  - Returns checklist:
    - ✓ All assets referenced exist
    - ✗ Some animations missing frames
    - ✓ Tilemap is valid
    - ⚠ Canvas is large, export will be slow
- [ ] Update `exportCanvas` tool:
  - Add pre-export validation
  - Show compatibility warnings
  - Suggest fixes before exporting

---

### **Task Group 7: Intelligent Prompting (Day 3 Morning)**

#### Task 7.1: Create Prompt Templates
**File:** `src/ai/promptTemplates.ts` (NEW)
- [ ] Define templates for common game dev tasks:
  - `platformer_level`: "Create a platformer level with {theme}"
  - `dungeon_generator`: "Generate a dungeon with {rooms} rooms"
  - `terrain_painter`: "Paint terrain using {algorithm}"
  - `sprite_animator`: "Create {type} animation for {sprite}"
- [ ] Each template includes:
  - User-facing description
  - Parameter placeholders
  - Default values
  - Expected tool calls
- [ ] Implement `expandTemplate(template, params)`:
  - Fills template with parameters
  - Returns complete prompt for AI

#### Task 7.2: Create Smart Suggestions System
**File:** `src/components/ai/SmartSuggestions.tsx` (NEW)
- [ ] Context-aware suggestion chips:
  - Detect: Empty canvas → "Generate a tilemap"
  - Detect: Tilemap exists → "Add platforms" or "Generate decorations"
  - Detect: Sprites exist → "Create animations"
  - Detect: Many objects → "Arrange in grid" or "Optimize performance"
- [ ] Click suggestion → fills prompt input
- [ ] Show 3-5 suggestions max (most relevant)
- [ ] Update suggestions when canvas changes

#### Task 7.3: Create AI Learning from Usage
**File:** `src/services/aiUsageTracking.ts` (NEW)
- [ ] Track successful AI commands (localStorage)
- [ ] Track user corrections/edits after AI actions
- [ ] Implement `getFrequentCommands()`:
  - Returns user's most-used commands
  - Use for personalized suggestions
- [ ] Implement `learnFromFeedback()`:
  - If user undoes AI action → reduce priority of that pattern
  - If user repeats command → increase priority
- [ ] Privacy-first: All data stored locally, never sent to server

---

### **Task Group 8: Advanced Tilemap Features (Day 3 Afternoon)**

#### Task 8.1: Implement Multi-Layer Tilemaps
**File:** `src/services/tilemap.ts` (EDIT)
- [ ] Add layer support to tilemap data model:
  ```typescript
  tilemaps/{canvasId}/layers/{layerId}/
    - name: string
    - zIndex: number
    - visible: boolean
    - tiles/{x_y}/...
  ```
- [ ] Implement `createLayer(canvasId, name)`:
  - Creates new layer
  - Assigns z-index
  - Returns layer ID
- [ ] Implement `setTileOnLayer(canvasId, layerId, x, y, tile)`
- [ ] Update rendering to support layers

#### Task 8.2: Create Layer Management UI
**File:** `src/components/tilemap/LayerPanel.tsx` (NEW)
- [ ] Show list of layers (like Photoshop)
- [ ] Each layer shows:
  - Name (editable)
  - Visibility toggle (eye icon)
  - Lock toggle
  - Opacity slider
- [ ] Drag to reorder layers (changes z-index)
- [ ] Active layer highlighted
- [ ] "Add Layer" button
- [ ] Context menu: Duplicate, Merge, Delete

#### Task 8.3: Implement Tilemap Decoration Layer
**File:** `src/ai/tools/tilemapTools.ts` (EDIT)
- [ ] Implement `addDecorationLayer` tool:
  - Parameters: `baseLayer`, `decorationType` (trees|rocks|flowers|grass-tufts)
  - Analyzes base terrain
  - Places decorations intelligently:
    - Trees on grass, not water
    - Rocks near mountains
    - Flowers in open areas
  - Uses noise for natural distribution
  - Creates separate decoration layer
- [ ] Add density parameter (sparse to dense)

---

### **Task Group 9: Game Design Patterns (Day 3 Evening - Day 4 Morning)**

#### Task 9.1: Create Pattern Library
**File:** `src/gamePatterns/patterns.ts` (NEW)
- [ ] Define common patterns:
  - `platformer_level`: Platforms, gaps, enemies, collectibles
  - `top_down_room`: Walls, entrance, exit, obstacles
  - `puzzle_grid`: Regular grid, interactable objects
  - `boss_arena`: Open space, hazards, spawn points
- [ ] Each pattern includes:
  - Description
  - Required elements
  - Layout constraints
  - Recommended tile types
  - Example generation function

#### Task 9.2: Implement Pattern Generation
**File:** `src/ai/tools/patternTools.ts` (NEW)
- [ ] Implement `generatePattern` tool:
  - Parameters: `patternType`, `size`, `difficulty`
  - Uses pattern library
  - Generates complete scene
  - Returns: Objects placed, tilemap generated
- [ ] Pattern-specific implementations:
  - **Platformer level:**
    - Generate ground layer
    - Add platforms at varying heights
    - Place gaps (jumpable distances)
    - Add enemies on platforms
    - Place collectibles
  - **Dungeon room:**
    - Generate walls (cellular automata)
    - Add doors (2-4 per room)
    - Place obstacles
    - Add enemies
    - Place treasure
  - **Boss arena:**
    - Large open circle/rectangle
    - Add hazards (pits, spikes)
    - Define spawn points
    - Add cover objects

#### Task 9.3: Create Pattern Recognition Tool
**File:** `src/ai/tools/patternTools.ts` (EDIT)
- [ ] Implement `identifyPattern` tool:
  - Analyzes current canvas
  - Attempts to match to known patterns
  - Returns: Pattern type + confidence + deviations
  - Suggests: "This looks like a platformer level, add some collectibles?"

---

### **Task Group 10: Natural Language Refinement (Day 4 Afternoon)**

#### Task 10.1: Enhance System Prompt
**File:** `src/ai/systemPrompt.ts` (NEW)
- [ ] Create comprehensive system prompt:
  - Role: "You are an expert game developer assistant"
  - Capabilities: List all tools with descriptions
  - Context: Include game type, assets, performance
  - Constraints: Don't break existing content, confirm destructive actions
  - Personality: Helpful, suggests improvements, asks clarifying questions
- [ ] Add game dev domain knowledge:
  - Common game design terms
  - Platform-specific considerations
  - Performance best practices
- [ ] Add example conversations:
  - Good: Multi-turn planning → execution → refinement
  - Bad: Single massive command with no clarification

#### Task 10.2: Implement Multi-Turn Planning
**File:** `src/hooks/useAIChat.ts` (EDIT)
- [ ] Add conversation memory (last 10 messages)
- [ ] Enable AI to ask clarifying questions:
  - "What theme? Forest, desert, or ice?"
  - "How many platforms? 10-20 is typical"
  - "Should I place enemies? If so, what difficulty?"
- [ ] Implement planning phase:
  - User: "Create a level"
  - AI: "I'll create a platformer level. Let me plan this out..."
  - AI: (internally) Decides on algorithm, parameters, layers
  - AI: "Here's my plan: [summarize]. Should I proceed?"
  - User: "Yes" or "Change X"
  - AI: Executes plan

#### Task 10.3: Add Undo/Modify Capability
**File:** `src/ai/tools/metaTools.ts` (NEW)
- [ ] Implement `undoLastAction` tool:
  - Reverts last AI command
  - Works with command history
- [ ] Implement `modifyLastAction` tool:
  - Parameters: `changes` (what to change about last action)
  - Re-executes last command with modifications
  - Example: "Make it bigger" → increases size parameter
- [ ] Add to AI context: Last action details (so AI can reference it)

---

### **Task Group 11: Advanced Context Awareness**

#### Task 11.1: Create Scene Understanding
**File:** `src/ai/sceneUnderstanding.ts` (NEW)
- [ ] Implement `describeScene(canvas)`:
  - Returns natural language description:
    - "A partially completed platformer level with grass terrain"
    - "An empty canvas ready for content"
    - "A top-down dungeon with 3 connected rooms"
  - Used in AI context
- [ ] Implement `identifyIncomplete()`:
  - Detects missing elements:
    - "No player spawn point"
    - "Level has no exit"
    - "Isolated platforms (unreachable)"
  - Returns suggestions to complete
- [ ] Implement `estimatePlaytime()`:
  - For platformer: Count platforms, estimate jumps
  - For dungeon: Count rooms, estimate exploration
  - Returns: "~2-3 minutes of gameplay"

#### Task 11.2: Add User Intent Detection
**File:** `src/ai/intentDetection.ts` (NEW)
- [ ] Implement `detectIntent(message)`:
  - Classifies user intent:
    - `create`: Making new content
    - `modify`: Changing existing content
    - `analyze`: Getting information
    - `export`: Preparing for export
    - `learn`: Asking questions
  - Returns intent + confidence
  - Used to route to appropriate tools
- [ ] Add ambiguity handling:
  - If confidence < 70%, ask for clarification
  - Suggest: "Did you mean A or B?"

---

### **Task Group 12: Testing & Documentation**

#### Task 12.1: Unit Tests
**Files to test:**
- [ ] All algorithm files (`perlinNoise.ts`, `cellularAutomata.ts`, etc.)
  - Test with known seeds → verify reproducible results
  - Test edge cases (0x0 map, 1x1 map, 10000x10000 map)
- [ ] `gameTypeDetection.ts` - pattern recognition accuracy
- [ ] `animationAnalyzer.ts` - frame detection logic
- [ ] `performanceProfiler.ts` - metric calculations

#### Task 12.2: Integration Tests
- [ ] Test: AI generates terrain → verify auto-tiling applied
- [ ] Test: AI creates animation → verify playback works
- [ ] Test: AI optimizes canvas → verify performance improves
- [ ] Test: Multi-turn conversation → verify context maintained
- [ ] Test: Pattern generation → verify valid game layout

#### Task 12.3: Algorithm Validation Tests
- [ ] Perlin noise: Visual inspection (should look natural)
- [ ] Cellular automata: Verify caves are navigable
- [ ] WFC: Verify no constraint violations
- [ ] Random walk: Verify paths are connected

#### Task 12.4: AI Quality Tests
- [ ] Test 50 common commands → measure success rate (target: >90%)
- [ ] Test ambiguous commands → verify asks for clarification
- [ ] Test destructive commands → verify requires confirmation
- [ ] Test context awareness → verify uses canvas state correctly

#### Task 12.5: Documentation
**File:** `docs/AI_GAME_AWARE.md` (NEW)
- [ ] Document all procedural algorithms with examples
- [ ] Document game type detection logic
- [ ] Document pattern library (with visual examples)
- [ ] Provide 50+ example commands for game development
- [ ] Include best practices for AI-assisted game dev

**File:** `docs/PROCEDURAL_GENERATION.md` (NEW)
- [ ] Explain each algorithm in detail:
  - How it works
  - When to use it
  - Parameters and effects
  - Examples with screenshots
- [ ] Provide algorithm comparison guide
- [ ] Include performance considerations
- [ ] Link to academic papers / resources

---

## Acceptance Criteria

### Procedural Generation
- [ ] All 4 algorithms (Perlin, Cellular, WFC, Random Walk) work correctly
- [ ] Generated tilemaps look natural and playable
- [ ] Auto-tiling integrates seamlessly
- [ ] Performance is acceptable (1000x1000 map in <5s)

### AI Intelligence
- [ ] AI correctly identifies game types (>80% accuracy)
- [ ] AI suggests contextually appropriate actions
- [ ] AI detects incomplete scenes and suggests fixes
- [ ] AI provides useful performance recommendations

### Animation Intelligence
- [ ] Animation analyzer detects frame layouts correctly
- [ ] Suggested FPS values are sensible
- [ ] Auto-created animations play properly

### Export Guidance
- [ ] Export recommendations match canvas content
- [ ] Compatibility checks catch real issues
- [ ] Guidance helps users succeed in target engine

### User Experience
- [ ] Smart suggestions are helpful, not annoying
- [ ] Multi-turn conversations feel natural
- [ ] AI asks good clarifying questions
- [ ] Performance optimizations are noticeable

### Code Quality
- [ ] All algorithms have comprehensive tests
- [ ] AI tools handle errors gracefully
- [ ] Context building is efficient (<100ms)
- [ ] No memory leaks in long conversations

---

## Files Summary

### New Files (25+)
**Algorithms:**
1. `src/algorithms/perlinNoise.ts`
2. `src/algorithms/cellularAutomata.ts`
3. `src/algorithms/waveFunctionCollapse.ts`
4. `src/algorithms/randomWalk.ts`

**Services:**
5. `src/services/gameTypeDetection.ts`
6. `src/services/performanceProfiler.ts`
7. `src/services/exportRecommender.ts`
8. `src/services/aiUsageTracking.ts`

**Utils:**
9. `src/utils/animationAnalyzer.ts`

**AI Components:**
10. `src/ai/systemPrompt.ts`
11. `src/ai/promptTemplates.ts`
12. `src/ai/sceneUnderstanding.ts`
13. `src/ai/intentDetection.ts`

**AI Tools:**
14. `src/ai/tools/analysisTools.ts`
15. `src/ai/tools/assetTools.ts`
16. `src/ai/tools/optimizationTools.ts`
17. `src/ai/tools/patternTools.ts`
18. `src/ai/tools/metaTools.ts`

**Game Patterns:**
19. `src/gamePatterns/patterns.ts`

**Components:**
20. `src/components/ai/SmartSuggestions.tsx`
21. `src/components/tilemap/LayerPanel.tsx`

**Documentation:**
22. `docs/AI_GAME_AWARE.md`
23. `docs/PROCEDURAL_GENERATION.md`

### Edited Files (6)
1. `src/ai/tools/tilemapTools.ts`
2. `src/ai/tools/animationTools.ts`
3. `src/ai/tools/exportTools.ts`
4. `src/ai/contextBuilder.ts`
5. `src/hooks/useAIChat.ts`
6. `src/services/tilemap.ts`

---

## Dependencies

Add to `package.json`:
```json
{
  "dependencies": {
    "simplex-noise": "^4.0.1"  // For Perlin noise implementation
  }
}
```

---

## Performance Considerations

### Algorithm Optimization
- **Perlin Noise:** Pre-compute gradient vectors, cache results
- **Cellular Automata:** Use typed arrays for speed
- **WFC:** Implement early termination on contradiction
- **Random Walk:** Limit max iterations

### AI Context Size
- Limit canvas description to 2000 tokens
- Summarize large asset libraries
- Compress tilemap representation (run-length encoding)

### Caching Strategy
- Cache game type detection results (invalidate on canvas change)
- Cache performance profiles (update every 5 seconds)
- Cache asset recommendations (update on library change)

---

## Risk Mitigation

### Risk: AI Generates Unplayable Levels
**Mitigation:** Add validation checks (connected regions, reachable goals), provide "regenerate" option, allow manual fixing

### Risk: Procedural Algorithms Too Slow
**Mitigation:** Run in web worker, show progress bar, add cancellation, optimize hot paths

### Risk: AI Context Too Large
**Mitigation:** Implement summarization, remove old conversation history, compress representations

### Risk: Pattern Detection False Positives
**Mitigation:** Require confidence >80%, provide user override, learn from corrections

---

## Future Enhancements (Post-Phase 4)

1. **AI Training on User Projects:** Learn common patterns from user's past work
2. **Community Pattern Library:** Share/import patterns from other users
3. **Advanced Physics:** More realistic simulation in preview mode
4. **Sound Integration:** Audio triggers, background music
5. **Scripting Support:** Simple behavior scripts for objects
6. **Multiplayer Testing:** Preview with multiple players
7. **Version Control:** Git-like branching for canvas iterations

---

## Success Metrics

- **AI Command Success Rate:** >90% (user doesn't immediately undo)
- **Generation Time:** Typical tilemap in <2 seconds
- **Pattern Detection Accuracy:** >80%
- **User Satisfaction:** Measured via surveys/feedback
- **Export Success Rate:** >95% of exports import successfully
- **Performance Improvement:** Optimization tool improves FPS by >20%

---

## Next Steps After PR-32

✅ **Complete Auto-Tiling + AI Roadmap Integration**
- All phases delivered
- Professional game dev platform ready
- AI-powered workflow functional

**Potential Phase 5 (Future):**
- Multiplayer game testing
- Advanced scripting/behavior system
- Community asset marketplace
- Real-time collaboration enhancements
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/App.css">
/* App-specific styles */

#root {
  width: 100%;
  height: 100vh;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
</file>

<file path="src/App.tsx">
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { useAuth } from './hooks/useAuth'
import { useEffect } from 'react'
import { autoMigrateIfNeeded } from './utils/migration/migrationScript'
import CanvasPage from './pages/CanvasPage'
import Login from './components/Login'
import ProtectedRoute from './components/ProtectedRoute'
import './App.css'

/**
 * App Component with React Router (PR-22)
 * Main routing configuration - Landing page is the canvas
 */
function App() {
  const { user } = useAuth()

  // Auto-migrate existing data on first login (PR-22)
  useEffect(() => {
    if (user?.uid) {
      autoMigrateIfNeeded(user.uid)
    }
  }, [user?.uid])

  return (
    <BrowserRouter>
      <Routes>
        {/* Login page */}
        <Route
          path="/login"
          element={
            user ? <Navigate to="/" replace /> : <Login />
          }
        />

        {/* Landing page - Direct to canvas (protected) */}
        <Route
          path="/"
          element={
            <ProtectedRoute>
              <CanvasPage />
            </ProtectedRoute>
          }
        />

        {/* Canvas page with dynamic ID (protected) */}
        <Route
          path="/canvas/:canvasId"
          element={
            <ProtectedRoute>
              <CanvasPage />
            </ProtectedRoute>
          }
        />

        {/* Catch-all redirect to root */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  )
}

export default App
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/ai/MessageBubble.tsx">
/**
 * Message Bubble Component
 * Displays AI chat messages
 * PR-30: Task 5.1
 */

import React from 'react';
import type { ChatMessage } from '../../hooks/useAIChat';

interface MessageBubbleProps {
  message: ChatMessage;
}

export const MessageBubble: React.FC<MessageBubbleProps> = ({ message }) => {
  const isUser = message.role === 'user';
  const isError = message.role === 'error';

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-2`}>
      <div
        className={`max-w-[85%] px-2.5 py-1.5 rounded-lg ${
          isUser
            ? 'bg-blue-500 text-white'
            : isError
            ? 'bg-red-100 text-red-800 border border-red-300'
            : 'bg-gray-100 text-gray-800'
        }`}
      >
        {/* Message content */}
        <div className="text-xs whitespace-pre-wrap break-words">
          {message.content}
        </div>

        {/* Tool results indicator */}
        {message.toolResults && message.toolResults.length > 0 && (
          <div className="mt-1 pt-1 border-t border-gray-300 text-[10px] opacity-75">
            ✓ {message.toolResults.length} operation(s)
          </div>
        )}

        {/* Timestamp */}
        <div className={`text-[10px] mt-0.5 ${isUser ? 'text-blue-100' : 'text-gray-500'}`}>
          {new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/canvas/ShapeCanvas.tsx">
import { useRef, useState, useCallback, useEffect } from 'react'
import { Stage, Layer, Line as KonvaLine } from 'react-konva'
import Konva from 'konva'
import type { ViewportTransform, ToolType, Shape } from '../../types/canvas'
import { DEFAULT_CANVAS_BOUNDS } from '../../types/canvas'
import type { SelectionBox as SelectionBoxType } from '../../types/selection'
import {
  createInitialSelectionBox,
  shapeIntersectsSelectionBox,
} from '../../types/selection'
import { useAuth } from '../../hooks/useAuth'
import { usePresence } from '../../hooks/usePresence'
import { useCanvas } from '../../hooks/useCanvas'
import { useGroups } from '../../hooks/useGroups'
import { useCanvasViewport } from '../../hooks/useCanvasViewport'
import { useShapeKeyboardShortcuts } from '../../hooks/useShapeKeyboardShortcuts'
import { simplifyPath } from '../../utils/canvas/pathHelpers'
import Cursor from '../Cursor'
import { SelectionBox } from '../shapes/SelectionBox'
import { QuickActionsPopup } from '../QuickActionsPopup'
import { TextEditor } from '../TextEditor'
import { ContextMenu } from '../ui/ContextMenu'
import { AlignmentToolbar } from '../toolbar/AlignmentToolbar'
import { ShapeRenderer } from './ShapeRenderer'

const CANVAS_BOUNDS = DEFAULT_CANVAS_BOUNDS

interface ShapeCanvasProps {
  selectedTool: ToolType
  onShapeSelect: (id: string | null) => void
  deleteTriggered?: number
  onUndoRedoChange?: (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => void
  canvasId: string
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
  onZoomControlsReady?: (zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => void
  snapToGrid?: boolean
  onColorSamplingReady?: (fn: (callback: (color: string) => void) => void) => void
}

export default function ShapeCanvas({
  selectedTool,
  onShapeSelect,
  deleteTriggered,
  onUndoRedoChange,
  canvasId,
  onViewportChange,
  onZoomChange,
  onZoomControlsReady,
  snapToGrid: snapToGridProp = false,
  onColorSamplingReady,
}: ShapeCanvasProps) {
  const stageRef = useRef<Konva.Stage>(null)
  const isDraggingShapeRef = useRef(false)
  const dragStartPosRef = useRef<{ x: number; y: number } | null>(null)
  const isTransformingShapeRef = useRef(false)
  const lastMouseDownWasOnShapeRef = useRef(false)
  
  // UI State
  const [textInput, setTextInput] = useState<{ x: number; y: number; value: string } | null>(null)
  const [selectionBox, setSelectionBox] = useState<SelectionBoxType>(createInitialSelectionBox())
  const [isDrawingSelection, setIsDrawingSelection] = useState(false)
  const [isDrawingPath, setIsDrawingPath] = useState(false)
  const [currentPathPoints, setCurrentPathPoints] = useState<number[]>([])
  const [isDrawingLine, setIsDrawingLine] = useState(false)
  const [lineStartPoint, setLineStartPoint] = useState<{ x: number; y: number } | null>(null)
  const [linePreviewEnd, setLinePreviewEnd] = useState<{ x: number; y: number } | null>(null)
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number; visible: boolean }>({ x: 0, y: 0, visible: false })
  const [isColorSamplingMode, setIsColorSamplingMode] = useState(false)
  const [colorSampleCallback, setColorSampleCallback] = useState<((color: string) => void) | null>(null)
  const [editingText, setEditingText] = useState<{
    id: string
    text: string
    screenX: number
    screenY: number
    width: number
    shape: Shape
  } | null>(null)
  const [showQuickActions, setShowQuickActions] = useState(false)
  
  const snapToGrid = snapToGridProp
  const SNAP_GRID_SIZE = 20
  
  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight

  // Viewport hook
  const {
    viewport,
    handleWheel: baseHandleWheel,
    handleDragEnd: baseHandleDragEnd,
    handleZoomIn,
    handleZoomOut,
    handleZoomReset,
    handleZoomFit,
  } = useCanvasViewport({
    containerWidth,
    containerHeight,
    onViewportChange,
    onZoomChange,
  })

  // Canvas hooks
  const { user } = useAuth()
  const { otherUsers, updateCursorPosition, updateSelection } = usePresence({
    userId: user?.uid || '',
    userName: user?.displayName || user?.email || 'Anonymous',
    canvasId: canvasId,
  })
  
  const {
    shapes,
    selectedId,
    selectedIds,
    addShape,
    addText,
    updateShape,
    deleteShape,
    setSelection,
    toggleSelection,
    selectMultiple,
    clearSelection,
    selectAll,
    bulkMove,
    bulkDelete,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    canUndo,
    canRedo,
    addLine,
    addPolygon,
    addStar,
    addRoundedRect,
    addPath,
    bringToFront,
    sendToBack,
    bringForward,
    sendBackward,
    sortShapesByZIndex,
    alignSelected,
    distributeSelectedHorizontally,
    distributeSelectedVertically,
    centerSelectedInCanvas,
  } = useCanvas({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  const {
    groups,
    createGroup,
    ungroup,
    isShapeInGroup,
    calculateBounds,
  } = useGroups({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  // Helper functions
  const rgbToHex = (r: number, g: number, b: number): string => {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16).toUpperCase()
      return hex.length === 1 ? '0' + hex : hex
    }).join('')
  }
  
  const snapToGridCoord = useCallback((coord: number): number => {
    if (!snapToGrid) return coord
    return Math.round(coord / SNAP_GRID_SIZE) * SNAP_GRID_SIZE
  }, [snapToGrid])
  
  const sampleColorFromStage = (x: number, y: number) => {
    const stage = stageRef.current
    if (!stage) return null
    
    const layers = stage.getLayers()
    if (layers.length < 2) return null
    
    const layer = layers[1]
    const canvas = layer.getCanvas()._canvas as HTMLCanvasElement
    const ctx = canvas.getContext('2d')
    
    if (!ctx) return null
    
    try {
      const pixelData = ctx.getImageData(x, y, 1, 1).data
      const hex = rgbToHex(pixelData[0], pixelData[1], pixelData[2])
      const alpha = Math.round((pixelData[3] / 255) * 255).toString(16).padStart(2, '0').toUpperCase()
      return hex + alpha
    } catch (error) {
      console.error('Error sampling color:', error)
      return null
    }
  }
  
  const enableColorSampling = useCallback((callback: (color: string) => void) => {
    setIsColorSamplingMode(true)
    setColorSampleCallback(() => callback)
  }, [])
  
  const cancelColorSampling = () => {
    setIsColorSamplingMode(false)
    setColorSampleCallback(null)
  }
  
  const handleTextDoubleClick = (shape: Shape) => {
    const stage = stageRef.current
    if (!stage) return
    
    const stageBox = stage.container().getBoundingClientRect()
    const screenX = stageBox.left + shape.x * viewport.scale + viewport.x
    const screenY = stageBox.top + shape.y * viewport.scale + viewport.y
    
    setEditingText({
      id: shape.id,
      text: shape.text || '',
      screenX,
      screenY,
      width: shape.width * viewport.scale,
      shape,
    })
  }
  
  const handleTextSave = (newText: string) => {
    if (editingText) {
      updateShape(editingText.id, { text: newText })
    }
    setEditingText(null)
  }
  
  const handleTextEditorCancel = () => {
    setEditingText(null)
  }

  // Keyboard shortcuts hook
  useShapeKeyboardShortcuts({
    selectedIds,
    groups,
    canUndo,
    canRedo,
    isColorSamplingMode,
    bulkDelete,
    clearSelection,
    selectAll,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    createGroup,
    ungroup,
    cancelColorSampling,
  })

  // Effects
  useEffect(() => {
    const selectionArray = Array.from(selectedIds)
    updateSelection(selectionArray.length > 0 ? selectionArray : null)
    onShapeSelect(selectedId)
  }, [selectedIds, selectedId, updateSelection, onShapeSelect])

  useEffect(() => {
    if (onUndoRedoChange) {
      onUndoRedoChange(canUndo, canRedo, undo, redo)
    }
  }, [canUndo, canRedo, undo, redo, onUndoRedoChange])
  
  // Expose zoom controls - only on mount to avoid render-during-render
  useEffect(() => {
    if (onZoomControlsReady) {
      onZoomControlsReady(handleZoomIn, handleZoomOut, handleZoomReset, handleZoomFit)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Expose color sampling - only on mount to avoid render-during-render
  useEffect(() => {
    if (onColorSamplingReady) {
      onColorSamplingReady(enableColorSampling)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    if (deleteTriggered && deleteTriggered > 0) {
      if (selectedIds.size > 0) {
        bulkDelete()
      } else if (selectedId) {
        deleteShape(selectedId)
      }
    }
  }, [deleteTriggered, selectedId, selectedIds, deleteShape, bulkDelete])

  useEffect(() => {
    if (selectedTool !== 'line' && isDrawingLine) {
      setIsDrawingLine(false)
      setLineStartPoint(null)
      setLinePreviewEnd(null)
    }
  }, [selectedTool, isDrawingLine])

  useEffect(() => {
    if (selectedIds.size === 0) {
      setShowQuickActions(false)
    }
  }, [selectedIds])

  // Mouse handlers
  const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
    const stage = stageRef.current
    if (stage) {
      baseHandleWheel(e, stage)
    }
  }, [baseHandleWheel])

  const handleStageMouseDown = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      const stage = stageRef.current
      if (!stage) return

      const pointer = stage.getPointerPosition()
      if (!pointer) return

      if (isColorSamplingMode && colorSampleCallback) {
        const sampledColor = sampleColorFromStage(pointer.x, pointer.y)
        if (sampledColor) {
          colorSampleCallback(sampledColor)
        }
        cancelColorSampling()
        return
      }
      
      lastMouseDownWasOnShapeRef.current = e.target !== stage
      if (e.target !== stage) return

      const canvasX = (pointer.x - viewport.x) / viewport.scale
      const canvasY = (pointer.y - viewport.y) / viewport.scale

      if (selectedTool === 'line') {
        if (!isDrawingLine) {
          setIsDrawingLine(true)
          setLineStartPoint({ x: snapToGridCoord(canvasX), y: snapToGridCoord(canvasY) })
          setLinePreviewEnd({ x: snapToGridCoord(canvasX), y: snapToGridCoord(canvasY) })
          clearSelection()
          return
        } else {
          if (lineStartPoint) {
            addLine(lineStartPoint.x, lineStartPoint.y, snapToGridCoord(canvasX), snapToGridCoord(canvasY))
            setIsDrawingLine(false)
            setLineStartPoint(null)
            setLinePreviewEnd(null)
          }
          return
        }
      }
      
      if (selectedTool === 'pencil' || selectedTool === 'pen') {
        setIsDrawingPath(true)
        setCurrentPathPoints([canvasX, canvasY])
        clearSelection()
        return
      }

      if (selectedTool === 'select') {
        setIsDrawingSelection(true)
        setSelectionBox({
          startX: canvasX,
          startY: canvasY,
          currentX: canvasX,
          currentY: canvasY,
          visible: true,
        })
      }
    },
    [selectedTool, viewport, clearSelection, isColorSamplingMode, colorSampleCallback, cancelColorSampling, snapToGridCoord, isDrawingLine, lineStartPoint, addLine]
  )

  const handleStageMouseMove = useCallback(
    (_e: Konva.KonvaEventObject<MouseEvent>) => {
      const stage = stageRef.current
      if (!stage) return

      const pointer = stage.getPointerPosition()
      if (!pointer) return

      const canvasX = (pointer.x - viewport.x) / viewport.scale
      const canvasY = (pointer.y - viewport.y) / viewport.scale

      if (isDrawingLine && selectedTool === 'line' && lineStartPoint) {
        setLinePreviewEnd({ x: canvasX, y: canvasY })
      }
      
      if (isDrawingPath && (selectedTool === 'pencil' || selectedTool === 'pen')) {
        setCurrentPathPoints((prev) => {
          const lastX = prev[prev.length - 2]
          const lastY = prev[prev.length - 1]
          const distance = Math.sqrt((canvasX - lastX) ** 2 + (canvasY - lastY) ** 2)
          const minDistance = selectedTool === 'pen' ? 3 : 6
          if (distance >= minDistance) {
            return [...prev, canvasX, canvasY]
          }
          return prev
        })
        return
      }

      if (isDrawingSelection && selectedTool === 'select') {
        setSelectionBox((prev) => ({
          ...prev,
          currentX: canvasX,
          currentY: canvasY,
        }))
      }

      updateCursorPosition(canvasX, canvasY)
    },
    [isDrawingPath, isDrawingSelection, selectedTool, viewport, updateCursorPosition, isDrawingLine, lineStartPoint]
  )

  const handleStageMouseUp = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      if (isDrawingPath && (selectedTool === 'pencil' || selectedTool === 'pen')) {
        setIsDrawingPath(false)
        if (currentPathPoints.length >= 4) {
          const isPen = selectedTool === 'pen'
          const tension = isPen ? 0.5 : 0
          const simplificationTolerance = isPen ? 2 : 6
          const simplified = simplifyPath(currentPathPoints, simplificationTolerance)
          addPath(simplified, tension)
        }
        setCurrentPathPoints([])
        return
      }
      
      const stage = stageRef.current
      if (!stage) return

      const pointer = stage.getPointerPosition()
      if (!pointer) return

      const canvasX = (pointer.x - viewport.x) / viewport.scale
      const canvasY = (pointer.y - viewport.y) / viewport.scale

      if (isDrawingSelection && selectedTool === 'select') {
        setIsDrawingSelection(false)
        const intersectingIds = shapes
          .filter((shape) => shapeIntersectsSelectionBox(shape, selectionBox))
          .map((shape) => shape.id)
        if (intersectingIds.length > 0) {
          selectMultiple(intersectingIds)
        }
        setSelectionBox((prev) => ({ ...prev, visible: false }))
        return
      }

      if (!isDrawingSelection) {
        if (isDraggingShapeRef.current || isTransformingShapeRef.current) {
          isTransformingShapeRef.current = false
          return
        }
        if (lastMouseDownWasOnShapeRef.current) {
          lastMouseDownWasOnShapeRef.current = false
          return
        }
        if (e.target !== e.target.getStage()) return

        const snappedX = snapToGridCoord(canvasX)
        const snappedY = snapToGridCoord(canvasY)

        if (selectedTool === 'rectangle') {
          addShape('rectangle', snappedX, snappedY)
        } else if (selectedTool === 'circle') {
          addShape('circle', snappedX, snappedY)
        } else if (selectedTool === 'text') {
          setTextInput({ x: snappedX, y: snappedY, value: '' })
        } else if (selectedTool === 'roundRect') {
          addRoundedRect(snappedX, snappedY, 10)
        } else if (selectedTool === 'polygon') {
          addPolygon(snappedX, snappedY, 5)
        } else if (selectedTool === 'star') {
          addStar(snappedX, snappedY, 5)
        } else if (selectedTool === 'select' && !e.evt.shiftKey) {
          clearSelection()
          setShowQuickActions(false)
        }
      }
    },
    [isDrawingPath, isDrawingSelection, selectedTool, viewport, currentPathPoints, selectionBox, shapes, selectMultiple, addShape, addPath, clearSelection, snapToGridCoord, addRoundedRect, addPolygon, addStar]
  )

  const handleShapeSelect = useCallback(
    (shapeId: string, shiftKey: boolean) => {
      if (shiftKey) {
        toggleSelection(shapeId)
      } else {
        setSelection(shapeId)
      }
      setContextMenu({ x: 0, y: 0, visible: false })
    },
    [setSelection, toggleSelection]
  )

  const handleContextMenu = useCallback((e: Konva.KonvaEventObject<PointerEvent>) => {
    e.evt.preventDefault()
    setContextMenu({ x: e.evt.clientX, y: e.evt.clientY, visible: true })
  }, [])

  const closeContextMenu = useCallback(() => {
    setContextMenu({ x: 0, y: 0, visible: false })
  }, [])

  const handleShapeDragStart = useCallback(
    (shapeId: string, x: number, y: number) => {
      isDraggingShapeRef.current = true
      dragStartPosRef.current = { x, y }
      if (!selectedIds.has(shapeId)) {
        setSelection(shapeId)
      }
    },
    [selectedIds, setSelection]
  )

  const handleShapeDragEnd = useCallback(
    (shapeId: string, x: number, y: number) => {
      if (!dragStartPosRef.current) return

      const snappedX = snapToGridCoord(x)
      const snappedY = snapToGridCoord(y)
      const deltaX = snappedX - dragStartPosRef.current.x
      const deltaY = snappedY - dragStartPosRef.current.y

      if (selectedIds.size > 1 && selectedIds.has(shapeId)) {
        bulkMove(deltaX, deltaY)
      } else {
        updateShape(shapeId, { x: snappedX, y: snappedY })
      }

      isDraggingShapeRef.current = false
      dragStartPosRef.current = null
    },
    [selectedIds, bulkMove, updateShape, snapToGridCoord]
  )

  const handleShapeTransformEnd = useCallback(
    (shapeId: string, width: number, height: number, rotation: number, x: number, y: number) => {
      updateShape(shapeId, { width, height, rotation, x, y })
    },
    [updateShape]
  )

  const DotGrid = useCallback(() => {
    return (
      <KonvaLine
        points={[]}
        listening={false}
        perfectDrawEnabled={false}
        hitStrokeWidth={0}
        sceneFunc={(context) => {
          const spacing = 20
          const dotRadius = 1.2
          context.fillStyle = '#D1D5DB'
          for (let x = 0; x <= CANVAS_BOUNDS.maxX; x += spacing) {
            for (let y = 0; y <= CANVAS_BOUNDS.maxY; y += spacing) {
              context.beginPath()
              context.arc(x, y, dotRadius, 0, Math.PI * 2)
              context.fill()
            }
          }
        }}
      />
    )
  }, [])

  return (
    <div className="w-full h-full bg-gray-100 overflow-hidden relative flex flex-col">
      <AlignmentToolbar
        visible={selectedIds.size >= 2}
        selectedCount={selectedIds.size}
        onAlign={(type) => alignSelected(type)}
        onDistributeHorizontally={() => distributeSelectedHorizontally()}
        onDistributeVertically={() => distributeSelectedVertically()}
        onCenterInCanvas={() => centerSelectedInCanvas(containerWidth, containerHeight)}
      />

      <div className="flex-1 relative">
        <Stage
          ref={stageRef}
          width={containerWidth}
          height={containerHeight}
          draggable={selectedTool === 'hand'}
          onWheel={handleWheel}
          onDragEnd={baseHandleDragEnd}
          onMouseMove={handleStageMouseMove}
          onMouseDown={handleStageMouseDown}
          onMouseUp={handleStageMouseUp}
          onContextMenu={handleContextMenu}
          x={viewport.x}
          y={viewport.y}
          scaleX={viewport.scale}
          scaleY={viewport.scale}
        >
          <Layer listening={false} perfectDrawEnabled={false}>
            <DotGrid />
          </Layer>

          <Layer>
            <ShapeRenderer
              shapes={shapes}
              groups={groups}
              selectedIds={selectedIds}
              viewport={viewport}
              containerWidth={containerWidth}
              containerHeight={containerHeight}
              isDrawingLine={isDrawingLine}
              lineStartPoint={lineStartPoint}
              linePreviewEnd={linePreviewEnd}
              isDrawingPath={isDrawingPath}
              currentPathPoints={currentPathPoints}
              selectedTool={selectedTool}
              sortShapesByZIndex={sortShapesByZIndex}
              isShapeInGroup={(id) => !!isShapeInGroup(id)}
              calculateBounds={calculateBounds}
              handleShapeSelect={handleShapeSelect}
              handleShapeDragStart={handleShapeDragStart}
              handleShapeDragEnd={handleShapeDragEnd}
              handleShapeTransformEnd={handleShapeTransformEnd}
              handleTextDoubleClick={handleTextDoubleClick}
              updateShape={updateShape}
              dragStartPosRef={dragStartPosRef}
            />
            <SelectionBox selectionBox={selectionBox} />
          </Layer>

          <Layer listening={false}>
            {Array.from(otherUsers.entries()).map(([userId, presence]) => (
              <Cursor
                key={userId}
                x={presence.c[0]}
                y={presence.c[1]}
                userName={presence.n}
                color={presence.cl}
              />
            ))}
          </Layer>
        </Stage>

        {textInput && (
          <div
            className="absolute bg-white border-2 border-blue-500 rounded shadow-lg p-2"
            style={{
              left: textInput.x * viewport.scale + viewport.x,
              top: textInput.y * viewport.scale + viewport.y,
              zIndex: 1000,
            }}
          >
            <input
              type="text"
              autoFocus
              value={textInput.value}
              onChange={(e) => setTextInput({ ...textInput, value: e.target.value })}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && textInput.value.trim()) {
                  addText(textInput.value, textInput.x, textInput.y)
                  setTextInput(null)
                } else if (e.key === 'Escape') {
                  setTextInput(null)
                }
              }}
              onBlur={() => setTextInput(null)}
              placeholder="Type text..."
              className="px-2 py-1 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
              style={{ width: '200px' }}
            />
            <div className="text-xs text-gray-500 mt-1">Press Enter to create, Esc to cancel</div>
          </div>
        )}

        {editingText && (
          <TextEditor
            initialText={editingText.text}
            x={editingText.screenX}
            y={editingText.screenY}
            width={editingText.width}
            fontFamily={editingText.shape.fontFamily}
            fontSize={editingText.shape.fontSize}
            fontWeight={editingText.shape.fontWeight}
            fontStyle={editingText.shape.fontStyle}
            textAlign={editingText.shape.textAlign}
            fill={editingText.shape.fill}
            onSave={handleTextSave}
            onCancel={handleTextEditorCancel}
          />
        )}

        {showQuickActions && selectedIds.size > 0 && (() => {
          const selectedShape = shapes.find(s => selectedIds.has(s.id))
          if (!selectedShape) return null
          return (
            <QuickActionsPopup
              screenX={selectedShape.x * viewport.scale + viewport.x + (selectedShape.width || 0) * viewport.scale}
              screenY={selectedShape.y * viewport.scale + viewport.y}
              selectedCount={selectedIds.size}
              canGroup={selectedIds.size >= 2}
              onBringToFront={() => bringToFront()}
              onSendToBack={() => sendToBack()}
              onBringForward={() => bringForward()}
              onSendBackward={() => sendBackward()}
              onGroup={() => createGroup(Array.from(selectedIds))}
              onUngroup={() => {
                const firstSelected = Array.from(selectedIds)[0]
                if (firstSelected) ungroup(firstSelected)
              }}
              onDuplicate={() => duplicateSelected()}
              onDelete={() => bulkDelete()}
              onClose={() => setShowQuickActions(false)}
            />
          )
        })()}

        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          visible={contextMenu.visible}
          onClose={closeContextMenu}
          hasSelection={selectedIds.size > 0}
          canCopy={selectedIds.size > 0}
          canPaste={true}
          selectedCount={selectedIds.size}
          onBringToFront={() => bringToFront()}
          onBringForward={() => bringForward()}
          onSendBackward={() => sendBackward()}
          onSendToBack={() => sendToBack()}
          onCopy={copySelected}
          onPaste={paste}
          onDuplicate={duplicateSelected}
          onDelete={bulkDelete}
          onAlign={(type) => alignSelected(type)}
          onDistributeHorizontally={() => distributeSelectedHorizontally()}
          onDistributeVertically={() => distributeSelectedVertically()}
          onCenterInCanvas={() => centerSelectedInCanvas(containerWidth, containerHeight)}
        />
      </div>
    </div>
  )
}
</file>

<file path="src/components/canvas/ShapeRenderer.tsx">
import { Line as KonvaLine, Circle as KonvaCircle } from 'react-konva'
import Konva from 'konva'
import type { Shape, ViewportTransform } from '../../types/canvas'
import type { Group as GroupType } from '../../types/group'
import Rectangle from '../shapes/Rectangle'
import Circle from '../shapes/Circle'
import TextShape from '../shapes/TextShape'
import Line from '../shapes/Line'
import Polygon from '../shapes/Polygon'
import Star from '../shapes/Star'
import RoundedRect from '../shapes/RoundedRect'
import Path from '../shapes/Path'
import Group from '../Group'

interface ShapeRendererProps {
  shapes: Shape[]
  groups: GroupType[]
  selectedIds: Set<string>
  viewport: ViewportTransform
  containerWidth: number
  containerHeight: number
  isDrawingLine: boolean
  lineStartPoint: { x: number; y: number } | null
  linePreviewEnd: { x: number; y: number } | null
  isDrawingPath: boolean
  currentPathPoints: number[]
  selectedTool: 'select' | 'pen' | 'pencil' | string
  sortShapesByZIndex: () => Shape[]
  isShapeInGroup: (shapeId: string) => boolean
  calculateBounds: (groupId: string, shapes: Shape[]) => { x: number; y: number; width: number; height: number } | null
  handleShapeSelect: (shapeId: string, shiftKey: boolean) => void
  handleShapeDragStart: (shapeId: string, x: number, y: number) => void
  handleShapeDragEnd: (shapeId: string, x: number, y: number) => void
  handleShapeTransformEnd: (shapeId: string, width: number, height: number, rotation: number, x: number, y: number) => void
  handleTextDoubleClick: (shape: Shape) => void
  updateShape: (shapeId: string, updates: Partial<Shape>) => void
  dragStartPosRef: React.MutableRefObject<{ x: number; y: number } | null>
}

export function ShapeRenderer({
  shapes,
  groups,
  selectedIds,
  viewport,
  containerWidth,
  containerHeight,
  isDrawingLine,
  lineStartPoint,
  linePreviewEnd,
  isDrawingPath,
  currentPathPoints,
  selectedTool,
  sortShapesByZIndex,
  isShapeInGroup,
  calculateBounds,
  handleShapeSelect,
  handleShapeDragStart,
  handleShapeDragEnd,
  handleShapeTransformEnd,
  handleTextDoubleClick,
  updateShape,
  dragStartPosRef,
}: ShapeRendererProps) {
  const getUserColor = () => '#3B82F6'

  const isShapeInViewport = (shape: Shape): boolean => {
    const margin = 500
    const viewportLeft = -viewport.x / viewport.scale - margin
    const viewportTop = -viewport.y / viewport.scale - margin
    const viewportRight = viewportLeft + (containerWidth / viewport.scale) + margin * 2
    const viewportBottom = viewportTop + (containerHeight / viewport.scale) + margin * 2
    
    if ((shape.type === 'path' || shape.type === 'line') && shape.points && shape.points.length >= 2) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity
      for (let i = 0; i < shape.points.length; i += 2) {
        const x = shape.type === 'line' ? shape.points[i] : shape.points[i] + (shape.x || 0)
        const y = shape.type === 'line' ? shape.points[i + 1] : shape.points[i + 1] + (shape.y || 0)
        minX = Math.min(minX, x)
        minY = Math.min(minY, y)
        maxX = Math.max(maxX, x)
        maxY = Math.max(maxY, y)
      }
      
      return !(
        maxX < viewportLeft ||
        minX > viewportRight ||
        maxY < viewportTop ||
        minY > viewportBottom
      )
    }
    
    const shapeRight = shape.x + (shape.width || 0)
    const shapeBottom = shape.y + (shape.height || 0)
    
    return !(
      shapeRight < viewportLeft ||
      shape.x > viewportRight ||
      shapeBottom < viewportTop ||
      shape.y > viewportBottom
    )
  }

  return (
    <>
      {sortShapesByZIndex()
        .filter((shape) => !isShapeInGroup(shape.id))
        .filter((shape) => {
          if (selectedIds.has(shape.id)) {
            return true
          }
          return isShapeInViewport(shape)
        })
        .map((shape) => {
        const isSelected = selectedIds.has(shape.id)
        const userColor = getUserColor()

        if (shape.type === 'rectangle') {
          return (
            <Rectangle
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'circle') {
          const radius = shape.width / 2
          const centerX = shape.x + radius
          const centerY = shape.y + radius
          
          return (
            <KonvaCircle
              key={shape.id}
              x={centerX}
              y={centerY}
              radius={radius}
              fill={shape.fill}
              stroke={shape.stroke || '#000000'}
              strokeWidth={shape.strokeWidth || 2}
              draggable
              onClick={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(e) => {
                const node = e.target
                handleShapeDragStart(shape.id, node.x() - radius, node.y() - radius)
              }}
              onDragEnd={(e) => {
                const node = e.target
                handleShapeDragEnd(shape.id, node.x() - radius, node.y() - radius)
              }}
            />
          )
        } else if (shape.type === 'text' && shape.text) {
          return (
            <TextShape
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              text={shape.text}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              fontFamily={shape.fontFamily}
              fontSize={shape.fontSize}
              fontWeight={shape.fontWeight}
              fontStyle={shape.fontStyle}
              textAlign={shape.textAlign}
              textDecoration={shape.textDecoration}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
              onDoubleClick={() => handleTextDoubleClick(shape)}
            />
          )
        } else if (shape.type === 'line' && shape.points) {
          return (
            <Line
              key={shape.id}
              id={shape.id}
              points={shape.points}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              arrows={shape.arrows}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(pts: number[], x: number, y: number) => {
                updateShape(shape.id, { points: pts, x, y })
              }}
            />
          )
        } else if (shape.type === 'polygon' && shape.sides) {
          return (
            <Polygon
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              sides={shape.sides}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'star' && shape.sides) {
          return (
            <Star
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              sides={shape.sides}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'roundRect' && shape.cornerRadius !== undefined) {
          return (
            <RoundedRect
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              cornerRadius={shape.cornerRadius}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'path' && shape.points) {
          return (
            <Path
              key={shape.id}
              id={shape.id}
              points={shape.points}
              stroke={shape.stroke || '#3B82F6'}
              strokeWidth={shape.strokeWidth || 2}
              tension={shape.tension}
              closed={shape.closed}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(pts: number[], x: number, y: number) => {
                updateShape(shape.id, { points: pts, x, y })
              }}
            />
          )
        }
        return null
      })}
      
      {/* Line preview while drawing */}
      {isDrawingLine && lineStartPoint && linePreviewEnd && (
        <KonvaLine
          points={[lineStartPoint.x, lineStartPoint.y, linePreviewEnd.x, linePreviewEnd.y]}
          stroke="#6366F1"
          strokeWidth={2}
          lineCap="round"
          listening={false}
          opacity={0.7}
          dash={[5, 5]}
        />
      )}
      
      {/* Path preview while drawing */}
      {isDrawingPath && currentPathPoints.length >= 2 && (
        <KonvaLine
          points={currentPathPoints}
          stroke="#6366F1"
          strokeWidth={2}
          tension={selectedTool === 'pen' ? 0.5 : 0}
          lineCap="round"
          lineJoin="round"
          listening={false}
          opacity={0.7}
        />
      )}
      
      {/* Render groups */}
      {groups.map((group) => {
        const isSelected = selectedIds.has(group.id)
        const userColor = getUserColor()
        const bounds = calculateBounds(group.id, shapes)
        
        if (!bounds) return null
        
        const renderGroupMember = (shapeId: string) => {
          const shape = shapes.find((s) => s.id === shapeId)
          if (!shape) return null
          
          const relativeX = shape.x - bounds.x
          const relativeY = shape.y - bounds.y
          
          if (shape.type === 'rectangle') {
            return (
              <Rectangle
                key={shape.id}
                id={shape.id}
                x={relativeX}
                y={relativeY}
                width={shape.width}
                height={shape.height}
                rotation={shape.rotation}
                fill={shape.fill}
                stroke={shape.stroke}
                strokeWidth={shape.strokeWidth}
                isSelected={false}
                onSelect={() => {}}
                onDragStart={() => {}}
                onDragEnd={() => {}}
                onTransformEnd={() => {}}
              />
            )
          } else if (shape.type === 'circle') {
            return (
              <Circle
                key={shape.id}
                id={shape.id}
                x={relativeX}
                y={relativeY}
                width={shape.width}
                height={shape.height}
                rotation={shape.rotation}
                fill={shape.fill}
                stroke={shape.stroke}
                strokeWidth={shape.strokeWidth}
                isSelected={false}
                onSelect={() => {}}
                onDragStart={() => {}}
                onDragEnd={() => {}}
                onTransformEnd={() => {}}
              />
            )
          }
          return null
        }
        
        return (
          <Group
            key={group.id}
            id={group.id}
            x={bounds.x}
            y={bounds.y}
            width={bounds.width}
            height={bounds.height}
            rotation={group.rotation}
            isSelected={isSelected}
            selectionColor={isSelected ? userColor : undefined}
            locked={group.locked}
            visible={group.visible}
            onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(group.id, e.evt.shiftKey)}
            onDragStart={() => {
              dragStartPosRef.current = { x: bounds.x, y: bounds.y }
            }}
            onDragEnd={(x: number, y: number) => {
              if (dragStartPosRef.current) {
                const deltaX = x - dragStartPosRef.current.x
                const deltaY = y - dragStartPosRef.current.y
                
                group.memberIds.forEach((memberId) => {
                  const shape = shapes.find((s) => s.id === memberId)
                  if (shape) {
                    updateShape(memberId, {
                      x: shape.x + deltaX,
                      y: shape.y + deltaY,
                    })
                  }
                })
                
                dragStartPosRef.current = null
              }
            }}
          >
            {group.memberIds.map(renderGroupMember)}
          </Group>
        )
      })}
    </>
  )
}
</file>

<file path="src/components/canvas/ShapeStatusBar.tsx">
/**
 * ShapeStatusBar Component
 * Bottom status bar showing shape canvas information
 * Displays shape count, selection info, zoom, and connection status
 */

interface ShapeStatusBarProps {
  shapeCount: number
  selectedCount: number
  zoom: number
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting'
  aiChat?: React.ReactNode // Optional AI chat component to render inline
}

/**
 * Status bar component for shape editor
 * Shows relevant information at the bottom of the canvas
 */
export default function ShapeStatusBar({
  shapeCount,
  selectedCount,
  zoom,
  connectionStatus,
  aiChat,
}: ShapeStatusBarProps) {
  const connectionIndicators = {
    connected: { icon: '🟢', text: 'Connected', color: 'text-green-400' },
    disconnected: { icon: '🔴', text: 'Disconnected', color: 'text-red-400' },
    reconnecting: { icon: '🟡', text: 'Reconnecting...', color: 'text-yellow-400' },
  }
  
  const indicator = connectionIndicators[connectionStatus]
  
  return (
    <div className="fixed bottom-0 left-0 right-0 h-10 z-50 bg-gradient-to-r from-slate-900/95 to-slate-800/95 backdrop-blur-md border-t border-white/10 flex items-center justify-between px-2 sm:px-4 gap-2 sm:gap-4 text-xs text-white/90 font-mono shadow-lg">
      {/* Left side - AI Chat */}
      <div id="status-bar-left" className="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
        {aiChat}
      </div>

      {/* Right side - Status Info */}
      <div className="flex items-center gap-2 sm:gap-4 flex-shrink-0">
        {/* Shape Count */}
        <div className="flex items-center gap-2">
          <span className="text-white/50">Shapes:</span>
          <span className="text-white/90 font-semibold">{shapeCount}</span>
        </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
      {/* Selection Info */}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Selected:</span>
        <span className="text-white/90 font-semibold">{selectedCount}</span>
      </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
      {/* Zoom Level */}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Zoom:</span>
        <span className="text-white/90 font-semibold">{Math.round(zoom * 100)}%</span>
      </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
        {/* Connection Status */}
        <div className={`flex items-center gap-2 ${indicator.color}`}>
          <span>{indicator.icon}</span>
          <span className="font-semibold">{indicator.text}</span>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/canvas/SpriteTile.tsx">
/**
 * SpriteTile Component
 * Renders a single tile using a sprite sheet with variant-based cropping
 */

import { useEffect, useState } from 'react'
import { Image as KonvaImage, Rect } from 'react-konva'
import { useSprite } from '../../hooks/useSpriteCache'

interface SpriteTileProps {
  x: number                 // World X position (pixels)
  y: number                 // World Y position (pixels)
  tileSize: number          // Rendered tile size (16, 32, etc.)
  tilePath: string          // URL to individual tile image
  color?: string            // Fallback color if sprite fails to load
  opacity?: number          // Tile opacity
}

/**
 * Sprite Tile Renderer
 * 
 * Renders a tile from an individual tile image file.
 * Falls back to colored rectangle if image fails to load.
 * 
 * @performance
 * - Individual tile images are cached (no redundant loads)
 * - Scales tiles efficiently (16x16 → 32x32, etc.)
 */
export default function SpriteTile({
  x,
  y,
  tileSize,
  tilePath,
  color = '#888888',
  opacity = 1,
}: SpriteTileProps) {
  const image = useSprite(tilePath)
  const [isLoading, setIsLoading] = useState(!image)
  const [hasError, setHasError] = useState(false)
  
  useEffect(() => {
    if (image) {
      setIsLoading(false)
      setHasError(false)
    }
  }, [image])
  
  // Show loading/error fallback (colored rectangle)
  if (isLoading || hasError || !image) {
    return (
      <Rect
        x={x}
        y={y}
        width={tileSize}
        height={tileSize}
        fill={color}
        opacity={opacity * 0.7}
        stroke={color}
        strokeWidth={0.5}
      />
    )
  }
  
  // Render tile image
  return (
    <KonvaImage
      x={x}
      y={y}
      width={tileSize}
      height={tileSize}
      image={image}
      opacity={opacity}
      // Pixelated scaling for crisp pixel art
      imageSmoothingEnabled={false}
    />
  )
}
</file>

<file path="src/components/Cursor.tsx">
import { Group, Path, Text, Rect } from 'react-konva'

interface CursorProps {
  x: number
  y: number
  userName: string
  color: string
}

/**
 * Cursor component - Professional Figma-style multiplayer cursors (PR-20)
 * Shows an SVG arrow pointer with drop shadow and name label
 * Position jumps to coordinates (no smooth interpolation per MVP requirements)
 */
export default function Cursor({ x, y, userName, color }: CursorProps) {
  // Arrow pointer SVG path data (pointing up-left like a standard cursor)
  const arrowPath =
    'M 0 0 L 0 18 L 5 13 L 9 20 L 11 19 L 7 12 L 13 11 Z'

  // Measure text width for background pill with 4px padding (PR-20)
  const textWidth = userName.length * 6.5 + 8 // 11px font ~6.5px per char + 4px padding each side
  const textHeight = 19

  return (
    <Group x={x} y={y}>
      {/* Arrow pointer with 1px white stroke and drop shadow (PR-20) */}
      <Path
        data={arrowPath}
        fill={color}
        stroke="#FFFFFF"
        strokeWidth={1}
        shadowColor="rgba(0, 0, 0, 0.2)"
        shadowBlur={2}
        shadowOffsetX={1}
        shadowOffsetY={1}
      />

      {/* Name label background - rounded tag (PR-20) */}
      <Rect
        x={15}
        y={3}
        width={textWidth}
        height={textHeight}
        fill={color}
        cornerRadius={4}
        shadowColor="rgba(0, 0, 0, 0.2)"
        shadowBlur={2}
        shadowOffsetX={1}
        shadowOffsetY={1}
      />

      {/* Name label text - 11px Inter font, white text, 4px padding (PR-20) */}
      <Text
        x={19}
        y={6}
        text={userName}
        fontSize={11}
        fontFamily="Inter, system-ui, sans-serif"
        fill="#FFFFFF"
        fontStyle="normal"
      />
    </Group>
  )
}
</file>

<file path="src/components/ErrorBoundary.tsx">
import { Component, type ReactNode, type ErrorInfo } from 'react'

interface ErrorBoundaryProps {
  children: ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
}

/**
 * ErrorBoundary - Catches React errors and displays fallback UI
 * Prevents entire app from crashing due to component errors
 */
class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    }
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error details for debugging
    console.error('ErrorBoundary caught an error:', error, errorInfo)
    this.setState({
      error,
      errorInfo,
    })
  }

  handleReset = (): void => {
    // Reset error state and reload the page
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    })
    window.location.reload()
  }

  render(): ReactNode {
    if (this.state.hasError) {
      // Fallback UI when error occurs
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-100 p-4">
          <div className="max-w-2xl w-full bg-white rounded-lg shadow-lg p-8">
            <div className="flex items-center justify-center mb-6">
              <svg
                className="h-16 w-16 text-red-500"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                />
              </svg>
            </div>

            <h1 className="text-2xl font-bold text-gray-900 text-center mb-4">
              Oops! Something went wrong
            </h1>

            <p className="text-gray-600 text-center mb-6">
              We encountered an unexpected error. Don't worry, your work is saved
              in Firebase. Try refreshing the page to continue.
            </p>

            {/* Error details (only in development) */}
            {import.meta.env.DEV && this.state.error && (
              <details className="mb-6 p-4 bg-gray-50 rounded border border-gray-200">
                <summary className="cursor-pointer font-semibold text-gray-700 mb-2">
                  Error Details (Development Only)
                </summary>
                <div className="text-sm">
                  <p className="font-mono text-red-600 mb-2">
                    {this.state.error.toString()}
                  </p>
                  {this.state.errorInfo && (
                    <pre className="overflow-auto text-xs text-gray-700 bg-white p-2 rounded">
                      {this.state.errorInfo.componentStack}
                    </pre>
                  )}
                </div>
              </details>
            )}

            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <button
                onClick={this.handleReset}
                className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Reload Application
              </button>
              <a
                href="/"
                className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium text-center"
              >
                Go to Home
              </a>
            </div>

            <div className="mt-8 pt-6 border-t border-gray-200">
              <p className="text-sm text-gray-500 text-center">
                If this problem persists, please try:
              </p>
              <ul className="mt-2 text-sm text-gray-600 space-y-1">
                <li className="flex items-center justify-center">
                  <span className="mr-2">•</span>
                  Clearing your browser cache and cookies
                </li>
                <li className="flex items-center justify-center">
                  <span className="mr-2">•</span>
                  Using a different browser
                </li>
                <li className="flex items-center justify-center">
                  <span className="mr-2">•</span>
                  Checking your internet connection
                </li>
              </ul>
            </div>
          </div>
        </div>
      )
    }

    // No error, render children normally
    return this.props.children
  }
}

export default ErrorBoundary
</file>

<file path="src/components/Group.tsx">
/**
 * Group Component (PR-19)
 * Konva Group wrapper that renders all member shapes together
 * Supports dragging entire group and selection indication
 */

import { useRef, useEffect } from 'react'
import { Group as KonvaGroup, Rect } from 'react-konva'
import type Konva from 'konva'

interface GroupProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  isSelected: boolean
  selectionColor?: string
  locked?: boolean
  visible?: boolean
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  children: React.ReactNode
}

/**
 * Group component that renders a collection of shapes as a single unit
 * Shows dashed bounding box when selected
 * Handles drag for entire group
 */
export default function Group({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  isSelected,
  selectionColor = '#6366F1',
  locked = false,
  visible = true,
  onSelect,
  onDragStart,
  onDragEnd,
  children,
}: GroupProps) {
  const groupRef = useRef<Konva.Group>(null)

  useEffect(() => {
    if (groupRef.current) {
      groupRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  if (!visible) {
    return null
  }

  return (
    <KonvaGroup
      ref={groupRef}
      x={x}
      y={y}
      rotation={rotation}
      draggable={!locked}
      onClick={onSelect}
      onTap={onSelect}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      {/* Render children (member shapes) */}
      {children}

      {/* Selection indicator - dashed bounding box */}
      {isSelected && (
        <Rect
          x={0}
          y={0}
          width={width}
          height={height}
          stroke={selectionColor}
          strokeWidth={2}
          dash={[10, 5]}
          fill="transparent"
          listening={false} // Don't intercept mouse events
        />
      )}

      {/* Locked indicator - small lock icon position */}
      {locked && (
        <Rect
          x={width - 20}
          y={-20}
          width={16}
          height={16}
          fill="#EF4444"
          cornerRadius={2}
          listening={false}
        />
      )}
    </KonvaGroup>
  )
}
</file>

<file path="src/components/KeyboardShortcuts.tsx">
import { useEffect } from 'react'
import { getShortcutsByCategory, formatShortcut } from '../constants/shortcuts'

interface KeyboardShortcutsProps {
  visible: boolean
  onClose: () => void
}

/**
 * KeyboardShortcuts - Help overlay modal showing all keyboard shortcuts (PR-20)
 * Triggered by pressing "?" key
 */
export function KeyboardShortcuts({ visible, onClose }: KeyboardShortcutsProps) {
  // Close on Escape key
  useEffect(() => {
    if (!visible) return

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [visible, onClose])

  if (!visible) return null

  const shortcutsByCategory = getShortcutsByCategory()

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]">
      {/* Modal */}
      <div className="bg-white rounded-lg shadow-hard max-w-3xl w-full max-h-[80vh] overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-neutral-200">
          <h2 className="text-lg font-semibold text-neutral-900">
            Keyboard Shortcuts
          </h2>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center rounded hover:bg-neutral-100 transition-colors"
          >
            <span className="text-neutral-500 text-xl">×</span>
          </button>
        </div>

        {/* Content */}
        <div className="overflow-y-auto max-h-[calc(80vh-5rem)] px-6 py-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
            {Object.entries(shortcutsByCategory).map(([category, shortcuts]) => (
              <div key={category}>
                <h3 className="text-sm font-semibold text-neutral-700 mb-3">
                  {category}
                </h3>
                <div className="space-y-2">
                  {shortcuts.map((shortcut, index) => (
                    <div
                      key={`${shortcut.action}-${index}`}
                      className="flex items-center justify-between text-sm"
                    >
                      <span className="text-neutral-600">
                        {shortcut.description}
                      </span>
                      <kbd className="px-2 py-1 bg-neutral-100 border border-neutral-300 rounded text-neutral-700 font-mono text-xs">
                        {formatShortcut(shortcut)}
                      </kbd>
                    </div>
                  ))}
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t border-neutral-200 bg-neutral-50">
          <p className="text-xs text-neutral-500 text-center">
            Press <kbd className="px-1.5 py-0.5 bg-white border border-neutral-300 rounded text-neutral-700 font-mono">Esc</kbd> or click outside to close
          </p>
        </div>
      </div>

      {/* Backdrop - click to close */}
      <div
        className="absolute inset-0 -z-10"
        onClick={onClose}
      />
    </div>
  )
}
</file>

<file path="src/components/LayerItem.tsx">
/**
 * LayerItem Component (PR-19)
 * Individual layer row in the layer panel with visibility toggle, lock, and name
 */

import { useState } from 'react'
import type { Layer } from '../types/layer'

interface LayerItemProps {
  layer: Layer
  isSelected: boolean
  level: number
  onSelect: (id: string) => void
  onToggleVisibility: (id: string) => void
  onToggleLock: (id: string) => void
  onRename: (id: string, newName: string) => void
  onDelete?: (id: string) => void
  children?: React.ReactNode
  isExpanded?: boolean
  onToggleExpand?: () => void
  themed?: boolean
}

/**
 * LayerItem component for displaying a single layer in the layer panel
 * Supports nesting for groups, visibility/lock toggles, and inline renaming
 */
export function LayerItem({
  layer,
  isSelected,
  level,
  onSelect,
  onToggleVisibility,
  onToggleLock,
  onRename,
  onDelete,
  children,
  isExpanded = true,
  onToggleExpand,
  themed = false,
}: LayerItemProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [editName, setEditName] = useState(layer.name)

  const handleDoubleClick = () => {
    setIsEditing(true)
    setEditName(layer.name)
  }

  const handleRename = () => {
    if (editName.trim() && editName !== layer.name) {
      onRename(layer.id, editName.trim())
    }
    setIsEditing(false)
  }

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleRename()
    } else if (e.key === 'Escape') {
      setIsEditing(false)
      setEditName(layer.name)
    }
  }

  const getIconForType = (type: string) => {
    switch (type) {
      case 'rectangle':
        return '▭'
      case 'circle':
        return '○'
      case 'text':
        return 'T'
      case 'line':
        return '—'
      case 'path':
        return '✎' // Pencil/pen freehand path
      case 'polygon':
        return '⬟'
      case 'star':
        return '★'
      case 'roundRect':
        return '▢'
      case 'group':
        return '◫'
      default:
        return '□'
    }
  }

  return (
    <div className={themed ? 'px-2 py-0.5' : ''}>
      <div
        className={`flex items-center px-2 py-1.5 cursor-pointer rounded-md transition-colors ${
          themed 
            ? isSelected 
              ? 'bg-white/50 border-l-4 border-white shadow-md' 
              : 'bg-white/15 hover:bg-white/25'
            : isSelected 
              ? 'bg-blue-100 border-l-4 border-blue-600 shadow-sm' 
              : 'hover:bg-gray-100'
        }`}
        style={{ paddingLeft: `${8 + level * 16}px` }}
        onClick={() => onSelect(layer.id)}
      >
        {/* Expand/collapse for groups */}
        {layer.type === 'group' && onToggleExpand && (
          <button
            className={`mr-1 rounded p-0.5 ${
              themed ? 'hover:bg-white/30 text-white' : 'hover:bg-gray-200'
            }`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleExpand()
            }}
          >
            {isExpanded ? (
              <span className="text-xs">▼</span>
            ) : (
              <span className="text-xs">▶</span>
            )}
          </button>
        )}

        {/* Icon for shape type */}
        <span className={`mr-2 text-xs font-mono ${
          themed ? 'text-white/80' : 'text-gray-600'
        }`}>
          {getIconForType(layer.type)}
        </span>

        {/* Layer name - editable on double-click */}
        {isEditing ? (
          <input
            type="text"
            value={editName}
            onChange={(e) => setEditName(e.target.value)}
            onKeyDown={handleKeyDown}
            onBlur={handleRename}
            className={`flex-1 px-1 py-0 text-sm rounded focus:outline-none ${
              themed 
                ? 'bg-white/80 text-gray-900 border border-white/60'
                : 'border border-blue-500'
            }`}
            autoFocus
            onClick={(e) => e.stopPropagation()}
          />
        ) : (
          <span
            className={`flex-1 text-sm ${
              themed
                ? layer.visible ? 'text-white' : 'text-white/40'
                : layer.visible ? 'text-gray-900' : 'text-gray-400'
            }`}
            onDoubleClick={handleDoubleClick}
          >
            {layer.name}
          </span>
        )}

        {/* Buttons container - fixed width for alignment */}
        <div className="flex items-center gap-0 ml-auto">
          {/* Lock toggle */}
          <button
            className={`w-7 h-7 flex items-center justify-center rounded ${
              themed ? 'hover:bg-white/30' : 'hover:bg-gray-200'
            }`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleLock(layer.id)
            }}
          >
            {layer.locked ? (
              <span className="text-sm text-red-500">🔒</span>
            ) : (
              <span className={`text-sm ${themed ? 'text-white/60' : 'text-gray-400'}`}>🔓</span>
            )}
          </button>

          {/* Visibility toggle */}
          <button
            className={`w-7 h-7 flex items-center justify-center rounded ${
              themed ? 'hover:bg-white/30' : 'hover:bg-gray-200'
            }`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleVisibility(layer.id)
            }}
          >
            {layer.visible ? (
              <span className={`text-sm ${themed ? 'text-white/80' : 'text-gray-600'}`}>👁️</span>
            ) : (
              <span className={`text-sm ${themed ? 'text-white/40' : 'text-gray-400'}`}>👁️‍🗨️</span>
            )}
          </button>

          {/* Delete button */}
          {onDelete && (
            <button
              className={`w-7 h-7 flex items-center justify-center rounded ${
                themed ? 'hover:bg-red-500/30 text-red-400' : 'hover:bg-red-100 text-red-600'
              }`}
              onClick={(e) => {
                e.stopPropagation()
                onDelete(layer.id)
              }}
              title="Delete layer"
            >
              <span className="text-sm">🗑️</span>
            </button>
          )}
        </div>
      </div>

      {/* Children (nested layers for groups) */}
      {layer.type === 'group' && isExpanded && children && (
        <div>{children}</div>
      )}
    </div>
  )
}
</file>

<file path="src/components/Login.tsx">
import { useState } from 'react'
import type { FormEvent } from 'react'
import { signUp, signIn } from '../services/auth'

export default function Login() {
  const [isSignUp, setIsSignUp] = useState(false)
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [displayName, setDisplayName] = useState('')
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()
    setError('')

    // Validation
    if (!email || !password) {
      setError('Please fill in all required fields')
      return
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters')
      return
    }

    if (isSignUp && !displayName) {
      setError('Please enter your display name')
      return
    }

    setLoading(true)

    try {
      if (isSignUp) {
        await signUp(email, password, displayName)
      } else {
        await signIn(email, password)
      }
      // Success - auth state change will trigger redirect via useAuth
    } catch (err: any) {
      setError(err.message || 'Authentication failed')
    } finally {
      setLoading(false)
    }
  }

  const toggleMode = () => {
    setIsSignUp(!isSignUp)
    setError('')
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100">
      <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-md">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            CollabCanvas
          </h1>
          <p className="text-gray-600">
            {isSignUp ? 'Create your account' : 'Sign in to continue'}
          </p>
        </div>

        {/* Error Message */}
        {error && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
            {error}
          </div>
        )}

        {/* Form */}
        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Display Name (Sign Up Only) */}
          {isSignUp && (
            <div>
              <label
                htmlFor="displayName"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Display Name
              </label>
              <input
                id="displayName"
                type="text"
                value={displayName}
                onChange={(e) => setDisplayName(e.target.value)}
                placeholder="Enter your name"
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                required={isSignUp}
                disabled={loading}
              />
            </div>
          )}

          {/* Email */}
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700 mb-1"
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Enter your email"
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
              required
              disabled={loading}
            />
          </div>

          {/* Password */}
          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700 mb-1"
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Enter your password"
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
              required
              minLength={6}
              disabled={loading}
            />
            <p className="text-xs text-gray-500 mt-1">
              Must be at least 6 characters
            </p>
          </div>

          {/* Submit Button */}
          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 px-4 rounded-lg font-medium hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition"
          >
            {loading ? (
              <span className="flex items-center justify-center">
                <svg
                  className="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    className="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    strokeWidth="4"
                  ></circle>
                  <path
                    className="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  ></path>
                </svg>
                Processing...
              </span>
            ) : isSignUp ? (
              'Sign Up'
            ) : (
              'Sign In'
            )}
          </button>
        </form>

        {/* Toggle Mode */}
        <div className="mt-6 text-center">
          <button
            type="button"
            onClick={toggleMode}
            disabled={loading}
            className="text-blue-600 hover:text-blue-700 font-medium text-sm disabled:opacity-50"
          >
            {isSignUp
              ? 'Already have an account? Sign In'
              : "Don't have an account? Sign Up"}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/PresenceBar.tsx">
import { useState, useRef, useEffect } from 'react'
import { logOut } from '../services/auth'
import type { Presence } from '../types/firebase'
import { ZoomControls } from './ui/ZoomControls'
import { Tooltip } from './ui/Tooltip'

interface PresenceBarProps {
  currentUser: {
    displayName: string | null
    email: string | null
  }
  otherUsers: Map<string, Presence>
  // PR-20: Zoom controls
  scale?: number
  onZoomIn?: () => void
  onZoomOut?: () => void
  onZoomReset?: () => void
  onZoomFit?: () => void
  // Back button
  onBack?: () => void
  // Tilemap mode toggle
  isTilemapMode?: boolean
  onToggleTilemapMode?: () => void
  // Asset Library toggle
  onToggleAssetLibrary?: () => void
  // Import/Export functions (available for both modes)
  onImport?: (format: 'json' | 'png' | 'tilemap') => void
  onExport?: (format: 'json' | 'png' | 'svg' | 'tilemap' | 'godot' | 'unity') => void
  // Legacy export functions (for backward compatibility)
  onExportJSON?: () => void
  onExportPNG?: () => void
  // Theme prop (always grey theme now)
  collabTheme?: {
    primary: string
    secondary: string
    gradient: string
    displayName: string
    softBg: string
    softBorder: string
  } | null
}

/**
 * PresenceBar - Professional Figma-style header (PR-20)
 * 64px height, white background, with back button, canvas name, zoom controls, and user presence
 */
export default function PresenceBar({ 
  currentUser, 
  otherUsers,
  scale = 1,
  onZoomIn = () => {},
  onZoomOut = () => {},
  onZoomReset = () => {},
  onZoomFit = () => {},
  onBack,
  isTilemapMode = false,
  onToggleTilemapMode,
  onToggleAssetLibrary,
  onImport,
  onExport,
  onExportJSON,
  onExportPNG,
  collabTheme = {
    primary: '#475569',
    secondary: '#374151',
    gradient: 'from-slate-600 to-gray-700',
    displayName: '',
    softBg: 'rgba(71, 85, 105, 0.3)',
    softBorder: 'rgba(71, 85, 105, 0.4)'
  },
}: PresenceBarProps) {
  const [showImportMenu, setShowImportMenu] = useState(false)
  const [showExportMenu, setShowExportMenu] = useState(false)
  const importMenuRef = useRef<HTMLDivElement>(null)
  const exportMenuRef = useRef<HTMLDivElement>(null)

  const handleLogout = async () => {
    try {
      await logOut()
    } catch (error) {
      console.error('Logout failed:', error)
    }
  }

  // Close dropdowns when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (importMenuRef.current && !importMenuRef.current.contains(event.target as Node)) {
        setShowImportMenu(false)
      }
      if (exportMenuRef.current && !exportMenuRef.current.contains(event.target as Node)) {
        setShowExportMenu(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Combine current user with other users for display
  const allUsers = [
    {
      name: currentUser.displayName || currentUser.email || 'You',
      color: '#3B82F6', // Blue for current user
      isSelf: true,
    },
    ...Array.from(otherUsers.values()).map((presence) => ({
      name: presence.n,
      color: presence.cl,
      isSelf: false,
    })),
  ]

  return (
    <div 
      className="fixed top-0 left-0 right-0 h-12 shadow-sm z-50 flex items-center justify-between px-8 relative overflow-hidden bg-gradient-to-br from-slate-900/95 to-slate-800/95 backdrop-blur-md"
    >
      {/* Dot pattern overlay */}
      <div 
        className="absolute inset-0" 
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>

      {/* Content wrapper */}
      <div className="relative z-10 w-full flex items-center justify-between gap-6">
      {/* Left Section: Title only */}
      <div className="flex items-center gap-3">
        {onBack && (
              <button
                type="button"
                onClick={onBack}
                className={`w-5 h-5 flex items-center justify-center rounded transition-colors ${
              collabTheme 
                ? 'hover:bg-white/20 text-white' 
                : 'hover:bg-neutral-100 text-neutral-700'
            }`}
            title="Back to dashboard"
          >
            <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          </button>
        )}
        
        <div className="text-[24px] font-bold text-white">
          CollabCanvas
        </div>
      </div>

      {/* Right Section: All controls right-aligned */}
      <div className="flex items-center gap-2">
        <ZoomControls
          scale={scale}
          onZoomIn={onZoomIn}
          onZoomOut={onZoomOut}
          onZoomReset={onZoomReset}
          onZoomFit={onZoomFit}
          collabTheme={collabTheme}
        />
        
        {/* Separator */}
        <div className="w-px h-4 bg-white/20 mx-1" />
        
        {/* Tilemap Mode Toggle */}
        {onToggleTilemapMode && (
          <button
            onClick={onToggleTilemapMode}
            className={`h-7 px-2.5 rounded font-medium text-[9px] transition-all flex items-center ${
              isTilemapMode
                ? 'bg-white/30 text-white hover:bg-white/40 shadow-sm ring-1 ring-white/20'
                : 'bg-white/15 text-white/90 hover:bg-white/25'
            }`}
            title={isTilemapMode ? 'Switch to Shape Mode' : 'Switch to Tilemap Mode'}
          >
            {isTilemapMode ? 'Shapes' : 'Tilemap'}
          </button>
        )}
        
        {/* Asset Library Toggle */}
        {onToggleAssetLibrary && (
          <button
            onClick={onToggleAssetLibrary}
            className="h-7 px-2.5 rounded font-medium text-[9px] transition-all flex items-center gap-1 bg-white/15 text-white/90 hover:bg-white/25"
            title="Open Asset Library"
          >
            <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            Assets
          </button>
        )}
        
        {/* Import/Export Buttons */}
        {(onImport || onExport || onExportJSON) && (
          <>
            <div className="w-px h-4 bg-white/20 mx-1" />
            <div className="flex items-center gap-1.5">
              {/* Import Dropdown */}
              {onImport && (
                <div className="relative" ref={importMenuRef}>
                  <button
                    onClick={() => setShowImportMenu(!showImportMenu)}
                    className="h-7 px-2.5 rounded font-medium text-[9px] transition-all bg-white/15 text-white hover:bg-white/25 flex items-center gap-1"
                  >
                    Import
                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>
                  
                  {showImportMenu && (
                    <div className="absolute top-full mt-1 right-0 bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[120px] z-50">
                      <button
                        onClick={() => {
                          onImport('json')
                          setShowImportMenu(false)
                        }}
                        className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                      >
                        JSON
                      </button>
                      <button
                        onClick={() => {
                          onImport('png')
                          setShowImportMenu(false)
                        }}
                        className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                      >
                        PNG/Image
                      </button>
                      <button
                        onClick={() => {
                          onImport('tilemap')
                          setShowImportMenu(false)
                        }}
                        className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                      >
                        Tilemap JSON
                      </button>
                    </div>
                  )}
                </div>
              )}

              {/* Export Dropdown */}
              {(onExport || onExportJSON) && (
                <div className="relative" ref={exportMenuRef}>
                  <button
                    onClick={() => setShowExportMenu(!showExportMenu)}
                    className="h-7 px-2.5 rounded font-medium text-[9px] transition-all bg-white/15 text-white hover:bg-white/25 flex items-center gap-1"
                  >
                    Export
                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>
                  
                  {showExportMenu && (
                    <div className="absolute top-full mt-1 right-0 bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[140px] z-50">
                      <button
                        onClick={() => {
                          if (onExport) onExport('json')
                          else if (onExportJSON) onExportJSON()
                          setShowExportMenu(false)
                        }}
                        className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                      >
                        JSON
                      </button>
                      <button
                        onClick={() => {
                          if (onExport) onExport('png')
                          else if (onExportPNG) onExportPNG()
                          setShowExportMenu(false)
                        }}
                        className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                      >
                        PNG
                      </button>
                      <button
                        onClick={() => {
                          if (onExport) onExport('svg')
                          setShowExportMenu(false)
                        }}
                        className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                      >
                        SVG
                      </button>
                      {isTilemapMode && (
                        <>
                          <div className="my-1 border-t border-gray-200" />
                          <div className="px-3 py-1 text-[8px] text-gray-500 uppercase font-semibold">
                            Game Engines
                          </div>
                          <button
                            onClick={() => {
                              if (onExport) onExport('godot')
                              setShowExportMenu(false)
                            }}
                            className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                          >
                            Godot (.tscn)
                          </button>
                          <button
                            onClick={() => {
                              if (onExport) onExport('unity')
                              setShowExportMenu(false)
                            }}
                            className="w-full px-3 py-1.5 text-left text-xs text-gray-700 hover:bg-gray-100 transition-colors"
                          >
                            Unity (.prefab)
                          </button>
                        </>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>
          </>
        )}
        
        {/* Separator before users */}
        <div className="w-px h-4 bg-white/20 mx-1" />
        
        {/* User avatars */}
        <div className="flex items-center -space-x-1.5">
          {allUsers.slice(0, 5).map((user, index) => (
            <Tooltip key={index} content={user.name + (user.isSelf ? ' (You)' : '')} side="bottom">
              <div
                className="w-7 h-7 rounded-full border border-white flex items-center justify-center text-white text-[10px] font-medium shadow-sm"
                style={{ 
                  backgroundColor: user.color,
                  zIndex: allUsers.length - index 
                }}
              >
                {user.name.charAt(0).toUpperCase()}
              </div>
            </Tooltip>
          ))}
          {allUsers.length > 5 && (
            <Tooltip content={`${allUsers.length - 5} more users`} side="bottom">
              <div className="w-7 h-7 rounded-full border border-white bg-white/20 flex items-center justify-center text-white text-[10px] font-medium shadow-sm">
                +{allUsers.length - 5}
              </div>
            </Tooltip>
          )}
        </div>

        {/* Separator */}
        <div className="w-px h-4 bg-white/20 mx-1" />

        {/* Logout Button */}
        <button
          onClick={handleLogout}
          className="h-7 px-2.5 text-[9px] font-medium rounded transition-all bg-white/15 text-white hover:bg-white/25 flex items-center"
          title="Sign out"
        >
          Logout
        </button>
      </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/ProtectedRoute.tsx">
import type { ReactNode } from 'react'
import { useAuth } from '../hooks/useAuth'
import Login from './Login'

interface ProtectedRouteProps {
  children: ReactNode
}

/**
 * ProtectedRoute - Wrapper component that requires authentication
 * Shows Login component if user is not authenticated
 * Shows loading state while checking auth
 */
export default function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { user, loading } = useAuth()

  // Show loading spinner while checking auth state
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100">
        <div className="text-center">
          <svg
            className="animate-spin h-12 w-12 text-blue-600 mx-auto mb-4"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          <p className="text-gray-600 text-lg">Loading...</p>
        </div>
      </div>
    )
  }

  // Show login if not authenticated
  if (!user) {
    return <Login />
  }

  // User is authenticated, show protected content
  return <>{children}</>
}
</file>

<file path="src/components/QuickActionsPopup.tsx">
/**
 * QuickActionsPopup - Tiny popup with quick object actions
 * Appears next to selected shape for layer/object operations
 */

import { useEffect, useRef } from 'react'

interface QuickActionsPopupProps {
  screenX: number
  screenY: number
  selectedCount: number
  canGroup: boolean
  onBringToFront: () => void
  onSendToBack: () => void
  onBringForward: () => void
  onSendBackward: () => void
  onGroup: () => void
  onUngroup: () => void
  onDuplicate: () => void
  onDelete: () => void
  onClose: () => void
}

export function QuickActionsPopup({
  screenX,
  screenY,
  selectedCount,
  canGroup,
  onBringToFront,
  onSendToBack,
  onBringForward,
  onSendBackward,
  onGroup,
  onUngroup,
  onDuplicate,
  onDelete,
  onClose,
}: QuickActionsPopupProps) {
  const popupRef = useRef<HTMLDivElement>(null)

  // Close on click outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (popupRef.current && !popupRef.current.contains(e.target as Node)) {
        onClose()
      }
    }
    setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside)
    }, 0)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [onClose])

  // Close on Escape
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [onClose])

  const handleAction = (action: () => void) => {
    action()
    onClose()
  }

  return (
    <div
      ref={popupRef}
      className="fixed bg-white rounded-md shadow-2xl border border-gray-300 z-50 py-0.5"
      style={{
        left: Math.min(screenX + 10, window.innerWidth - 150),
        top: Math.min(screenY - 10, window.innerHeight - 300),
      }}
    >
      {/* Layer Order */}
      <button
        onClick={() => handleAction(onBringToFront)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">⬆️</span>
        Bring to Front
      </button>
      <button
        onClick={() => handleAction(onBringForward)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">↑</span>
        Bring Forward
      </button>
      <button
        onClick={() => handleAction(onSendBackward)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">↓</span>
        Send Backward
      </button>
      <button
        onClick={() => handleAction(onSendToBack)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">⬇️</span>
        Send to Back
      </button>

      <div className="border-t border-gray-200" />

      {/* Group Operations */}
      {selectedCount >= 2 && (
        <>
          {canGroup && (
            <button
              onClick={() => handleAction(onGroup)}
              className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
            >
              <span className="text-xs">📦</span>
              Group
            </button>
          )}
          <button
            onClick={() => handleAction(onUngroup)}
            className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
          >
            <span className="text-xs">📂</span>
            Ungroup
          </button>
          <div className="border-t border-gray-200" />
        </>
      )}

      {/* Actions */}
      <button
        onClick={() => handleAction(onDuplicate)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">📋</span>
        Duplicate
      </button>
      <button
        onClick={() => handleAction(onDelete)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-red-50 text-red-600 flex items-center gap-1.5"
      >
        <span className="text-xs">🗑️</span>
        Delete
      </button>
    </div>
  )
}
</file>

<file path="src/components/QuickPropertiesPopup.tsx">
/**
 * QuickPropertiesPopup - Compact properties tooltip near selected shape
 * Small, tablet-style window that appears next to shape for quick edits
 */

import { useState, useEffect, useRef } from 'react'
import type { Shape } from '../types/canvas'

interface QuickPropertiesPopupProps {
  shape: Shape
  screenX: number
  screenY: number
  onUpdateColors: (fill?: string, stroke?: string, strokeWidth?: number) => void
  onOpenFullPanel: () => void
  onClose: () => void
}

export function QuickPropertiesPopup({
  shape,
  screenX,
  screenY,
  onUpdateColors,
  onOpenFullPanel,
  onClose,
}: QuickPropertiesPopupProps) {
  const [localFill, setLocalFill] = useState(shape.fill || '#3B82F6FF')
  const [localStroke, setLocalStroke] = useState(shape.stroke || '#000000FF')
  const [localStrokeWidth, setLocalStrokeWidth] = useState(shape.strokeWidth || 0)
  const popupRef = useRef<HTMLDivElement>(null)

  // Close on click outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (popupRef.current && !popupRef.current.contains(e.target as Node)) {
        onClose()
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [onClose])

  // Close on Escape
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [onClose])

  const handleFillChange = (color: string) => {
    setLocalFill(color)
    onUpdateColors(color, undefined, undefined)
  }

  const handleStrokeChange = (color: string) => {
    setLocalStroke(color)
    onUpdateColors(undefined, color, undefined)
  }

  const handleStrokeWidthChange = (width: number) => {
    setLocalStrokeWidth(width)
    onUpdateColors(undefined, undefined, width)
  }

  // Extract RGB and opacity from hex color
  const getRGBFromHex = (hex: string) => {
    const rgb = hex.slice(1, 7)
    const alpha = hex.slice(7, 9) || 'FF'
    return { rgb: `#${rgb}`, opacity: parseInt(alpha, 16) / 255 }
  }

  const fillData = getRGBFromHex(localFill)
  const strokeData = getRGBFromHex(localStroke)

  return (
    <div
      ref={popupRef}
      className="fixed bg-white rounded-lg shadow-2xl border border-gray-300 z-50 p-2"
      style={{
        left: Math.min(screenX + 10, window.innerWidth - 220),
        top: Math.min(screenY - 10, window.innerHeight - 200),
        width: '200px',
      }}
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-2 pb-1 border-b border-gray-200">
        <span className="text-xs font-semibold text-gray-700 uppercase tracking-wide">
          {shape.type}
        </span>
        <button
          onClick={onClose}
          className="text-gray-400 hover:text-gray-600 p-0.5"
          title="Close (Esc)"
        >
          <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Fill Color */}
      <div className="mb-2">
        <label className="text-xs font-medium text-gray-600 block mb-1">Fill</label>
        <div className="flex items-center gap-1.5">
          <input
            type="color"
            value={fillData.rgb}
            onChange={(e) => handleFillChange(e.target.value + localFill.slice(7))}
            className="w-8 h-6 rounded border border-gray-300 cursor-pointer"
          />
          <input
            type="text"
            value={localFill.slice(0, 7).toUpperCase()}
            onChange={(e) => {
              if (/^#[0-9A-F]{0,6}$/i.test(e.target.value)) {
                handleFillChange(e.target.value.padEnd(7, '0') + localFill.slice(7))
              }
            }}
            className="flex-1 px-1.5 py-0.5 text-xs border border-gray-300 rounded"
            maxLength={7}
          />
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={fillData.opacity}
            onChange={(e) => {
              const alpha = Math.round(parseFloat(e.target.value) * 255).toString(16).padStart(2, '0')
              handleFillChange(localFill.slice(0, 7) + alpha.toUpperCase())
            }}
            className="w-12 h-1"
            title={`Opacity: ${Math.round(fillData.opacity * 100)}%`}
          />
        </div>
      </div>

      {/* Stroke Color */}
      <div className="mb-2">
        <label className="text-xs font-medium text-gray-600 block mb-1">Stroke</label>
        <div className="flex items-center gap-1.5">
          <input
            type="color"
            value={strokeData.rgb}
            onChange={(e) => handleStrokeChange(e.target.value + localStroke.slice(7))}
            className="w-8 h-6 rounded border border-gray-300 cursor-pointer"
          />
          <input
            type="text"
            value={localStroke.slice(0, 7).toUpperCase()}
            onChange={(e) => {
              if (/^#[0-9A-F]{0,6}$/i.test(e.target.value)) {
                handleStrokeChange(e.target.value.padEnd(7, '0') + localStroke.slice(7))
              }
            }}
            className="flex-1 px-1.5 py-0.5 text-xs border border-gray-300 rounded"
            maxLength={7}
          />
        </div>
      </div>

      {/* Stroke Width */}
      <div className="mb-2">
        <label className="text-xs font-medium text-gray-600 block mb-1">
          Width: {localStrokeWidth}px
        </label>
        <input
          type="range"
          min="0"
          max="20"
          step="1"
          value={localStrokeWidth}
          onChange={(e) => handleStrokeWidthChange(parseInt(e.target.value))}
          className="w-full h-1"
        />
      </div>

      {/* Position Info */}
      <div className="mb-2 pb-2 border-b border-gray-200">
        <div className="text-xs text-gray-500 flex justify-between">
          <span>X: {Math.round(shape.x)}</span>
          <span>Y: {Math.round(shape.y)}</span>
          <span>W: {Math.round(shape.width || 0)}</span>
          <span>H: {Math.round(shape.height || 0)}</span>
        </div>
      </div>

      {/* More Options Button */}
      <button
        onClick={onOpenFullPanel}
        className="w-full py-1 text-xs font-medium text-blue-600 hover:bg-blue-50 rounded transition-colors"
      >
        More Options →
      </button>
    </div>
  )
}
</file>

<file path="src/components/shapes/Circle.tsx">
import { useRef, useEffect } from 'react'
import { Circle as KonvaCircle, Transformer } from 'react-konva'
import type Konva from 'konva'

interface CircleProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}

/**
 * Circle shape component
 * Variable size (ellipse), customizable colors, with Transformer for resize/rotate
 * Supports multi-select highlighting
 */
export default function Circle({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: CircleProps) {
  const shapeRef = useRef<Konva.Circle>(null)
  const trRef = useRef<Konva.Transformer>(null)

  const radiusX = width / 2
  const radiusY = height / 2

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to radius instead
    node.scaleX(1)
    node.scaleY(1)

    const radius = node.radius()
    onTransformEnd(
      Math.max(10, radius * 2 * scaleX), // min width 10px
      Math.max(10, radius * 2 * scaleY), // min height 10px
      node.rotation(),
      node.x() - radius * scaleX, // adjust x for radius change
      node.y() - radius * scaleY  // adjust y for radius change
    )
  }

  return (
    <>
      {/* Main Circle (positioned at center, so offset by radius) */}
      <KonvaCircle
        ref={shapeRef}
        x={x + radiusX}
        y={y + radiusY}
        radiusX={radiusX}
        radiusY={radiusY}
        rotation={rotation}
        fill={fill}
        stroke={stroke || '#000000'}
        strokeWidth={strokeWidth || 0}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for resize/rotate handles - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum size
            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }
            // Limit maximum size to canvas bounds
            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Line.tsx">
import { useRef, useEffect } from 'react'
import { Line as KonvaLine, Arrow, Transformer } from 'react-konva'
import type Konva from 'konva'

interface LineProps {
  id: string
  points: number[] // [x1, y1, x2, y2]
  fill: string // used for line color
  stroke?: string
  strokeWidth?: number
  arrows?: { start?: boolean; end?: boolean }
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (points: number[], x: number, y: number) => void
}

/**
 * Line shape component
 * Supports optional start/end arrows
 * Transformable with Transformer
 */
export default function Line({
  id: _id,
  points,
  fill,
  stroke: _stroke,
  strokeWidth = 2,
  arrows,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: LineProps) {
  const shapeRef = useRef<Konva.Line | Konva.Arrow>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Calculate position from points (use first point as position)
  const x = points[0]
  const y = points[1]
  
  // Convert absolute points to relative points
  const relativePoints = [0, 0, points[2] - points[0], points[3] - points[1]]

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale
    node.scaleX(1)
    node.scaleY(1)

    // Get current points and scale them
    const currentPoints = (node as any).points() || relativePoints
    const newPoints = [
      currentPoints[0],
      currentPoints[1],
      currentPoints[2] * scaleX,
      currentPoints[3] * scaleY,
    ]

    // Convert back to absolute coordinates
    const absPoints = [
      node.x() + newPoints[0],
      node.y() + newPoints[1],
      node.x() + newPoints[2],
      node.y() + newPoints[3],
    ]

    onTransformEnd(absPoints, node.x(), node.y())
  }

  // Determine if we should use Arrow or Line component
  const hasArrows = arrows?.start || arrows?.end

  // Use stroke prop if provided, otherwise fall back to fill
  const lineColor = _stroke || fill

  return (
    <>
      {hasArrows ? (
        <Arrow
          ref={shapeRef as any}
          x={x}
          y={y}
          points={relativePoints}
          stroke={lineColor}
          strokeWidth={strokeWidth}
          fill={lineColor}
          pointerAtBeginning={arrows.start}
          pointerAtEnding={arrows.end}
          pointerLength={10}
          pointerWidth={10}
          draggable
          onClick={onSelect}
          onTap={onSelect}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
          onTransformEnd={handleTransformEnd}
        />
      ) : (
        <KonvaLine
          ref={shapeRef as any}
          x={x}
          y={y}
          points={relativePoints}
          stroke={lineColor}
          strokeWidth={strokeWidth}
          lineCap="round"
          lineJoin="round"
          draggable
          onClick={onSelect}
          onTap={onSelect}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
          onTransformEnd={handleTransformEnd}
        />
      )}

      {/* Transformer for line endpoints - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(_oldBox, newBox) => {
            // Allow any size for lines
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={false}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Path.tsx">
/**
 * Path Component (PR-21)
 * Konva Line component for freehand drawing with pencil and pen tools
 */

import { useRef, useEffect } from 'react'
import { Line, Transformer } from 'react-konva'
import type Konva from 'konva'

interface PathProps {
  id: string
  points: number[] // [x1, y1, x2, y2, ...]
  stroke: string
  strokeWidth: number
  tension?: number // 0 = sharp (pencil), 0.5 = smooth (pen)
  closed?: boolean
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (points: number[], x: number, y: number) => void
}

/**
 * Path shape component for freehand drawing
 * Renders as Konva Line with tension control
 */
export default function Path({
  id: _id,
  points,
  stroke,
  strokeWidth,
  tension = 0,
  closed = false,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: PathProps) {
  const shapeRef = useRef<Konva.Line>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to points instead
    node.scaleX(1)
    node.scaleY(1)

    // Scale the points
    const currentPoints = node.points()
    const scaledPoints = currentPoints.map((point, index) => {
      if (index % 2 === 0) {
        // x coordinate
        return point * scaleX
      } else {
        // y coordinate
        return point * scaleY
      }
    })

    onTransformEnd(scaledPoints, node.x(), node.y())
  }

  return (
    <>
      {/* Main Path */}
      <Line
        ref={shapeRef}
        points={points}
        stroke={stroke}
        strokeWidth={strokeWidth}
        tension={tension}
        closed={closed}
        lineCap="round"
        lineJoin="round"
        bezier={tension > 0}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for resize/rotate handles */}
      {isSelected && (
        <Transformer
          ref={trRef}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Polygon.tsx">
import { useRef, useEffect } from 'react'
import { RegularPolygon, Transformer } from 'react-konva'
import type Konva from 'konva'

interface PolygonProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  sides: number // 3-12 sides
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}

/**
 * Polygon shape component
 * Regular polygon with 3-12 sides
 * Auto-cached when >6 sides for performance
 */
export default function Polygon({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  sides,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: PolygonProps) {
  const shapeRef = useRef<Konva.RegularPolygon>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Calculate radius from width/height (use average)
  const radius = (width + height) / 4

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  // Auto-cache for polygons with >6 sides (performance optimization)
  useEffect(() => {
    if (shapeRef.current && sides > 6) {
      shapeRef.current.cache()
    }
  }, [sides])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to radius instead
    node.scaleX(1)
    node.scaleY(1)

    // Calculate new width/height from scaled radius
    const newRadius = node.radius() * Math.max(scaleX, scaleY)
    const newWidth = newRadius * 2
    const newHeight = newRadius * 2

    onTransformEnd(
      Math.max(10, newWidth),
      Math.max(10, newHeight),
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {/* Main Polygon */}
      <RegularPolygon
        ref={shapeRef}
        x={x + radius}
        y={y + radius}
        sides={Math.max(3, Math.min(12, sides))}
        radius={radius}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for resize/rotate handles - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum size
            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }
            // Limit maximum size to canvas bounds
            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Rectangle.tsx">
import { useRef, useEffect } from 'react'
import { Rect, Transformer } from 'react-konva'
import type Konva from 'konva'

interface RectangleProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}

/**
 * Rectangle shape component
 * Variable size, customizable colors, with Transformer for resize/rotate
 * Supports multi-select highlighting
 */
export default function Rectangle({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: RectangleProps) {
  const shapeRef = useRef<Konva.Rect>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to width/height instead
    node.scaleX(1)
    node.scaleY(1)

    onTransformEnd(
      Math.max(10, node.width() * scaleX), // min width 10px
      Math.max(10, node.height() * scaleY), // min height 10px
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {/* Main Rectangle */}
      <Rect
        ref={shapeRef}
        x={x}
        y={y}
        width={width}
        height={height}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for resize/rotate handles - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum size
            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }
            // Limit maximum size to canvas bounds
            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/RoundedRect.tsx">
import { useRef, useEffect } from 'react'
import { Rect, Transformer } from 'react-konva'
import type Konva from 'konva'

interface RoundedRectProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  cornerRadius: number // 0-50px
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}

/**
 * Rounded Rectangle shape component
 * Rectangle with adjustable corner radius (0-50px)
 * Supports fill, stroke, resize, and rotate
 */
export default function RoundedRect({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  cornerRadius,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: RoundedRectProps) {
  const shapeRef = useRef<Konva.Rect>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to width/height instead
    node.scaleX(1)
    node.scaleY(1)

    onTransformEnd(
      Math.max(10, node.width() * scaleX), // min width 10px
      Math.max(10, node.height() * scaleY), // min height 10px
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {/* Main Rounded Rectangle */}
      <Rect
        ref={shapeRef}
        x={x}
        y={y}
        width={width}
        height={height}
        cornerRadius={Math.max(0, Math.min(50, cornerRadius))}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for resize/rotate handles - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum size
            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }
            // Limit maximum size to canvas bounds
            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/SelectionBox.tsx">
import { memo } from 'react'
import { Rect } from 'react-konva'
import { getSelectionBoxBounds } from '../../types/selection'
import type { SelectionBox as SelectionBoxType } from '../../types/selection'

interface SelectionBoxProps {
  selectionBox: SelectionBoxType
}

/**
 * SelectionBox Component
 * 
 * Visual indicator for drag-to-select (marquee selection)
 * Shows a dashed rectangle with semi-transparent fill while dragging
 * Optimized with React.memo to prevent unnecessary re-renders
 */
export const SelectionBox = memo(function SelectionBox({ selectionBox }: SelectionBoxProps) {
  // Only render if selection box is visible
  if (!selectionBox.visible) {
    return null
  }

  // Calculate actual bounds (handles any drag direction)
  const bounds = getSelectionBoxBounds(selectionBox)

  return (
    <Rect
      x={bounds.x}
      y={bounds.y}
      width={bounds.width}
      height={bounds.height}
      fill="rgba(59, 130, 246, 0.1)" // semi-transparent blue (#3B82F6 at 10% opacity)
      stroke="#3B82F6" // solid blue border
      strokeWidth={1}
      dash={[5, 5]} // dashed border (5px dash, 5px gap)
      listening={false} // don't capture mouse events
      perfectDrawEnabled={false} // optimize rendering
    />
  )
})
</file>

<file path="src/components/shapes/Star.tsx">
import { useRef, useEffect } from 'react'
import { Star as KonvaStar, Transformer } from 'react-konva'
import type Konva from 'konva'

interface StarProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  sides: number // 3-12 points (referred to as "points" in UI but stored as sides)
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}

/**
 * Star shape component
 * Star with 3-12 points
 * Auto-cached when >6 points for performance
 */
export default function Star({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  sides,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: StarProps) {
  const shapeRef = useRef<Konva.Star>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Calculate outer and inner radius from width/height
  const outerRadius = (width + height) / 4
  const innerRadius = outerRadius * 0.5 // Inner radius is 50% of outer

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  // Auto-cache for stars with >6 points (performance optimization)
  useEffect(() => {
    if (shapeRef.current && sides > 6) {
      shapeRef.current.cache()
    }
  }, [sides])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()

    // Reset scale to 1 and apply to radius instead
    node.scaleX(1)
    node.scaleY(1)

    // Calculate new width/height from scaled radius
    const newOuterRadius = node.outerRadius() * Math.max(scaleX, scaleY)
    const newWidth = newOuterRadius * 2
    const newHeight = newOuterRadius * 2

    onTransformEnd(
      Math.max(10, newWidth),
      Math.max(10, newHeight),
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {/* Main Star */}
      <KonvaStar
        ref={shapeRef}
        x={x + outerRadius}
        y={y + outerRadius}
        numPoints={Math.max(3, Math.min(12, sides))}
        innerRadius={innerRadius}
        outerRadius={outerRadius}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for resize/rotate handles - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum size
            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }
            // Limit maximum size to canvas bounds
            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/TextShape.tsx">
import { useRef, useEffect } from 'react'
import { Text, Transformer } from 'react-konva'
import type Konva from 'konva'

interface TextShapeProps {
  id: string
  x: number
  y: number
  text: string
  width: number
  height: number
  rotation?: number
  fill: string
  isSelected: boolean
  selectionColor?: string
  // PR-25: Text formatting properties
  fontFamily?: string
  fontSize?: number
  fontWeight?: 'normal' | 'bold'
  fontStyle?: 'normal' | 'italic'
  textAlign?: 'left' | 'center' | 'right'
  textDecoration?: '' | 'underline' | 'line-through'
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
  onDoubleClick?: () => void // PR-25: Double-click to edit
}

/**
 * Text shape component (PR-25: Enhanced with text formatting)
 * Customizable color, font properties, editable on double-click
 * Resizable (width) but NO rotation
 * Supports multi-select highlighting
 */
export default function TextShape({
  id: _id,
  x,
  y,
  text,
  width,
  height: _height,
  rotation = 0,
  fill,
  isSelected,
  selectionColor: _selectionColor,
  fontFamily = 'Inter, sans-serif',
  fontSize = 20,
  fontWeight = 'normal',
  fontStyle = 'normal',
  textAlign = 'left',
  textDecoration = '',
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
  onDoubleClick,
}: TextShapeProps) {
  const shapeRef = useRef<Konva.Text>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()

    // Reset scale to 1 and apply to width instead
    node.scaleX(1)
    node.scaleY(1)

    // Text height auto-adjusts based on content and width
    onTransformEnd(
      Math.max(50, node.width() * scaleX), // min width 50px
      node.height(), // auto-calculated by Konva
      0, // no rotation for text
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {/* Main Text - PR-25: Now with font properties and double-click */}
      <Text
        ref={shapeRef}
        x={x}
        y={y}
        text={text}
        fontSize={fontSize}
        fontFamily={fontFamily}
        fontStyle={`${fontStyle} ${fontWeight}`} // Konva combines style and weight
        textDecoration={textDecoration}
        align={textAlign}
        fill={fill}
        width={width}
        rotation={rotation}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDblClick={onDoubleClick}
        onDblTap={onDoubleClick}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for width resize only (no rotation for text) - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum width
            if (newBox.width < 50) {
              return oldBox
            }
            // Limit maximum width to canvas bounds
            if (newBox.width > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'middle-left',
            'middle-right',
          ]}
          rotateEnabled={false}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/TextEditor.tsx">
import React, { useState, useRef, useEffect } from 'react'

/**
 * TextEditor Component (PR-25)
 * Contenteditable overlay for editing text shapes on double-click
 */

interface TextEditorProps {
  initialText: string
  x: number // screen position (already transformed by viewport)
  y: number
  width: number
  fontFamily?: string
  fontSize?: number
  fontWeight?: 'normal' | 'bold'
  fontStyle?: 'normal' | 'italic'
  textAlign?: 'left' | 'center' | 'right'
  fill: string
  onSave: (newText: string) => void
  onCancel: () => void
}

export const TextEditor: React.FC<TextEditorProps> = ({
  initialText,
  x,
  y,
  width,
  fontFamily = 'Inter, sans-serif',
  fontSize = 20,
  fontWeight = 'normal',
  fontStyle = 'normal',
  textAlign = 'left',
  fill,
  onSave,
  onCancel,
}) => {
  const [text, setText] = useState(initialText)
  const editorRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    // Auto-focus and select all text
    if (editorRef.current) {
      editorRef.current.focus()
      
      // Select all text
      const range = document.createRange()
      range.selectNodeContents(editorRef.current)
      const selection = window.getSelection()
      selection?.removeAllRanges()
      selection?.addRange(range)
    }
  }, [])

  const handleBlur = () => {
    const trimmedText = text.trim()
    if (trimmedText && trimmedText !== initialText.trim()) {
      onSave(trimmedText)
    } else if (trimmedText) {
      // Text unchanged
      onCancel()
    } else {
      // Empty text - cancel
      onCancel()
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      e.preventDefault()
      onCancel()
    }
    // Allow Enter for multi-line text
  }

  const handleInput = (e: React.FormEvent<HTMLDivElement>) => {
    setText(e.currentTarget.textContent || '')
  }

  return (
    <div
      className="absolute bg-white border-2 border-blue-500 rounded shadow-lg z-[1000]"
      style={{
        left: x,
        top: y,
        width: width,
      }}
    >
      <div
        ref={editorRef}
        contentEditable
        suppressContentEditableWarning
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
        onInput={handleInput}
        className="px-2 py-1 min-h-[30px] outline-none whitespace-pre-wrap break-words overflow-hidden"
        style={{
          fontFamily,
          fontSize: `${fontSize}px`,
          fontWeight,
          fontStyle,
          textAlign: textAlign as any,
          color: fill.slice(0, 7), // Remove alpha for text color
          lineHeight: '1.2',
        }}
      >
        {initialText}
      </div>
      <div className="text-xs text-gray-500 px-2 pb-1 border-t bg-gray-50">
        Press Esc to cancel • Click outside to save
      </div>
    </div>
  )
}
</file>

<file path="src/components/tilemap/TilemapCanvas.tsx">
import { useRef, useState, useCallback, useEffect, useMemo } from 'react'
import { Stage, Layer } from 'react-konva'
import Konva from 'konva'
import type { ViewportTransform } from '../../types/canvas'
import type { TileMode, PaletteColor, TileData } from '../../types/tilemap'
import { useAuth } from '../../hooks/useAuth'
import { usePresence } from '../../hooks/usePresence'
import { useCanvasViewport } from '../../hooks/useCanvasViewport'
import { useTilemap } from '../../hooks/useTilemap'
import { coordToKey } from '../../types/tilemap'
import { createHistoryManager } from '../../services/canvas/commandHistory'
import { TileSetCommand, BulkTileCommand } from '../../commands/tile/TileCommand'
import { TileStrokeCommand } from '../../commands/tile/TileStrokeCommand'
import { TileFillCommand } from '../../commands/tile/TileFillCommand'
import { exportTilemapJSON, generateExportFilename } from '../../services/tilemap/tilemapExport'
import { DEFAULT_TILEMAP_PALETTE, hasSpriteAsset } from '../../constants/tilemapDefaults'
import { calculateTileVariant, calculateAutoTileUpdates } from '../../utils/tilemap/autoTile'
import Cursor from '../Cursor'
import TilemapGrid from './TilemapGrid'
import TileRenderer from './TileRenderer'
import TileStatusBar from './TileStatusBar'
import TilePalette from '../panels/TilePalette'

interface TilemapCanvasProps {
  canvasId: string
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
  onZoomControlsReady?: (zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => void
  onUndoRedoChange?: (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => void
  onExportFunctionsReady?: (exportJSON: () => void, exportPNG: () => void) => void
  // Tilemap state passed from parent
  tileMode: TileMode
  onTileModeChange: (mode: TileMode) => void
  brushSize: number
  onBrushSizeChange: (size: number) => void
  autoTilingEnabled: boolean
  onAutoTilingToggle: () => void
  showGrid: boolean
  onGridToggle: () => void
  selectedPaletteIndex: number
  onPaletteIndexChange: (index: number) => void
  selectedVariant?: number
  onVariantChange?: (variant: number | undefined) => void
  plainColor: string
  onPlainColorChange: (color: string) => void
  aiChat?: React.ReactNode // Optional AI chat component to render inline in status bar
}

const DEFAULT_PALETTE: PaletteColor[] = DEFAULT_TILEMAP_PALETTE

export default function TilemapCanvas({
  canvasId,
  onViewportChange,
  onZoomChange,
  onZoomControlsReady,
  onUndoRedoChange,
  onExportFunctionsReady,
  tileMode,
  onTileModeChange,
  brushSize,
  onBrushSizeChange,
  autoTilingEnabled,
  onAutoTilingToggle,
  showGrid,
  onGridToggle,
  selectedPaletteIndex,
  onPaletteIndexChange,
  selectedVariant,
  onVariantChange,
  plainColor,
  onPlainColorChange,
  aiChat,
}: TilemapCanvasProps) {
  const stageRef = useRef<Konva.Stage>(null)
  
  // Command history manager
  const historyManager = useMemo(() => createHistoryManager(), [])
  
  // State (only keep internal state, not toolbar-controlled state)
  const [tileSize, setTileSize] = useState(16)
  const [isPainting, setIsPainting] = useState(false)
  const [hoverTile, setHoverTile] = useState<{ x: number; y: number } | null>(null)
  const [isSpacePressed, setIsSpacePressed] = useState(false)
  const [lastPanPosition, setLastPanPosition] = useState<{ x: number; y: number } | null>(null)
  
  // Track stroke for bulk undo/redo
  const currentStrokeRef = useRef<Array<{ x: number; y: number; oldTile: TileData | undefined; newTile: TileData | null }>>([])
  
  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight

  // Viewport hook
  const {
    viewport,
    setViewport,
    handleWheel: baseHandleWheel,
    handleDragEnd,
    handleZoomIn,
    handleZoomOut,
    handleZoomReset,
    handleZoomFit,
  } = useCanvasViewport({
    containerWidth,
    containerHeight,
    onViewportChange,
    onZoomChange,
  })

  // Auth and presence
  const { user } = useAuth()
  const { otherUsers, updateCursorPosition } = usePresence({
    userId: user?.uid || '',
    userName: user?.displayName || user?.email || 'Anonymous',
    canvasId: canvasId,
  })

  // Tilemap hook
  const {
    tiles,
    meta,
    isConnected,
    connectionStatus,
    setTile,
    setTiles,
    deleteTile,
    deleteTiles,
    getTile,
    fillTiles,
    loadVisibleChunks,
  } = useTilemap({
    canvasId,
    userId: user?.uid || '',
  })

  // Load visible chunks whenever viewport changes
  useEffect(() => {
    if (!meta) return
    
    // Calculate viewport in canvas coordinates
    const viewportX = -viewport.x / viewport.scale
    const viewportY = -viewport.y / viewport.scale
    const viewportWidth = containerWidth / viewport.scale
    const viewportHeight = containerHeight / viewport.scale
    
    loadVisibleChunks({
      x: viewportX,
      y: viewportY,
      width: viewportWidth,
      height: viewportHeight,
    })
  }, [viewport.x, viewport.y, viewport.scale, containerWidth, containerHeight, meta, loadVisibleChunks])

  // Expose zoom controls - only on mount to avoid render-during-render
  useEffect(() => {
    if (onZoomControlsReady) {
      onZoomControlsReady(handleZoomIn, handleZoomOut, handleZoomReset, handleZoomFit)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Undo/Redo functions
  const handleUndo = useCallback(() => {
    historyManager.undo()
  }, [historyManager])

  const handleRedo = useCallback(() => {
    historyManager.redo()
  }, [historyManager])

  // Expose undo/redo state to parent
  useEffect(() => {
    if (onUndoRedoChange) {
      onUndoRedoChange(
        historyManager.canUndo(),
        historyManager.canRedo(),
        handleUndo,
        handleRedo
      )
    }
  }, [historyManager, onUndoRedoChange, handleUndo, handleRedo, tiles]) // Re-run when tiles change

  // Export functions
  const handleExportJSON = useCallback(() => {
    const exported = exportTilemapJSON(tiles, meta, user?.email || 'anonymous')
    const filename = generateExportFilename(canvasId)
    const blob = new Blob([JSON.stringify(exported, null, 2)], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  }, [tiles, meta, user?.email, canvasId])

  const handleExportPNG = useCallback(() => {
    if (!stageRef.current) return
    
    // Export the stage as PNG
    const uri = stageRef.current.toDataURL({ pixelRatio: 2 })
    const a = document.createElement('a')
    a.href = uri
    a.download = `${canvasId}-tilemap.png`
    a.click()
  }, [canvasId])

  // Expose export functions to parent
  useEffect(() => {
    if (onExportFunctionsReady) {
      onExportFunctionsReady(handleExportJSON, handleExportPNG)
    }
  }, [onExportFunctionsReady, handleExportJSON, handleExportPNG])

  // Get current palette selection
  const selectedPalette = DEFAULT_PALETTE[selectedPaletteIndex]
  const isPlainTile = selectedPalette?.type === 'plain'
  const effectiveColor = isPlainTile ? plainColor : selectedPalette?.color

  // Convert screen coordinates to tile coordinates
  const screenToTileCoords = useCallback((screenX: number, screenY: number): { x: number; y: number } => {
    const canvasX = (screenX - viewport.x) / viewport.scale
    const canvasY = (screenY - viewport.y) / viewport.scale
    const tileX = Math.floor(canvasX / tileSize)
    const tileY = Math.floor(canvasY / tileSize)
    return { x: tileX, y: tileY }
  }, [viewport, tileSize])

  // Get all tiles affected by the brush at a given position
  const getBrushTiles = useCallback((centerX: number, centerY: number): Array<{x: number, y: number}> => {
    const tiles: Array<{x: number, y: number}> = []
    const offset = Math.floor(brushSize / 2)
    
    for (let dy = 0; dy < brushSize; dy++) {
      for (let dx = 0; dx < brushSize; dx++) {
        tiles.push({
          x: centerX - offset + dx,
          y: centerY - offset + dy
        })
      }
    }
    
    return tiles
  }, [brushSize])

  // Handle painting/erasing tiles with command pattern
  const paintTileAt = useCallback((tileX: number, tileY: number, isStrokePainting: boolean = false) => {
    const affectedTiles = getBrushTiles(tileX, tileY)
    
    if (tileMode === 'stamp') {
      // Collect changes for all tiles in brush
      const changes: Array<{x: number, y: number, oldTile: TileData | undefined, newTile: TileData}> = []
      
      // Paint all tiles in the brush area
      affectedTiles.forEach(({x, y}) => {
        const oldTile = getTile(x, y)
        
        // Calculate variant if this tile type has sprite assets
        let variant: number | undefined
        if (hasSpriteAsset(selectedPalette.type)) {
          if (autoTilingEnabled) {
            // Auto-tiling: calculate based on neighbors
            variant = calculateTileVariant(x, y, tiles, selectedPalette.type)
          } else {
            // Manual mode: use selected variant or default to center (variant 4)
            variant = selectedVariant !== undefined ? selectedVariant : 4
          }
        }
        
        const newTile: TileData = {
          type: selectedPalette.type,
          color: effectiveColor,
          variant,
        }
        
        changes.push({x, y, oldTile, newTile})
        
        // Only update tiles immediately during stroke (for visual feedback)
        if (isStrokePainting) {
          setTile(x, y, newTile)
        }
      })
      
      // Collect neighbor variant updates if auto-tiling is enabled
      const neighborUpdates: Array<{x: number, y: number, oldTile: TileData, newTile: TileData}> = []
      if (autoTilingEnabled && hasSpriteAsset(selectedPalette.type)) {
        affectedTiles.forEach(({x, y}) => {
          const updates = calculateAutoTileUpdates(x, y, tiles, selectedPalette.type)
          updates.forEach(update => {
            const existingTile = getTile(update.x, update.y)
            if (existingTile && !affectedTiles.some(t => t.x === update.x && t.y === update.y)) {
              // Only update neighbors, not the tiles we just painted
              neighborUpdates.push({
                x: update.x,
                y: update.y,
                oldTile: existingTile,
                newTile: { ...existingTile, variant: update.variant }
              })
              
              // Apply immediately during stroke for visual feedback
              if (isStrokePainting) {
                setTile(update.x, update.y, { ...existingTile, variant: update.variant })
              }
            }
          })
        })
      }
      
      // Handle undo/redo
      if (isStrokePainting) {
        // Add both painted tiles and neighbor updates to stroke
        changes.forEach(change => {
          currentStrokeRef.current.push({ x: change.x, y: change.y, oldTile: change.oldTile, newTile: change.newTile })
        })
        neighborUpdates.forEach(update => {
          currentStrokeRef.current.push({ x: update.x, y: update.y, oldTile: update.oldTile, newTile: update.newTile })
        })
      } else {
        // Single click - combine painted tiles and neighbor updates
        const allChanges = [...changes, ...neighborUpdates]
        if (allChanges.length === 1) {
          const change = allChanges[0]
          const command = new TileSetCommand(change.x, change.y, change.oldTile, change.newTile, setTile, deleteTile)
          historyManager.executeCommand(command)
        } else {
          const command = new BulkTileCommand(allChanges, setTile, deleteTile)
          historyManager.executeCommand(command)
        }
      }
    } else if (tileMode === 'erase') {
      // Erase all tiles in brush area
      const changes: Array<{x: number, y: number, oldTile: TileData | undefined}> = []
      
      affectedTiles.forEach(({x, y}) => {
        const oldTile = getTile(x, y)
        if (oldTile) {
          changes.push({x, y, oldTile})
          
          // Apply immediately during stroke
          if (isStrokePainting) {
            deleteTile(x, y)
          }
        }
      })
      
      // Collect neighbor variant updates if auto-tiling is enabled
      const neighborUpdates: Array<{x: number, y: number, oldTile: TileData, newTile: TileData}> = []
      affectedTiles.forEach(({x, y}) => {
        const oldTile = getTile(x, y)
        if (oldTile && autoTilingEnabled && hasSpriteAsset(oldTile.type)) {
          const updates = calculateAutoTileUpdates(x, y, tiles, null)
          updates.forEach(update => {
            const existingTile = getTile(update.x, update.y)
            if (existingTile) {
              neighborUpdates.push({
                x: update.x,
                y: update.y,
                oldTile: existingTile,
                newTile: { ...existingTile, variant: update.variant }
              })
              
              // Apply immediately during stroke
              if (isStrokePainting) {
                setTile(update.x, update.y, { ...existingTile, variant: update.variant })
              }
            }
          })
        }
      })
      
      // Handle undo/redo
      if (isStrokePainting) {
        changes.forEach(change => {
          currentStrokeRef.current.push({ x: change.x, y: change.y, oldTile: change.oldTile, newTile: null })
        })
        neighborUpdates.forEach(update => {
          currentStrokeRef.current.push({ x: update.x, y: update.y, oldTile: update.oldTile, newTile: update.newTile })
        })
      } else {
        // Single click erase - combine deletions and neighbor updates
        const allChanges: Array<{x: number, y: number, oldTile: TileData | undefined, newTile: TileData | null}> = [
          ...changes.map(c => ({...c, newTile: null as null})),
          ...neighborUpdates.map(u => ({x: u.x, y: u.y, oldTile: u.oldTile as TileData | undefined, newTile: u.newTile as TileData | null}))
        ]
        
        if (allChanges.length > 0) {
          const command = new TileStrokeCommand(allChanges, setTiles, deleteTiles)
          historyManager.executeCommand(command)
        }
      }
    } else if (tileMode === 'fill') {
      // Fill mode - uses flood fill algorithm
      const targetTileKey = coordToKey(tileX, tileY)
      const targetTile = tiles.get(targetTileKey)
      const targetType = targetTile?.type || 'empty'
      
      // Collect all tiles that would be filled
      const fillChanges: Array<{ x: number; y: number; oldTile: TileData | undefined; newTile: TileData | null }> = []
      
      // Perform flood fill (this will modify tiles directly)
      // We need to track which tiles were changed
      const tilesBefore = new Map(tiles)
      fillTiles(tileX, tileY, targetType, selectedPalette.type, selectedPalette.color)
      
      // Calculate changes by comparing before/after
      // Note: This is a simplified approach - ideally floodFill would return the changes
      // For now, we'll create a fill command
      const command = new TileFillCommand(
        tileX,
        tileY,
        fillChanges, // Empty for now, fill will be re-executed
        setTiles,
        deleteTiles
      )
      
      // Override execute to use fillTiles
      command.execute = () => {
        fillTiles(tileX, tileY, targetType, selectedPalette.type, selectedPalette.color)
      }
      command.undo = () => {
        // TODO: Proper undo for fill - need to track affected tiles
        console.warn('Fill undo not yet implemented')
      }
      
      historyManager.executeCommand(command)
    } else if (tileMode === 'pick') {
      // Eyedropper mode - pick the color at this tile (no undo needed)
      const tileKey = coordToKey(tileX, tileY)
      const tile = tiles.get(tileKey)
      if (tile) {
        const paletteIndex = DEFAULT_PALETTE.findIndex(p => p.type === tile.type)
        if (paletteIndex !== -1) {
          onPaletteIndexChange(paletteIndex)
        }
      }
      onTileModeChange('stamp')
    }
  }, [tileMode, selectedPalette, selectedVariant, effectiveColor, autoTilingEnabled, brushSize, getBrushTiles, setTile, setTiles, deleteTile, deleteTiles, getTile, fillTiles, tiles, historyManager, onPaletteIndexChange, onTileModeChange])

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ignore if typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return
      }
      
      // Spacebar: Enable pan mode
      if (e.key === ' ' && !isSpacePressed) {
        e.preventDefault()
        setIsSpacePressed(true)
        return
      }
      
      // Number keys 1-9: Select palette
      if (e.key >= '1' && e.key <= '9') {
        const index = parseInt(e.key) - 1
        if (index < DEFAULT_PALETTE.length) {
          e.preventDefault()
          onPaletteIndexChange(index)
        }
      }
      
      // B: Stamp/Brush mode
      if (e.key === 'b' || e.key === 'B') {
        e.preventDefault()
        onTileModeChange('stamp')
      }
      
      // E: Erase mode
      if (e.key === 'e' || e.key === 'E') {
        e.preventDefault()
        onTileModeChange('erase')
      }
      
      // F: Fill mode
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault()
        onTileModeChange('fill')
      }
      
      // I: Pick/Eyedropper mode
      if (e.key === 'i' || e.key === 'I') {
        e.preventDefault()
        onTileModeChange('pick')
      }
      
      // G: Toggle grid
      if (e.key === 'g' || e.key === 'G') {
        e.preventDefault()
        onGridToggle()
      }
      
      // Ctrl+Z / Cmd+Z: Undo
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault()
        handleUndo()
      }
      
      // Ctrl+Y / Cmd+Y OR Ctrl+Shift+Z / Cmd+Shift+Z: Redo
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault()
        handleRedo()
      }
    }

    const handleKeyUp = (e: KeyboardEvent) => {
      // Spacebar: Disable pan mode
      if (e.key === ' ') {
        e.preventDefault()
        setIsSpacePressed(false)
        setLastPanPosition(null)
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)
    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
    }
  }, [showGrid, isSpacePressed, handleUndo, handleRedo, onPaletteIndexChange, onTileModeChange, onGridToggle])

  // Mouse handlers
  const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
    const stage = stageRef.current
    if (stage) {
      baseHandleWheel(e, stage)
    }
  }, [baseHandleWheel])

  const handleStageMouseDown = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    const stage = stageRef.current
    if (!stage) return

    // Only handle left mouse button
    if (e.evt.button !== 0) return

    const pointer = stage.getPointerPosition()
    if (!pointer) return

    // If spacebar is pressed, initialize panning (don't paint)
    if (isSpacePressed) {
      setLastPanPosition({ x: pointer.x, y: pointer.y })
      return
    }

    // Otherwise, start painting - clear stroke accumulator
    currentStrokeRef.current = []
    const { x: tileX, y: tileY } = screenToTileCoords(pointer.x, pointer.y)
    setIsPainting(true)
    
    // For fill mode, execute immediately (no stroke)
    if (tileMode === 'fill' || tileMode === 'pick') {
      paintTileAt(tileX, tileY, false)
    } else {
      // For stamp/erase, start stroke painting
      paintTileAt(tileX, tileY, true)
    }
  }, [screenToTileCoords, paintTileAt, isSpacePressed, tileMode])

  const handleStageMouseMove = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    const stage = stageRef.current
    if (!stage) return

    const pointer = stage.getPointerPosition()
    if (!pointer) return

    // If spacebar is pressed, enable panning (no click required)
    if (isSpacePressed) {
      if (lastPanPosition) {
        // Pan is active - calculate delta and update viewport
        const dx = pointer.x - lastPanPosition.x
        const dy = pointer.y - lastPanPosition.y
        
        setViewport(prev => ({
          ...prev,
          x: prev.x + dx,
          y: prev.y + dy
        }))
      }
      // Always update last position when spacebar is pressed
      setLastPanPosition({ x: pointer.x, y: pointer.y })
      return
    }

    const { x: tileX, y: tileY } = screenToTileCoords(pointer.x, pointer.y)
    
    // Update hover tile for preview (don't show hover when spacebar is pressed)
    setHoverTile({ x: tileX, y: tileY })
    
    // Continue painting if mouse is down and spacebar is not pressed
    if (isPainting && tileMode !== 'fill' && tileMode !== 'pick') {
      paintTileAt(tileX, tileY, true) // Stroke painting
    }

    // Update presence cursor
    const canvasX = (pointer.x - viewport.x) / viewport.scale
    const canvasY = (pointer.y - viewport.y) / viewport.scale
    updateCursorPosition(canvasX, canvasY)
  }, [screenToTileCoords, isPainting, tileMode, paintTileAt, viewport, updateCursorPosition, isSpacePressed, lastPanPosition, setViewport])

  const handleStageMouseUp = useCallback(() => {
    // Finalize stroke painting - create command for all accumulated changes
    if (isPainting && currentStrokeRef.current.length > 0) {
      const command = new TileStrokeCommand(
        currentStrokeRef.current,
        setTiles,
        deleteTiles
      )
      historyManager.executeCommand(command)
      currentStrokeRef.current = []
    }
    
    setIsPainting(false)
    setLastPanPosition(null)
  }, [isPainting, setTiles, deleteTiles, historyManager])

  const handleStageMouseLeave = useCallback(() => {
    // Finalize stroke if mouse leaves canvas
    if (isPainting && currentStrokeRef.current.length > 0) {
      const command = new TileStrokeCommand(
        currentStrokeRef.current,
        setTiles,
        deleteTiles
      )
      historyManager.executeCommand(command)
      currentStrokeRef.current = []
    }
    
    setIsPainting(false)
    setHoverTile(null)
  }, [isPainting, setTiles, deleteTiles, historyManager])

  // Right-click to erase
  const handleContextMenu = useCallback((e: Konva.KonvaEventObject<PointerEvent>) => {
    e.evt.preventDefault()
    
    const stage = stageRef.current
    if (!stage) return

    const pointer = stage.getPointerPosition()
    if (!pointer) return

    const { x: tileX, y: tileY } = screenToTileCoords(pointer.x, pointer.y)
    deleteTile(tileX, tileY)
  }, [screenToTileCoords, deleteTile])

  return (
    <div className="w-full h-full bg-gray-100 overflow-hidden relative">
      <div className="w-full h-full relative" style={{ cursor: lastPanPosition ? 'grabbing' : (isSpacePressed ? 'grab' : 'default') }}>
        <Stage
          ref={stageRef}
          width={containerWidth}
          height={containerHeight}
          draggable={false}
          onWheel={handleWheel}
          onMouseDown={handleStageMouseDown}
          onMouseMove={handleStageMouseMove}
          onMouseUp={handleStageMouseUp}
          onMouseLeave={handleStageMouseLeave}
          onContextMenu={handleContextMenu}
          x={viewport.x}
          y={viewport.y}
          scaleX={viewport.scale}
          scaleY={viewport.scale}
        >
          {/* Grid Layer */}
          <TilemapGrid
            tileSize={tileSize}
            viewportX={-viewport.x / viewport.scale}
            viewportY={-viewport.y / viewport.scale}
            viewportWidth={containerWidth / viewport.scale}
            viewportHeight={containerHeight / viewport.scale}
            visible={showGrid}
          />

          {/* Tiles Layer */}
          <TileRenderer
            tiles={tiles}
            tileSize={tileSize}
            viewportX={-viewport.x / viewport.scale}
            viewportY={-viewport.y / viewport.scale}
            viewportWidth={containerWidth / viewport.scale}
            viewportHeight={containerHeight / viewport.scale}
            previewTile={hoverTile && tileMode === 'stamp' && !isPainting ? {
              x: hoverTile.x,
              y: hoverTile.y,
              tile: { type: selectedPalette.type, color: selectedPalette.color }
            } : null}
            showPreview={tileMode === 'stamp' && !isPainting}
          />

          {/* Cursors Layer */}
          <Layer listening={false}>
            {Array.from(otherUsers.entries()).map(([userId, presence]) => (
              <Cursor
                key={userId}
                x={presence.c[0]}
                y={presence.c[1]}
                userName={presence.n}
                color={presence.cl}
              />
            ))}
          </Layer>
        </Stage>
      </div>

      {/* Tile Palette - Overlay on the left */}
      <TilePalette
        palette={DEFAULT_PALETTE}
        selectedIndex={selectedPaletteIndex}
        onSelectIndex={onPaletteIndexChange}
        selectedVariant={selectedVariant}
        onVariantChange={onVariantChange}
        plainColor={plainColor}
        onPlainColorChange={onPlainColorChange}
        autoTilingEnabled={autoTilingEnabled}
        onToggleAutoTiling={onAutoTilingToggle}
        brushSize={brushSize}
        onBrushSizeChange={onBrushSizeChange}
        mode={tileMode}
        onModeChange={onTileModeChange}
        tileCount={tiles.size}
        cursorPosition={hoverTile || undefined}
        showGrid={showGrid}
        onToggleGrid={onGridToggle}
      />

      {/* Status Bar - Fixed at bottom */}
      <TileStatusBar
        cursorPosition={hoverTile || undefined}
        tileCount={tiles.size}
        mode={tileMode}
        tileSize={tileSize}
        zoom={viewport.scale}
        connectionStatus={connectionStatus}
        aiChat={aiChat}
      />
    </div>
  )
}
</file>

<file path="src/components/tilemap/TilemapGrid.tsx">
/**
 * TilemapGrid Component
 * Renders a grid overlay for the tilemap editor
 * Uses FastLayer for optimal performance
 */

import { useMemo } from 'react'
import { Layer, Line } from 'react-konva'

interface TilemapGridProps {
  tileSize: number
  viewportX: number
  viewportY: number
  viewportWidth: number
  viewportHeight: number
  visible?: boolean
  opacity?: number
  color?: string
}

/**
 * Grid overlay component for tilemap editing
 * Only renders visible grid lines within the viewport for performance
 */
export default function TilemapGrid({
  tileSize,
  viewportX,
  viewportY,
  viewportWidth,
  viewportHeight,
  visible = true,
  opacity = 0.3,
  color = '#94a3b8', // slate-400
}: TilemapGridProps) {
  // Calculate grid lines to render (only visible ones)
  const gridLines = useMemo(() => {
    if (!visible) return { vertical: [], horizontal: [] }
    
    // Calculate visible tile range with padding
    const startX = Math.floor(viewportX / tileSize) * tileSize
    const endX = Math.ceil((viewportX + viewportWidth) / tileSize) * tileSize
    const startY = Math.floor(viewportY / tileSize) * tileSize
    const endY = Math.ceil((viewportY + viewportHeight) / tileSize) * tileSize
    
    const vertical: number[][] = []
    const horizontal: number[][] = []
    
    // Vertical lines (x-axis)
    for (let x = startX; x <= endX; x += tileSize) {
      if (x >= 0) { // Only positive coordinates
        vertical.push([x, Math.max(0, startY), x, endY])
      }
    }
    
    // Horizontal lines (y-axis)
    for (let y = startY; y <= endY; y += tileSize) {
      if (y >= 0) { // Only positive coordinates
        horizontal.push([Math.max(0, startX), y, endX, y])
      }
    }
    
    return { vertical, horizontal }
  }, [tileSize, viewportX, viewportY, viewportWidth, viewportHeight, visible])
  
  return (
    <Layer
      listening={false}
      perfectDrawEnabled={false}
      visible={visible}
    >
      {/* Vertical grid lines */}
      {gridLines.vertical.map((points, index) => (
        <Line
          key={`v-${index}`}
          points={points}
          stroke={color}
          strokeWidth={1}
          opacity={opacity}
          listening={false}
          perfectDrawEnabled={false}
        />
      ))}
      
      {/* Horizontal grid lines */}
      {gridLines.horizontal.map((points, index) => (
        <Line
          key={`h-${index}`}
          points={points}
          stroke={color}
          strokeWidth={1}
          opacity={opacity}
          listening={false}
          perfectDrawEnabled={false}
        />
      ))}
    </Layer>
  )
}
</file>

<file path="src/components/tilemap/TilemapLayer.tsx">
/**
 * TilemapLayer Component
 * Wrapper layer that combines grid and tile rendering
 * Conditionally mounted when in tilemap mode
 */

import { useEffect } from 'react'
import TilemapGrid from './TilemapGrid'
import TileRenderer from './TileRenderer'
import type { TileData } from '../../types/tilemap'

interface TilemapLayerProps {
  tiles: Map<string, TileData>
  tileSize: number
  showGrid: boolean
  previewTile?: { x: number; y: number; tile: TileData } | null
  viewportX: number
  viewportY: number
  viewportWidth: number
  viewportHeight: number
  onViewportChange?: (viewport: { x: number; y: number; width: number; height: number }) => void
}

/**
 * Combined tilemap layer
 * Renders grid overlay and tiles in a dedicated FastLayer
 * Positioned at z-index 1 (above background, below shapes)
 */
export default function TilemapLayer({
  tiles,
  tileSize,
  showGrid,
  previewTile,
  viewportX,
  viewportY,
  viewportWidth,
  viewportHeight,
  onViewportChange,
}: TilemapLayerProps) {
  // Notify parent of viewport changes for chunk loading
  useEffect(() => {
    if (onViewportChange) {
      onViewportChange({ x: viewportX, y: viewportY, width: viewportWidth, height: viewportHeight })
    }
  }, [viewportX, viewportY, viewportWidth, viewportHeight, onViewportChange])
  
  return (
    <>
      {/* Grid overlay */}
      <TilemapGrid
        tileSize={tileSize}
        viewportX={viewportX}
        viewportY={viewportY}
        viewportWidth={viewportWidth}
        viewportHeight={viewportHeight}
        visible={showGrid}
      />
      
      {/* Tiles */}
      <TileRenderer
        tiles={tiles}
        tileSize={tileSize}
        viewportX={viewportX}
        viewportY={viewportY}
        viewportWidth={viewportWidth}
        viewportHeight={viewportHeight}
        previewTile={previewTile}
      />
    </>
  )
}
</file>

<file path="src/components/tilemap/TileRenderer.tsx">
/**
 * TileRenderer Component
 * Efficiently renders tiles with viewport culling
 * Supports both sprite and colored tile rendering
 */

import { useMemo } from 'react'
import { Layer, Rect } from 'react-konva'
import type { TileData } from '../../types/tilemap'
import { coordToKey } from '../../types/tilemap'
import { getTilePath, hasSpriteAsset } from '../../constants/tilemapDefaults'
import SpriteTile from '../canvas/SpriteTile'

interface TileRendererProps {
  tiles: Map<string, TileData>
  tileSize: number
  viewportX: number
  viewportY: number
  viewportWidth: number
  viewportHeight: number
  previewTile?: { x: number; y: number; tile: TileData } | null
  showPreview?: boolean
}

/**
 * Tile renderer with viewport culling
 * Only renders tiles visible in the current viewport for performance
 */
export default function TileRenderer({
  tiles,
  tileSize,
  viewportX,
  viewportY,
  viewportWidth,
  viewportHeight,
  previewTile,
  showPreview = true,
}: TileRendererProps) {
  // Calculate visible tiles with viewport culling
  const visibleTiles = useMemo(() => {
    const visible: Array<{ key: string; x: number; y: number; tile: TileData }> = []
    
    // Calculate visible tile range with some padding
    const padding = 2 // Extra tiles outside viewport
    const startX = Math.max(0, Math.floor(viewportX / tileSize) - padding)
    const endX = Math.ceil((viewportX + viewportWidth) / tileSize) + padding
    const startY = Math.max(0, Math.floor(viewportY / tileSize) - padding)
    const endY = Math.ceil((viewportY + viewportHeight) / tileSize) + padding
    
    // Iterate through tiles and filter visible ones
    tiles.forEach((tile, key) => {
      const [xStr, yStr] = key.split('_')
      const x = parseInt(xStr, 10)
      const y = parseInt(yStr, 10)
      
      // Check if tile is in visible range
      if (x >= startX && x <= endX && y >= startY && y <= endY) {
        visible.push({ key, x, y, tile })
      }
    })
    
    return visible
  }, [tiles, tileSize, viewportX, viewportY, viewportWidth, viewportHeight])
  
  return (
    <Layer
      listening={false}
      perfectDrawEnabled={false}
    >
      {/* Render visible tiles */}
      {visibleTiles.map(({ key, x, y, tile }) => {
        const hasSprite = hasSpriteAsset(tile.type)
        
        // Render sprite tile if available, otherwise colored rect
        if (hasSprite && tile.variant !== undefined) {
          // Clamp variant to valid range (0-8) to handle old data
          const clampedVariant = Math.max(0, Math.min(8, tile.variant))
          const tilePath = getTilePath(tile.type, clampedVariant)
          return (
            <SpriteTile
              key={key}
              x={x * tileSize}
              y={y * tileSize}
              tileSize={tileSize}
              tilePath={tilePath}
              color={tile.color}
              opacity={1}
            />
          )
        }
        
        // Fallback to colored rectangle (backwards compatible)
        return (
          <Rect
            key={key}
            x={x * tileSize}
            y={y * tileSize}
            width={tileSize}
            height={tileSize}
            fill={tile.color}
            stroke="rgba(0, 0, 0, 0.1)"
            strokeWidth={1}
            listening={false}
            perfectDrawEnabled={false}
          />
        )
      })}
      
      {/* Render preview tile (ghost) */}
      {showPreview && previewTile && (() => {
        const hasSprite = hasSpriteAsset(previewTile.tile.type)
        
        // Render sprite preview if available
        if (hasSprite && previewTile.tile.variant !== undefined) {
          // Clamp variant to valid range (0-8)
          const clampedVariant = Math.max(0, Math.min(8, previewTile.tile.variant))
          const tilePath = getTilePath(previewTile.tile.type, clampedVariant)
          return (
            <SpriteTile
              key="preview"
              x={previewTile.x * tileSize}
              y={previewTile.y * tileSize}
              tileSize={tileSize}
              tilePath={tilePath}
              color={previewTile.tile.color}
              opacity={0.5}
            />
          )
        }
        
        // Fallback to colored preview
        return (
          <Rect
            key="preview"
            x={previewTile.x * tileSize}
            y={previewTile.y * tileSize}
            width={tileSize}
            height={tileSize}
            fill={previewTile.tile.color}
            opacity={0.5}
            stroke="#3b82f6"
            strokeWidth={2}
            dash={[4, 4]}
            listening={false}
            perfectDrawEnabled={false}
          />
        )
      })()}
    </Layer>
  )
}
</file>

<file path="src/components/tilemap/TileStatusBar.tsx">
/**
 * TileStatusBar Component
 * Bottom status bar showing tilemap information
 * Displays cursor position, tile count, mode, size, zoom, and connection status
 */

import type { TileMode, ConnectionStatus } from '../../types/tilemap'

interface TileStatusBarProps {
  cursorPosition?: { x: number; y: number }
  tileCount: number
  mode: TileMode
  tileSize: number
  zoom: number
  connectionStatus: ConnectionStatus
  aiChat?: React.ReactNode // Optional AI chat component to render inline
}

/**
 * Status bar component for tilemap editor
 * Shows relevant information at the bottom of the canvas
 */
export default function TileStatusBar({
  cursorPosition,
  tileCount,
  mode,
  tileSize,
  zoom,
  connectionStatus,
  aiChat,
}: TileStatusBarProps) {
  const connectionIndicators = {
    connected: { icon: '🟢', text: 'Connected', color: 'text-green-400' },
    disconnected: { icon: '🔴', text: 'Disconnected', color: 'text-red-400' },
    reconnecting: { icon: '🟡', text: 'Reconnecting...', color: 'text-yellow-400' },
  }
  
  const modeIcons: Record<TileMode, string> = {
    stamp: '🖌️',
    erase: '🧽',
    fill: '🪣',
    pick: '💧',
  }
  
  const indicator = connectionIndicators[connectionStatus]
  
  return (
    <div className="fixed bottom-0 left-0 right-0 h-10 z-50 bg-gradient-to-r from-slate-900/95 to-slate-800/95 backdrop-blur-md border-t border-white/10 flex items-center justify-between px-2 sm:px-4 gap-2 sm:gap-4 text-xs text-white/90 font-mono shadow-lg">
      {/* Left side - AI Chat */}
      <div id="status-bar-left" className="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
        {aiChat}
      </div>

      {/* Right side - Status Info */}
      <div className="flex items-center gap-2 sm:gap-4 flex-shrink-0">
        {/* Cursor Position */}
        {cursorPosition && (
          <div className="flex items-center gap-2">
            <span className="text-white/50">Tile:</span>
            <span className="text-white/90 font-semibold">
              X: {cursorPosition.x}, Y: {cursorPosition.y}
            </span>
          </div>
        )}
        
        {/* Separator */}
        {cursorPosition && <div className="h-4 w-px bg-white/20" />}
      
      {/* Tile Count */}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Tiles:</span>
        <span className="text-white/90 font-semibold">{tileCount}</span>
      </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
      {/* Current Mode */}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Mode:</span>
        <span className="text-white/90 font-semibold flex items-center gap-1">
          <span>{modeIcons[mode]}</span>
          <span className="capitalize">{mode}</span>
        </span>
      </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
      {/* Tile Size */}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Tile Size:</span>
        <span className="text-white/90 font-semibold">{tileSize}×{tileSize}px</span>
      </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
      {/* Zoom Level */}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Zoom:</span>
        <span className="text-white/90 font-semibold">{Math.round(zoom * 100)}%</span>
      </div>
      
      {/* Separator */}
      <div className="h-4 w-px bg-white/20" />
      
        {/* Connection Status */}
        <div className={`flex items-center gap-2 ${indicator.color}`}>
          <span>{indicator.icon}</span>
          <span className="font-semibold">{indicator.text}</span>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/constants/shortcuts.ts">
/**
 * Keyboard Shortcuts Definitions (PR-20)
 * Comprehensive keyboard shortcut mapping for CollabCanvas
 */

export interface KeyboardShortcut {
  key: string
  modifiers?: {
    ctrl?: boolean
    shift?: boolean
    alt?: boolean
  }
  description: string
  action: string
  category: string
}

export const KEYBOARD_SHORTCUTS: KeyboardShortcut[] = [
  // Tools
  {
    key: 'V',
    description: 'Select tool',
    action: 'selectTool',
    category: 'Tools',
  },
  {
    key: 'H',
    description: 'Hand tool (pan)',
    action: 'handTool',
    category: 'Tools',
  },
  {
    key: 'R',
    description: 'Rectangle',
    action: 'rectangleTool',
    category: 'Tools',
  },
  {
    key: 'O',
    description: 'Circle',
    action: 'circleTool',
    category: 'Tools',
  },
  {
    key: 'T',
    description: 'Text',
    action: 'textTool',
    category: 'Tools',
  },
  {
    key: 'L',
    description: 'Line',
    action: 'lineTool',
    category: 'Tools',
  },
  {
    key: 'P',
    description: 'Pencil (freehand)',
    action: 'pencilTool',
    category: 'Tools',
  },
  {
    key: 'N',
    description: 'Pen (smooth)',
    action: 'penTool',
    category: 'Tools',
  },
  {
    key: 'Space',
    description: 'Temporary hand tool',
    action: 'tempHandTool',
    category: 'Tools',
  },

  // Edit
  {
    key: 'C',
    modifiers: { ctrl: true },
    description: 'Copy',
    action: 'copy',
    category: 'Edit',
  },
  {
    key: 'V',
    modifiers: { ctrl: true },
    description: 'Paste',
    action: 'paste',
    category: 'Edit',
  },
  {
    key: 'D',
    modifiers: { ctrl: true },
    description: 'Duplicate',
    action: 'duplicate',
    category: 'Edit',
  },
  {
    key: 'A',
    modifiers: { ctrl: true },
    description: 'Select all',
    action: 'selectAll',
    category: 'Edit',
  },
  {
    key: 'Z',
    modifiers: { ctrl: true },
    description: 'Undo',
    action: 'undo',
    category: 'Edit',
  },
  {
    key: 'Z',
    modifiers: { ctrl: true, shift: true },
    description: 'Redo',
    action: 'redo',
    category: 'Edit',
  },
  {
    key: 'Delete',
    description: 'Delete',
    action: 'delete',
    category: 'Edit',
  },
  {
    key: 'Backspace',
    description: 'Delete',
    action: 'delete',
    category: 'Edit',
  },
  {
    key: 'Escape',
    description: 'Clear selection',
    action: 'clearSelection',
    category: 'Edit',
  },

  // Arrange
  {
    key: 'G',
    modifiers: { ctrl: true },
    description: 'Group',
    action: 'group',
    category: 'Arrange',
  },
  {
    key: 'G',
    modifiers: { ctrl: true, shift: true },
    description: 'Ungroup',
    action: 'ungroup',
    category: 'Arrange',
  },
  {
    key: ']',
    modifiers: { ctrl: true },
    description: 'Bring forward',
    action: 'bringForward',
    category: 'Arrange',
  },
  {
    key: '[',
    modifiers: { ctrl: true },
    description: 'Send backward',
    action: 'sendBackward',
    category: 'Arrange',
  },
  {
    key: ']',
    modifiers: { ctrl: true, shift: true },
    description: 'Bring to front',
    action: 'bringToFront',
    category: 'Arrange',
  },
  {
    key: '[',
    modifiers: { ctrl: true, shift: true },
    description: 'Send to back',
    action: 'sendToBack',
    category: 'Arrange',
  },

  // View
  {
    key: 'E',
    modifiers: { ctrl: true },
    description: 'Export',
    action: 'export',
    category: 'View',
  },
  {
    key: '?',
    description: 'Show keyboard shortcuts',
    action: 'showShortcuts',
    category: 'View',
  },
]

/**
 * Format shortcut for display
 */
export function formatShortcut(shortcut: KeyboardShortcut): string {
  const parts: string[] = []
  
  if (shortcut.modifiers?.ctrl) {
    parts.push(navigator.platform.includes('Mac') ? '⌘' : 'Ctrl')
  }
  if (shortcut.modifiers?.shift) {
    parts.push('Shift')
  }
  if (shortcut.modifiers?.alt) {
    parts.push(navigator.platform.includes('Mac') ? '⌥' : 'Alt')
  }
  
  parts.push(shortcut.key)
  
  return parts.join(' + ')
}

/**
 * Group shortcuts by category
 */
export function getShortcutsByCategory(): Record<string, KeyboardShortcut[]> {
  const grouped: Record<string, KeyboardShortcut[]> = {}
  
  KEYBOARD_SHORTCUTS.forEach(shortcut => {
    if (!grouped[shortcut.category]) {
      grouped[shortcut.category] = []
    }
    grouped[shortcut.category].push(shortcut)
  })
  
  return grouped
}
</file>

<file path="src/constants/tilemapDefaults.ts">
/**
 * Tilemap Default Configuration
 * Consolidated defaults for tilemap editor (palette, sprites, metadata)
 */

import type { PaletteColor, TilemapMeta } from '../types/tilemap'

/**
 * Auto-tile sprite set configuration
 * This is the same interface as TilesetAsset but defined here for convenience
 */
export interface AutoTileSet {
  basePath: string          // Base path to tile directory (e.g., '/assets/tiles/water')
  tileSize: number          // Size of each tile (16x16)
  variants: number[]        // Maps position (0-8) to sprite index for 3×3 grid
}

/**
 * Get path to individual tile file
 * For 3×3 grid: variants 1-9 (not 0-indexed)
 */
export function getTilePath(tileType: string, variant: number): string {
  const sprite = TILESET_SPRITES[tileType]
  if (!sprite) return ''
  
  // Clamp variant to valid range (0-8)
  const clampedVariant = Math.max(0, Math.min(8, variant))
  
  // Variants are 1-9 for 3×3 grid
  const variantNumber = clampedVariant + 1 // Convert 0-based to 1-based
  const path = `${sprite.basePath}/${tileType}_${variantNumber.toString().padStart(2, '0')}.png`
  
  return path
}

/**
 * Default tilemap palette
 * 
 * These are the default tile types available in the palette.
 * The palette is stored in Firebase per canvas and can be customized.
 * 
 * Note: First 5 types (grass, dirt, stone, water, flower) have sprite assets
 * available via TILESET_SPRITES map below.
 */
export const DEFAULT_TILEMAP_PALETTE: PaletteColor[] = [
  { type: 'grass', color: '#4ade80', name: 'Grass' },
  { type: 'dirt', color: '#92400e', name: 'Dirt' },
  { type: 'stone', color: '#6b7280', name: 'Stone' },
  { type: 'water', color: '#3b82f6', name: 'Water' },
  { type: 'flower', color: '#ec4899', name: 'Flower' },
  { type: 'plain', color: '#ffffff', name: 'Plain' },
]

/**
 * Tileset sprite metadata (client-only, NOT stored in Firebase)
 * 
 * Maps tile type to sprite asset configuration for auto-tiling.
 * Only tiles with entries here will render as sprites; others render
 * as colored rectangles (backwards compatible).
 * 
 * 3×3 Grid Auto-tiling System:
 * - 9 variants per tileset (files numbered 01-09)
 * - Layout: [TL, TC, TR, ML, MC, MR, BL, BC, BR]
 * 
 * License: Kenney Micro Roguelike assets (CC0 Public Domain)
 * Source: https://kenney.nl/assets/micro-roguelike
 */
export const TILESET_SPRITES: Record<string, AutoTileSet> = {
  grass: {
    basePath: '/assets/tiles/grass',
    tileSize: 16,
    variants: [0, 1, 2, 3, 4, 5, 6, 7, 8], // 3×3 grid (9 variants)
  },
  
  dirt: {
    basePath: '/assets/tiles/dirt',
    tileSize: 16,
    variants: [0, 1, 2, 3, 4, 5, 6, 7, 8],
  },
  
  stone: {
    basePath: '/assets/tiles/stone',
    tileSize: 16,
    variants: [0, 1, 2, 3, 4, 5, 6, 7, 8],
  },
  
  water: {
    basePath: '/assets/tiles/water',
    tileSize: 16,
    variants: [0, 1, 2, 3, 4, 5, 6, 7, 8],
  },
  
  flower: {
    basePath: '/assets/tiles/flower',
    tileSize: 16,
    variants: [0, 1, 2, 3, 4, 5, 6, 7, 8],
  },
}

/**
 * Check if a tile type has sprite assets available
 */
export function hasSpriteAsset(tileType: string): boolean {
  return tileType in TILESET_SPRITES
}

/**
 * Get sprite asset for a tile type
 */
export function getSpriteAsset(tileType: string): AutoTileSet | undefined {
  return TILESET_SPRITES[tileType]
}

/**
 * Get sprite variant index for a given variant (0-8 for 3×3 grid)
 * Note: This returns the variant as-is since variants are 0-indexed internally
 */
export function getSpriteVariant(tileType: string, variant: number): number {
  const sprite = TILESET_SPRITES[tileType]
  if (!sprite) return 0
  
  // Clamp variant to valid range (0-8 for 3×3 grid)
  return Math.max(0, Math.min(8, variant))
}

/**
 * Get all tile types that have sprite assets
 */
export function getSpriteTileTypes(): string[] {
  return Object.keys(TILESET_SPRITES)
}

/**
 * Default tilemap metadata configuration
 * Used when initializing a new tilemap
 */
export const DEFAULT_TILEMAP_META: TilemapMeta = {
  tileSize: 16,
  width: 256,
  height: 256,
  chunkSize: 16,
  palette: DEFAULT_TILEMAP_PALETTE,
  version: 1,
}
</file>

<file path="src/constants/tilesetAssets.ts">
/**
 * Tileset Asset Manifest
 * Kenney.nl Micro Roguelike sprite assets configuration
 * 
 * License: CC0 (Public Domain)
 * Source: https://kenney.nl/assets/micro-roguelike
 */

/**
 * Auto-tile sprite set configuration
 */
export interface TilesetAsset {
  id: string
  name: string
  spriteSheet: string       // Path to sprite sheet image
  tileSize: number          // Size of each tile in pixels (8x8)
  variantCount: number      // Number of variants (16 for 4-neighbor bitmask)
  variantMap: number[]      // Maps bitmask (0-15) to sprite index
}

/**
 * Bitmask to sprite index mapping
 * 
 * 4-Neighbor Bitmask Format: NESW (North, East, South, West)
 * - 1 = neighbor of same type exists
 * - 0 = no neighbor or different type
 * 
 * Examples:
 * - 0000 (0):  Island tile (no neighbors)
 * - 1111 (15): Center tile (all neighbors match)
 * - 0101 (5):  Vertical corridor (East + West)
 * - 1010 (10): Horizontal corridor (North + South)
 * 
 * Sequential mapping: bitmask value directly maps to sprite index
 */
const SEQUENTIAL_VARIANT_MAP: number[] = [
  0,   // 0000 - Island
  1,   // 0001 - West edge
  2,   // 0010 - South edge
  3,   // 0011 - South-West corner
  4,   // 0100 - East edge
  5,   // 0101 - Vertical (E+W)
  6,   // 0110 - South-East corner
  7,   // 0111 - South T-junction
  8,   // 1000 - North edge
  9,   // 1001 - North-West corner
  10,  // 1010 - Horizontal (N+S)
  11,  // 1011 - West T-junction
  12,  // 1100 - North-East corner
  13,  // 1101 - North T-junction
  14,  // 1110 - East T-junction
  15,  // 1111 - Center (all neighbors)
]

/**
 * Kenney Micro Roguelike Tilesets
 * 
 * All tilesets use 16x16px tiles with 16 variants for 4-neighbor auto-tiling.
 * Sequential variant mapping provides optimal performance (O(1) lookup).
 */
export const KENNEY_TILESETS: Record<string, TilesetAsset> = {
  grass: {
    id: 'grass',
    name: 'Grass Terrain',
    spriteSheet: '/assets/tilesets/grass.png',
    tileSize: 16,
    variantCount: 16,
    variantMap: SEQUENTIAL_VARIANT_MAP,
  },
  
  water: {
    id: 'water',
    name: 'Water Liquid',
    spriteSheet: '/assets/tilesets/water.png',
    tileSize: 16,
    variantCount: 16,
    variantMap: SEQUENTIAL_VARIANT_MAP,
  },
  
  stone: {
    id: 'stone',
    name: 'Stone Walls',
    spriteSheet: '/assets/tilesets/stone.png',
    tileSize: 16,
    variantCount: 16,
    variantMap: SEQUENTIAL_VARIANT_MAP,
  },
  
  dirt: {
    id: 'dirt',
    name: 'Dirt Ground',
    spriteSheet: '/assets/tilesets/dirt.png',
    tileSize: 16,
    variantCount: 16,
    variantMap: SEQUENTIAL_VARIANT_MAP,
  },
}

/**
 * Get tileset asset by ID
 */
export function getTilesetAsset(id: string): TilesetAsset | undefined {
  return KENNEY_TILESETS[id]
}

/**
 * Get all available tileset IDs
 */
export function getAvailableTilesets(): string[] {
  return Object.keys(KENNEY_TILESETS)
}

/**
 * Check if a tileset exists
 */
export function hasTileset(id: string): boolean {
  return id in KENNEY_TILESETS
}
</file>

<file path="src/hooks/useAIChat.ts">
/**
 * AI Chat Hook
 * Manages AI chat state and communication
 * PR-30: Task 5.2
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import { sendAICommand } from '../services/ai/ai';
import type { AIRequest, AIResponse } from '../services/ai/ai';

export type ChatMessage = {
  id: string;
  role: 'user' | 'assistant' | 'error';
  content: string;
  timestamp: number;
  toolResults?: any[];
}

interface UseAIChatOptions {
  canvasId: string;
  userId: string;
  onToolExecuted?: (results: any[]) => void;
}

export function useAIChat(options: UseAIChatOptions) {
  const { canvasId, userId, onToolExecuted } = options;

  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const messagesRef = useRef<ChatMessage[]>([]);

  // Keep ref in sync
  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  /**
   * Send message to AI
   */
  const sendMessage = useCallback(async (
    message: string,
    context: {
      selectedShapes: string[];
      viewport: any;
      mode: 'shapes' | 'tilemap';
      tilemapMeta?: any;
    }
  ) => {
    if (!message.trim() || isLoading) return;

    const userMessage: ChatMessage = {
      id: `msg-${Date.now()}-user`,
      role: 'user',
      content: message.trim(),
      timestamp: Date.now(),
    };

    // Add user message
    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setError(null);

    try {
      // Call AI service
      const request: AIRequest = {
        message: message.trim(),
        context: {
          canvasId,
          userId,
          selectedShapes: context.selectedShapes,
          viewport: context.viewport,
          mode: context.mode,
          tilemapMeta: context.tilemapMeta,
        },
      };

      const response: AIResponse = await sendAICommand(request);

      if (response.success) {
        // Add assistant response
        const assistantMessage: ChatMessage = {
          id: `msg-${Date.now()}-assistant`,
          role: 'assistant',
          content: response.message,
          timestamp: Date.now(),
          toolResults: response.toolResults,
        };

        setMessages(prev => [...prev, assistantMessage]);

        // Notify about tool execution
        if (response.toolResults && response.toolResults.length > 0 && onToolExecuted) {
          onToolExecuted(response.toolResults);
        }

      } else {
        // Add error message
        const errorMessage: ChatMessage = {
          id: `msg-${Date.now()}-error`,
          role: 'error',
          content: response.error || 'An error occurred',
          timestamp: Date.now(),
        };

        setMessages(prev => [...prev, errorMessage]);
        setError(response.error || 'An error occurred');
      }

    } catch (err: any) {
      console.error('Error sending AI message:', err);
      
      const errorMessage: ChatMessage = {
        id: `msg-${Date.now()}-error`,
        role: 'error',
        content: err.message || 'Failed to send message',
        timestamp: Date.now(),
      };

      setMessages(prev => [...prev, errorMessage]);
      setError(err.message || 'Failed to send message');

    } finally {
      setIsLoading(false);
    }
  }, [canvasId, userId, isLoading, onToolExecuted]);

  /**
   * Clear chat history
   */
  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  /**
   * Retry last message
   */
  const retryLastMessage = useCallback((context: any) => {
    const lastUserMessage = messagesRef.current
      .filter(msg => msg.role === 'user')
      .pop();

    if (lastUserMessage) {
      // Remove last assistant/error messages
      setMessages(prev => {
        const lastUserIndex = prev.findIndex(msg => msg.id === lastUserMessage.id);
        return prev.slice(0, lastUserIndex + 1);
      });

      // Resend
      sendMessage(lastUserMessage.content, context);
    }
  }, [sendMessage]);

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    clearMessages,
    retryLastMessage,
  };
}
</file>

<file path="src/hooks/useAuth.ts">
import { useState, useEffect } from 'react'
import { onAuthStateChanged } from 'firebase/auth'
import type { User as FirebaseUser } from 'firebase/auth'
import { auth } from '../services/firebase'
import type { User } from '../types/firebase'

interface UseAuthReturn {
  user: User | null
  loading: boolean
}

/**
 * Hook to manage Firebase authentication state
 * Returns current user and loading state
 */
export function useAuth(): UseAuthReturn {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(
      auth,
      (firebaseUser: FirebaseUser | null) => {
        if (firebaseUser) {
          // Map Firebase user to our User type
          setUser({
            uid: firebaseUser.uid,
            email: firebaseUser.email,
            displayName: firebaseUser.displayName,
          })
        } else {
          setUser(null)
        }
        setLoading(false)
      },
      (error) => {
        console.error('Auth state change error:', error)
        setUser(null)
        setLoading(false)
      }
    )

    // Cleanup subscription on unmount
    return () => unsubscribe()
  }, [])

  return { user, loading }
}
</file>

<file path="src/hooks/useCanvas.ts">
import { useState, useCallback, useEffect, useRef, useMemo } from 'react'
import { v4 as uuidv4 } from 'uuid'
import type { Shape } from '../types/canvas'
import { DEFAULT_CANVAS_CONFIG } from '../types/canvas'
import {
  syncCreateShape,
  syncUpdateShape,
  syncDeleteShape,
  syncBulkMove,
  syncBulkDelete,
  syncBatchCreate,
  syncZIndex,
  subscribeToCanvas,
} from '../services/canvas/canvasSync'
import {
  copyShapes as copyShapesToClipboard,
  pasteShapes as pasteShapesFromClipboard,
  duplicateShapes as duplicateShapesInternal,
} from '../services/canvas/clipboard'
import { createHistoryManager } from '../services/canvas/commandHistory'
import { CreateCommand } from '../commands/shape/CreateCommand'
import { DeleteCommand } from '../commands/shape/DeleteCommand'
import { ZIndexCommand } from '../commands/shape/ZIndexCommand'
import { AlignmentCommand } from '../commands/advanced/AlignmentCommand'
import {
  loadRecentColors,
  saveRecentColors,
} from '../services/canvas/colorStorage'
import {
  alignShapes,
  distributeHorizontally,
  distributeVertically,
  centerInCanvas,
  type AlignmentType,
} from '../services/collaboration/alignment'

interface UseCanvasOptions {
  canvasId: string
  userId: string
  enableSync?: boolean
}

interface UseCanvasReturn {
  shapes: Shape[]
  selectedId: string | null // for backward compatibility
  selectedIds: Set<string> // NEW: multi-select support
  addShape: (type: 'rectangle' | 'circle', x: number, y: number) => string
  addText: (text: string, x: number, y: number) => string | null
  updateShape: (id: string, updates: Partial<Shape>) => void
  deleteShape: (id: string) => void
  setSelection: (id: string | null) => void // for backward compatibility
  // NEW: Multi-select functions
  toggleSelection: (id: string) => void
  selectMultiple: (ids: string[]) => void
  clearSelection: () => void
  selectAll: () => void
  getSelectedShapes: () => Shape[]
  bulkMove: (deltaX: number, deltaY: number) => void
  bulkDelete: () => void
  // NEW: Copy/Paste/Duplicate functions (PR-13)
  copySelected: () => void
  paste: () => void
  duplicateSelected: () => void
  // NEW: Undo/Redo functions (PR-14)
  undo: () => void
  redo: () => void
  canUndo: boolean
  canRedo: boolean
  // NEW: Color management functions (PR-15)
  updateColors: (fill?: string, stroke?: string, strokeWidth?: number) => void
  getRecentColors: () => string[]
  addRecentColor: (color: string) => void
  // NEW: Advanced shape creation functions (PR-16)
  addLine: (x1: number, y1: number, x2: number, y2: number, arrows?: { start?: boolean; end?: boolean }) => string
  addPolygon: (x: number, y: number, sides?: number) => string
  addStar: (x: number, y: number, points?: number) => string
  addRoundedRect: (x: number, y: number, cornerRadius?: number) => string
  // NEW: Freehand drawing function (PR-21)
  addPath: (points: number[], tension?: number, strokeColor?: string, strokeWidth?: number) => string
  // NEW: Z-index manipulation functions (PR-17)
  bringToFront: (ids?: string[]) => void
  sendToBack: (ids?: string[]) => void
  bringForward: (ids?: string[]) => void
  sendBackward: (ids?: string[]) => void
  sortShapesByZIndex: () => Shape[]
  // NEW: Alignment functions (PR-18)
  alignSelected: (type: AlignmentType) => void
  distributeSelectedHorizontally: () => void
  distributeSelectedVertically: () => void
  centerSelectedInCanvas: (canvasWidth: number, canvasHeight: number) => void
}

/**
 * Hook for managing canvas shapes state with Firebase sync
 * Handles shape creation, updates, deletion, and selection
 */
export function useCanvas(options?: UseCanvasOptions): UseCanvasReturn {
  const [shapes, setShapes] = useState<Shape[]>([])
  const [selectedId, setSelectedId] = useState<string | null>(null) // for backward compatibility
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set()) // NEW: multi-select
  const syncEnabled = options?.enableSync ?? true
  const canvasId = options?.canvasId ?? 'default-canvas'
  const userId = options?.userId ?? ''
  
  // Track locally created shapes to avoid duplicate onCreate from Firebase
  const localShapesRef = useRef(new Set<string>())
  
  // Command history for undo/redo (PR-14)
  const historyManager = useMemo(() => createHistoryManager(), [])
  const [canUndo, setCanUndo] = useState(false)
  const [canRedo, setCanRedo] = useState(false)
  
  // Recent colors for color picker (PR-15)
  const [recentColors, setRecentColors] = useState<string[]>(() => loadRecentColors())
  const DEFAULT_FILL = '#3B82F6FF' // Default blue with full opacity

  /**
   * Helper function to add shape to state (used by commands)
   */
  const addShapeToState = useCallback((shape: Shape): void => {
    setShapes((prev) => [...prev, shape])
    localShapesRef.current.add(shape.id)
  }, [])

  /**
   * Helper function to remove shape from state (used by commands)
   */
  const removeShapeFromState = useCallback((id: string): void => {
    setShapes((prev) => prev.filter((shape) => shape.id !== id))
    localShapesRef.current.delete(id)
  }, [])

  /**
   * Helper function to sync shape creation (used by commands)
   */
  const syncShapeCreate = useCallback(
    (shape: Shape): Promise<void> => {
      if (syncEnabled && userId) {
        return syncCreateShape(canvasId, shape.id, shape)
      }
      return Promise.resolve()
    },
    [syncEnabled, userId, canvasId]
  )

  /**
   * Helper function to sync shape deletion (used by commands)
   */
  const syncShapeDelete = useCallback(
    (id: string): Promise<void> => {
      if (syncEnabled && userId) {
        return syncDeleteShape(canvasId, id)
      }
      return Promise.resolve()
    },
    [syncEnabled, userId, canvasId]
  )

  /**
   * Update undo/redo availability after each command execution
   */
  const updateHistoryState = useCallback((): void => {
    setCanUndo(historyManager.canUndo())
    setCanRedo(historyManager.canRedo())
  }, [historyManager])

  /**
   * Add a rectangle or circle shape
   * All shapes are fixed 100x100px, blue (#3B82F6)
   * Shape is centered on the click point (not top-left corner)
   * Uses command pattern for undo/redo (PR-14)
   */
  const addShape = useCallback(
    (type: 'rectangle' | 'circle', x: number, y: number): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize
      const newShape: Shape = {
        id,
        type,
        x: x - size / 2, // Center on click point
        y: y - size / 2, // Center on click point
        width: size,
        height: size,
        fill: DEFAULT_FILL, // PR-15: Default color
        stroke: '#000000FF', // Add default black stroke
        strokeWidth: 2, // Add default stroke width
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      // Create command for this operation
      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      // Execute command and add to history
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState]
  )

  /**
   * Add a text shape
   * Validates that text is not empty (min 1 character)
   * Auto-calculates dimensions based on content
   * Uses command pattern for undo/redo (PR-14)
   */
  const addText = useCallback(
    (text: string, x: number, y: number): string | null => {
      // Validate text - prevent empty text objects
      if (!text || text.trim().length === 0) {
        return null
      }

      const id = uuidv4()

      // Calculate text dimensions (approximate)
      const fontSize = 20
      const charWidth = fontSize * 0.6 // Approximate character width
      const width = Math.max(text.length * charWidth, 50)
      const height = fontSize + 10 // Add some padding

      const newShape: Shape = {
        id,
        type: 'text',
        x,
        y,
        width,
        height,
        text,
        fill: DEFAULT_FILL, // PR-15: Default color
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      // Create command for this operation
      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      // Execute command and add to history
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState]
  )

  /**
   * Add a line shape (PR-16)
   * Creates a line with two endpoints and optional arrows
   */
  const addLine = useCallback(
    (x1: number, y1: number, x2: number, y2: number, arrows?: { start?: boolean; end?: boolean }): string => {
      const id = uuidv4()
      const newShape: Shape = {
        id,
        type: 'line',
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1),
        points: [x1, y1, x2, y2],
        fill: DEFAULT_FILL,
        stroke: '#000000FF', // Add default black stroke
        strokeWidth: 2, // Add default stroke width
        arrows: arrows || { start: false, end: false },
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )

  /**
   * Add a polygon shape (PR-16)
   * Creates a regular polygon with specified number of sides (default: 5)
   */
  const addPolygon = useCallback(
    (x: number, y: number, sides: number = 5): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize
      
      const newShape: Shape = {
        id,
        type: 'polygon',
        x: x - size / 2, // Center on click point
        y: y - size / 2, // Center on click point
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        sides: Math.max(3, Math.min(12, sides)),
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )

  /**
   * Add a star shape (PR-16)
   * Creates a star with specified number of points (default: 5)
   */
  const addStar = useCallback(
    (x: number, y: number, points: number = 5): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize
      
      const newShape: Shape = {
        id,
        type: 'star',
        x: x - size / 2, // Center on click point
        y: y - size / 2, // Center on click point
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        sides: Math.max(3, Math.min(12, points)),
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )

  /**
   * Add a rounded rectangle shape (PR-16)
   * Creates a rectangle with rounded corners (default: 10px radius)
   */
  const addRoundedRect = useCallback(
    (x: number, y: number, cornerRadius: number = 10): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize
      
      const newShape: Shape = {
        id,
        type: 'roundRect',
        x: x - size / 2, // Center on click point
        y: y - size / 2, // Center on click point
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        cornerRadius: Math.max(0, Math.min(50, cornerRadius)),
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )

  /**
   * Add a path shape for freehand drawing (PR-21)
   * Creates a path with points array and tension for smooth/sharp rendering
   */
  const addPath = useCallback(
    (points: number[], tension: number = 0, strokeColor?: string, strokeWidth: number = 2): string => {
      const id = uuidv4()
      
      const newShape: Shape = {
        id,
        type: 'path',
        x: 0,
        y: 0,
        width: 0, // Path doesn't use width/height
        height: 0,
        points,
        stroke: strokeColor || DEFAULT_FILL,
        strokeWidth,
        fill: 'transparent', // Paths don't have fill
        tension,
        closed: false,
        zIndex: Date.now(), // PR-17: Set z-index to current timestamp
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
      
      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )

  /**
   * Update shape properties (position, dimensions, rotation, colors)
   */
  const updateShape = useCallback(
    (id: string, updates: Partial<Shape>): void => {
      // Update local state immediately
      setShapes((prev) =>
        prev.map((shape) =>
          shape.id === id ? { ...shape, ...updates } : shape
        )
      )
      
      // Sync to Firebase if any syncable properties changed
      const hasSyncableUpdate = 
        updates.x !== undefined ||
        updates.y !== undefined ||
        updates.width !== undefined ||
        updates.height !== undefined ||
        updates.rotation !== undefined ||
        updates.fill !== undefined ||
        updates.stroke !== undefined ||
        updates.strokeWidth !== undefined ||
        updates.zIndex !== undefined
      
      if (syncEnabled && userId && hasSyncableUpdate) {
        syncUpdateShape(canvasId, id, updates).catch((error) => {
          console.error('Failed to sync shape update:', error)
        })
      }
    },
    [syncEnabled, canvasId, userId]
  )

  /**
   * Delete a shape and clear selection if it was selected
   * Uses command pattern for undo/redo (PR-14)
   */
  const deleteShape = useCallback(
    (id: string): void => {
      // Find the shape to delete (need it for undo)
      const shapeToDelete = shapes.find((shape) => shape.id === id)
      if (!shapeToDelete) return

      // Clear selection if this shape was selected
      setSelectedId((prev) => (prev === id ? null : prev))
      setSelectedIds((prev) => {
        const next = new Set(prev)
        next.delete(id)
        return next
      })

      // Create command for this operation
      const command = new DeleteCommand(
        shapeToDelete,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )
      
      // Execute command and add to history
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [shapes, historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState]
  )

  /**
   * Set selected shape ID (backward compatibility - single selection)
   * Selection state is synced via presence (handled in Canvas component)
   */
  const setSelection = useCallback((id: string | null): void => {
    setSelectedId(id)
    // Update selectedIds to match
    if (id === null) {
      setSelectedIds(new Set())
    } else {
      setSelectedIds(new Set([id]))
    }
  }, [])

  /**
   * Toggle selection of a shape (add/remove from selection)
   * Used for Shift+Click behavior
   */
  const toggleSelection = useCallback((id: string): void => {
    setSelectedIds((prev) => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      // Update selectedId for backward compatibility (use last selected)
      setSelectedId(next.size > 0 ? id : null)
      return next
    })
  }, [])

  /**
   * Select multiple shapes at once
   * Used after drag-to-select box completes
   */
  const selectMultiple = useCallback((ids: string[]): void => {
    const newSelection = new Set(ids)
    setSelectedIds(newSelection)
    // Update selectedId for backward compatibility (use last in array)
    setSelectedId(ids.length > 0 ? ids[ids.length - 1] : null)
  }, [])

  /**
   * Clear all selections
   */
  const clearSelection = useCallback((): void => {
    setSelectedIds(new Set())
    setSelectedId(null)
  }, [])

  /**
   * Select all shapes on the canvas
   */
  const selectAll = useCallback((): void => {
    const allIds = shapes.map((shape) => shape.id)
    selectMultiple(allIds)
  }, [shapes, selectMultiple])

  /**
   * Get array of currently selected shape objects
   */
  const getSelectedShapes = useCallback((): Shape[] => {
    return shapes.filter((shape) => selectedIds.has(shape.id))
  }, [shapes, selectedIds])

  /**
   * Move all selected shapes by delta amount
   * Maintains relative positions
   */
  const bulkMove = useCallback(
    (deltaX: number, deltaY: number): void => {
      const updates: Record<string, { x: number; y: number }> = {}
      
      // Calculate new positions for all selected shapes
      shapes.forEach((shape) => {
        if (selectedIds.has(shape.id)) {
          updates[shape.id] = {
            x: shape.x + deltaX,
            y: shape.y + deltaY,
          }
        }
      })
      
      // Update local state immediately
      setShapes((prev) =>
        prev.map((shape) =>
          updates[shape.id]
            ? { ...shape, ...updates[shape.id] }
            : shape
        )
      )
      
      // Sync to Firebase (only if user is authenticated)
      if (syncEnabled && userId && Object.keys(updates).length > 0) {
        syncBulkMove(canvasId, updates).catch((error) => {
          console.error('Failed to sync bulk move:', error)
        })
      }
    },
    [shapes, selectedIds, syncEnabled, canvasId, userId]
  )

  /**
   * Delete all selected shapes
   */
  const bulkDelete = useCallback((): void => {
    const idsToDelete = Array.from(selectedIds)
    
    // Update local state immediately
    setShapes((prev) => prev.filter((shape) => !selectedIds.has(shape.id)))
    
    // Clear selection
    clearSelection()
    
    // Remove from local shapes tracking
    idsToDelete.forEach((id) => localShapesRef.current.delete(id))
    
    // Sync to Firebase (only if user is authenticated)
    if (syncEnabled && userId && idsToDelete.length > 0) {
      syncBulkDelete(canvasId, idsToDelete).catch((error) => {
        console.error('Failed to sync bulk delete:', error)
      })
    }
  }, [selectedIds, syncEnabled, canvasId, userId, clearSelection])

  /**
   * Copy selected shapes to in-memory clipboard (PR-13)
   */
  const copySelected = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    if (selectedShapes.length > 0) {
      copyShapesToClipboard(selectedShapes)
    }
  }, [getSelectedShapes])

  /**
   * Paste shapes from clipboard with offset (PR-13)
   * Auto-selects pasted shapes
   */
  const paste = useCallback((): void => {
    const pastedShapes = pasteShapesFromClipboard()
    
    if (pastedShapes.length === 0) {
      return
    }

    // Add to local state immediately
    setShapes((prev) => [...prev, ...pastedShapes])
    
    // Mark all as locally created
    pastedShapes.forEach((shape) => {
      localShapesRef.current.add(shape.id)
    })
    
    // Auto-select pasted shapes
    selectMultiple(pastedShapes.map((s) => s.id))
    
    // Sync to Firebase (only if user is authenticated)
    if (syncEnabled && userId) {
      // Use batch create for efficient multi-shape sync
      syncBatchCreate(canvasId, pastedShapes).catch((error) => {
        console.error('Failed to sync pasted shapes:', error)
      })
    }
  }, [syncEnabled, canvasId, userId, selectMultiple])

  /**
   * Duplicate selected shapes with offset (PR-13)
   * Auto-selects duplicated shapes
   */
  const duplicateSelected = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    const duplicatedShapes = duplicateShapesInternal(selectedShapes)
    
    if (duplicatedShapes.length === 0) {
      return
    }

    // Add to local state immediately
    setShapes((prev) => [...prev, ...duplicatedShapes])
    
    // Mark all as locally created
    duplicatedShapes.forEach((shape) => {
      localShapesRef.current.add(shape.id)
    })
    
    // Auto-select duplicated shapes
    selectMultiple(duplicatedShapes.map((s) => s.id))
    
    // Sync to Firebase (only if user is authenticated)
    if (syncEnabled && userId) {
      // Use batch create for efficient multi-shape sync
      syncBatchCreate(canvasId, duplicatedShapes).catch((error) => {
        console.error('Failed to sync duplicated shapes:', error)
      })
    }
  }, [getSelectedShapes, syncEnabled, canvasId, userId, selectMultiple])

  /**
   * Add color to recent colors list (PR-15)
   * Maintains max 5 colors, most recent first
   */
  const addRecentColor = useCallback((color: string): void => {
    setRecentColors((prev) => {
      // Remove color if it already exists
      const filtered = prev.filter((c) => c.toUpperCase() !== color.toUpperCase())
      // Add to front and limit to 5
      return [color, ...filtered].slice(0, 5)
    })
  }, [])

  /**
   * Get recent colors (PR-15)
   */
  const getRecentColors = useCallback((): string[] => {
    return recentColors
  }, [recentColors])

  /**
   * Update colors for selected shapes (PR-15)
   * Updates fill, stroke, and strokeWidth for all selected shapes
   */
  const updateColors = useCallback(
    (fill?: string, stroke?: string, strokeWidth?: number): void => {
      const selectedShapesList = getSelectedShapes()
      if (selectedShapesList.length === 0) return

      // Build updates object
      const updates: Partial<Shape> = {}
      if (fill !== undefined) updates.fill = fill
      if (stroke !== undefined) updates.stroke = stroke
      if (strokeWidth !== undefined) updates.strokeWidth = strokeWidth

      // Update all selected shapes
      selectedShapesList.forEach((shape) => {
        updateShape(shape.id, updates)
      })

      // Add fill color to recent colors if provided
      if (fill !== undefined) {
        addRecentColor(fill)
      }
    },
    [getSelectedShapes, updateShape, addRecentColor]
  )

  /**
   * Undo the last command (PR-14)
   */
  const undo = useCallback((): void => {
    historyManager.undo()
    // Update undo/redo availability
    setCanUndo(historyManager.canUndo())
    setCanRedo(historyManager.canRedo())
  }, [historyManager])

  /**
   * Redo the last undone command (PR-14)
   */
  const redo = useCallback((): void => {
    historyManager.redo()
    // Update undo/redo availability
    setCanUndo(historyManager.canUndo())
    setCanRedo(historyManager.canRedo())
  }, [historyManager])

  /**
   * Sort shapes by z-index (PR-17)
   * Returns a new array sorted by z-index (lowest first, highest last)
   */
  const sortShapesByZIndex = useCallback((): Shape[] => {
    return [...shapes].sort((a, b) => {
      const aZ = a.zIndex ?? 0
      const bZ = b.zIndex ?? 0
      return aZ - bZ
    })
  }, [shapes])

  /**
   * Bring shapes to front (PR-17)
   * Sets z-index to max+1 for all selected shapes (or provided ids)
   * Multi-select: maintains relative order among selected shapes
   */
  const bringToFront = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return

      // Find max z-index
      const maxZ = Math.max(...shapes.map((s) => s.zIndex ?? 0))
      
      // Create old/new z-index maps for undo
      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()
      
      // Sort target shapes by current z-index to maintain relative order
      const targetShapes = shapes.filter((s) => targetIds.includes(s.id))
        .sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0))
      
      // Assign new z-indices starting from maxZ + 1
      targetShapes.forEach((shape, index) => {
        oldZIndices.set(shape.id, shape.zIndex ?? 0)
        newZIndices.set(shape.id, maxZ + 1 + index)
      })

      // Create command for this operation
      const command = new ZIndexCommand(
        targetIds,
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )

  /**
   * Send shapes to back (PR-17)
   * Sets z-index to min-1 for all selected shapes (or provided ids)
   * Multi-select: maintains relative order among selected shapes
   */
  const sendToBack = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return

      // Find min z-index
      const minZ = Math.min(...shapes.map((s) => s.zIndex ?? 0))
      
      // Create old/new z-index maps for undo
      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()
      
      // Sort target shapes by current z-index to maintain relative order
      const targetShapes = shapes.filter((s) => targetIds.includes(s.id))
        .sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0))
      
      // Assign new z-indices starting from minZ - targetShapes.length
      targetShapes.forEach((shape, index) => {
        oldZIndices.set(shape.id, shape.zIndex ?? 0)
        newZIndices.set(shape.id, minZ - targetShapes.length + index)
      })

      // Create command for this operation
      const command = new ZIndexCommand(
        targetIds,
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )

  /**
   * Bring shapes forward by one layer (PR-17)
   * Increments z-index by swapping with the shape above
   */
  const bringForward = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return

      // Sort all shapes by z-index
      const sortedShapes = sortShapesByZIndex()
      
      // Create old/new z-index maps
      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()
      
      // For each target shape, swap with the shape above it
      targetIds.forEach((id) => {
        const currentIndex = sortedShapes.findIndex((s) => s.id === id)
        if (currentIndex < sortedShapes.length - 1) {
          const currentShape = sortedShapes[currentIndex]
          const nextShape = sortedShapes[currentIndex + 1]
          
          if (!targetIds.includes(nextShape.id)) {
            // Only swap if the next shape is not also being moved
            oldZIndices.set(currentShape.id, currentShape.zIndex ?? 0)
            newZIndices.set(currentShape.id, nextShape.zIndex ?? 0)
            oldZIndices.set(nextShape.id, nextShape.zIndex ?? 0)
            newZIndices.set(nextShape.id, currentShape.zIndex ?? 0)
          }
        }
      })

      if (newZIndices.size === 0) return // Nothing to do

      // Create command for this operation
      const command = new ZIndexCommand(
        Array.from(newZIndices.keys()),
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, sortShapesByZIndex, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )

  /**
   * Send shapes backward by one layer (PR-17)
   * Decrements z-index by swapping with the shape below
   */
  const sendBackward = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return

      // Sort all shapes by z-index
      const sortedShapes = sortShapesByZIndex()
      
      // Create old/new z-index maps
      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()
      
      // For each target shape, swap with the shape below it
      targetIds.forEach((id) => {
        const currentIndex = sortedShapes.findIndex((s) => s.id === id)
        if (currentIndex > 0) {
          const currentShape = sortedShapes[currentIndex]
          const prevShape = sortedShapes[currentIndex - 1]
          
          if (!targetIds.includes(prevShape.id)) {
            // Only swap if the previous shape is not also being moved
            oldZIndices.set(currentShape.id, currentShape.zIndex ?? 0)
            newZIndices.set(currentShape.id, prevShape.zIndex ?? 0)
            oldZIndices.set(prevShape.id, prevShape.zIndex ?? 0)
            newZIndices.set(prevShape.id, currentShape.zIndex ?? 0)
          }
        }
      })

      if (newZIndices.size === 0) return // Nothing to do

      // Create command for this operation
      const command = new ZIndexCommand(
        Array.from(newZIndices.keys()),
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, sortShapesByZIndex, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )

  /**
   * Align selected shapes (PR-18)
   * Uses alignment service to calculate new positions
   */
  const alignSelected = useCallback(
    (type: AlignmentType): void => {
      const selectedShapes = getSelectedShapes()
      if (selectedShapes.length < 2) return

      // Calculate new positions using alignment service
      const alignmentResult = alignShapes(selectedShapes, type)
      
      if (Object.keys(alignmentResult).length === 0) return

      // Store old positions for undo
      const oldPositions = new Map<string, { x: number; y: number }>()
      const newPositions = new Map<string, { x: number; y: number }>()
      
      selectedShapes.forEach(shape => {
        oldPositions.set(shape.id, { x: shape.x, y: shape.y })
        if (alignmentResult[shape.id]) {
          newPositions.set(shape.id, alignmentResult[shape.id])
        }
      })

      // Create command for this operation
      const command = new AlignmentCommand(
        Array.from(newPositions.keys()),
        oldPositions,
        newPositions,
        (id, updates) => updateShape(id, updates),
        (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState]
  )

  /**
   * Distribute selected shapes horizontally (PR-18)
   */
  const distributeSelectedHorizontally = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    if (selectedShapes.length < 3) return // Need at least 3 shapes

    // Calculate new positions using alignment service
    const distributionResult = distributeHorizontally(selectedShapes)
    
    if (Object.keys(distributionResult).length === 0) return

    // Store old positions for undo
    const oldPositions = new Map<string, { x: number; y: number }>()
    const newPositions = new Map<string, { x: number; y: number }>()
    
    selectedShapes.forEach(shape => {
      oldPositions.set(shape.id, { x: shape.x, y: shape.y })
      if (distributionResult[shape.id]) {
        newPositions.set(shape.id, distributionResult[shape.id])
      }
    })

    // Create command for this operation
    const command = new AlignmentCommand(
      Array.from(newPositions.keys()),
      oldPositions,
      newPositions,
      (id, updates) => updateShape(id, updates),
      (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
    )
    
    historyManager.executeCommand(command)
    updateHistoryState()
  }, [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState])

  /**
   * Distribute selected shapes vertically (PR-18)
   */
  const distributeSelectedVertically = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    if (selectedShapes.length < 3) return // Need at least 3 shapes

    // Calculate new positions using alignment service
    const distributionResult = distributeVertically(selectedShapes)
    
    if (Object.keys(distributionResult).length === 0) return

    // Store old positions for undo
    const oldPositions = new Map<string, { x: number; y: number }>()
    const newPositions = new Map<string, { x: number; y: number }>()
    
    selectedShapes.forEach(shape => {
      oldPositions.set(shape.id, { x: shape.x, y: shape.y })
      if (distributionResult[shape.id]) {
        newPositions.set(shape.id, distributionResult[shape.id])
      }
    })

    // Create command for this operation
    const command = new AlignmentCommand(
      Array.from(newPositions.keys()),
      oldPositions,
      newPositions,
      (id, updates) => updateShape(id, updates),
      (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
    )
    
    historyManager.executeCommand(command)
    updateHistoryState()
  }, [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState])

  /**
   * Center selected shapes in canvas viewport (PR-18)
   */
  const centerSelectedInCanvas = useCallback(
    (canvasWidth: number, canvasHeight: number): void => {
      const selectedShapes = getSelectedShapes()
      if (selectedShapes.length === 0) return

      // Calculate new positions using alignment service
      const centerResult = centerInCanvas(selectedShapes, canvasWidth, canvasHeight)
      
      if (Object.keys(centerResult).length === 0) return

      // Store old positions for undo
      const oldPositions = new Map<string, { x: number; y: number }>()
      const newPositions = new Map<string, { x: number; y: number }>()
      
      selectedShapes.forEach(shape => {
        oldPositions.set(shape.id, { x: shape.x, y: shape.y })
        if (centerResult[shape.id]) {
          newPositions.set(shape.id, centerResult[shape.id])
        }
      })

      // Create command for this operation
      const command = new AlignmentCommand(
        Array.from(newPositions.keys()),
        oldPositions,
        newPositions,
        (id, updates) => updateShape(id, updates),
        (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
      )
      
      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState]
  )

  /**
   * Persist recent colors to localStorage (PR-15)
   */
  useEffect(() => {
    saveRecentColors(recentColors)
  }, [recentColors])

  /**
   * Subscribe to Firebase updates from other users
   */
  useEffect(() => {
    // Don't subscribe if sync is disabled or user is not authenticated
    if (!syncEnabled || !userId) return

    const unsubscribe = subscribeToCanvas(canvasId, {
      onCreate: (shape) => {
        // Only add if not created locally
        if (!localShapesRef.current.has(shape.id)) {
          setShapes((prev) => {
            // Avoid duplicates
            if (prev.some((s) => s.id === shape.id)) {
              return prev
            }
            return [...prev, shape]
          })
        }
      },
      onUpdate: (shapeId, updates) => {
        setShapes((prev) =>
          prev.map((shape) =>
            shape.id === shapeId ? { ...shape, ...updates } : shape
          )
        )
      },
      onDelete: (shapeId) => {
        setShapes((prev) => prev.filter((shape) => shape.id !== shapeId))
        setSelectedId((prev) => (prev === shapeId ? null : prev))
        // Remove from selectedIds if it was selected
        setSelectedIds((prev) => {
          const next = new Set(prev)
          next.delete(shapeId)
          return next
        })
        localShapesRef.current.delete(shapeId)
      },
    })

    return () => {
      unsubscribe()
    }
  }, [syncEnabled, canvasId, userId])

  return {
    shapes,
    selectedId,
    selectedIds,
    addShape,
    addText,
    updateShape,
    deleteShape,
    setSelection,
    toggleSelection,
    selectMultiple,
    clearSelection,
    selectAll,
    getSelectedShapes,
    bulkMove,
    bulkDelete,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    canUndo,
    canRedo,
    updateColors,
    getRecentColors,
    addRecentColor,
    addLine,
    addPolygon,
    addStar,
    addRoundedRect,
    addPath,
    bringToFront,
    sendToBack,
    bringForward,
    sendBackward,
    sortShapesByZIndex,
    alignSelected,
    distributeSelectedHorizontally,
    distributeSelectedVertically,
    centerSelectedInCanvas,
  }
}
</file>

<file path="src/hooks/useCanvasList.ts">
/**
 * useCanvasList Hook (PR-22)
 * Manages canvas list state with real-time Firebase updates
 */

import { useState, useEffect, useCallback } from 'react'
import { ref, onValue, off } from 'firebase/database'
import { db } from '../services/firebase'
import {
  createCanvas as createCanvasService,
  deleteCanvas as deleteCanvasService,
  duplicateCanvas as duplicateCanvasService,
  updateCanvas as updateCanvasService,
  type CanvasMetadata,
} from '../services/canvas/canvasManager'
import { useNavigate } from 'react-router-dom'

interface UseCanvasListReturn {
  canvases: CanvasMetadata[]
  loading: boolean
  error: string | null
  createCanvas: (name: string) => Promise<void>
  deleteCanvas: (canvasId: string) => Promise<void>
  duplicateCanvas: (canvasId: string) => Promise<void>
  updateCanvasName: (canvasId: string, name: string) => Promise<void>
  refreshCanvases: () => void
}

/**
 * Hook for managing user's canvas list
 * Subscribes to real-time updates from Firebase
 */
export function useCanvasList(userId: string): UseCanvasListReturn {
  const [canvases, setCanvases] = useState<CanvasMetadata[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const navigate = useNavigate()

  // Subscribe to user's canvases
  useEffect(() => {
    if (!userId) {
      setLoading(false)
      return
    }

    setLoading(true)
    const canvasesRef = ref(db, `users/${userId}/canvases`)

    const handleValue = (snapshot: any) => {
      try {
        if (!snapshot.exists()) {
          setCanvases([])
          setLoading(false)
          return
        }

        const canvasesData = snapshot.val()
        const canvasList: CanvasMetadata[] = Object.values(canvasesData)

        // Sort by updatedAt (most recent first)
        canvasList.sort((a, b) => b.updatedAt - a.updatedAt)

        setCanvases(canvasList)
        setError(null)
      } catch (err) {
        console.error('Error processing canvases:', err)
        setError('Failed to load canvases')
      } finally {
        setLoading(false)
      }
    }

    const handleError = (err: Error) => {
      console.error('Firebase error:', err)
      setError('Failed to connect to database')
      setLoading(false)
    }

    onValue(canvasesRef, handleValue, handleError)

    // Cleanup subscription on unmount
    return () => {
      off(canvasesRef, 'value', handleValue)
    }
  }, [userId])

  /**
   * Create new canvas and navigate to it
   */
  const createCanvas = useCallback(
    async (name: string) => {
      try {
        setError(null)
        const canvas = await createCanvasService(name, userId)
        console.log('Canvas created:', canvas.id)
        
        // Navigate to the new canvas
        navigate(`/canvas/${canvas.id}`)
      } catch (err) {
        console.error('Error creating canvas:', err)
        setError('Failed to create canvas')
        throw err
      }
    },
    [userId, navigate]
  )

  /**
   * Delete canvas
   */
  const deleteCanvas = useCallback(
    async (canvasId: string) => {
      try {
        setError(null)
        await deleteCanvasService(canvasId, userId)
        console.log('Canvas deleted:', canvasId)
      } catch (err) {
        console.error('Error deleting canvas:', err)
        setError('Failed to delete canvas')
        throw err
      }
    },
    [userId]
  )

  /**
   * Duplicate canvas (clone with all objects)
   */
  const duplicateCanvas = useCallback(
    async (canvasId: string) => {
      try {
        setError(null)
        const duplicatedCanvas = await duplicateCanvasService(canvasId, userId)
        console.log('Canvas duplicated:', duplicatedCanvas.id)
      } catch (err) {
        console.error('Error duplicating canvas:', err)
        setError('Failed to duplicate canvas')
        throw err
      }
    },
    [userId]
  )

  /**
   * Update canvas name
   */
  const updateCanvasName = useCallback(
    async (canvasId: string, name: string) => {
      try {
        setError(null)
        await updateCanvasService(canvasId, userId, { name })
        console.log('Canvas renamed:', canvasId)
      } catch (err) {
        console.error('Error updating canvas name:', err)
        setError('Failed to update canvas name')
        throw err
      }
    },
    [userId]
  )

  /**
   * Force refresh canvases (manual trigger)
   */
  const refreshCanvases = useCallback(() => {
    // Firebase onValue automatically updates, but we can trigger re-subscription
    setLoading(true)
  }, [])

  return {
    canvases,
    loading,
    error,
    createCanvas,
    deleteCanvas,
    duplicateCanvas,
    updateCanvasName,
    refreshCanvases,
  }
}
</file>

<file path="src/hooks/useCanvasViewport.ts">
import { useState, useCallback, useEffect, useRef } from 'react'
import Konva from 'konva'
import type { ViewportTransform } from '../types/canvas'
import { DEFAULT_CANVAS_CONFIG, DEFAULT_CANVAS_BOUNDS } from '../types/canvas'

const CANVAS_CONFIG = DEFAULT_CANVAS_CONFIG
const CANVAS_BOUNDS = DEFAULT_CANVAS_BOUNDS

interface UseCanvasViewportProps {
  containerWidth: number
  containerHeight: number
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
}

export function useCanvasViewport({
  containerWidth,
  containerHeight,
  onViewportChange,
  onZoomChange,
}: UseCanvasViewportProps) {
  const [viewport, setViewport] = useState<ViewportTransform>({
    x: 0,
    y: 0,
    scale: 1,
  })

  // Center canvas on initial load
  useEffect(() => {
    const centerX = (containerWidth / 2) - (CANVAS_BOUNDS.maxX / 2)
    const centerY = (containerHeight / 2) - (CANVAS_BOUNDS.maxY / 2)
    
    const initialViewport = {
      x: centerX,
      y: centerY,
      scale: 1,
    }
    setViewport(initialViewport)
    onViewportChange?.(initialViewport)
    onZoomChange?.(1)
  }, [containerWidth, containerHeight]) // eslint-disable-line react-hooks/exhaustive-deps

  // Notify parent of viewport changes
  const viewportCallbacksRef = useRef({ onViewportChange, onZoomChange })
  useEffect(() => {
    viewportCallbacksRef.current = { onViewportChange, onZoomChange }
  }, [onViewportChange, onZoomChange])

  useEffect(() => {
    viewportCallbacksRef.current.onViewportChange?.(viewport)
    viewportCallbacksRef.current.onZoomChange?.(viewport.scale)
  }, [viewport])

  /**
   * Zoom towards a specific point
   */
  const zoomToPoint = useCallback((newScale: number, pointX: number, pointY: number) => {
    const clampedScale = Math.max(
      CANVAS_CONFIG.minScale,
      Math.min(CANVAS_CONFIG.maxScale, newScale)
    )

    const mousePointTo = {
      x: (pointX - viewport.x) / viewport.scale,
      y: (pointY - viewport.y) / viewport.scale,
    }

    const newX = pointX - mousePointTo.x * clampedScale
    const newY = pointY - mousePointTo.y * clampedScale

    setViewport({
      x: newX,
      y: newY,
      scale: clampedScale,
    })
  }, [viewport])

  /**
   * Handle mouse wheel for zoom functionality
   */
  const handleWheel = useCallback(
    (e: Konva.KonvaEventObject<WheelEvent>, stageRef: Konva.Stage) => {
      e.evt.preventDefault()

      const pointer = stageRef.getPointerPosition()
      if (!pointer) return

      const scaleBy = 1.05
      const newScale =
        e.evt.deltaY > 0 ? viewport.scale / scaleBy : viewport.scale * scaleBy

      zoomToPoint(newScale, pointer.x, pointer.y)
    },
    [viewport.scale, zoomToPoint]
  )

  /**
   * Handle drag end for pan functionality with boundary enforcement
   */
  const handleDragEnd = useCallback(
    (e: Konva.KonvaEventObject<DragEvent>) => {
      const stage = e.target.getStage()
      if (e.target !== stage) {
        return // This is a shape drag, not a stage pan
      }

      const newX = stage.x()
      const newY = stage.y()
      const scale = stage.scaleX()

      // Enforce hard boundaries
      const clampedX = Math.min(
        0,
        Math.max(newX, containerWidth - CANVAS_BOUNDS.maxX * scale)
      )
      const clampedY = Math.min(
        0,
        Math.max(newY, containerHeight - CANVAS_BOUNDS.maxY * scale)
      )

      if (clampedX !== newX || clampedY !== newY) {
        stage.position({ x: clampedX, y: clampedY })
      }

      setViewport({
        x: clampedX,
        y: clampedY,
        scale,
      })
    },
    [containerWidth, containerHeight]
  )

  /**
   * Zoom control functions
   */
  const handleZoomIn = useCallback(() => {
    const newScale = Math.min(viewport.scale * 1.2, CANVAS_CONFIG.maxScale)
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    zoomToPoint(newScale, centerX, centerY)
  }, [viewport.scale, containerWidth, containerHeight, zoomToPoint])

  const handleZoomOut = useCallback(() => {
    const newScale = Math.max(viewport.scale / 1.2, CANVAS_CONFIG.minScale)
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    zoomToPoint(newScale, centerX, centerY)
  }, [viewport.scale, containerWidth, containerHeight, zoomToPoint])

  const handleZoomReset = useCallback(() => {
    setViewport((prev) => ({
      ...prev,
      scale: 1,
    }))
  }, [])

  const handleZoomFit = useCallback(() => {
    const scaleX = containerWidth / CANVAS_BOUNDS.maxX
    const scaleY = containerHeight / CANVAS_BOUNDS.maxY
    const newScale = Math.min(scaleX, scaleY) * 0.9

    const newX = (containerWidth - CANVAS_BOUNDS.maxX * newScale) / 2
    const newY = (containerHeight - CANVAS_BOUNDS.maxY * newScale) / 2

    setViewport({
      x: newX,
      y: newY,
      scale: Math.max(CANVAS_CONFIG.minScale, Math.min(CANVAS_CONFIG.maxScale, newScale)),
    })
  }, [containerWidth, containerHeight])

  return {
    viewport,
    setViewport,
    handleWheel,
    handleDragEnd,
    handleZoomIn,
    handleZoomOut,
    handleZoomReset,
    handleZoomFit,
    zoomToPoint,
  }
}
</file>

<file path="src/hooks/useContextMenu.ts">
import { useState, useCallback } from 'react'

interface ContextMenuState {
  x: number
  y: number
  visible: boolean
}

/**
 * useContextMenu - Hook for managing context menu state (PR-20)
 * Provides show/hide functionality with position tracking
 */
export function useContextMenu() {
  const [contextMenu, setContextMenu] = useState<ContextMenuState>({
    x: 0,
    y: 0,
    visible: false,
  })

  const show = useCallback((x: number, y: number) => {
    setContextMenu({ x, y, visible: true })
  }, [])

  const hide = useCallback(() => {
    setContextMenu((prev) => ({ ...prev, visible: false }))
  }, [])

  const toggle = useCallback((x: number, y: number) => {
    setContextMenu((prev) => 
      prev.visible ? { ...prev, visible: false } : { x, y, visible: true }
    )
  }, [])

  return {
    contextMenu,
    show,
    hide,
    toggle,
  }
}
</file>

<file path="src/hooks/useGroups.ts">
/**
 * useGroups Hook (PR-19)
 * Hook for managing group state and operations with Firebase sync
 */

import { useState, useCallback, useEffect } from 'react'
import { ref, onValue, off } from 'firebase/database'
import { db } from '../services/firebase'
import type { Group } from '../types/group'
import type { Shape } from '../types/canvas'
import {
  syncCreateGroup,
  syncUpdateGroup,
  syncDeleteGroup,
  syncAddToGroup,
  syncRemoveFromGroup,
} from '../services/collaboration/groupSync'
import {
  isInAnyGroup,
  getAllGroupMembers,
  getGroupShapes,
  hasCircularDependency,
  updateGroupBounds,
} from '../utils/canvas/groupHelpers'

interface UseGroupsOptions {
  canvasId: string
  userId: string
  enableSync?: boolean
}

interface UseGroupsReturn {
  groups: Group[]
  createGroup: (shapeIds: string[], name?: string) => Promise<string | null>
  ungroup: (groupId: string) => Promise<void>
  addToGroup: (groupId: string, shapeId: string) => Promise<void>
  removeFromGroup: (groupId: string, shapeId: string) => Promise<void>
  updateGroup: (groupId: string, updates: Partial<Omit<Group, 'id' | 'createdAt' | 'createdBy'>>) => Promise<void>
  getGroupById: (groupId: string) => Group | undefined
  isShapeInGroup: (shapeId: string) => string | null
  getGroupMembers: (groupId: string) => string[]
  calculateBounds: (groupId: string, shapes: Shape[]) => { x: number; y: number; width: number; height: number } | null
}

/**
 * Hook for managing groups with Firebase sync
 * Handles group creation, updates, deletion, and membership operations
 */
export function useGroups(options?: UseGroupsOptions): UseGroupsReturn {
  const [groups, setGroups] = useState<Group[]>([])
  const syncEnabled = options?.enableSync ?? true
  const canvasId = options?.canvasId ?? 'default-canvas'
  const userId = options?.userId ?? 'anonymous'

  /**
   * Subscribe to groups changes from Firebase
   */
  useEffect(() => {
    if (!syncEnabled) return

    const groupsRef = ref(db, `canvases/${canvasId}/groups`)

    const handleGroupsChange = (snapshot: any) => {
      if (snapshot.exists()) {
        const groupsData = snapshot.val()
        const groupsArray = Object.values(groupsData) as Group[]
        setGroups(groupsArray)
      } else {
        setGroups([])
      }
    }

    onValue(groupsRef, handleGroupsChange)

    return () => {
      off(groupsRef, 'value', handleGroupsChange)
    }
  }, [canvasId, syncEnabled])

  /**
   * Create a new group from selected shapes
   */
  const createGroup = useCallback(
    async (shapeIds: string[], name?: string): Promise<string | null> => {
      if (shapeIds.length < 2) {
        console.warn('Cannot create group with less than 2 shapes')
        return null
      }

      // Check for circular dependencies
      for (const shapeId of shapeIds) {
        // Check if any of the shapes are groups that would create a circular dependency
        const potentialGroup = groups.find((g) => g.id === shapeId)
        if (potentialGroup) {
          for (const otherShapeId of shapeIds) {
            if (shapeId !== otherShapeId && hasCircularDependency(shapeId, otherShapeId, groups)) {
              console.error('Cannot create group: circular dependency detected')
              return null
            }
          }
        }
      }

      try {
        const group = await syncCreateGroup(canvasId, shapeIds, userId, name)
        console.log(`Group created: ${group.id}`)
        return group.id
      } catch (error) {
        console.error('Error creating group:', error)
        return null
      }
    },
    [canvasId, userId, groups]
  )

  /**
   * Dissolve a group (ungroup) - keeps member shapes
   */
  const ungroup = useCallback(
    async (groupId: string): Promise<void> => {
      try {
        await syncDeleteGroup(canvasId, groupId)
        console.log(`Group ungrouped: ${groupId}`)
      } catch (error) {
        console.error('Error ungrouping:', error)
        throw error
      }
    },
    [canvasId]
  )

  /**
   * Add a shape to an existing group
   */
  const addToGroup = useCallback(
    async (groupId: string, shapeId: string): Promise<void> => {
      // Check for circular dependency
      if (hasCircularDependency(groupId, shapeId, groups)) {
        console.error('Cannot add to group: circular dependency detected')
        return
      }

      try {
        await syncAddToGroup(canvasId, groupId, shapeId)
        console.log(`Added ${shapeId} to group ${groupId}`)
      } catch (error) {
        console.error('Error adding to group:', error)
        throw error
      }
    },
    [canvasId, groups]
  )

  /**
   * Remove a shape from a group
   */
  const removeFromGroup = useCallback(
    async (groupId: string, shapeId: string): Promise<void> => {
      try {
        await syncRemoveFromGroup(canvasId, groupId, shapeId)
        console.log(`Removed ${shapeId} from group ${groupId}`)
      } catch (error) {
        console.error('Error removing from group:', error)
        throw error
      }
    },
    [canvasId]
  )

  /**
   * Update group properties
   */
  const updateGroup = useCallback(
    async (
      groupId: string,
      updates: Partial<Omit<Group, 'id' | 'createdAt' | 'createdBy'>>
    ): Promise<void> => {
      try {
        await syncUpdateGroup(canvasId, groupId, updates)
        console.log(`Group updated: ${groupId}`)
      } catch (error) {
        console.error('Error updating group:', error)
        throw error
      }
    },
    [canvasId]
  )

  /**
   * Get group by ID
   */
  const getGroupById = useCallback(
    (groupId: string): Group | undefined => {
      return groups.find((g) => g.id === groupId)
    },
    [groups]
  )

  /**
   * Check if a shape is in any group
   */
  const isShapeInGroup = useCallback(
    (shapeId: string): string | null => {
      return isInAnyGroup(shapeId, groups)
    },
    [groups]
  )

  /**
   * Get all member IDs of a group (including nested groups)
   */
  const getGroupMembers = useCallback(
    (groupId: string): string[] => {
      return getAllGroupMembers(groupId, groups)
    },
    [groups]
  )

  /**
   * Calculate group bounding box from member positions
   */
  const calculateBounds = useCallback(
    (groupId: string, shapes: Shape[]): { x: number; y: number; width: number; height: number } | null => {
      const group = groups.find((g) => g.id === groupId)
      if (!group) {
        return null
      }

      const memberShapes = getGroupShapes(groupId, groups, shapes)
      if (memberShapes.length === 0) {
        return null
      }

      return updateGroupBounds(group, shapes, groups)
    },
    [groups]
  )

  return {
    groups,
    createGroup,
    ungroup,
    addToGroup,
    removeFromGroup,
    updateGroup,
    getGroupById,
    isShapeInGroup,
    getGroupMembers,
    calculateBounds,
  }
}
</file>

<file path="src/hooks/useKeyboardShortcuts.ts">
import { useEffect } from 'react'

interface KeyboardShortcutHandlers {
  [action: string]: () => void
}

/**
 * useKeyboardShortcuts - Global keyboard event handler (PR-20)
 * Manages keyboard shortcuts for tools, editing, and navigation
 */
export function useKeyboardShortcuts(handlers: KeyboardShortcutHandlers) {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't trigger shortcuts when typing in input fields
      const target = e.target as HTMLElement
      if (
        target.tagName === 'INPUT' ||
        target.tagName === 'TEXTAREA' ||
        target.isContentEditable
      ) {
        return
      }

      const key = e.key.toUpperCase()
      const ctrl = e.metaKey || e.ctrlKey
      const shift = e.shiftKey
      const alt = e.altKey

      // Tools (no modifiers)
      if (!ctrl && !shift && !alt) {
        if (key === 'V' && handlers.selectTool) {
          e.preventDefault()
          handlers.selectTool()
        } else if (key === 'H' && handlers.handTool) {
          e.preventDefault()
          handlers.handTool()
        } else if (key === 'R' && handlers.rectangleTool) {
          e.preventDefault()
          handlers.rectangleTool()
        } else if (key === 'O' && handlers.circleTool) {
          e.preventDefault()
          handlers.circleTool()
        } else if (key === 'T' && handlers.textTool) {
          e.preventDefault()
          handlers.textTool()
        } else if (key === 'L' && handlers.lineTool) {
          e.preventDefault()
          handlers.lineTool()
        } else if (key === 'P' && handlers.pencilTool) {
          e.preventDefault()
          handlers.pencilTool()
        } else if (key === 'N' && handlers.penTool) {
          e.preventDefault()
          handlers.penTool()
        } else if (key === '?' && handlers.showShortcuts) {
          e.preventDefault()
          handlers.showShortcuts()
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
          if (handlers.delete) {
            e.preventDefault()
            handlers.delete()
          }
        } else if (e.key === 'Escape' && handlers.clearSelection) {
          e.preventDefault()
          handlers.clearSelection()
        }
      }

      // Edit (Ctrl/Cmd + key)
      if (ctrl && !shift && !alt) {
        if (key === 'C' && handlers.copy) {
          e.preventDefault()
          handlers.copy()
        } else if (key === 'V' && handlers.paste) {
          e.preventDefault()
          handlers.paste()
        } else if (key === 'D' && handlers.duplicate) {
          e.preventDefault()
          handlers.duplicate()
        } else if (key === 'A' && handlers.selectAll) {
          e.preventDefault()
          handlers.selectAll()
        } else if (key === 'Z' && handlers.undo) {
          e.preventDefault()
          handlers.undo()
        } else if (key === 'E' && handlers.export) {
          e.preventDefault()
          handlers.export()
        } else if (key === 'G' && handlers.group) {
          e.preventDefault()
          handlers.group()
        } else if (key === ']' && handlers.bringForward) {
          e.preventDefault()
          handlers.bringForward()
        } else if (key === '[' && handlers.sendBackward) {
          e.preventDefault()
          handlers.sendBackward()
        }
      }

      // Edit with Shift (Ctrl/Cmd + Shift + key)
      if (ctrl && shift && !alt) {
        if (key === 'Z' && handlers.redo) {
          e.preventDefault()
          handlers.redo()
        } else if (key === 'G' && handlers.ungroup) {
          e.preventDefault()
          handlers.ungroup()
        } else if (key === ']' && handlers.bringToFront) {
          e.preventDefault()
          handlers.bringToFront()
        } else if (key === '[' && handlers.sendToBack) {
          e.preventDefault()
          handlers.sendToBack()
        }
      }
    }

    const handleKeyUp = (e: KeyboardEvent) => {
      // Handle Space key release for temporary hand tool
      if (e.key === ' ' && handlers.tempHandToolRelease) {
        e.preventDefault()
        handlers.tempHandToolRelease()
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    document.addEventListener('keyup', handleKeyUp)

    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.removeEventListener('keyup', handleKeyUp)
    }
  }, [handlers])
}
</file>

<file path="src/hooks/useLayers.ts">
/**
 * useLayers Hook (PR-19)
 * Hook for managing layer state, visibility, locking, and z-index reordering
 */

import { useState, useCallback, useEffect } from 'react'
import { ref, onValue, off, update } from 'firebase/database'
import { db } from '../services/firebase'
import type { LayerVisibility, LayerLock } from '../types/layer'
import type { Shape } from '../types/canvas'

interface UseLayersOptions {
  canvasId: string
  enableSync?: boolean
}

interface UseLayersReturn {
  visibility: LayerVisibility
  locks: LayerLock
  toggleVisibility: (objectId: string) => Promise<void>
  toggleLock: (objectId: string) => Promise<void>
  setVisibility: (objectId: string, visible: boolean) => Promise<void>
  setLock: (objectId: string, locked: boolean) => Promise<void>
  reorderLayers: (fromIndex: number, toIndex: number, shapes: Shape[]) => Promise<void>
  isVisible: (objectId: string) => boolean
  isLocked: (objectId: string) => boolean
}

/**
 * Hook for managing layer visibility, locking, and z-index
 * Syncs with Firebase for real-time collaboration
 */
export function useLayers(options?: UseLayersOptions): UseLayersReturn {
  const [visibility, setVisibilityState] = useState<LayerVisibility>({})
  const [locks, setLocksState] = useState<LayerLock>({})
  const syncEnabled = options?.enableSync ?? true
  const canvasId = options?.canvasId ?? 'default-canvas'

  /**
   * Subscribe to visibility changes from Firebase
   */
  useEffect(() => {
    if (!syncEnabled) return

    const visibilityRef = ref(db, `canvases/${canvasId}/visibility`)
    const locksRef = ref(db, `canvases/${canvasId}/locks`)

    const handleVisibilityChange = (snapshot: any) => {
      if (snapshot.exists()) {
        setVisibilityState(snapshot.val())
      } else {
        setVisibilityState({})
      }
    }

    const handleLocksChange = (snapshot: any) => {
      if (snapshot.exists()) {
        setLocksState(snapshot.val())
      } else {
        setLocksState({})
      }
    }

    onValue(visibilityRef, handleVisibilityChange)
    onValue(locksRef, handleLocksChange)

    return () => {
      off(visibilityRef, 'value', handleVisibilityChange)
      off(locksRef, 'value', handleLocksChange)
    }
  }, [canvasId, syncEnabled])

  /**
   * Toggle visibility for an object
   */
  const toggleVisibility = useCallback(
    async (objectId: string): Promise<void> => {
      const currentVisibility = visibility[objectId] !== false // default to visible
      const newVisibility = !currentVisibility

      if (syncEnabled) {
        const visibilityRef = ref(db, `canvases/${canvasId}/visibility/${objectId}`)
        await update(visibilityRef, { value: newVisibility })
      } else {
        setVisibilityState((prev) => ({
          ...prev,
          [objectId]: newVisibility,
        }))
      }
    },
    [canvasId, syncEnabled, visibility]
  )

  /**
   * Toggle lock for an object
   */
  const toggleLock = useCallback(
    async (objectId: string): Promise<void> => {
      const currentLock = locks[objectId] === true // default to unlocked
      const newLock = !currentLock

      if (syncEnabled) {
        const lockRef = ref(db, `canvases/${canvasId}/locks/${objectId}`)
        await update(lockRef, { value: newLock })
      } else {
        setLocksState((prev) => ({
          ...prev,
          [objectId]: newLock,
        }))
      }
    },
    [canvasId, syncEnabled, locks]
  )

  /**
   * Set visibility for an object
   */
  const setVisibility = useCallback(
    async (objectId: string, visible: boolean): Promise<void> => {
      if (syncEnabled) {
        const visibilityRef = ref(db, `canvases/${canvasId}/visibility/${objectId}`)
        await update(visibilityRef, { value: visible })
      } else {
        setVisibilityState((prev) => ({
          ...prev,
          [objectId]: visible,
        }))
      }
    },
    [canvasId, syncEnabled]
  )

  /**
   * Set lock for an object
   */
  const setLock = useCallback(
    async (objectId: string, locked: boolean): Promise<void> => {
      if (syncEnabled) {
        const lockRef = ref(db, `canvases/${canvasId}/locks/${objectId}`)
        await update(lockRef, { value: locked })
      } else {
        setLocksState((prev) => ({
          ...prev,
          [objectId]: locked,
        }))
      }
    },
    [canvasId, syncEnabled]
  )

  /**
   * Reorder layers by changing z-index
   */
  const reorderLayers = useCallback(
    async (fromIndex: number, toIndex: number, shapes: Shape[]): Promise<void> => {
      if (fromIndex === toIndex) return

      // Reorder the shapes array
      const reordered = [...shapes]
      const [moved] = reordered.splice(fromIndex, 1)
      reordered.splice(toIndex, 0, moved)

      // Update z-index for all shapes
      const updates: { [key: string]: any } = {}
      reordered.forEach((shape, index) => {
        if (syncEnabled) {
          updates[`canvases/${canvasId}/objects/${shape.id}/zIndex`] = index
        }
      })

      if (syncEnabled && Object.keys(updates).length > 0) {
        await update(ref(db), updates)
      }
    },
    [canvasId, syncEnabled]
  )

  /**
   * Check if an object is visible
   */
  const isVisible = useCallback(
    (objectId: string): boolean => {
      return visibility[objectId] !== false // default to visible
    },
    [visibility]
  )

  /**
   * Check if an object is locked
   */
  const isLocked = useCallback(
    (objectId: string): boolean => {
      return locks[objectId] === true // default to unlocked
    },
    [locks]
  )

  return {
    visibility,
    locks,
    toggleVisibility,
    toggleLock,
    setVisibility,
    setLock,
    reorderLayers,
    isVisible,
    isLocked,
  }
}
</file>

<file path="src/hooks/usePresence.ts">
import { useEffect, useRef, useCallback, useState } from 'react'
import { ref, set, onValue, onDisconnect, off } from 'firebase/database'
import { db } from '../services/firebase'
import type { Presence, PresenceData } from '../types/firebase'
import { throttle } from '../utils/common/throttle'

// Predefined color palette for user cursors and selections
const USER_COLORS = [
  '#EF4444', // red
  '#F59E0B', // amber
  '#10B981', // emerald
  '#3B82F6', // blue
  '#8B5CF6', // violet
  '#EC4899', // pink
  '#14B8A6', // teal
  '#F97316', // orange
]

/**
 * Generate a consistent color for a user based on their userId
 */
function getUserColor(userId: string): string {
  // Simple hash function to get consistent color per user
  let hash = 0
  for (let i = 0; i < userId.length; i++) {
    hash = userId.charCodeAt(i) + ((hash << 5) - hash)
  }
  const index = Math.abs(hash) % USER_COLORS.length
  return USER_COLORS[index]
}

interface UsePresenceOptions {
  userId: string
  userName: string
  canvasId: string
}

interface UsePresenceReturn {
  otherUsers: Map<string, Presence>
  updateCursorPosition: (x: number, y: number) => void
  updateSelection: (objectIds: string[] | null) => void
}

/**
 * Hook to manage user presence (cursor position, selection state)
 * Throttles cursor updates to 20Hz (50ms intervals)
 */
export function usePresence({
  userId,
  userName,
  canvasId: _canvasId,
}: UsePresenceOptions): UsePresenceReturn {
  const [otherUsers, setOtherUsers] = useState<Map<string, Presence>>(new Map())
  const userColor = useRef<string>(getUserColor(userId || 'default'))
  const currentPresence = useRef<Presence>({
    n: userName,
    cl: userColor.current,
    c: [0, 0],
    sel: null,
  })

  /**
   * Update cursor position (throttled to 33ms / 30Hz for smoother movement)
   */
  const updateCursorPosition = useCallback(
    throttle((x: number, y: number) => {
      // Don't update if user is not authenticated
      if (!userId || !_canvasId) return
      
      // Collab Spaces use shared presence paths
      const collabSpaces = ['collab-art', 'collab-design', 'collab-education', 'collab-content', 'collab-gamedev', 'collab-architecture']
      const presencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}/${userId}` : `presence/${_canvasId}/${userId}`
      const presenceRef = ref(db, presencePath)
      
      currentPresence.current.c = [x, y]
      set(presenceRef, currentPresence.current).catch((error) => {
        console.error('Failed to update cursor position:', error)
      })
    }, 33), // 30Hz = 33ms between updates for smoother cursor movement
    [userId, _canvasId]
  )

  /**
   * Update selected object IDs (no throttle needed)
   * Now supports multi-select with array format
   */
  const updateSelection = useCallback(
    (objectIds: string[] | null) => {
      // Don't update if user is not authenticated
      if (!userId || !_canvasId) return
      
      // Collab Spaces use shared presence paths
      const collabSpaces = ['collab-art', 'collab-design', 'collab-education', 'collab-content', 'collab-gamedev', 'collab-architecture']
      const presencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}/${userId}` : `presence/${_canvasId}/${userId}`
      const presenceRef = ref(db, presencePath)
      
      currentPresence.current.sel = objectIds
      set(presenceRef, currentPresence.current).catch((error) => {
        console.error('Failed to update selection:', error)
      })
    },
    [userId, _canvasId]
  )

  /**
   * Initialize presence and listen to other users
   */
  useEffect(() => {
    // Don't initialize presence if userId or canvasId is empty
    if (!userId || !_canvasId) {
      return
    }

    // Collab Spaces use shared presence paths
    const collabSpaces = ['collab-art', 'collab-design', 'collab-education', 'collab-brainstorm', 'collab-content', 'collab-gamedev', 'collab-architecture']
    const presencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}/${userId}` : `presence/${_canvasId}/${userId}`
    const presenceRef = ref(db, presencePath)

    // Set initial presence
    const initialPresence: Presence = {
      n: userName,
      cl: userColor.current,
      c: [0, 0],
      sel: null,
    }
    currentPresence.current = initialPresence
    set(presenceRef, initialPresence).catch((error) => {
      console.error('Failed to set initial presence:', error)
    })

    // Clean up presence on disconnect
    const disconnectRef = onDisconnect(presenceRef)
    disconnectRef.remove().catch((error) => {
      console.error('Failed to set onDisconnect:', error)
    })

    // Listen to all presence updates for this canvas
    const allPresencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}` : `presence/${_canvasId}`
    const allPresenceRef = ref(db, allPresencePath)
    const unsubscribe = onValue(
      allPresenceRef,
      (snapshot) => {
        const presenceData = snapshot.val() as PresenceData | null
        if (!presenceData) {
          setOtherUsers(new Map())
          return
        }

        // Filter out current user and create map
        const otherUsersMap = new Map<string, Presence>()
        Object.entries(presenceData).forEach(([uid, presence]) => {
          if (uid !== userId) {
            otherUsersMap.set(uid, presence)
          }
        })

        setOtherUsers(otherUsersMap)
      },
      (error) => {
        console.error('Failed to listen to presence:', error)
      }
    )

    // Cleanup on unmount
    return () => {
      // Remove presence data
      set(presenceRef, null).catch((error) => {
        console.error('Failed to remove presence:', error)
      })
      // Unsubscribe from presence updates
      off(allPresenceRef, 'value', unsubscribe)
    }
  }, [userId, userName, _canvasId])

  return {
    otherUsers,
    updateCursorPosition,
    updateSelection,
  }
}
</file>

<file path="src/hooks/useShapeKeyboardShortcuts.ts">
import { useEffect } from 'react'
import type { Group as GroupType } from '../types/group'

interface UseShapeKeyboardShortcutsProps {
  selectedIds: Set<string>
  groups: GroupType[]
  canUndo: boolean
  canRedo: boolean
  isColorSamplingMode: boolean
  bulkDelete: () => void
  clearSelection: () => void
  selectAll: () => void
  copySelected: () => void
  paste: () => void
  duplicateSelected: () => void
  undo: () => void
  redo: () => void
  createGroup: (shapeIds: string[]) => Promise<string | null>
  ungroup: (groupId: string) => Promise<void>
  cancelColorSampling: () => void
}

/**
 * Custom hook for managing keyboard shortcuts in shape canvas
 * Handles:
 * - Delete/Backspace: Delete selected shapes
 * - Escape: Cancel color sampling or clear selection
 * - Cmd/Ctrl+A: Select all
 * - Cmd/Ctrl+C: Copy
 * - Cmd/Ctrl+V: Paste
 * - Cmd/Ctrl+D: Duplicate
 * - Cmd/Ctrl+Z: Undo
 * - Cmd/Ctrl+Shift+Z: Redo
 * - Cmd/Ctrl+G: Group
 * - Cmd/Ctrl+Shift+G: Ungroup
 */
export function useShapeKeyboardShortcuts({
  selectedIds,
  groups,
  canUndo,
  canRedo,
  isColorSamplingMode,
  bulkDelete,
  clearSelection,
  selectAll,
  copySelected,
  paste,
  duplicateSelected,
  undo,
  redo,
  createGroup,
  ungroup,
  cancelColorSampling,
}: UseShapeKeyboardShortcutsProps) {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Delete/Backspace - delete selected shapes
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedIds.size > 0) {
        e.preventDefault()
        bulkDelete()
      }
      
      // Escape - cancel color sampling or clear selection
      if (e.key === 'Escape') {
        e.preventDefault()
        if (isColorSamplingMode) {
          cancelColorSampling()
        } else {
          clearSelection()
        }
      }
      
      // Cmd/Ctrl+A - select all
      if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
        e.preventDefault()
        selectAll()
      }
      
      // Cmd/Ctrl+C - copy selected shapes
      if ((e.metaKey || e.ctrlKey) && e.key === 'c' && selectedIds.size > 0) {
        e.preventDefault()
        copySelected()
      }
      
      // Cmd/Ctrl+V - paste shapes
      if ((e.metaKey || e.ctrlKey) && e.key === 'v') {
        e.preventDefault()
        paste()
      }
      
      // Cmd/Ctrl+D - duplicate selected shapes
      if ((e.metaKey || e.ctrlKey) && e.key === 'd' && selectedIds.size > 0) {
        e.preventDefault()
        duplicateSelected()
      }
      
      // Cmd/Ctrl+Z - undo
      if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'z' && canUndo) {
        e.preventDefault()
        undo()
      }
      
      // Cmd/Ctrl+Shift+Z - redo
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'z' && canRedo) {
        e.preventDefault()
        redo()
      }
      
      // Cmd/Ctrl+G - create group from selected shapes
      if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'g' && selectedIds.size >= 2) {
        e.preventDefault()
        const shapeIds = Array.from(selectedIds)
        createGroup(shapeIds).then((groupId) => {
          if (groupId) {
            clearSelection()
          }
        })
      }
      
      // Cmd/Ctrl+Shift+G - ungroup selected group
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'g' && selectedIds.size === 1) {
        e.preventDefault()
        const selectedArray = Array.from(selectedIds)
        const selectedId = selectedArray[0]
        const group = groups.find((g) => g.id === selectedId)
        if (group) {
          ungroup(selectedId).then(() => {
            clearSelection()
          })
        }
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [
    selectedIds,
    groups,
    canUndo,
    canRedo,
    isColorSamplingMode,
    bulkDelete,
    clearSelection,
    selectAll,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    createGroup,
    ungroup,
    cancelColorSampling,
  ])
}
</file>

<file path="src/hooks/useSpriteCache.ts">
/**
 * Sprite Cache Hook
 * Preloads and caches tileset sprite sheets for optimal performance
 */

import { useState, useEffect, useRef } from 'react'

/**
 * Sprite loading state
 */
export interface SpriteLoadState {
  loaded: number
  total: number
  isLoading: boolean
  errors: string[]
}

/**
 * Cache of loaded sprite sheet images
 * Shared across all components
 */
const spriteImageCache = new Map<string, HTMLImageElement>()
const loadingPromises = new Map<string, Promise<HTMLImageElement>>()

/**
 * Load a single sprite sheet image
 * 
 * @param url Path to sprite sheet
 * @returns Promise that resolves to loaded image
 */
function loadSpriteImage(url: string): Promise<HTMLImageElement> {
  // Check if already cached
  const cached = spriteImageCache.get(url)
  if (cached) {
    return Promise.resolve(cached)
  }
  
  // Check if currently loading
  const loading = loadingPromises.get(url)
  if (loading) {
    return loading
  }
  
  // Start loading
  const promise = new Promise<HTMLImageElement>((resolve, reject) => {
    const img = new Image()
    
    img.onload = () => {
      spriteImageCache.set(url, img)
      loadingPromises.delete(url)
      resolve(img)
    }
    
    img.onerror = () => {
      loadingPromises.delete(url)
      reject(new Error(`Failed to load sprite: ${url}`))
    }
    
    // Only set crossOrigin for external URLs (not local assets)
    if (url.startsWith('http://') || url.startsWith('https://')) {
      img.crossOrigin = 'anonymous'
    }
    img.src = url
  })
  
  loadingPromises.set(url, promise)
  return promise
}

/**
 * Preload multiple sprite sheets
 * 
 * @param urls Array of sprite sheet URLs
 * @returns Promise that resolves when all loaded
 */
export async function preloadSprites(urls: string[]): Promise<void> {
  const promises = urls.map((url) => loadSpriteImage(url))
  await Promise.all(promises)
}

/**
 * Hook to load and cache sprite sheets
 * 
 * @param spriteUrls Array of sprite sheet URLs to preload
 * @returns Tuple of [loadState, getSprite function]
 * 
 * @example
 * ```tsx
 * const [loadState, getSprite] = useSpriteCache([
 *   '/assets/tilesets/grass.png',
 *   '/assets/tilesets/water.png',
 * ])
 * 
 * if (loadState.isLoading) return <LoadingBar progress={loadState.loaded / loadState.total} />
 * 
 * const image = getSprite('/assets/tilesets/grass.png')
 * ```
 */
export function useSpriteCache(spriteUrls: string[]): [
  SpriteLoadState,
  (url: string) => HTMLImageElement | null
] {
  const [loadState, setLoadState] = useState<SpriteLoadState>({
    loaded: 0,
    total: spriteUrls.length,
    isLoading: true,
    errors: [],
  })
  
  const urlsRef = useRef<string[]>([])
  
  useEffect(() => {
    // Only reload if URLs actually changed
    const urlsChanged = JSON.stringify(spriteUrls) !== JSON.stringify(urlsRef.current)
    if (!urlsChanged) return
    
    urlsRef.current = spriteUrls
    
    // Reset load state
    setLoadState({
      loaded: 0,
      total: spriteUrls.length,
      isLoading: true,
      errors: [],
    })
    
    // If no URLs, mark as complete
    if (spriteUrls.length === 0) {
      setLoadState({
        loaded: 0,
        total: 0,
        isLoading: false,
        errors: [],
      })
      return
    }
    
    // Load all sprites
    let loadedCount = 0
    const errors: string[] = []
    
    const loadPromises = spriteUrls.map(async (url) => {
      try {
        await loadSpriteImage(url)
        loadedCount++
        setLoadState((prev) => ({
          ...prev,
          loaded: loadedCount,
        }))
      } catch (error) {
        const errorMsg = `Failed to load ${url}: ${error}`
        console.error(errorMsg)
        errors.push(errorMsg)
        setLoadState((prev) => ({
          ...prev,
          errors: [...prev.errors, errorMsg],
        }))
      }
    })
    
    // Wait for all to complete
    Promise.all(loadPromises).finally(() => {
      setLoadState((prev) => ({
        ...prev,
        isLoading: false,
      }))
    })
  }, [spriteUrls])
  
  /**
   * Get a cached sprite image
   */
  const getSprite = (url: string): HTMLImageElement | null => {
    return spriteImageCache.get(url) || null
  }
  
  return [loadState, getSprite]
}

/**
 * Hook to get a single sprite (assumes it's already cached)
 * 
 * @param url Sprite sheet URL
 * @returns Cached image or null
 */
export function useSprite(url: string): HTMLImageElement | null {
  const [image, setImage] = useState<HTMLImageElement | null>(
    () => spriteImageCache.get(url) || null
  )
  
  useEffect(() => {
    // Check cache first
    const cached = spriteImageCache.get(url)
    if (cached) {
      setImage(cached)
      return
    }
    
    // Load if not cached
    loadSpriteImage(url)
      .then((img) => setImage(img))
      .catch((error) => {
        console.error(`Failed to load sprite: ${url}`, error)
        setImage(null)
      })
  }, [url])
  
  return image
}

/**
 * Clear the sprite cache (useful for testing/memory management)
 */
export function clearSpriteCache(): void {
  spriteImageCache.clear()
  loadingPromises.clear()
}

/**
 * Get cache statistics
 */
export function getSpriteCacheStats(): {
  cachedCount: number
  loadingCount: number
  cachedUrls: string[]
} {
  return {
    cachedCount: spriteImageCache.size,
    loadingCount: loadingPromises.size,
    cachedUrls: Array.from(spriteImageCache.keys()),
  }
}
</file>

<file path="src/hooks/useTilemap.ts">
/**
 * useTilemap Hook
 * Manages tilemap state with chunked Firebase sync and debounced writes
 */

import { useState, useCallback, useEffect, useRef } from 'react'
import { ref, onValue } from 'firebase/database'
import { db } from '../services/firebase'
import {
  subscribeToChunk,
  subscribeToMeta,
  setTile as _syncSetTile,
  setTiles as syncSetTiles,
  deleteTile as _syncDeleteTile,
  deleteTiles as syncDeleteTiles,
  getMeta,
  setMeta as syncSetMeta,
  initializeTilemap,
} from '../services/tilemap/tilemapSync'
import { floodFill } from '../services/tilemap/tileFill'
import type {
  TileData,
  TilemapMeta,
  TileMode,
  ConnectionStatus,
  PaletteColor,
  coordToKey,
  keyToChunkCoord,
  getVisibleChunks,
} from '../types/tilemap'
import {
  coordToKey as _coordToKey,
  keyToChunkCoord as _keyToChunkCoord,
  getVisibleChunks as _getVisibleChunks,
  DEFAULT_TILEMAP_META,
  isValidTileCoord,
} from '../types/tilemap'

// Re-export for convenience
export type { coordToKey }

interface UseTilemapOptions {
  canvasId: string
  userId: string
  enableSync?: boolean
}

interface UseTilemapReturn {
  // State
  tiles: Map<string, TileData>
  meta: TilemapMeta
  isInitialized: boolean
  isConnected: boolean
  connectionStatus: ConnectionStatus
  
  // Tile operations
  setTile: (x: number, y: number, tile: TileData) => void
  getTile: (x: number, y: number) => TileData | undefined
  deleteTile: (x: number, y: number) => void
  clearAllTiles: () => void
  
  // Bulk operations (for paint strokes and fill)
  setTiles: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void
  deleteTiles: (tiles: Array<{ x: number; y: number }>) => void
  fillTiles: (x: number, y: number, targetType: string, newType: string, newColor: string) => void
  
  // Metadata operations
  updateMeta: (updates: Partial<TilemapMeta>) => void
  
  // Chunk management
  loadVisibleChunks: (viewport: { x: number; y: number; width: number; height: number }) => void
  loadedChunks: Set<string>
  
  // Statistics
  getTileCount: () => number
  
  // Palette
  selectedPaletteIndex: number
  setSelectedPaletteIndex: (index: number) => void
  getSelectedTile: () => PaletteColor
  
  // Mode
  mode: TileMode
  setMode: (mode: TileMode) => void
}

/**
 * Hook for managing tilemap state with Firebase sync
 * Implements chunked loading and debounced writes for performance
 */
export function useTilemap(options: UseTilemapOptions): UseTilemapReturn {
  const { canvasId, userId, enableSync = true } = options
  
  // Core state
  const [tiles, setTiles] = useState<Map<string, TileData>>(new Map())
  const [meta, setMeta] = useState<TilemapMeta>(DEFAULT_TILEMAP_META)
  const [isInitialized, setIsInitialized] = useState(false)
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('connected')
  
  // Chunk management
  const loadedChunksRef = useRef<Set<string>>(new Set())
  const [loadedChunks, setLoadedChunks] = useState<Set<string>>(new Set())
  const chunkUnsubscribes = useRef<Map<string, () => void>>(new Map())
  
  // Debounced writes queue
  const [pendingWrites, setPendingWrites] = useState<Map<string, { x: number; y: number; tile: TileData | null }>>(new Map())
  const writeTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)
  
  // UI state
  const [selectedPaletteIndex, setSelectedPaletteIndex] = useState(0)
  const [mode, setMode] = useState<TileMode>('stamp')
  
  // ============================================================================
  // Connection Status Monitoring
  // ============================================================================
  
  useEffect(() => {
    const connectedRef = ref(db, '.info/connected')
    const unsubscribe = onValue(connectedRef, (snap) => {
      const connected = snap.val() as boolean
      setConnectionStatus(connected ? 'connected' : 'disconnected')
    })
    
    return unsubscribe
  }, [])
  
  // ============================================================================
  // Initialize Tilemap
  // ============================================================================
  
  useEffect(() => {
    if (!enableSync) return
    
    const initTilemap = async () => {
      try {
        // Check if tilemap exists
        const existingMeta = await getMeta(canvasId)
        
        if (existingMeta) {
          // Tilemap exists, load metadata
          setMeta(existingMeta)
        } else {
          // Initialize new tilemap
          await initializeTilemap(canvasId, DEFAULT_TILEMAP_META)
          setMeta(DEFAULT_TILEMAP_META)
        }
        
        setIsInitialized(true)
      } catch (error) {
        console.error('Failed to initialize tilemap:', error)
      }
    }
    
    initTilemap()
  }, [canvasId, enableSync])
  
  // ============================================================================
  // Subscribe to Metadata Changes
  // ============================================================================
  
  useEffect(() => {
    if (!enableSync || !isInitialized) return
    
    const unsubscribe = subscribeToMeta(canvasId, (newMeta) => {
      setMeta(newMeta)
    })
    
    return unsubscribe
  }, [canvasId, enableSync, isInitialized])
  
  // ============================================================================
  // Debounced Write System
  // ============================================================================
  
  useEffect(() => {
    if (pendingWrites.size === 0) return
    
    // Clear existing timer
    if (writeTimerRef.current) {
      clearTimeout(writeTimerRef.current)
    }
    
    // Set new timer for batch write
    writeTimerRef.current = setTimeout(async () => {
      if (!enableSync) {
        setPendingWrites(new Map())
        return
      }
      
      try {
        // Separate tiles to set and delete
        const tilesToSet: Array<{ x: number; y: number; tile: TileData }> = []
        const tilesToDelete: Array<{ x: number; y: number }> = []
        
        pendingWrites.forEach((entry) => {
          if (entry.tile === null) {
            tilesToDelete.push({ x: entry.x, y: entry.y })
          } else {
            tilesToSet.push({ x: entry.x, y: entry.y, tile: entry.tile })
          }
        })
        
        // Batch write to Firebase
        if (tilesToSet.length > 0) {
          await syncSetTiles(canvasId, tilesToSet, userId, meta.chunkSize)
        }
        if (tilesToDelete.length > 0) {
          await syncDeleteTiles(canvasId, tilesToDelete, meta.chunkSize)
        }
        
        // Clear pending writes
        setPendingWrites(new Map())
      } catch (error) {
        console.error('Failed to batch write tiles:', error)
        // Keep pending writes in queue on error (will retry)
      }
    }, 100) // 100ms batch window
    
    return () => {
      if (writeTimerRef.current) {
        clearTimeout(writeTimerRef.current)
      }
    }
  }, [pendingWrites, enableSync, canvasId, userId, meta.chunkSize])
  
  // ============================================================================
  // Chunk Loading
  // ============================================================================
  
  const loadVisibleChunks = useCallback(
    (viewport: { x: number; y: number; width: number; height: number }) => {
      if (!isInitialized) return
      
      // Get chunks that should be visible
      const visibleChunkKeys = _getVisibleChunks(
        viewport.x,
        viewport.y,
        viewport.width,
        viewport.height,
        meta.tileSize,
        meta.chunkSize
      )
      
      const visibleSet = new Set(visibleChunkKeys)
      
      // Unsubscribe from chunks that are no longer visible
      loadedChunksRef.current.forEach((chunkKey) => {
        if (!visibleSet.has(chunkKey)) {
          const unsub = chunkUnsubscribes.current.get(chunkKey)
          if (unsub) {
            unsub()
            chunkUnsubscribes.current.delete(chunkKey)
          }
        }
      })
      
      // Subscribe to new chunks
      visibleChunkKeys.forEach((chunkKey) => {
        if (!loadedChunksRef.current.has(chunkKey) && enableSync) {
          const { cx, cy } = _keyToChunkCoord(chunkKey)
          
          const unsub = subscribeToChunk(
            canvasId,
            cx,
            cy,
            {
              onTile: (x, y, tile) => {
                const key = _coordToKey(x, y)
                setTiles((prev) => {
                  const newTiles = new Map(prev)
                  newTiles.set(key, tile)
                  return newTiles
                })
              },
              onRemove: (x, y) => {
                const key = _coordToKey(x, y)
                setTiles((prev) => {
                  const newTiles = new Map(prev)
                  newTiles.delete(key)
                  return newTiles
                })
              },
            },
            meta.chunkSize
          )
          
          chunkUnsubscribes.current.set(chunkKey, unsub)
        }
      })
      
      // Update loaded chunks (both ref and state)
      loadedChunksRef.current = visibleSet
      setLoadedChunks(visibleSet)
    },
    [isInitialized, enableSync, canvasId, meta.tileSize, meta.chunkSize]
  )
  
  // Cleanup subscriptions on unmount
  useEffect(() => {
    return () => {
      chunkUnsubscribes.current.forEach((unsub) => unsub())
      chunkUnsubscribes.current.clear()
    }
  }, [])
  
  // ============================================================================
  // Tile Operations
  // ============================================================================
  
  const setTileLocal = useCallback(
    (x: number, y: number, tile: TileData) => {
      // Validate coordinates
      if (!isValidTileCoord(x, y, meta)) {
        console.warn('Tile coordinates out of bounds:', x, y)
        return
      }
      
      const key = _coordToKey(x, y)
      
      // Optimistic update
      setTiles((prev) => {
        const newTiles = new Map(prev)
        newTiles.set(key, tile)
        return newTiles
      })
      
      // Add to pending writes queue
      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        newPending.set(key, { x, y, tile })
        return newPending
      })
    },
    [meta]
  )
  
  const getTile = useCallback(
    (x: number, y: number): TileData | undefined => {
      const key = _coordToKey(x, y)
      return tiles.get(key)
    },
    [tiles]
  )
  
  const deleteTileLocal = useCallback(
    (x: number, y: number) => {
      const key = _coordToKey(x, y)
      
      // Optimistic update
      setTiles((prev) => {
        const newTiles = new Map(prev)
        newTiles.delete(key)
        return newTiles
      })
      
      // Add to pending writes queue (null indicates deletion)
      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        newPending.set(key, { x, y, tile: null })
        return newPending
      })
    },
    []
  )
  
  const setTilesLocal = useCallback(
    (tilesToSet: Array<{ x: number; y: number; tile: TileData }>) => {
      // Optimistic update
      setTiles((prev) => {
        const newTiles = new Map(prev)
        tilesToSet.forEach(({ x, y, tile }) => {
          if (isValidTileCoord(x, y, meta)) {
            const key = _coordToKey(x, y)
            newTiles.set(key, tile)
          }
        })
        return newTiles
      })
      
      // Add all to pending writes queue
      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        tilesToSet.forEach(({ x, y, tile }) => {
          if (isValidTileCoord(x, y, meta)) {
            const key = _coordToKey(x, y)
            newPending.set(key, { x, y, tile })
          }
        })
        return newPending
      })
    },
    [meta]
  )
  
  const deleteTilesLocal = useCallback(
    (tilesToDelete: Array<{ x: number; y: number }>) => {
      // Optimistic update
      setTiles((prev) => {
        const newTiles = new Map(prev)
        tilesToDelete.forEach(({ x, y }) => {
          const key = _coordToKey(x, y)
          newTiles.delete(key)
        })
        return newTiles
      })
      
      // Add all to pending writes queue
      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        tilesToDelete.forEach(({ x, y }) => {
          const key = _coordToKey(x, y)
          newPending.set(key, { x, y, tile: null })
        })
        return newPending
      })
    },
    []
  )
  
  const clearAllTiles = useCallback(() => {
    setTiles(new Map())
    // Note: Actual Firebase deletion would need to be implemented separately
    // for clearAllTiles to avoid massive individual deletions
  }, [])
  
  const fillTilesLocal = useCallback(
    (x: number, y: number, targetType: string, newType: string, newColor: string) => {
      // Perform flood fill
      const fillResult = floodFill(
        tiles,
        x,
        y,
        { type: newType, color: newColor },
        meta.width || 256,
        meta.height || 256,
        1000 // Max tiles to fill at once
      )
      
      if (fillResult.tiles.length > 0) {
        // Apply the fill using bulk operation
        setTilesLocal(fillResult.tiles)
        
        if (fillResult.limitReached) {
          console.warn('Fill limit reached (1000 tiles). Large areas may require multiple fills.')
        }
      }
    },
    [tiles, meta, setTilesLocal]
  )
  
  // ============================================================================
  // Metadata Operations
  // ============================================================================
  
  const updateMeta = useCallback(
    async (updates: Partial<TilemapMeta>) => {
      try {
        // Optimistic update
        setMeta((prev) => ({ ...prev, ...updates }))
        
        // Sync to Firebase
        if (enableSync) {
          await syncSetMeta(canvasId, updates)
        }
      } catch (error) {
        console.error('Failed to update tilemap meta:', error)
        // Revert on error (would need to fetch current state)
      }
    },
    [canvasId, enableSync]
  )
  
  // ============================================================================
  // Utility Functions
  // ============================================================================
  
  const getTileCount = useCallback(() => {
    return tiles.size
  }, [tiles])
  
  const getSelectedTile = useCallback((): PaletteColor => {
    return meta.palette[selectedPaletteIndex] || meta.palette[0]
  }, [meta.palette, selectedPaletteIndex])
  
  // ============================================================================
  // Return Hook Interface
  // ============================================================================
  
  return {
    // State
    tiles,
    meta,
    isInitialized,
    isConnected: connectionStatus === 'connected',
    connectionStatus,
    
    // Tile operations
    setTile: setTileLocal,
    getTile,
    deleteTile: deleteTileLocal,
    clearAllTiles,
    
    // Bulk operations
    setTiles: setTilesLocal,
    deleteTiles: deleteTilesLocal,
    fillTiles: fillTilesLocal,
    
    // Metadata operations
    updateMeta,
    
    // Chunk management
    loadVisibleChunks,
    loadedChunks,
    
    // Statistics
    getTileCount,
    
    // Palette
    selectedPaletteIndex,
    setSelectedPaletteIndex,
    getSelectedTile,
    
    // Mode
    mode,
    setMode,
  }
}
</file>

<file path="src/hooks/useTilemapPainter.ts">
/**
 * Tilemap Painter Hook
 * Handles painting logic with auto-tile variant calculation
 */

import { useCallback, useRef } from 'react'
import type { TileData, TileMode } from '../types/tilemap'
import { coordToKey } from '../types/tilemap'
import { calculateTileVariant, calculateAutoTileUpdates } from '../utils/tilemap/autoTile'
import { hasSpriteAsset } from '../constants/tilemapDefaults'

export interface UseTilemapPainterOptions {
  mode: TileMode
  selectedTile: { type: string; color: string }
  tiles: Map<string, TileData>
  setTile: (x: number, y: number, tile: TileData) => void
  deleteTile: (x: number, y: number) => void
  fillTiles: (x: number, y: number, targetType: string, newType: string, newColor: string) => void
  onStrokeStart?: () => void
  onStrokeEnd?: (stroke: Array<{ x: number; y: number; oldTile: TileData | undefined; newTile: TileData }>) => void
}

export interface UseTilemapPainterReturn {
  handleMouseDown: (tileX: number, tileY: number) => void
  handleMouseMove: (tileX: number, tileY: number) => void
  handleMouseUp: () => void
  isPainting: boolean
}

/**
 * Hook for handling tilemap painting with auto-tiling
 * 
 * Features:
 * - Stamp: Place tiles with auto-calculated variants
 * - Erase: Remove tiles and update neighbor variants
 * - Fill: Flood fill with variant calculation
 * - Pick: Eyedropper to select tile from canvas
 * - Stroke tracking: For undo/redo bulk operations
 */
export function useTilemapPainter(options: UseTilemapPainterOptions): UseTilemapPainterReturn {
  const {
    mode,
    selectedTile,
    tiles,
    setTile,
    deleteTile,
    fillTiles,
    onStrokeStart,
    onStrokeEnd,
  } = options
  
  const isPaintingRef = useRef(false)
  const lastTileRef = useRef<{ x: number; y: number } | null>(null)
  const currentStrokeRef = useRef<Array<{ x: number; y: number; oldTile: TileData | undefined; newTile: TileData }>>([])
  
  /**
   * Calculate and place a tile with auto-tiling variant
   */
  const placeTileWithVariant = useCallback(
    (x: number, y: number) => {
      const { type, color } = selectedTile
      
      // Calculate variant if sprite assets available
      let variant: number | undefined
      if (hasSpriteAsset(type)) {
        variant = calculateTileVariant(x, y, tiles, type)
      }
      
      // Create tile data
      const newTile: TileData = {
        type,
        color,
        variant,
      }
      
      // Place tile
      const key = coordToKey(x, y)
      const oldTile = tiles.get(key)
      setTile(x, y, newTile)
      
      // Track for stroke (undo/redo)
      currentStrokeRef.current.push({ x, y, oldTile, newTile })
      
      // Update neighbor variants if using sprites
      if (hasSpriteAsset(type)) {
        updateNeighborVariants(x, y, type)
      }
    },
    [selectedTile, tiles, setTile]
  )
  
  /**
   * Update variants of neighboring tiles
   */
  const updateNeighborVariants = useCallback(
    (x: number, y: number, tileType: string) => {
      // Get updates for neighbors
      const updates = calculateAutoTileUpdates(x, y, tiles, tileType)
      
      // Apply variant updates to neighbors (skip center, already placed)
      updates.forEach((update) => {
        if (update.x === x && update.y === y) return // Skip center
        
        const key = coordToKey(update.x, update.y)
        const existingTile = tiles.get(key)
        
        if (existingTile) {
          // Update existing tile's variant
          setTile(update.x, update.y, {
            ...existingTile,
            variant: update.variant,
          })
        }
      })
    },
    [tiles, setTile]
  )
  
  /**
   * Erase a tile and update neighbors
   */
  const eraseTileWithVariantUpdate = useCallback(
    (x: number, y: number) => {
      const key = coordToKey(x, y)
      const oldTile = tiles.get(key)
      
      if (!oldTile) return // Nothing to erase
      
      // Delete tile
      deleteTile(x, y)
      
      // Track for stroke
      currentStrokeRef.current.push({
        x,
        y,
        oldTile,
        newTile: { type: '', color: '' }, // Placeholder for deleted
      })
      
      // Update neighbor variants if old tile had sprites
      if (hasSpriteAsset(oldTile.type)) {
        updateNeighborVariantsAfterDelete(x, y, oldTile.type)
      }
    },
    [tiles, deleteTile]
  )
  
  /**
   * Update neighbor variants after tile deletion
   */
  const updateNeighborVariantsAfterDelete = useCallback(
    (x: number, y: number, deletedType: string) => {
      // Check all 4 neighbors
      const neighborPositions = [
        { x: x, y: y - 1 },  // North
        { x: x + 1, y: y },  // East
        { x: x, y: y + 1 },  // South
        { x: x - 1, y: y },  // West
      ]
      
      neighborPositions.forEach((pos) => {
        const key = coordToKey(pos.x, pos.y)
        const neighborTile = tiles.get(key)
        
        if (neighborTile && hasSpriteAsset(neighborTile.type)) {
          // Recalculate neighbor's variant (tile at x,y is now deleted)
          const variant = calculateTileVariant(pos.x, pos.y, tiles, neighborTile.type)
          setTile(pos.x, pos.y, {
            ...neighborTile,
            variant,
          })
        }
      })
    },
    [tiles, setTile]
  )
  
  /**
   * Handle mouse down - start painting
   */
  const handleMouseDown = useCallback(
    (tileX: number, tileY: number) => {
      isPaintingRef.current = true
      lastTileRef.current = { x: tileX, y: tileY }
      currentStrokeRef.current = []
      
      if (onStrokeStart) {
        onStrokeStart()
      }
      
      // Execute tool action
      switch (mode) {
        case 'stamp':
          placeTileWithVariant(tileX, tileY)
          break
          
        case 'erase':
          eraseTileWithVariantUpdate(tileX, tileY)
          break
          
        case 'fill':
          // Get target tile type
          const targetKey = coordToKey(tileX, tileY)
          const targetTile = tiles.get(targetKey)
          const targetType = targetTile?.type || ''
          
          // Don't fill if clicking same type
          if (targetType === selectedTile.type) break
          
          // Execute fill (handled by useTilemap hook)
          fillTiles(tileX, tileY, targetType, selectedTile.type, selectedTile.color)
          break
          
        case 'pick':
          // Eyedropper handled at component level (sets selectedTile)
          break
      }
    },
    [mode, selectedTile, tiles, placeTileWithVariant, eraseTileWithVariantUpdate, fillTiles, onStrokeStart]
  )
  
  /**
   * Handle mouse move - continuous painting
   */
  const handleMouseMove = useCallback(
    (tileX: number, tileY: number) => {
      if (!isPaintingRef.current) return
      
      // Check if moved to new tile
      const lastTile = lastTileRef.current
      if (lastTile && lastTile.x === tileX && lastTile.y === tileY) {
        return // Still on same tile
      }
      
      lastTileRef.current = { x: tileX, y: tileY }
      
      // Only stamp and erase support continuous painting
      if (mode === 'stamp') {
        placeTileWithVariant(tileX, tileY)
      } else if (mode === 'erase') {
        eraseTileWithVariantUpdate(tileX, tileY)
      }
    },
    [mode, placeTileWithVariant, eraseTileWithVariantUpdate]
  )
  
  /**
   * Handle mouse up - finish painting
   */
  const handleMouseUp = useCallback(() => {
    if (isPaintingRef.current && onStrokeEnd && currentStrokeRef.current.length > 0) {
      onStrokeEnd(currentStrokeRef.current)
    }
    
    isPaintingRef.current = false
    lastTileRef.current = null
    currentStrokeRef.current = []
  }, [onStrokeEnd])
  
  return {
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    isPainting: isPaintingRef.current,
  }
}
</file>

<file path="src/index.css">
@import "tailwindcss";

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Full-screen canvas layout */
html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100vh;
  overflow: hidden;
  background-color: #f3f4f6; /* gray-100 */
}

/* Button styles for toolbar and UI elements */
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover {
  opacity: 0.9;
}

button:focus,
button:focus-visible {
  outline: 2px solid #3B82F6;
  outline-offset: 2px;
}

/* Brush slider - thin white line */
input[type="range"].brush-slider {
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  cursor: pointer;
  height: 16px;
}

input[type="range"].brush-slider::-webkit-slider-runnable-track {
  height: 2px;
  border-radius: 1px;
}

input[type="range"].brush-slider::-moz-range-track {
  height: 2px;
  border-radius: 1px;
  background: transparent;
}

/* Webkit browsers (Chrome, Safari) */
input[type="range"].brush-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: white;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  transition: all 0.15s ease;
}

input[type="range"].brush-slider::-webkit-slider-thumb:hover {
  transform: scale(1.15);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
}

/* Firefox */
input[type="range"].brush-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  border: none;
  border-radius: 50%;
  background: white;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  transition: all 0.15s ease;
}

input[type="range"].brush-slider::-moz-range-thumb:hover {
  transform: scale(1.15);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
}

/* Minimal, sleek scrollbar for tilemap panel - hidden by default, appears on hover */
.tilemap-panel-scroll {
  scrollbar-width: thin;
  scrollbar-color: transparent transparent;
  transition: scrollbar-color 0.3s ease;
}

.tilemap-panel-scroll:hover {
  scrollbar-color: rgba(255, 255, 255, 0.25) rgba(255, 255, 255, 0.05);
}

/* Webkit browsers (Chrome, Safari, Edge) */
.tilemap-panel-scroll::-webkit-scrollbar {
  width: 8px;
  /* Overlay mode - doesn't take up layout space */
}

.tilemap-panel-scroll::-webkit-scrollbar-track {
  background: transparent;
  border-radius: 4px;
  margin: 4px 0;
}

.tilemap-panel-scroll::-webkit-scrollbar-thumb {
  background: transparent;
  border-radius: 4px;
  border: 2px solid transparent;
  background-clip: padding-box;
  transition: background 0.3s ease, opacity 0.3s ease;
  opacity: 0;
}

/* Show scrollbar on container hover or when scrolling */
.tilemap-panel-scroll:hover::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  background-clip: padding-box;
  opacity: 1;
}

/* Brighter on direct scrollbar hover */
.tilemap-panel-scroll::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
  background-clip: padding-box;
  opacity: 1;
}

/* Active state when dragging scrollbar */
.tilemap-panel-scroll::-webkit-scrollbar-thumb:active {
  background: rgba(255, 255, 255, 0.7);
  background-clip: padding-box;
}

/* Hide scrollbar for toolbar - scrolling still works */
.toolbar-scrollable {
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.toolbar-scrollable::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

/* AI Chat Toast Animations */
@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate-slide-up {
  animation: slide-up 0.3s ease-out;
}

.animate-fade-in {
  animation: fade-in 0.3s ease-out;
}
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import ErrorBoundary from './components/ErrorBoundary.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </StrictMode>,
)
</file>

<file path="src/pages/DashboardPage.tsx">
/**
 * DashboardPage Component (PR-22)
 * Main dashboard showing grid of user's canvases
 */

import { useAuth } from '../hooks/useAuth'
import { useCanvasList } from '../hooks/useCanvasList'
import { CanvasCard } from '../components/canvas/CanvasCard'
import { SkeletonCard } from '../components/ui/Skeleton'
import { logOut } from '../services/auth'

/**
 * Dashboard page with canvas grid
 */
export default function DashboardPage() {
  const { user } = useAuth()
  const {
    canvases,
    loading,
    error,
    createCanvas,
    deleteCanvas,
    duplicateCanvas,
    updateCanvasName,
  } = useCanvasList(user?.uid || '')

  const handleLogout = async () => {
    try {
      await logOut()
    } catch (error) {
      console.error('Logout failed:', error)
    }
  }

  const handleCreateCanvas = async () => {
    const name = prompt('Canvas name:', 'Untitled Canvas')
    if (name && name.trim()) {
      try {
        await createCanvas(name.trim())
      } catch (err) {
        alert('Failed to create canvas')
      }
    }
  }

  return (
    <div className="min-h-screen bg-neutral-50">
      {/* Header */}
      <header className="fixed top-0 left-0 right-0 h-16 bg-white border-b border-neutral-200 shadow-soft z-50">
        <div className="max-w-7xl mx-auto px-6 h-full flex items-center justify-between">
          {/* Logo/Title */}
          <div className="flex items-center gap-3">
            <h1 className="text-xl font-bold text-neutral-900">CollabCanvas</h1>
          </div>

          {/* Right section */}
          <div className="flex items-center gap-3">
            {/* User info */}
            <div className="text-sm text-neutral-600">
              {user?.displayName || user?.email}
            </div>

            {/* Logout button */}
            <button
              onClick={handleLogout}
              className="px-3 py-1.5 bg-neutral-100 hover:bg-neutral-200 text-neutral-700 text-sm font-medium rounded-lg transition-colors"
            >
              Logout
            </button>
          </div>
        </div>
      </header>

      {/* Main content - pt-20 (80px) to account for 64px header + extra spacing */}
      <main className="pt-20">
        <div className="max-w-7xl mx-auto px-6 py-8">
          {/* Public Board - Large Featured Tile */}
          <div className="mb-12">
            <a href="/canvas/public-board" className="group block">
              <div className="relative bg-gradient-to-br from-slate-600 to-gray-700 rounded-2xl p-8 shadow-xl hover:shadow-2xl transition-all duration-300 transform hover:scale-[1.02] min-h-[240px]">
                {/* Dot pattern overlay */}
                <div className="absolute inset-0 bg-white/10 rounded-2xl" style={{
                  backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
                  backgroundSize: '16px 16px'
                }}></div>
                
                {/* Content */}
                <div className="relative z-10 h-full flex flex-col">
                  <div className="flex items-start justify-between mb-6">
                    <div className="flex items-center gap-4">
                      <div className="w-16 h-16 bg-white/20 backdrop-blur-sm rounded-xl flex items-center justify-center shadow-lg">
                        <svg className="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                        </svg>
                      </div>
                      <div>
                        <h2 className="text-3xl font-bold text-white mb-2">Public Collaboration Board</h2>
                        <p className="text-slate-200 text-sm">Join the community canvas - collaborate in real-time with everyone</p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2 bg-emerald-500/20 border border-emerald-400/30 backdrop-blur-sm px-4 py-2 rounded-full">
                      <div className="w-2.5 h-2.5 bg-emerald-400 rounded-full animate-pulse"></div>
                      <span className="text-emerald-100 text-sm font-medium">Live Now</span>
                    </div>
                  </div>
                  
                  <p className="text-white/90 text-base mb-6 flex-1 max-w-3xl">
                    A shared creative space where anyone can draw, design, and collaborate together. 
                    Perfect for brainstorming, art projects, or just having fun with others.
                  </p>
                  
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-6">
                      <span className="text-white/80 text-sm flex items-center gap-2">
                        <span className="text-lg">👥</span> 
                        <span className="font-medium">12 active users</span>
                      </span>
                      <span className="text-white/80 text-sm flex items-center gap-2">
                        <span className="text-lg">🎨</span> 
                        <span className="font-medium">Open to all</span>
                      </span>
                    </div>
                    <span className="text-white text-lg font-semibold group-hover:translate-x-2 transition-transform flex items-center gap-2">
                      Join Public Board →
                    </span>
                  </div>
                </div>
              </div>
            </a>
          </div>

          {/* Personal Canvases Section */}
          <div className="mb-8">
            <h2 className="text-2xl font-bold text-neutral-900 mb-2">
              Your Private Canvases
            </h2>
            <p className="text-neutral-600">
              Create and manage your personal design projects
            </p>
          </div>

          {/* Error message */}
          {error && (
            <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg text-red-600 text-sm">
              {error}
            </div>
          )}

          {/* Canvas grid */}
          {loading ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              <SkeletonCard />
              <SkeletonCard />
              <SkeletonCard />
              <SkeletonCard />
            </div>
          ) : canvases.length === 0 ? (
            /* Empty state */
            <div className="text-center py-16">
              <div className="mb-4">
                <span className="text-6xl">🎨</span>
              </div>
              <h3 className="text-xl font-semibold text-neutral-900 mb-2">
                No canvases yet
              </h3>
              <p className="text-neutral-600 mb-6">
                Create your first canvas to get started
              </p>
              <button
                onClick={handleCreateCanvas}
                className="px-6 py-3 bg-primary-600 hover:bg-primary-700 text-white font-medium rounded-lg transition-colors"
              >
                Create New Canvas
              </button>
            </div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              {/* Create new canvas card */}
              <button
                key="create-new"
                onClick={handleCreateCanvas}
                className="h-[260px] bg-white rounded-lg border-2 border-dashed border-neutral-300 hover:border-primary-500 hover:bg-primary-50 transition-all duration-150 flex flex-col items-center justify-center gap-3"
              >
                <span className="text-4xl text-neutral-400">+</span>
                <span className="text-sm font-medium text-neutral-600">
                  Create New Canvas
                </span>
              </button>

              {/* Canvas cards */}
              {canvases.map((canvas) => (
                <CanvasCard
                  key={canvas.id}
                  canvas={canvas}
                  onDelete={deleteCanvas}
                  onDuplicate={duplicateCanvas}
                  onRename={updateCanvasName}
                />
              ))}
            </div>
          )}
        </div>
      </main>
    </div>
  )
}
</file>

<file path="src/services/auth.ts">
import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  updateProfile,
} from 'firebase/auth'
import type { UserCredential } from 'firebase/auth'
import { auth } from './firebase'
import type { User } from '../types/firebase'

/**
 * Sign up a new user with email, password, and display name
 */
export async function signUp(
  email: string,
  password: string,
  displayName: string
): Promise<User> {
  try {
    // Create user with email and password
    const userCredential: UserCredential = await createUserWithEmailAndPassword(
      auth,
      email,
      password
    )

    // Update user profile with display name
    await updateProfile(userCredential.user, {
      displayName,
    })

    // Return user object
    return {
      uid: userCredential.user.uid,
      email: userCredential.user.email,
      displayName,
    }
  } catch (error: any) {
    // Handle specific Firebase auth errors
    if (error.code === 'auth/email-already-in-use') {
      throw new Error('Email already in use')
    } else if (error.code === 'auth/invalid-email') {
      throw new Error('Invalid email address')
    } else if (error.code === 'auth/weak-password') {
      throw new Error('Password should be at least 6 characters')
    } else {
      throw new Error('Failed to create account: ' + error.message)
    }
  }
}

/**
 * Sign in an existing user with email and password
 */
export async function signIn(email: string, password: string): Promise<User> {
  try {
    const userCredential: UserCredential = await signInWithEmailAndPassword(
      auth,
      email,
      password
    )

    return {
      uid: userCredential.user.uid,
      email: userCredential.user.email,
      displayName: userCredential.user.displayName,
    }
  } catch (error: any) {
    // Handle specific Firebase auth errors
    if (error.code === 'auth/user-not-found') {
      throw new Error('No account found with this email')
    } else if (error.code === 'auth/wrong-password') {
      throw new Error('Incorrect password')
    } else if (error.code === 'auth/invalid-email') {
      throw new Error('Invalid email address')
    } else if (error.code === 'auth/user-disabled') {
      throw new Error('This account has been disabled')
    } else {
      throw new Error('Failed to sign in: ' + error.message)
    }
  }
}

/**
 * Log out the current user
 */
export async function logOut(): Promise<void> {
  try {
    await signOut(auth)
  } catch (error: any) {
    throw new Error('Failed to log out: ' + error.message)
  }
}
</file>

<file path="src/services/firebase.ts">
import { initializeApp } from 'firebase/app'
import { getDatabase, connectDatabaseEmulator } from 'firebase/database'
import { getFirestore, connectFirestoreEmulator } from 'firebase/firestore'
import { getAuth, connectAuthEmulator } from 'firebase/auth'
import { getFunctions, connectFunctionsEmulator } from 'firebase/functions'
import { getStorage, connectStorageEmulator } from 'firebase/storage'

// Firebase configuration from environment variables
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  databaseURL: import.meta.env.VITE_FIREBASE_DATABASE_URL,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
}

// Initialize Firebase
const app = initializeApp(firebaseConfig)

// Initialize services
export const db = getDatabase(app)
export const firestore = getFirestore(app)
export const auth = getAuth(app)
export const functions = getFunctions(app)
export const storage = getStorage(app)

// Connect to emulators in development
// Uncomment to use local emulators (requires Java and firebase init emulators)
/*
if (import.meta.env.DEV) {
  // Check if emulator is already connected (prevents double connection on HMR)
  if (!(db as any)._repoInternal?.repoInfo_.secure) {
    connectDatabaseEmulator(db, 'localhost', 9000)
  }
  
  if (!(auth as any).config.emulator) {
    connectAuthEmulator(auth, 'http://localhost:9099', { disableWarnings: true })
  }
  
  // Connect Functions to local emulator
  if (!(functions as any)._customDomain) {
    connectFunctionsEmulator(functions, 'localhost', 5001)
  }
  
  // Connect Storage to local emulator
  if (!(storage as any)._host) {
    connectStorageEmulator(storage, 'localhost', 9199)
  }
}
*/

export default app
</file>

<file path="src/types/canvas.ts">
// Canvas-specific TypeScript Types

/**
 * 2D Position coordinates
 */
export interface Position {
  x: number
  y: number
}

/**
 * Viewport transformation state for pan and zoom
 */
export interface ViewportTransform {
  x: number // pan offset X
  y: number // pan offset Y
  scale: number // zoom scale (1 = 100%, 0.5 = 50%, 2 = 200%)
}

/**
 * Shape types supported by the canvas
 * Phase 3 PR-16: Added line, polygon, star, roundRect
 * Phase 4 PR-21: Added path for freehand drawing
 * Phase 3 PR-31: Added animatedSprite for sprite animations
 */
export type ShapeType = 'rectangle' | 'circle' | 'text' | 'line' | 'polygon' | 'star' | 'roundRect' | 'path' | 'animatedSprite'

/**
 * Client-side representation of a canvas shape
 * This extends the Firebase CanvasObject with additional client-side properties
 */
export interface Shape {
  id: string // unique identifier (generated client-side)
  type: ShapeType // shape type
  x: number // x position
  y: number // y position
  width: number // width (now variable in Phase 2)
  height: number // height (now variable in Phase 2)
  rotation?: number // rotation in degrees (0-360) - Phase 2
  text?: string // text content (text shapes only)
  // Phase 5: Text formatting properties (PR-25)
  fontFamily?: string // font family (default: 'Inter, sans-serif')
  fontSize?: number // font size in pixels (12-72, default: 20)
  fontWeight?: 'normal' | 'bold' // font weight (default: 'normal')
  fontStyle?: 'normal' | 'italic' // font style (default: 'normal')
  textAlign?: 'left' | 'center' | 'right' // text alignment (default: 'left')
  textDecoration?: '' | 'underline' | 'line-through' // text decoration (default: '')
  // Phase 3: Color properties (PR-15)
  fill: string // fill color (RGBA hex format, e.g., #3B82F6FF)
  stroke?: string // stroke color (RGBA hex format, optional)
  strokeWidth?: number // stroke width in pixels (0-20, optional)
  // Phase 3: Line shape properties (PR-16)
  points?: number[] // [x1, y1, x2, y2] for line shapes
  arrows?: { start?: boolean; end?: boolean } // arrow options for lines
  // Phase 3: Polygon/Star properties (PR-16)
  sides?: number // number of sides for polygon (3-12) or points for star (3-12)
  // Phase 3: Rounded rectangle properties (PR-16)
  cornerRadius?: number // corner radius for rounded rectangles (0-50px)
  // Phase 3: Z-Index for layering (PR-17)
  zIndex?: number // z-index for layer ordering (higher = on top, default: creation timestamp)
  // Phase 4: Path properties for freehand drawing (PR-21)
  tension?: number // 0 = sharp (pencil), 0.5 = smooth (pen)
  closed?: boolean // whether the path is closed
  // Phase 3 PR-31: Animated sprite properties
  animationId?: string // reference to animation (for animatedSprite type)
  spriteSheetId?: string // reference to sprite sheet asset (for animatedSprite type)
  currentFrame?: number // current animation frame (for animatedSprite type)
  isPlaying?: boolean // whether animation is playing (for animatedSprite type)
  flipX?: boolean // flip horizontally (for animatedSprite type)
  flipY?: boolean // flip vertically (for animatedSprite type)
  opacity?: number // 0-1 opacity (for animatedSprite type)
}

/**
 * Canvas configuration constants
 */
export interface CanvasConfig {
  width: number // canvas width
  height: number // canvas height
  gridSpacing: number // grid line spacing in pixels
  defaultShapeSize: number // default shape size (100px)
  defaultColor: string // default shape color (#3B82F6)
  minScale: number // minimum zoom scale
  maxScale: number // maximum zoom scale
}

/**
 * Tool types for the canvas toolbar
 * Phase 3 PR-16: Added line, polygon, star, roundRect
 * Phase 4 PR-21: Added pencil, pen, hand tools
 * Phase 3 PR-31: Added animation tool for placing animated sprites
 */
export type ToolType = 'select' | 'rectangle' | 'circle' | 'text' | 'delete' | 'line' | 'polygon' | 'star' | 'roundRect' | 'pencil' | 'pen' | 'hand' | 'animation'

/**
 * Canvas bounds for enforcing hard boundaries
 */
export interface CanvasBounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
}

/**
 * Default canvas configuration
 */
export const DEFAULT_CANVAS_CONFIG: CanvasConfig = {
  width: 5000,
  height: 5000,
  gridSpacing: 50,
  defaultShapeSize: 100,
  defaultColor: '#3B82F6', // blue
  minScale: 0.1, // 10% minimum zoom
  maxScale: 3, // 300% maximum zoom
}

/**
 * Default canvas bounds (5000x5000px)
 */
export const DEFAULT_CANVAS_BOUNDS: CanvasBounds = {
  minX: 0,
  minY: 0,
  maxX: 5000,
  maxY: 5000,
}
</file>

<file path="src/types/command.ts">
// Command Pattern Types for Undo/Redo (PR-14)

/**
 * Command interface for undo/redo operations
 * All commands must implement execute, undo, and redo methods
 */
export interface Command {
  type: 'create' | 'delete' | 'move' | 'transform' | 'bulk' | 'color' | 'zindex' | 'alignment'
  execute(): void
  undo(): void
  redo(): void
}

/**
 * Command type for creating shapes
 */
export type CreateCommandType = 'create'

/**
 * Command type for deleting shapes
 */
export type DeleteCommandType = 'delete'

/**
 * Command type for moving shapes
 */
export type MoveCommandType = 'move'

/**
 * Command type for transforming shapes (resize/rotate)
 */
export type TransformCommandType = 'transform'

/**
 * Command type for bulk operations (multiple commands at once)
 */
export type BulkCommandType = 'bulk'

/**
 * Command type for color changes (PR-15)
 */
export type ColorCommandType = 'color'

/**
 * Command type for z-index changes (PR-17)
 */
export type ZIndexCommandType = 'zindex'

/**
 * Command type for alignment operations (PR-18)
 */
export type AlignmentCommandType = 'alignment'

/**
 * Union type of all command types
 */
export type CommandType = CreateCommandType | DeleteCommandType | MoveCommandType | TransformCommandType | BulkCommandType | ColorCommandType | ZIndexCommandType | AlignmentCommandType
</file>

<file path="src/types/firebase.ts">
// Firebase Realtime Database Types

/**
 * Canvas object stored in Firebase
 * Path: canvas/objects/{objectId}
 */
export interface CanvasObject {
  t: 'r' | 'c' | 't' | 'l' | 'pg' | 'st' | 'rr' | 'p' // type: rectangle, circle, text, line, polygon, star, roundRect, path (Phase 3 PR-16, Phase 4 PR-21)
  x: number // x position
  y: number // y position
  w: number // width (variable in Phase 2)
  h: number // height (variable in Phase 2)
  rot?: number // rotation in degrees (Phase 2)
  txt?: string // text content (text objects only)
  // Phase 5 PR-25: Text formatting properties
  ff?: string // fontFamily (text only)
  fs?: number // fontSize (text only)
  fw?: 'normal' | 'bold' // fontWeight (text only)
  fst?: 'normal' | 'italic' // fontStyle (text only)
  ta?: 'left' | 'center' | 'right' // textAlign (text only)
  td?: '' | 'underline' | 'line-through' // textDecoration (text only)
  f?: string // fill color (RGBA hex, Phase 3)
  s?: string // stroke color (RGBA hex, Phase 3, optional)
  sw?: number // stroke width (Phase 3, optional)
  // Phase 3 PR-16: Advanced shapes
  pts?: number[] // [x1, y1, x2, y2] for line shapes, or path coordinates for freehand drawing
  arr?: { s?: boolean; e?: boolean } // arrows for lines (s=start, e=end)
  sides?: number // sides for polygon/star (3-12)
  cr?: number // corner radius for rounded rectangles (0-50)
  // Phase 3 PR-17: Z-Index
  z?: number // z-index for layering (timestamp)
  // Phase 4 PR-21: Path properties
  ten?: number // tension for path smoothing (0 = sharp, 0.5 = smooth)
  cls?: boolean // closed path
}

/**
 * User presence data stored in Firebase
 * Path: presence/{userId}
 */
export interface Presence {
  n: string // name
  cl: string // color (for cursor and selection indicators)
  c: [number, number] // cursor position [x, y]
  sel: string[] | null // selected object IDs (array for multi-select, null if none)
}

/**
 * Firebase User data
 */
export interface User {
  uid: string
  email: string | null
  displayName: string | null
}

/**
 * Canvas data structure in Firebase
 */
export interface CanvasData {
  objects: {
    [objectId: string]: CanvasObject
  }
}

/**
 * Presence data structure in Firebase
 */
export interface PresenceData {
  [userId: string]: Presence
}
</file>

<file path="src/types/group.ts">
/**
 * Group Types (PR-19)
 * Type definitions for grouping shapes together
 */

export interface GroupMember {
  id: string
  type: 'shape' | 'group' // Can contain shapes or nested groups
}

export interface Group {
  id: string
  name: string
  memberIds: string[] // IDs of shapes or groups in this group
  x: number // Group position (calculated from members)
  y: number
  width: number // Group bounding box (calculated from members)
  height: number
  rotation: number
  locked: boolean
  visible: boolean
  createdAt: number
  updatedAt: number
  createdBy: string
  zIndex: number
}

export interface GroupBounds {
  x: number
  y: number
  width: number
  height: number
}
</file>

<file path="src/types/layer.ts">
/**
 * Layer Types (PR-19)
 * Type definitions for layer panel and hierarchy management
 */

export interface Layer {
  id: string
  name: string
  type: 'shape' | 'group'
  visible: boolean
  locked: boolean
  zIndex: number
  parentId?: string // For nested groups
  children?: Layer[] // For hierarchical display
}

export interface LayerVisibility {
  [id: string]: boolean
}

export interface LayerLock {
  [id: string]: boolean
}

export interface LayerTreeNode extends Layer {
  level: number // Nesting level (0 = root)
  expanded?: boolean // For collapsible groups
}
</file>

<file path="src/types/selection.ts">
// Multi-select and selection-related TypeScript types

/**
 * Selection box for drag-to-select (marquee selection)
 * Represents the visual rectangle drawn during drag
 */
export interface SelectionBox {
  startX: number // starting X coordinate when drag begins
  startY: number // starting Y coordinate when drag begins
  currentX: number // current X coordinate during drag
  currentY: number // current Y coordinate during drag
  visible: boolean // whether the selection box is currently visible
}

/**
 * Selection state for the canvas
 * Tracks which shapes are currently selected
 */
export interface SelectionState {
  selectedIds: Set<string> // Set of selected shape IDs (O(1) lookup)
  lastSelectedId: string | null // most recently selected shape ID
}

/**
 * Helper function to create an empty selection state
 */
export const createEmptySelection = (): SelectionState => ({
  selectedIds: new Set<string>(),
  lastSelectedId: null,
})

/**
 * Helper function to create an initial selection box (hidden)
 */
export const createInitialSelectionBox = (): SelectionBox => ({
  startX: 0,
  startY: 0,
  currentX: 0,
  currentY: 0,
  visible: false,
})

/**
 * Calculate the actual bounds of a selection box
 * Handles the case where drag goes in any direction (up/down/left/right)
 */
export const getSelectionBoxBounds = (box: SelectionBox) => {
  const x = Math.min(box.startX, box.currentX)
  const y = Math.min(box.startY, box.currentY)
  const width = Math.abs(box.currentX - box.startX)
  const height = Math.abs(box.currentY - box.startY)
  
  return { x, y, width, height }
}

/**
 * Check if a shape intersects with the selection box
 */
export const shapeIntersectsSelectionBox = (
  shape: { x: number; y: number; width: number; height: number },
  box: SelectionBox
): boolean => {
  const boxBounds = getSelectionBoxBounds(box)
  
  // Check if rectangles intersect
  return !(
    shape.x + shape.width < boxBounds.x || // shape is left of box
    shape.x > boxBounds.x + boxBounds.width || // shape is right of box
    shape.y + shape.height < boxBounds.y || // shape is above box
    shape.y > boxBounds.y + boxBounds.height // shape is below box
  )
}
</file>

<file path="src/types/tilemap.ts">
/**
 * Tilemap Type Definitions
 * Core types for the tilemap editor feature
 */

// ============================================================================
// Core Tile Data
// ============================================================================

/**
 * Represents a single tile in the tilemap
 */
export interface TileData {
  type: string;           // 'solid', 'platform', 'spawn', 'empty', etc.
  color: string;          // hex color (e.g., '#4ade80')
  variant?: number;       // Auto-tile variant (0-15 bitmask result) - optional for backwards compatibility
  metadata?: Record<string, any>;  // For game logic (collision, etc.)
}

/**
 * Palette color configuration
 */
export interface PaletteColor {
  type: string;
  color: string;
  name: string;
}

/**
 * Tilemap metadata configuration
 */
export interface TilemapMeta {
  tileSize: number;       // 8, 16, or 32
  width: number;          // Max tiles in X (default: 256)
  height: number;         // Max tiles in Y (default: 256)
  chunkSize: number;      // Tiles per chunk (16)
  palette: PaletteColor[]; // Array of {type, color, name}
  version: number;        // For future migrations
}

// ============================================================================
// Coordinate Types
// ============================================================================

/**
 * Tile coordinate (x, y position in tile grid)
 */
export interface TileCoordinate {
  x: number;
  y: number;
}

/**
 * Chunk coordinate with local tile position
 */
export interface ChunkCoordinate {
  cx: number;  // Chunk X
  cy: number;  // Chunk Y
  lx: number;  // Local X within chunk
  ly: number;  // Local Y within chunk
}

// ============================================================================
// UI State Types
// ============================================================================

/**
 * Tilemap editing mode
 */
export type TileMode = 'stamp' | 'erase' | 'fill' | 'pick';

/**
 * Connection status
 */
export type ConnectionStatus = 'connected' | 'disconnected' | 'reconnecting';

// ============================================================================
// Firebase Data Types
// ============================================================================

/**
 * Tile data as stored in Firebase (compressed)
 */
export interface FirebaseTileData {
  t: string;   // type
  c: string;   // color
  v?: number;  // variant (0-15 bitmask result) - optional for backwards compatibility
  by: string;  // last editor (user ID)
  ts: number;  // server timestamp
}

/**
 * Firebase tilemap structure
 */
export interface FirebaseTilemapMeta {
  tileSize: number;
  width: number;
  height: number;
  chunkSize: number;
  palette: PaletteColor[];
  version: number;
}

// ============================================================================
// Export/Import Types
// ============================================================================

/**
 * Exported tilemap JSON structure
 */
export interface ExportedTilemap {
  version: number;
  meta: TilemapMeta;
  format: 'sparse' | 'dense';
  tiles: Record<string, TileData> | TileData[][];
  exported_at: string;
  exported_by: string;
  tile_count: number;
}

// ============================================================================
// Coordinate Helper Functions
// ============================================================================

/**
 * Convert tile coordinates to string key
 * @example coordToKey(5, 12) → "5_12"
 */
export function coordToKey(x: number, y: number): string {
  return `${x}_${y}`;
}

/**
 * Parse string key to coordinates
 * @example keyToCoord("5_12") → { x: 5, y: 12 }
 */
export function keyToCoord(key: string): TileCoordinate {
  const [x, y] = key.split('_').map(Number);
  return { x, y };
}

/**
 * Convert chunk coordinates to string key
 * @example chunkToKey(2, 3) → "2_3"
 */
export function chunkToKey(cx: number, cy: number): string {
  return `${cx}_${cy}`;
}

/**
 * Parse chunk key to coordinates
 * @example keyToChunkCoord("2_3") → { cx: 2, cy: 3 }
 */
export function keyToChunkCoord(key: string): { cx: number; cy: number } {
  const [cx, cy] = key.split('_').map(Number);
  return { cx, cy };
}

/**
 * Convert tile coordinates to chunk coordinates
 * @param x Tile X coordinate
 * @param y Tile Y coordinate
 * @param chunkSize Tiles per chunk (typically 16)
 * @returns Chunk coordinate with local position
 * @example coordToChunk(20, 35, 16) → { cx: 1, cy: 2, lx: 4, ly: 3 }
 */
export function coordToChunk(x: number, y: number, chunkSize: number): ChunkCoordinate {
  const cx = Math.floor(x / chunkSize);
  const cy = Math.floor(y / chunkSize);
  const lx = x % chunkSize;
  const ly = y % chunkSize;
  
  return { cx, cy, lx, ly };
}

/**
 * Convert chunk coordinates back to tile coordinates
 * @param cx Chunk X
 * @param cy Chunk Y
 * @param lx Local X within chunk
 * @param ly Local Y within chunk
 * @param chunkSize Tiles per chunk
 * @returns Tile coordinate
 * @example chunkToCoord(1, 2, 4, 3, 16) → { x: 20, y: 35 }
 */
export function chunkToCoord(
  cx: number,
  cy: number,
  lx: number,
  ly: number,
  chunkSize: number
): TileCoordinate {
  return {
    x: cx * chunkSize + lx,
    y: cy * chunkSize + ly,
  };
}

/**
 * Get all chunk keys that intersect with a viewport
 * @param viewportX Viewport X position
 * @param viewportY Viewport Y position
 * @param viewportWidth Viewport width
 * @param viewportHeight Viewport height
 * @param tileSize Size of each tile in pixels
 * @param chunkSize Tiles per chunk
 * @returns Array of chunk keys
 */
export function getVisibleChunks(
  viewportX: number,
  viewportY: number,
  viewportWidth: number,
  viewportHeight: number,
  tileSize: number,
  chunkSize: number
): string[] {
  // Convert viewport to tile coordinates
  const startTileX = Math.floor(viewportX / tileSize);
  const startTileY = Math.floor(viewportY / tileSize);
  const endTileX = Math.ceil((viewportX + viewportWidth) / tileSize);
  const endTileY = Math.ceil((viewportY + viewportHeight) / tileSize);
  
  // Convert to chunk coordinates
  const startChunkX = Math.floor(startTileX / chunkSize);
  const startChunkY = Math.floor(startTileY / chunkSize);
  const endChunkX = Math.floor(endTileX / chunkSize);
  const endChunkY = Math.floor(endTileY / chunkSize);
  
  // Generate all chunk keys in range
  const chunks: string[] = [];
  for (let cy = startChunkY; cy <= endChunkY; cy++) {
    for (let cx = startChunkX; cx <= endChunkX; cx++) {
      // Skip negative chunks (out of bounds)
      if (cx >= 0 && cy >= 0) {
        chunks.push(chunkToKey(cx, cy));
      }
    }
  }
  
  return chunks;
}

// ============================================================================
// Validation Helpers
// ============================================================================

/**
 * Check if tile coordinates are within bounds
 */
export function isValidTileCoord(x: number, y: number, meta: TilemapMeta): boolean {
  return x >= 0 && y >= 0 && x < meta.width && y < meta.height;
}

/**
 * Clamp tile coordinates to valid bounds
 */
export function clampTileCoord(x: number, y: number, meta: TilemapMeta): TileCoordinate {
  return {
    x: Math.max(0, Math.min(x, meta.width - 1)),
    y: Math.max(0, Math.min(y, meta.height - 1)),
  };
}

// ============================================================================
// Default Values
// ============================================================================

/**
 * Default tilemap metadata
 */
export const DEFAULT_TILEMAP_META: TilemapMeta = {
  tileSize: 16,
  width: 256,
  height: 256,
  chunkSize: 16,
  palette: [
    { type: 'solid', color: '#4ade80', name: 'Ground' },
    { type: 'platform', color: '#60a5fa', name: 'Platform' },
    { type: 'spawn', color: '#fbbf24', name: 'Spawn' },
    { type: 'empty', color: '#ef4444', name: 'Empty' },
  ],
  version: 1,
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
      colors: {
        // Neutral grays for professional UI
        neutral: {
          50: '#FAFAFA',
          100: '#F5F5F5',
          150: '#EDEDED',
          200: '#E5E5E5',
          300: '#D4D4D4',
          400: '#A3A3A3',
          500: '#737373',
          600: '#525252',
          700: '#404040',
          800: '#262626',
          900: '#171717',
        },
        // Primary blue (Figma-style)
        primary: {
          50: '#EEF2FF',
          100: '#E0E7FF',
          200: '#C7D2FE',
          300: '#A5B4FC',
          400: '#818CF8',
          500: '#6366F1',
          600: '#4F46E5',
          700: '#4338CA',
        },
      },
      boxShadow: {
        'soft': '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
        'medium': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
        'hard': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
        'cursor': '0 1px 2px 0 rgba(0, 0, 0, 0.2)',
      },
      borderRadius: {
        'panel': '8px',
      },
      spacing: {
        'toolbar': '48px',
        'header': '64px',
        'panel': '256px',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './tests/setup.ts',
    css: true,
  },
})
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env.local
.env.development.local
.env.test.local
.env.production.local

# Firebase
.firebase/
.firebaserc
firebase-debug.log
firebase-debug.*.log

# Test coverage
coverage/
*.lcov

.tests/*
.context/*
.cursor/*
context/*
tests/*
</file>

<file path="firebase.json">
{
  "database": {
    "rules": "database.rules.json"
  },
  "storage": {
    "rules": "storage.rules"
  },
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ],
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "database": {
      "port": 9000
    },
    "storage": {
      "port": 9199
    },
    "ui": {
      "enabled": true,
      "port": 4000
    }
  }
}
</file>

<file path="src/pages/CanvasPage.tsx">
import { useState, useCallback, useEffect, useRef } from 'react'
import { useParams } from 'react-router-dom'
import Canvas from '../components/canvas/Canvas'
import PresenceBar from '../components/PresenceBar'
import Toolbar from '../components/toolbar/Toolbar'
import { LayerPanel } from '../components/panels/LayerPanel'
import ShapeStatusBar from '../components/canvas/ShapeStatusBar'
import { AIChatPanel } from '../components/panels/AIChatPanel'
import { AssetLibrary } from '../components/assets/AssetLibrary'
import ExportModal from '../components/export/ExportModal'
import { useAuth } from '../hooks/useAuth'
import { usePresence } from '../hooks/usePresence'
import { useCanvas } from '../hooks/useCanvas'
import { useGroups } from '../hooks/useGroups'
import { useLayers } from '../hooks/useLayers'
import { getCanvas, updateCanvas, generateThumbnail } from '../services/canvas/canvasManager'
import { isAIEnabled } from '../services/ai/ai'
import type { ToolType } from '../types/canvas'
import type { CanvasMetadata } from '../services/canvas/canvasManager'
import type Konva from 'konva'

/**
 * Canvas Page - Main page component for the collaborative canvas (PR-22: Dynamic canvas ID)
 * Includes PresenceBar at top, Toolbar on left, and Canvas in center
 */
export default function CanvasPage() {
  const { canvasId: routeCanvasId } = useParams<{ canvasId: string }>()
  const [selectedTool, setSelectedTool] = useState<ToolType>('select')
  const [canvasMetadata, setCanvasMetadata] = useState<CanvasMetadata | null>(null)
  const [viewport, setViewport] = useState({ x: 0, y: 0, scale: 1 })
  const stageRef = useRef<Konva.Stage | null>(null)
  
  // Use 'public-board' as default if no canvasId in route
  const canvasId = routeCanvasId || 'public-board'
  
  // Tilemap mode toggle
  const [isTilemapMode, setIsTilemapMode] = useState(false)
  
  // AI Assistant state
  const [showAIChat, setShowAIChat] = useState(false)
  
  // Asset Library state
  const [showAssetLibrary, setShowAssetLibrary] = useState(false)
  
  // Export Modal state
  const [showExportModal, setShowExportModal] = useState(false)
  
  // Tilemap state
  const [tileMode, setTileMode] = useState<'stamp' | 'erase' | 'fill' | 'pick'>('stamp')
  const [brushSize, setBrushSize] = useState(1)
  const [autoTilingEnabled, setAutoTilingEnabled] = useState(false)
  const [showTileGrid, setShowTileGrid] = useState(true)
  const [selectedPaletteIndex, setSelectedPaletteIndex] = useState(0)
  const [selectedVariant, setSelectedVariant] = useState<number | undefined>(undefined)
  const [plainColor, setPlainColor] = useState('#ffffff')
  const [tilemapCanUndo, setTilemapCanUndo] = useState(false)
  const [tilemapCanRedo, setTilemapCanRedo] = useState(false)
  const [tilemapUndoFn, setTilemapUndoFn] = useState<(() => void) | null>(null)
  const [tilemapRedoFn, setTilemapRedoFn] = useState<(() => void) | null>(null)
  
  // Zoom control functions (will be set by Canvas component)
  const zoomControlsRef = useRef<{
    zoomIn: () => void
    zoomOut: () => void
    zoomReset: () => void
    zoomFit: () => void
  } | null>(null)

  // Tilemap export functions (will be set by Canvas component)
  const exportFunctionsRef = useRef<{
    exportJSON: () => void
    exportPNG: () => void
  } | null>(null)

  const { user } = useAuth()

  // Canvas, Groups, and Layers hooks (PR-19)
  const { shapes, selectedIds, setSelection, updateColors, updateShape, getRecentColors, deleteShape } = useCanvas({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })
  
  // Color sampling callback (passed from Canvas)
  const [enableColorSampling, setEnableColorSampling] = useState<((callback: (color: string) => void) => void) | null>(null)
  
  // Wrap setEnableColorSampling to avoid setState during render
  const handleColorSamplingReady = useCallback((fn: (callback: (color: string) => void) => void) => {
    // Defer setState to next tick to avoid "setState during render" error
    setTimeout(() => {
      setEnableColorSampling(() => fn)
    }, 0)
  }, [])

  const { groups } = useGroups({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  const { toggleVisibility, toggleLock } = useLayers({
    canvasId: canvasId,
    enableSync: true,
  })
  
  
  // Load canvas metadata
  useEffect(() => {
    if (!user?.uid || !canvasId) return

    const loadCanvas = async () => {
      try {
        // Check if this is a collab space (public shared canvas)
        // Load canvas from database
        const canvas = await getCanvas(canvasId, user.uid)
        if (canvas) {
          setCanvasMetadata(canvas)
        }
        // If canvas not found, it will be created automatically by useCanvas hook
      } catch (error) {
        console.error('Error loading canvas:', error)
      }
    }

    loadCanvas()
  }, [canvasId, user?.uid])
  
  // Only initialize presence when user is authenticated
  const { otherUsers } = usePresence({
    userId: user?.uid || '',
    userName: user?.displayName || user?.email || 'Anonymous',
    canvasId: canvasId,
  })

  // Auto-save thumbnail every 30 seconds (PR-22)
  useEffect(() => {
    if (!user?.uid || !canvasId || !stageRef.current) return

    const interval = setInterval(() => {
      const thumbnail = generateThumbnail(stageRef.current)
      if (thumbnail) {
        updateCanvas(canvasId, user.uid, { thumbnail }).catch(console.error)
      }
    }, 30000) // 30 seconds

    return () => clearInterval(interval)
  }, [canvasId, user?.uid])

  // Handle tool selection
  const handleToolSelect = useCallback((tool: ToolType) => {
    setSelectedTool(tool)
    // Clear selection when switching to non-select tool
    if (tool !== 'select' && tool !== 'delete') {
      setSelection(null)
    }
  }, [setSelection])

  // Handle shape selection from canvas - use setSelection from useCanvas hook
  const handleShapeSelect = useCallback((id: string | null) => {
    setSelection(id)
  }, [setSelection])

  // Trigger delete from toolbar
  const [deleteTriggered, setDeleteTriggered] = useState(0)

  // Handle delete action from toolbar
  const handleDelete = useCallback(() => {
    // Increment to trigger delete in Canvas
    setDeleteTriggered((prev) => prev + 1)
  }, [])

  // PR-14: Undo/Redo state from Canvas
  const [canUndo, setCanUndo] = useState(false)
  const [canRedo, setCanRedo] = useState(false)
  const [undoFn, setUndoFn] = useState<(() => void) | null>(null)
  const [redoFn, setRedoFn] = useState<(() => void) | null>(null)

  // Handle undo/redo state changes from Canvas
  const handleUndoRedoChange = useCallback(
    (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => {
      if (isTilemapMode) {
        setTilemapCanUndo(canUndo)
        setTilemapCanRedo(canRedo)
        setTilemapUndoFn(() => undo)
        setTilemapRedoFn(() => redo)
      } else {
        setCanUndo(canUndo)
        setCanRedo(canRedo)
        setUndoFn(() => undo)
        setRedoFn(() => redo)
      }
    },
    [isTilemapMode]
  )

  // Zoom handlers (PR-20) - now delegated to Canvas component
  const handleZoomIn = useCallback(() => {
    zoomControlsRef.current?.zoomIn()
  }, [])

  const handleZoomOut = useCallback(() => {
    zoomControlsRef.current?.zoomOut()
  }, [])

  const handleZoomReset = useCallback(() => {
    zoomControlsRef.current?.zoomReset()
  }, [])

  const handleZoomFit = useCallback(() => {
    zoomControlsRef.current?.zoomFit()
  }, [])
  
  // Handle zoom controls ready from Canvas
  const handleZoomControlsReady = useCallback((zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => {
    zoomControlsRef.current = { zoomIn, zoomOut, zoomReset, zoomFit }
  }, [])

  // Handle export functions ready from Canvas
  const handleExportFunctionsReady = useCallback((exportJSON: () => void, exportPNG: () => void) => {
    exportFunctionsRef.current = { exportJSON, exportPNG }
  }, [])

  // Export handlers to pass to PresenceBar
  const handleExportJSON = useCallback(() => {
    exportFunctionsRef.current?.exportJSON()
  }, [])

  const handleExportPNG = useCallback(() => {
    exportFunctionsRef.current?.exportPNG()
  }, [])

  // Handle new export system (opens Export Modal)
  const handleExport = useCallback((format: 'json' | 'png' | 'svg' | 'tilemap' | 'godot' | 'unity') => {
    // For new formats (godot, unity) or when user wants advanced options, open the export modal
    if (format === 'godot' || format === 'unity') {
      setShowExportModal(true)
    } else if (format === 'json') {
      // Legacy: use existing JSON export
      handleExportJSON()
    } else if (format === 'png') {
      // Legacy: use existing PNG export
      handleExportPNG()
    } else {
      // For other formats, open export modal
      setShowExportModal(true)
    }
  }, [handleExportJSON, handleExportPNG])

  // Layer panel handlers (PR-19)
  const handleSelectLayer = useCallback((layerId: string) => {
    setSelection(layerId)
  }, [setSelection])

  const handleRenameLayer = useCallback((layerId: string, newName: string) => {
    // For shapes, we don't store custom names in this MVP
    // For groups, this would update the group name via Firebase
    console.log(`Rename layer ${layerId} to ${newName}`)
  }, [])

  return (
    <div className="w-full h-screen overflow-hidden flex flex-col bg-neutral-50">
      {/* Top Header - Presence Bar (48px height, z-index 50) */}
      <PresenceBar
        currentUser={{
          displayName: user?.displayName || null,
          email: user?.email || null,
        }}
        otherUsers={otherUsers}
        scale={viewport.scale}
        onZoomIn={handleZoomIn}
        onZoomOut={handleZoomOut}
        onZoomReset={handleZoomReset}
        onZoomFit={handleZoomFit}
        isTilemapMode={isTilemapMode}
        onToggleTilemapMode={() => setIsTilemapMode(!isTilemapMode)}
        onToggleAssetLibrary={() => setShowAssetLibrary(!showAssetLibrary)}
        onExport={handleExport}
        onExportJSON={handleExportJSON}
        onExportPNG={handleExportPNG}
      />

      {/* Main Content Area - Toolbar + Canvas + LayerPanel */}
      <div className="flex flex-row h-[calc(100vh-88px)] relative">
        {/* Left Toolbar - Only shown in shape mode */}
        {!isTilemapMode && (
          <Toolbar
            selectedTool={selectedTool}
            onToolSelect={handleToolSelect}
            hasSelection={selectedIds.size > 0}
            onDelete={handleDelete}
            canUndo={canUndo}
            canRedo={canRedo}
            onUndo={undoFn || undefined}
            onRedo={redoFn || undefined}
          />
        )}

        {/* Canvas Container - Flexible width, adjusts when layer panel is minimized */}
        <div className="flex-1 h-full overflow-hidden">
          <Canvas
            selectedTool={selectedTool}
            onShapeSelect={handleShapeSelect}
            deleteTriggered={deleteTriggered}
            onUndoRedoChange={handleUndoRedoChange}
            canvasId={canvasId}
            onViewportChange={(vp) => setViewport({ x: vp.x, y: vp.y, scale: vp.scale })}
            onZoomChange={(scale) => setViewport(prev => ({ ...prev, scale }))}
            onZoomControlsReady={handleZoomControlsReady}
            onColorSamplingReady={handleColorSamplingReady}
            isTilemapMode={isTilemapMode}
            onExportFunctionsReady={handleExportFunctionsReady}
            tileMode={tileMode}
            onTileModeChange={setTileMode}
            brushSize={brushSize}
            onBrushSizeChange={setBrushSize}
            autoTilingEnabled={autoTilingEnabled}
            onAutoTilingToggle={() => {
              setAutoTilingEnabled(!autoTilingEnabled)
              if (!autoTilingEnabled) {
                setSelectedVariant(undefined)
              }
            }}
            showTileGrid={showTileGrid}
            onTileGridToggle={() => setShowTileGrid(!showTileGrid)}
            selectedPaletteIndex={selectedPaletteIndex}
            onPaletteIndexChange={setSelectedPaletteIndex}
            selectedVariant={selectedVariant}
            onVariantChange={setSelectedVariant}
            plainColor={plainColor}
            onPlainColorChange={setPlainColor}
            aiChat={
              isAIEnabled() && user ? (
                <AIChatPanel
                  canvasId={canvasId}
                  userId={user.uid}
                  selectedShapes={Array.from(selectedIds)}
                  viewport={{
                    x: viewport.x,
                    y: viewport.y,
                    width: window.innerWidth,
                    height: window.innerHeight,
                    zoom: viewport.scale,
                  }}
                  mode={isTilemapMode ? 'tilemap' : 'shapes'}
                  onClose={() => {/* AI always visible in status bar */}}
                />
              ) : null
            }
          />
        </div>

        {/* Right Layer Panel (PR-19: 256px width, from top 64px) - Hidden in tilemap mode */}
        {!isTilemapMode && (
          <LayerPanel
            shapes={shapes}
            groups={groups}
            selectedIds={selectedIds}
            onSelectLayer={handleSelectLayer}
            onToggleVisibility={toggleVisibility}
            onToggleLock={toggleLock}
            onRenameLayer={handleRenameLayer}
            onDelete={deleteShape}
            onUpdateColors={(fill, stroke, strokeWidth) => updateColors(fill, stroke, strokeWidth)}
            onUpdateShapeProps={(id, updates) => updateShape(id, updates)}
            recentColors={getRecentColors()}
            onRequestColorSample={enableColorSampling || undefined}
            collabTheme={{
              primary: '#475569',
              secondary: '#374151',
              gradient: 'from-slate-600 to-gray-700',
              displayName: 'CollabCanvas',
              softBg: 'rgba(71, 85, 105, 0.3)',
              softBorder: 'rgba(71, 85, 105, 0.4)'
            }}
          />
        )}

      </div>

      {/* Status Bar with inline AI Chat - Fixed at bottom */}
      {!isTilemapMode && (
        <ShapeStatusBar
          shapeCount={shapes.length}
          selectedCount={selectedIds.size}
          zoom={viewport.scale}
          connectionStatus="connected"
          aiChat={
            isAIEnabled() && user ? (
              <AIChatPanel
                canvasId={canvasId}
                userId={user.uid}
                selectedShapes={Array.from(selectedIds)}
                viewport={{
                  x: viewport.x,
                  y: viewport.y,
                  width: window.innerWidth,
                  height: window.innerHeight,
                  zoom: viewport.scale,
                }}
                mode="shapes"
                onClose={() => {/* AI always visible in status bar */}}
              />
            ) : null
          }
        />
      )}

      {/* Asset Library Panel - Slides in from left */}
      {showAssetLibrary && user?.uid && (
        <div className="fixed left-0 top-12 bottom-0 w-80 z-40 shadow-2xl">
          <AssetLibrary 
            userId={user.uid}
            onClose={() => setShowAssetLibrary(false)}
            onSelectAsset={(assetId) => {
              console.log('Selected asset:', assetId)
              // TODO: Handle asset selection (add to canvas, open animation creator, etc.)
            }}
          />
        </div>
      )}

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        canvasId={canvasId}
        canvasName={canvasMetadata?.name || 'Untitled Canvas'}
      />
    </div>
  )
}
</file>

</files>
