This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
.repomixignore
database.rules.json
firebase.json
index.html
package.json
postcss.config.js
public/vite.svg
repomix.config.json
src/App.css
src/App.tsx
src/assets/react.svg
src/commands/AlignmentCommand.ts
src/commands/BulkCommand.ts
src/commands/ColorCommand.ts
src/commands/CreateCommand.ts
src/commands/DeleteCommand.ts
src/commands/MoveCommand.ts
src/commands/TileCommand.ts
src/commands/TileFillCommand.ts
src/commands/TileStrokeCommand.ts
src/commands/TransformCommand.ts
src/commands/ZIndexCommand.ts
src/components/AlignmentToolbar.tsx
src/components/Canvas.tsx
src/components/canvas/ShapeCanvas.tsx
src/components/canvas/ShapeRenderer.tsx
src/components/canvas/TilemapCanvas.tsx
src/components/CanvasCard.tsx
src/components/ColorPicker.tsx
src/components/ContextMenu.tsx
src/components/Cursor.tsx
src/components/ErrorBoundary.tsx
src/components/Group.tsx
src/components/KeyboardShortcuts.tsx
src/components/LayerItem.tsx
src/components/LayerPanel.tsx
src/components/Login.tsx
src/components/PresenceBar.tsx
src/components/PropertiesPanel.tsx
src/components/ProtectedRoute.tsx
src/components/QuickActionsPopup.tsx
src/components/QuickPropertiesPopup.tsx
src/components/shapes/Circle.tsx
src/components/shapes/Line.tsx
src/components/shapes/Path.tsx
src/components/shapes/Polygon.tsx
src/components/shapes/Rectangle.tsx
src/components/shapes/RoundedRect.tsx
src/components/shapes/SelectionBox.tsx
src/components/shapes/Star.tsx
src/components/shapes/TextShape.tsx
src/components/Skeleton.tsx
src/components/TextEditor.tsx
src/components/TilemapGrid.tsx
src/components/TilemapLayer.tsx
src/components/TilePalette.tsx
src/components/TileRenderer.tsx
src/components/TileStatusBar.tsx
src/components/Toolbar.tsx
src/components/ToolButton.tsx
src/components/Tooltip.tsx
src/components/ZoomControls.tsx
src/constants/shortcuts.ts
src/hooks/useAuth.ts
src/hooks/useCanvas.ts
src/hooks/useCanvasList.ts
src/hooks/useCanvasViewport.ts
src/hooks/useContextMenu.ts
src/hooks/useGroups.ts
src/hooks/useKeyboardShortcuts.ts
src/hooks/useLayers.ts
src/hooks/usePresence.ts
src/hooks/useShapeKeyboardShortcuts.ts
src/hooks/useTilemap.ts
src/index.css
src/main.tsx
src/pages/CanvasPage.tsx
src/pages/DashboardPage.tsx
src/services/alignment.ts
src/services/auth.ts
src/services/canvasManager.ts
src/services/canvasSync.ts
src/services/clipboard.ts
src/services/colorStorage.ts
src/services/commandHistory.ts
src/services/firebase.ts
src/services/groupSync.ts
src/services/tileFill.ts
src/services/tilemapExport.ts
src/services/tilemapImport.ts
src/services/tilemapSync.ts
src/types/canvas.ts
src/types/command.ts
src/types/firebase.ts
src/types/group.ts
src/types/layer.ts
src/types/selection.ts
src/types/tilemap.ts
src/utils/downloadHelper.ts
src/utils/groupHelpers.ts
src/utils/migrationScript.ts
src/utils/pathHelpers.ts
src/utils/performance.ts
src/utils/testFirebase.ts
src/utils/throttle.ts
src/vite-env.d.ts
tailwind.config.js
test-firebase.js
TESTING.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Firebase Configuration
# Copy this file to .env and fill in your Firebase project credentials
# Get these values from Firebase Console > Project Settings > General > Your apps

VITE_FIREBASE_API_KEY=your-api-key-here
VITE_FIREBASE_AUTH_DOMAIN=your-project-id.firebaseapp.com
VITE_FIREBASE_DATABASE_URL=https://your-project-id-default-rtdb.firebaseio.com
VITE_FIREBASE_PROJECT_ID=your-project-id

# Canvas ID (optional, defaults to 'default-canvas')
VITE_CANVAS_ID=default-canvas
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env.local
.env.development.local
.env.test.local
.env.production.local

# Firebase
.firebase/
.firebaserc
firebase-debug.log
firebase-debug.*.log

# Test coverage
coverage/
*.lcov

.tests/*
.context/*
.cursor/*
context/*
tests/*
</file>

<file path=".repomixignore">
readme.md
.readme.md
</file>

<file path="database.rules.json">
{
  "rules": {
    "users": {
      "$userId": {
        "canvases": {
          ".read": "$userId === auth.uid",
          ".write": "$userId === auth.uid"
        }
      }
    },
    "canvases": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "canvas": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "collab-spaces": {
      "$spaceId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },
    "presence": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null",
        "$userId": {
          ".write": "$userId === auth.uid"
        }
      }
    },
    "collab-presence": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null",
        "$userId": {
          ".write": "$userId === auth.uid"
        }
      }
    },
    "tilemaps": {
      "$canvasId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    }
  }
}
</file>

<file path="firebase.json">
{
  "database": {
    "rules": "database.rules.json"
  },
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <title>CollabCanvas - Real-time Collaborative Design</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "collabcanvas",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "deploy": "npm run build && firebase deploy --only hosting"
  },
  "dependencies": {
    "@tailwindcss/postcss": "^4.1.14",
    "firebase": "^12.4.0",
    "konva": "^10.0.2",
    "lodash-es": "^4.17.21",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-konva": "^19.0.10",
    "react-router-dom": "^7.9.4",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/lodash-es": "^4.17.12",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@types/react-router-dom": "^5.3.3",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/coverage-v8": "^3.2.4",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.21",
    "canvas": "^3.2.0",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "jsdom": "^27.0.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.14",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    "@tailwindcss/postcss": {},
    autoprefixer: {},
  },
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="repomix.config.json">
{
    "output": {
      "removeComments": true
    }
  }
</file>

<file path="src/App.css">
#root {
  width: 100%;
  height: 100vh;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
</file>

<file path="src/App.tsx">
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { useAuth } from './hooks/useAuth'
import { useEffect } from 'react'
import { autoMigrateIfNeeded } from './utils/migrationScript'
import CanvasPage from './pages/CanvasPage'
import DashboardPage from './pages/DashboardPage'
import Login from './components/Login'
import ProtectedRoute from './components/ProtectedRoute'
import './App.css'





function App() {
  const { user } = useAuth()


  useEffect(() => {
    if (user?.uid) {
      autoMigrateIfNeeded(user.uid)
    }
  }, [user?.uid])

  return (
    <BrowserRouter>
      <Routes>
        {}
        <Route
          path="/login"
          element={
            user ? <Navigate to="/" replace /> : <Login />
          }
        />

        {}
        <Route
          path="/"
          element={
            <ProtectedRoute>
              <DashboardPage />
            </ProtectedRoute>
          }
        />

        {}
        <Route
          path="/canvas/:canvasId"
          element={
            <ProtectedRoute>
              <CanvasPage />
            </ProtectedRoute>
          }
        />

        {}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  )
}

export default App
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/commands/AlignmentCommand.ts">
import type { Command } from '../types/command'






export class AlignmentCommand implements Command {
  readonly type = 'alignment' as const

  private shapeIds: string[]
  private oldPositions: Map<string, { x: number; y: number }>
  private newPositions: Map<string, { x: number; y: number }>
  private updateShape: (id: string, updates: { x: number; y: number }) => void
  private syncPosition: (id: string, x: number, y: number) => Promise<void>

  constructor(
    shapeIds: string[],
    oldPositions: Map<string, { x: number; y: number }>,
    newPositions: Map<string, { x: number; y: number }>,
    updateShape: (id: string, updates: { x: number; y: number }) => void,
    syncPosition: (id: string, x: number, y: number) => Promise<void>
  ) {
    this.shapeIds = shapeIds
    this.oldPositions = oldPositions
    this.newPositions = newPositions
    this.updateShape = updateShape
    this.syncPosition = syncPosition
  }

  execute(): void {

    this.shapeIds.forEach((id) => {
      const newPos = this.newPositions.get(id)
      if (newPos) {
        this.updateShape(id, newPos)
        this.syncPosition(id, newPos.x, newPos.y).catch((error) => {
          console.error('Failed to sync alignment position:', error)
        })
      }
    })
  }

  undo(): void {

    this.shapeIds.forEach((id) => {
      const oldPos = this.oldPositions.get(id)
      if (oldPos) {
        this.updateShape(id, oldPos)
        this.syncPosition(id, oldPos.x, oldPos.y).catch((error) => {
          console.error('Failed to sync alignment position in undo:', error)
        })
      }
    })
  }

  redo(): void {

    this.execute()
  }
}
</file>

<file path="src/commands/BulkCommand.ts">
import type { Command } from '../types/command'






export class BulkCommand implements Command {
  readonly type = 'bulk' as const

  private commands: Command[]

  constructor(commands: Command[]) {
    this.commands = commands
  }

  execute(): void {

    this.commands.forEach((command) => {
      command.execute()
    })
  }

  undo(): void {

    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo()
    }
  }

  redo(): void {

    this.commands.forEach((command) => {
      command.redo()
    })
  }
}
</file>

<file path="src/commands/ColorCommand.ts">
import type { Command } from '../types/command'




interface ColorData {
  fill: string
  stroke?: string
  strokeWidth?: number
}






export class ColorCommand implements Command {
  readonly type = 'color' as const

  private shapeId: string
  private oldColors: ColorData
  private newColors: ColorData
  private updateShapeInState: (id: string, updates: Partial<ColorData>) => void
  private syncUpdate: (id: string, updates: Partial<ColorData>) => Promise<void>

  constructor(
    shapeId: string,
    oldColors: ColorData,
    newColors: ColorData,
    updateShapeInState: (id: string, updates: Partial<ColorData>) => void,
    syncUpdate: (id: string, updates: Partial<ColorData>) => Promise<void>
  ) {
    this.shapeId = shapeId
    this.oldColors = oldColors
    this.newColors = newColors
    this.updateShapeInState = updateShapeInState
    this.syncUpdate = syncUpdate
  }

  execute(): void {

    this.updateShapeInState(this.shapeId, this.newColors)


    this.syncUpdate(this.shapeId, this.newColors).catch((error) => {
      console.error('Failed to sync color change:', error)
    })
  }

  undo(): void {

    this.updateShapeInState(this.shapeId, this.oldColors)


    this.syncUpdate(this.shapeId, this.oldColors).catch((error) => {
      console.error('Failed to sync color change in undo:', error)
    })
  }

  redo(): void {

    this.updateShapeInState(this.shapeId, this.newColors)


    this.syncUpdate(this.shapeId, this.newColors).catch((error) => {
      console.error('Failed to sync color change in redo:', error)
    })
  }
}
</file>

<file path="src/commands/CreateCommand.ts">
import type { Command } from '../types/command'
import type { Shape } from '../types/canvas'






export class CreateCommand implements Command {
  readonly type = 'create' as const

  private shape: Shape
  private addShapeToState: (shape: Shape) => void
  private removeShapeFromState: (id: string) => void
  private syncCreate: (shape: Shape) => Promise<void>
  private syncDelete: (id: string) => Promise<void>

  constructor(
    shape: Shape,
    addShapeToState: (shape: Shape) => void,
    removeShapeFromState: (id: string) => void,
    syncCreate: (shape: Shape) => Promise<void>,
    syncDelete: (id: string) => Promise<void>
  ) {
    this.shape = shape
    this.addShapeToState = addShapeToState
    this.removeShapeFromState = removeShapeFromState
    this.syncCreate = syncCreate
    this.syncDelete = syncDelete
  }

  execute(): void {

    this.addShapeToState(this.shape)


    this.syncCreate(this.shape).catch((error) => {
      console.error('Failed to sync shape creation:', error)
    })
  }

  undo(): void {

    this.removeShapeFromState(this.shape.id)


    this.syncDelete(this.shape.id).catch((error) => {
      console.error('Failed to sync shape deletion in undo:', error)
    })
  }

  redo(): void {

    this.addShapeToState(this.shape)


    this.syncCreate(this.shape).catch((error) => {
      console.error('Failed to sync shape creation in redo:', error)
    })
  }
}
</file>

<file path="src/commands/DeleteCommand.ts">
import type { Command } from '../types/command'
import type { Shape } from '../types/canvas'






export class DeleteCommand implements Command {
  readonly type = 'delete' as const

  private shape: Shape
  private addShapeToState: (shape: Shape) => void
  private removeShapeFromState: (id: string) => void
  private syncCreate: (shape: Shape) => Promise<void>
  private syncDelete: (id: string) => Promise<void>

  constructor(
    shape: Shape,
    addShapeToState: (shape: Shape) => void,
    removeShapeFromState: (id: string) => void,
    syncCreate: (shape: Shape) => Promise<void>,
    syncDelete: (id: string) => Promise<void>
  ) {
    this.shape = shape
    this.addShapeToState = addShapeToState
    this.removeShapeFromState = removeShapeFromState
    this.syncCreate = syncCreate
    this.syncDelete = syncDelete
  }

  execute(): void {

    this.removeShapeFromState(this.shape.id)


    this.syncDelete(this.shape.id).catch((error) => {
      console.error('Failed to sync shape deletion:', error)
    })
  }

  undo(): void {

    this.addShapeToState(this.shape)


    this.syncCreate(this.shape).catch((error) => {
      console.error('Failed to sync shape recreation in undo:', error)
    })
  }

  redo(): void {

    this.removeShapeFromState(this.shape.id)


    this.syncDelete(this.shape.id).catch((error) => {
      console.error('Failed to sync shape deletion in redo:', error)
    })
  }
}
</file>

<file path="src/commands/MoveCommand.ts">
import type { Command } from '../types/command'




interface Position {
  x: number
  y: number
}






export class MoveCommand implements Command {
  readonly type = 'move' as const

  private shapeId: string
  private oldPosition: Position
  private newPosition: Position
  private updateShapeInState: (id: string, updates: Partial<{ x: number; y: number }>) => void
  private syncUpdate: (id: string, updates: Partial<{ x: number; y: number }>) => Promise<void>

  constructor(
    shapeId: string,
    oldPosition: Position,
    newPosition: Position,
    updateShapeInState: (id: string, updates: Partial<{ x: number; y: number }>) => void,
    syncUpdate: (id: string, updates: Partial<{ x: number; y: number }>) => Promise<void>
  ) {
    this.shapeId = shapeId
    this.oldPosition = oldPosition
    this.newPosition = newPosition
    this.updateShapeInState = updateShapeInState
    this.syncUpdate = syncUpdate
  }

  execute(): void {

    this.updateShapeInState(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    })


    this.syncUpdate(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    }).catch((error) => {
      console.error('Failed to sync shape move:', error)
    })
  }

  undo(): void {

    this.updateShapeInState(this.shapeId, {
      x: this.oldPosition.x,
      y: this.oldPosition.y,
    })


    this.syncUpdate(this.shapeId, {
      x: this.oldPosition.x,
      y: this.oldPosition.y,
    }).catch((error) => {
      console.error('Failed to sync shape move in undo:', error)
    })
  }

  redo(): void {

    this.updateShapeInState(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    })


    this.syncUpdate(this.shapeId, {
      x: this.newPosition.x,
      y: this.newPosition.y,
    }).catch((error) => {
      console.error('Failed to sync shape move in redo:', error)
    })
  }
}
</file>

<file path="src/commands/TileCommand.ts">
import type { Command } from '../types/command'
import type { TileData } from '../types/tilemap'






export class TileSetCommand implements Command {
  readonly type = 'create' as const

  private x: number
  private y: number
  private oldTile: TileData | undefined
  private newTile: TileData
  private setTileInState: (x: number, y: number, tile: TileData) => void
  private deleteTileInState: (x: number, y: number) => void

  constructor(
    x: number,
    y: number,
    oldTile: TileData | undefined,
    newTile: TileData,
    setTileInState: (x: number, y: number, tile: TileData) => void,
    deleteTileInState: (x: number, y: number) => void
  ) {
    this.x = x
    this.y = y
    this.oldTile = oldTile
    this.newTile = newTile
    this.setTileInState = setTileInState
    this.deleteTileInState = deleteTileInState
  }

  execute(): void {

    this.setTileInState(this.x, this.y, this.newTile)
  }

  undo(): void {
    if (this.oldTile) {

      this.setTileInState(this.x, this.y, this.oldTile)
    } else {

      this.deleteTileInState(this.x, this.y)
    }
  }

  redo(): void {

    this.setTileInState(this.x, this.y, this.newTile)
  }
}
</file>

<file path="src/commands/TileFillCommand.ts">
import { TileStrokeCommand } from './TileStrokeCommand'
import type { TileData } from '../types/tilemap'








export class TileFillCommand extends TileStrokeCommand {
  private fillStartX: number
  private fillStartY: number
  private fillTileCount: number

  constructor(
    fillStartX: number,
    fillStartY: number,
    changes: Array<{ x: number; y: number; oldTile: TileData | undefined; newTile: TileData | null }>,
    setTilesInState: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void,
    deleteTilesInState: (tiles: Array<{ x: number; y: number }>) => void
  ) {
    super(changes, setTilesInState, deleteTilesInState)
    this.fillStartX = fillStartX
    this.fillStartY = fillStartY
    this.fillTileCount = changes.length
  }




  getFillMetadata() {
    return {
      startX: this.fillStartX,
      startY: this.fillStartY,
      tileCount: this.fillTileCount,
    }
  }


}
</file>

<file path="src/commands/TileStrokeCommand.ts">
import type { Command } from '../types/command'
import type { TileData } from '../types/tilemap'




interface TileChange {
  x: number
  y: number
  oldTile: TileData | undefined
  newTile: TileData | null
}







export class TileStrokeCommand implements Command {
  readonly type = 'bulk' as const

  private changes: TileChange[]
  private setTilesInState: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void
  private deleteTilesInState: (tiles: Array<{ x: number; y: number }>) => void

  constructor(
    changes: TileChange[],
    setTilesInState: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void,
    deleteTilesInState: (tiles: Array<{ x: number; y: number }>) => void
  ) {
    this.changes = changes
    this.setTilesInState = setTilesInState
    this.deleteTilesInState = deleteTilesInState
  }

  execute(): void {

    const tilesToSet: Array<{ x: number; y: number; tile: TileData }> = []
    const tilesToDelete: Array<{ x: number; y: number }> = []

    this.changes.forEach((change) => {
      if (change.newTile === null) {
        tilesToDelete.push({ x: change.x, y: change.y })
      } else {
        tilesToSet.push({ x: change.x, y: change.y, tile: change.newTile })
      }
    })

    if (tilesToSet.length > 0) {
      this.setTilesInState(tilesToSet)
    }
    if (tilesToDelete.length > 0) {
      this.deleteTilesInState(tilesToDelete)
    }
  }

  undo(): void {

    const tilesToSet: Array<{ x: number; y: number; tile: TileData }> = []
    const tilesToDelete: Array<{ x: number; y: number }> = []

    this.changes.forEach((change) => {
      if (change.oldTile) {
        tilesToSet.push({ x: change.x, y: change.y, tile: change.oldTile })
      } else {
        tilesToDelete.push({ x: change.x, y: change.y })
      }
    })

    if (tilesToSet.length > 0) {
      this.setTilesInState(tilesToSet)
    }
    if (tilesToDelete.length > 0) {
      this.deleteTilesInState(tilesToDelete)
    }
  }

  redo(): void {

    this.execute()
  }
}
</file>

<file path="src/commands/TransformCommand.ts">
import type { Command } from '../types/command'




interface Transform {
  width: number
  height: number
  rotation?: number
}






export class TransformCommand implements Command {
  readonly type = 'transform' as const

  private shapeId: string
  private oldTransform: Transform
  private newTransform: Transform
  private updateShapeInState: (id: string, updates: Partial<Transform>) => void
  private syncUpdate: (id: string, updates: Partial<Transform>) => Promise<void>

  constructor(
    shapeId: string,
    oldTransform: Transform,
    newTransform: Transform,
    updateShapeInState: (id: string, updates: Partial<Transform>) => void,
    syncUpdate: (id: string, updates: Partial<Transform>) => Promise<void>
  ) {
    this.shapeId = shapeId
    this.oldTransform = oldTransform
    this.newTransform = newTransform
    this.updateShapeInState = updateShapeInState
    this.syncUpdate = syncUpdate
  }

  execute(): void {

    this.updateShapeInState(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    })


    this.syncUpdate(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    }).catch((error) => {
      console.error('Failed to sync shape transform:', error)
    })
  }

  undo(): void {

    this.updateShapeInState(this.shapeId, {
      width: this.oldTransform.width,
      height: this.oldTransform.height,
      rotation: this.oldTransform.rotation,
    })


    this.syncUpdate(this.shapeId, {
      width: this.oldTransform.width,
      height: this.oldTransform.height,
      rotation: this.oldTransform.rotation,
    }).catch((error) => {
      console.error('Failed to sync shape transform in undo:', error)
    })
  }

  redo(): void {

    this.updateShapeInState(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    })


    this.syncUpdate(this.shapeId, {
      width: this.newTransform.width,
      height: this.newTransform.height,
      rotation: this.newTransform.rotation,
    }).catch((error) => {
      console.error('Failed to sync shape transform in redo:', error)
    })
  }
}
</file>

<file path="src/commands/ZIndexCommand.ts">
import type { Command } from '../types/command'






export class ZIndexCommand implements Command {
  readonly type = 'zindex' as const

  private shapeIds: string[]
  private oldZIndices: Map<string, number>
  private newZIndices: Map<string, number>
  private updateShape: (id: string, updates: { zIndex: number }) => void
  private syncZIndex: (id: string, zIndex: number) => Promise<void>

  constructor(
    shapeIds: string[],
    oldZIndices: Map<string, number>,
    newZIndices: Map<string, number>,
    updateShape: (id: string, updates: { zIndex: number }) => void,
    syncZIndex: (id: string, zIndex: number) => Promise<void>
  ) {
    this.shapeIds = shapeIds
    this.oldZIndices = oldZIndices
    this.newZIndices = newZIndices
    this.updateShape = updateShape
    this.syncZIndex = syncZIndex
  }

  execute(): void {

    this.shapeIds.forEach((id) => {
      const newZIndex = this.newZIndices.get(id)
      if (newZIndex !== undefined) {
        this.updateShape(id, { zIndex: newZIndex })
        this.syncZIndex(id, newZIndex).catch((error) => {
          console.error('Failed to sync z-index change:', error)
        })
      }
    })
  }

  undo(): void {

    this.shapeIds.forEach((id) => {
      const oldZIndex = this.oldZIndices.get(id)
      if (oldZIndex !== undefined) {
        this.updateShape(id, { zIndex: oldZIndex })
        this.syncZIndex(id, oldZIndex).catch((error) => {
          console.error('Failed to sync z-index change in undo:', error)
        })
      }
    })
  }

  redo(): void {

    this.execute()
  }
}
</file>

<file path="src/components/AlignmentToolbar.tsx">
import type { AlignmentType } from '../services/alignment'

interface AlignmentToolbarProps {
  visible: boolean
  selectedCount: number
  onAlign: (type: AlignmentType) => void
  onDistributeHorizontally: () => void
  onDistributeVertically: () => void
  onCenterInCanvas: () => void
}





export function AlignmentToolbar({
  visible,
  selectedCount,
  onAlign,
  onDistributeHorizontally,
  onDistributeVertically,
  onCenterInCanvas,
}: AlignmentToolbarProps) {
  if (!visible) return null


  const canDistribute = selectedCount >= 3

  return (
    <div className="bg-white border-b border-gray-300 px-4 py-2 flex items-center gap-2 shadow-sm">
      <span className="text-sm text-gray-600 mr-2">
        {selectedCount} selected
      </span>

      {}
      <div className="flex items-center gap-1 border-r border-gray-300 pr-2">
        <button
          onClick={() => onAlign('left')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Left"
        >
          <span className="font-mono">|◀</span>
        </button>
        <button
          onClick={() => onAlign('center')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Center"
        >
          <span className="font-mono">|●|</span>
        </button>
        <button
          onClick={() => onAlign('right')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Right"
        >
          <span className="font-mono">▶|</span>
        </button>
      </div>

      {}
      <div className="flex items-center gap-1 border-r border-gray-300 pr-2">
        <button
          onClick={() => onAlign('top')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Top"
        >
          <span className="font-mono">⬆|</span>
        </button>
        <button
          onClick={() => onAlign('middle')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Middle"
        >
          <span className="font-mono">—●—</span>
        </button>
        <button
          onClick={() => onAlign('bottom')}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Align Bottom"
        >
          <span className="font-mono">|⬇</span>
        </button>
      </div>

      {}
      <div className="flex items-center gap-1 border-r border-gray-300 pr-2">
        <button
          onClick={onDistributeHorizontally}
          disabled={!canDistribute}
          className={`px-3 py-1.5 text-sm rounded border transition-colors ${
            canDistribute
              ? 'bg-gray-100 hover:bg-gray-200 border-gray-300'
              : 'bg-gray-50 border-gray-200 text-gray-400 cursor-not-allowed'
          }`}
          title={canDistribute ? "Distribute Horizontally" : "Requires 3+ shapes"}
        >
          <span className="font-mono">←●●●→</span>
        </button>
        <button
          onClick={onDistributeVertically}
          disabled={!canDistribute}
          className={`px-3 py-1.5 text-sm rounded border transition-colors ${
            canDistribute
              ? 'bg-gray-100 hover:bg-gray-200 border-gray-300'
              : 'bg-gray-50 border-gray-200 text-gray-400 cursor-not-allowed'
          }`}
          title={canDistribute ? "Distribute Vertically" : "Requires 3+ shapes"}
        >
          <span className="font-mono">↑●●●↓</span>
        </button>
      </div>

      {}
      <div className="flex items-center gap-1">
        <button
          onClick={onCenterInCanvas}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 transition-colors"
          title="Center in Canvas"
        >
          <span className="font-mono">⊕</span>
        </button>
      </div>
    </div>
  )
}
</file>

<file path="src/components/Canvas.tsx">
import type { ViewportTransform, ToolType } from '../types/canvas'
import ShapeCanvas from './canvas/ShapeCanvas'
import TilemapCanvas from './canvas/TilemapCanvas'

interface CanvasProps {
  selectedTool: ToolType
  onShapeSelect: (id: string | null) => void
  deleteTriggered?: number
  onUndoRedoChange?: (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => void
  canvasId?: string
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
  onZoomControlsReady?: (zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => void
  snapToGrid?: boolean
  onColorSamplingReady?: (fn: (callback: (color: string) => void) => void) => void

  isTilemapMode?: boolean
}




















export default function Canvas({
  selectedTool,
  onShapeSelect,
  deleteTriggered,
  onUndoRedoChange,
  canvasId = 'default-canvas',
  onViewportChange,
  onZoomChange,
  onZoomControlsReady,
  snapToGrid: snapToGridProp = false,
  onColorSamplingReady,
  isTilemapMode = false,
}: CanvasProps) {

  if (isTilemapMode) {
    return (
      <TilemapCanvas
        canvasId={canvasId}
        onViewportChange={onViewportChange}
        onZoomChange={onZoomChange}
        onZoomControlsReady={onZoomControlsReady}
      />
    )
  }

  return (
    <ShapeCanvas
      selectedTool={selectedTool}
      onShapeSelect={onShapeSelect}
      deleteTriggered={deleteTriggered}
      onUndoRedoChange={onUndoRedoChange}
      canvasId={canvasId}
      onViewportChange={onViewportChange}
      onZoomChange={onZoomChange}
      onZoomControlsReady={onZoomControlsReady}
      snapToGrid={snapToGridProp}
      onColorSamplingReady={onColorSamplingReady}
    />
  )
}
</file>

<file path="src/components/canvas/ShapeCanvas.tsx">
import { useRef, useState, useCallback, useEffect } from 'react'
import { Stage, Layer, Line as KonvaLine } from 'react-konva'
import Konva from 'konva'
import type { ViewportTransform, ToolType, Shape } from '../../types/canvas'
import { DEFAULT_CANVAS_BOUNDS } from '../../types/canvas'
import type { SelectionBox as SelectionBoxType } from '../../types/selection'
import {
  createInitialSelectionBox,
  shapeIntersectsSelectionBox,
} from '../../types/selection'
import { useAuth } from '../../hooks/useAuth'
import { usePresence } from '../../hooks/usePresence'
import { useCanvas } from '../../hooks/useCanvas'
import { useGroups } from '../../hooks/useGroups'
import { useCanvasViewport } from '../../hooks/useCanvasViewport'
import { useShapeKeyboardShortcuts } from '../../hooks/useShapeKeyboardShortcuts'
import { simplifyPath } from '../../utils/pathHelpers'
import Cursor from '../Cursor'
import { SelectionBox } from '../shapes/SelectionBox'
import { QuickActionsPopup } from '../QuickActionsPopup'
import { TextEditor } from '../TextEditor'
import { ContextMenu } from '../ContextMenu'
import { AlignmentToolbar } from '../AlignmentToolbar'
import { ShapeRenderer } from './ShapeRenderer'

const CANVAS_BOUNDS = DEFAULT_CANVAS_BOUNDS

interface ShapeCanvasProps {
  selectedTool: ToolType
  onShapeSelect: (id: string | null) => void
  deleteTriggered?: number
  onUndoRedoChange?: (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => void
  canvasId: string
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
  onZoomControlsReady?: (zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => void
  snapToGrid?: boolean
  onColorSamplingReady?: (fn: (callback: (color: string) => void) => void) => void
}

export default function ShapeCanvas({
  selectedTool,
  onShapeSelect,
  deleteTriggered,
  onUndoRedoChange,
  canvasId,
  onViewportChange,
  onZoomChange,
  onZoomControlsReady,
  snapToGrid: snapToGridProp = false,
  onColorSamplingReady,
}: ShapeCanvasProps) {
  const stageRef = useRef<Konva.Stage>(null)
  const isDraggingShapeRef = useRef(false)
  const dragStartPosRef = useRef<{ x: number; y: number } | null>(null)
  const isTransformingShapeRef = useRef(false)
  const lastMouseDownWasOnShapeRef = useRef(false)


  const [textInput, setTextInput] = useState<{ x: number; y: number; value: string } | null>(null)
  const [selectionBox, setSelectionBox] = useState<SelectionBoxType>(createInitialSelectionBox())
  const [isDrawingSelection, setIsDrawingSelection] = useState(false)
  const [isDrawingPath, setIsDrawingPath] = useState(false)
  const [currentPathPoints, setCurrentPathPoints] = useState<number[]>([])
  const [isDrawingLine, setIsDrawingLine] = useState(false)
  const [lineStartPoint, setLineStartPoint] = useState<{ x: number; y: number } | null>(null)
  const [linePreviewEnd, setLinePreviewEnd] = useState<{ x: number; y: number } | null>(null)
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number; visible: boolean }>({ x: 0, y: 0, visible: false })
  const [isColorSamplingMode, setIsColorSamplingMode] = useState(false)
  const [colorSampleCallback, setColorSampleCallback] = useState<((color: string) => void) | null>(null)
  const [editingText, setEditingText] = useState<{
    id: string
    text: string
    screenX: number
    screenY: number
    width: number
    shape: Shape
  } | null>(null)
  const [showQuickActions, setShowQuickActions] = useState(false)

  const snapToGrid = snapToGridProp
  const SNAP_GRID_SIZE = 20

  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight


  const {
    viewport,
    handleWheel: baseHandleWheel,
    handleDragEnd: baseHandleDragEnd,
    handleZoomIn,
    handleZoomOut,
    handleZoomReset,
    handleZoomFit,
  } = useCanvasViewport({
    containerWidth,
    containerHeight,
    onViewportChange,
    onZoomChange,
  })


  const { user } = useAuth()
  const { otherUsers, updateCursorPosition, updateSelection } = usePresence({
    userId: user?.uid || '',
    userName: user?.displayName || user?.email || 'Anonymous',
    canvasId: canvasId,
  })

  const {
    shapes,
    selectedId,
    selectedIds,
    addShape,
    addText,
    updateShape,
    deleteShape,
    setSelection,
    toggleSelection,
    selectMultiple,
    clearSelection,
    selectAll,
    bulkMove,
    bulkDelete,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    canUndo,
    canRedo,
    addLine,
    addPolygon,
    addStar,
    addRoundedRect,
    addPath,
    bringToFront,
    sendToBack,
    bringForward,
    sendBackward,
    sortShapesByZIndex,
    alignSelected,
    distributeSelectedHorizontally,
    distributeSelectedVertically,
    centerSelectedInCanvas,
  } = useCanvas({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  const {
    groups,
    createGroup,
    ungroup,
    isShapeInGroup,
    calculateBounds,
  } = useGroups({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  // Helper functions
  const rgbToHex = (r: number, g: number, b: number): string => {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16).toUpperCase()
      return hex.length === 1 ? '0' + hex : hex
    }).join('')
  }

  const snapToGridCoord = useCallback((coord: number): number => {
    if (!snapToGrid) return coord
    return Math.round(coord / SNAP_GRID_SIZE) * SNAP_GRID_SIZE
  }, [snapToGrid])

  const sampleColorFromStage = (x: number, y: number) => {
    const stage = stageRef.current
    if (!stage) return null

    const layers = stage.getLayers()
    if (layers.length < 2) return null

    const layer = layers[1]
    const canvas = layer.getCanvas()._canvas as HTMLCanvasElement
    const ctx = canvas.getContext('2d')

    if (!ctx) return null

    try {
      const pixelData = ctx.getImageData(x, y, 1, 1).data
      const hex = rgbToHex(pixelData[0], pixelData[1], pixelData[2])
      const alpha = Math.round((pixelData[3] / 255) * 255).toString(16).padStart(2, '0').toUpperCase()
      return hex + alpha
    } catch (error) {
      console.error('Error sampling color:', error)
      return null
    }
  }

  const enableColorSampling = useCallback((callback: (color: string) => void) => {
    setIsColorSamplingMode(true)
    setColorSampleCallback(() => callback)
  }, [])

  const cancelColorSampling = () => {
    setIsColorSamplingMode(false)
    setColorSampleCallback(null)
  }

  const handleTextDoubleClick = (shape: Shape) => {
    const stage = stageRef.current
    if (!stage) return

    const stageBox = stage.container().getBoundingClientRect()
    const screenX = stageBox.left + shape.x * viewport.scale + viewport.x
    const screenY = stageBox.top + shape.y * viewport.scale + viewport.y

    setEditingText({
      id: shape.id,
      text: shape.text || '',
      screenX,
      screenY,
      width: shape.width * viewport.scale,
      shape,
    })
  }

  const handleTextSave = (newText: string) => {
    if (editingText) {
      updateShape(editingText.id, { text: newText })
    }
    setEditingText(null)
  }

  const handleTextEditorCancel = () => {
    setEditingText(null)
  }

  // Keyboard shortcuts hook
  useShapeKeyboardShortcuts({
    selectedIds,
    groups,
    canUndo,
    canRedo,
    isColorSamplingMode,
    bulkDelete,
    clearSelection,
    selectAll,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    createGroup,
    ungroup,
    cancelColorSampling,
  })

  // Effects
  useEffect(() => {
    const selectionArray = Array.from(selectedIds)
    updateSelection(selectionArray.length > 0 ? selectionArray : null)
    onShapeSelect(selectedId)
  }, [selectedIds, selectedId, updateSelection, onShapeSelect])

  useEffect(() => {
    if (onUndoRedoChange) {
      onUndoRedoChange(canUndo, canRedo, undo, redo)
    }
  }, [canUndo, canRedo, undo, redo, onUndoRedoChange])

  // Expose zoom controls - only on mount to avoid render-during-render
  useEffect(() => {
    if (onZoomControlsReady) {
      onZoomControlsReady(handleZoomIn, handleZoomOut, handleZoomReset, handleZoomFit)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Expose color sampling - only on mount to avoid render-during-render
  useEffect(() => {
    if (onColorSamplingReady) {
      onColorSamplingReady(enableColorSampling)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    if (deleteTriggered && deleteTriggered > 0) {
      if (selectedIds.size > 0) {
        bulkDelete()
      } else if (selectedId) {
        deleteShape(selectedId)
      }
    }
  }, [deleteTriggered, selectedId, selectedIds, deleteShape, bulkDelete])

  useEffect(() => {
    if (selectedTool !== 'line' && isDrawingLine) {
      setIsDrawingLine(false)
      setLineStartPoint(null)
      setLinePreviewEnd(null)
    }
  }, [selectedTool, isDrawingLine])

  useEffect(() => {
    if (selectedIds.size === 0) {
      setShowQuickActions(false)
    }
  }, [selectedIds])


  const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
    const stage = stageRef.current
    if (stage) {
      baseHandleWheel(e, stage)
    }
  }, [baseHandleWheel])

  const handleStageMouseDown = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      const stage = stageRef.current
      if (!stage) return

      const pointer = stage.getPointerPosition()
      if (!pointer) return

      if (isColorSamplingMode && colorSampleCallback) {
        const sampledColor = sampleColorFromStage(pointer.x, pointer.y)
        if (sampledColor) {
          colorSampleCallback(sampledColor)
        }
        cancelColorSampling()
        return
      }

      lastMouseDownWasOnShapeRef.current = e.target !== stage
      if (e.target !== stage) return

      const canvasX = (pointer.x - viewport.x) / viewport.scale
      const canvasY = (pointer.y - viewport.y) / viewport.scale

      if (selectedTool === 'line') {
        if (!isDrawingLine) {
          setIsDrawingLine(true)
          setLineStartPoint({ x: snapToGridCoord(canvasX), y: snapToGridCoord(canvasY) })
          setLinePreviewEnd({ x: snapToGridCoord(canvasX), y: snapToGridCoord(canvasY) })
          clearSelection()
          return
        } else {
          if (lineStartPoint) {
            addLine(lineStartPoint.x, lineStartPoint.y, snapToGridCoord(canvasX), snapToGridCoord(canvasY))
            setIsDrawingLine(false)
            setLineStartPoint(null)
            setLinePreviewEnd(null)
          }
          return
        }
      }

      if (selectedTool === 'pencil' || selectedTool === 'pen') {
        setIsDrawingPath(true)
        setCurrentPathPoints([canvasX, canvasY])
        clearSelection()
        return
      }

      if (selectedTool === 'select') {
        setIsDrawingSelection(true)
        setSelectionBox({
          startX: canvasX,
          startY: canvasY,
          currentX: canvasX,
          currentY: canvasY,
          visible: true,
        })
      }
    },
    [selectedTool, viewport, clearSelection, isColorSamplingMode, colorSampleCallback, snapToGridCoord, isDrawingLine, lineStartPoint, addLine]
  )

  const handleStageMouseMove = useCallback(
    (_e: Konva.KonvaEventObject<MouseEvent>) => {
      const stage = stageRef.current
      if (!stage) return

      const pointer = stage.getPointerPosition()
      if (!pointer) return

      const canvasX = (pointer.x - viewport.x) / viewport.scale
      const canvasY = (pointer.y - viewport.y) / viewport.scale

      if (isDrawingLine && selectedTool === 'line' && lineStartPoint) {
        setLinePreviewEnd({ x: canvasX, y: canvasY })
      }

      if (isDrawingPath && (selectedTool === 'pencil' || selectedTool === 'pen')) {
        setCurrentPathPoints((prev) => {
          const lastX = prev[prev.length - 2]
          const lastY = prev[prev.length - 1]
          const distance = Math.sqrt((canvasX - lastX) ** 2 + (canvasY - lastY) ** 2)
          const minDistance = selectedTool === 'pen' ? 3 : 6
          if (distance >= minDistance) {
            return [...prev, canvasX, canvasY]
          }
          return prev
        })
        return
      }

      if (isDrawingSelection && selectedTool === 'select') {
        setSelectionBox((prev) => ({
          ...prev,
          currentX: canvasX,
          currentY: canvasY,
        }))
      }

      updateCursorPosition(canvasX, canvasY)
    },
    [isDrawingPath, isDrawingSelection, selectedTool, viewport, updateCursorPosition, isDrawingLine, lineStartPoint]
  )

  const handleStageMouseUp = useCallback(
    (e: Konva.KonvaEventObject<MouseEvent>) => {
      if (isDrawingPath && (selectedTool === 'pencil' || selectedTool === 'pen')) {
        setIsDrawingPath(false)
        if (currentPathPoints.length >= 4) {
          const isPen = selectedTool === 'pen'
          const tension = isPen ? 0.5 : 0
          const simplificationTolerance = isPen ? 2 : 6
          const simplified = simplifyPath(currentPathPoints, simplificationTolerance)
          addPath(simplified, tension)
        }
        setCurrentPathPoints([])
        return
      }

      const stage = stageRef.current
      if (!stage) return

      const pointer = stage.getPointerPosition()
      if (!pointer) return

      const canvasX = (pointer.x - viewport.x) / viewport.scale
      const canvasY = (pointer.y - viewport.y) / viewport.scale

      if (isDrawingSelection && selectedTool === 'select') {
        setIsDrawingSelection(false)
        const intersectingIds = shapes
          .filter((shape) => shapeIntersectsSelectionBox(shape, selectionBox))
          .map((shape) => shape.id)
        if (intersectingIds.length > 0) {
          selectMultiple(intersectingIds)
        }
        setSelectionBox((prev) => ({ ...prev, visible: false }))
        return
      }

      if (!isDrawingSelection) {
        if (isDraggingShapeRef.current || isTransformingShapeRef.current) {
          isTransformingShapeRef.current = false
          return
        }
        if (lastMouseDownWasOnShapeRef.current) {
          lastMouseDownWasOnShapeRef.current = false
          return
        }
        if (e.target !== e.target.getStage()) return

        const snappedX = snapToGridCoord(canvasX)
        const snappedY = snapToGridCoord(canvasY)

        if (selectedTool === 'rectangle') {
          addShape('rectangle', snappedX, snappedY)
        } else if (selectedTool === 'circle') {
          addShape('circle', snappedX, snappedY)
        } else if (selectedTool === 'text') {
          setTextInput({ x: snappedX, y: snappedY, value: '' })
        } else if (selectedTool === 'roundRect') {
          addRoundedRect(snappedX, snappedY, 10)
        } else if (selectedTool === 'polygon') {
          addPolygon(snappedX, snappedY, 5)
        } else if (selectedTool === 'star') {
          addStar(snappedX, snappedY, 5)
        } else if (selectedTool === 'select' && !e.evt.shiftKey) {
          clearSelection()
          setShowQuickActions(false)
        }
      }
    },
    [isDrawingPath, isDrawingSelection, selectedTool, viewport, currentPathPoints, selectionBox, shapes, selectMultiple, addShape, addPath, clearSelection, snapToGridCoord, addRoundedRect, addPolygon, addStar]
  )

  const handleShapeSelect = useCallback(
    (shapeId: string, shiftKey: boolean) => {
      if (shiftKey) {
        toggleSelection(shapeId)
      } else {
        setSelection(shapeId)
      }
      setContextMenu({ x: 0, y: 0, visible: false })
    },
    [setSelection, toggleSelection]
  )

  const handleContextMenu = useCallback((e: Konva.KonvaEventObject<PointerEvent>) => {
    e.evt.preventDefault()
    setContextMenu({ x: e.evt.clientX, y: e.evt.clientY, visible: true })
  }, [])

  const closeContextMenu = useCallback(() => {
    setContextMenu({ x: 0, y: 0, visible: false })
  }, [])

  const handleShapeDragStart = useCallback(
    (shapeId: string, x: number, y: number) => {
      isDraggingShapeRef.current = true
      dragStartPosRef.current = { x, y }
      if (!selectedIds.has(shapeId)) {
        setSelection(shapeId)
      }
    },
    [selectedIds, setSelection]
  )

  const handleShapeDragEnd = useCallback(
    (shapeId: string, x: number, y: number) => {
      if (!dragStartPosRef.current) return

      const snappedX = snapToGridCoord(x)
      const snappedY = snapToGridCoord(y)
      const deltaX = snappedX - dragStartPosRef.current.x
      const deltaY = snappedY - dragStartPosRef.current.y

      if (selectedIds.size > 1 && selectedIds.has(shapeId)) {
        bulkMove(deltaX, deltaY)
      } else {
        updateShape(shapeId, { x: snappedX, y: snappedY })
      }

      isDraggingShapeRef.current = false
      dragStartPosRef.current = null
    },
    [selectedIds, bulkMove, updateShape, snapToGridCoord]
  )

  const handleShapeTransformEnd = useCallback(
    (shapeId: string, width: number, height: number, rotation: number, x: number, y: number) => {
      updateShape(shapeId, { width, height, rotation, x, y })
    },
    [updateShape]
  )

  const DotGrid = useCallback(() => {
    return (
      <KonvaLine
        points={[]}
        listening={false}
        perfectDrawEnabled={false}
        hitStrokeWidth={0}
        sceneFunc={(context) => {
          const spacing = 20
          const dotRadius = 1.2
          context.fillStyle = '#D1D5DB'
          for (let x = 0; x <= CANVAS_BOUNDS.maxX; x += spacing) {
            for (let y = 0; y <= CANVAS_BOUNDS.maxY; y += spacing) {
              context.beginPath()
              context.arc(x, y, dotRadius, 0, Math.PI * 2)
              context.fill()
            }
          }
        }}
      />
    )
  }, [])

  return (
    <div className="w-full h-full bg-gray-100 overflow-hidden relative flex flex-col">
      <AlignmentToolbar
        visible={selectedIds.size >= 2}
        selectedCount={selectedIds.size}
        onAlign={(type) => alignSelected(type)}
        onDistributeHorizontally={() => distributeSelectedHorizontally()}
        onDistributeVertically={() => distributeSelectedVertically()}
        onCenterInCanvas={() => centerSelectedInCanvas(containerWidth, containerHeight)}
      />

      <div className="flex-1 relative">
        <Stage
          ref={stageRef}
          width={containerWidth}
          height={containerHeight}
          draggable={selectedTool === 'hand' || (selectedTool === 'select' && !isDrawingSelection && !isDraggingShapeRef.current)}
          onWheel={handleWheel}
          onDragEnd={baseHandleDragEnd}
          onMouseMove={handleStageMouseMove}
          onMouseDown={handleStageMouseDown}
          onMouseUp={handleStageMouseUp}
          onContextMenu={handleContextMenu}
          x={viewport.x}
          y={viewport.y}
          scaleX={viewport.scale}
          scaleY={viewport.scale}
        >
          <Layer listening={false} perfectDrawEnabled={false}>
            <DotGrid />
          </Layer>

          <Layer>
            <ShapeRenderer
              shapes={shapes}
              groups={groups}
              selectedIds={selectedIds}
              viewport={viewport}
              containerWidth={containerWidth}
              containerHeight={containerHeight}
              isDrawingLine={isDrawingLine}
              lineStartPoint={lineStartPoint}
              linePreviewEnd={linePreviewEnd}
              isDrawingPath={isDrawingPath}
              currentPathPoints={currentPathPoints}
              selectedTool={selectedTool}
              sortShapesByZIndex={sortShapesByZIndex}
              isShapeInGroup={(id) => !!isShapeInGroup(id)}
              calculateBounds={calculateBounds}
              handleShapeSelect={handleShapeSelect}
              handleShapeDragStart={handleShapeDragStart}
              handleShapeDragEnd={handleShapeDragEnd}
              handleShapeTransformEnd={handleShapeTransformEnd}
              handleTextDoubleClick={handleTextDoubleClick}
              updateShape={updateShape}
              dragStartPosRef={dragStartPosRef}
            />
            <SelectionBox selectionBox={selectionBox} />
          </Layer>

          <Layer listening={false}>
            {Array.from(otherUsers.entries()).map(([userId, presence]) => (
              <Cursor
                key={userId}
                x={presence.c[0]}
                y={presence.c[1]}
                userName={presence.n}
                color={presence.cl}
              />
            ))}
          </Layer>
        </Stage>

        {textInput && (
          <div
            className="absolute bg-white border-2 border-blue-500 rounded shadow-lg p-2"
            style={{
              left: textInput.x * viewport.scale + viewport.x,
              top: textInput.y * viewport.scale + viewport.y,
              zIndex: 1000,
            }}
          >
            <input
              type="text"
              autoFocus
              value={textInput.value}
              onChange={(e) => setTextInput({ ...textInput, value: e.target.value })}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && textInput.value.trim()) {
                  addText(textInput.value, textInput.x, textInput.y)
                  setTextInput(null)
                } else if (e.key === 'Escape') {
                  setTextInput(null)
                }
              }}
              onBlur={() => setTextInput(null)}
              placeholder="Type text..."
              className="px-2 py-1 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
              style={{ width: '200px' }}
            />
            <div className="text-xs text-gray-500 mt-1">Press Enter to create, Esc to cancel</div>
          </div>
        )}

        {editingText && (
          <TextEditor
            initialText={editingText.text}
            x={editingText.screenX}
            y={editingText.screenY}
            width={editingText.width}
            fontFamily={editingText.shape.fontFamily}
            fontSize={editingText.shape.fontSize}
            fontWeight={editingText.shape.fontWeight}
            fontStyle={editingText.shape.fontStyle}
            textAlign={editingText.shape.textAlign}
            fill={editingText.shape.fill}
            onSave={handleTextSave}
            onCancel={handleTextEditorCancel}
          />
        )}

        {showQuickActions && selectedIds.size > 0 && (() => {
          const selectedShape = shapes.find(s => selectedIds.has(s.id))
          if (!selectedShape) return null
          return (
            <QuickActionsPopup
              screenX={selectedShape.x * viewport.scale + viewport.x + (selectedShape.width || 0) * viewport.scale}
              screenY={selectedShape.y * viewport.scale + viewport.y}
              selectedCount={selectedIds.size}
              canGroup={selectedIds.size >= 2}
              onBringToFront={() => bringToFront()}
              onSendToBack={() => sendToBack()}
              onBringForward={() => bringForward()}
              onSendBackward={() => sendBackward()}
              onGroup={() => createGroup(Array.from(selectedIds))}
              onUngroup={() => {
                const firstSelected = Array.from(selectedIds)[0]
                if (firstSelected) ungroup(firstSelected)
              }}
              onDuplicate={() => duplicateSelected()}
              onDelete={() => bulkDelete()}
              onClose={() => setShowQuickActions(false)}
            />
          )
        })()}

        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          visible={contextMenu.visible}
          onClose={closeContextMenu}
          hasSelection={selectedIds.size > 0}
          canCopy={selectedIds.size > 0}
          canPaste={true}
          selectedCount={selectedIds.size}
          onBringToFront={() => bringToFront()}
          onBringForward={() => bringForward()}
          onSendBackward={() => sendBackward()}
          onSendToBack={() => sendToBack()}
          onCopy={copySelected}
          onPaste={paste}
          onDuplicate={duplicateSelected}
          onDelete={bulkDelete}
          onAlign={(type) => alignSelected(type)}
          onDistributeHorizontally={() => distributeSelectedHorizontally()}
          onDistributeVertically={() => distributeSelectedVertically()}
          onCenterInCanvas={() => centerSelectedInCanvas(containerWidth, containerHeight)}
        />
      </div>
    </div>
  )
}
</file>

<file path="src/components/canvas/ShapeRenderer.tsx">
import { Line as KonvaLine, Circle as KonvaCircle } from 'react-konva'
import Konva from 'konva'
import type { Shape, ViewportTransform } from '../../types/canvas'
import type { Group as GroupType } from '../../types/group'
import Rectangle from '../shapes/Rectangle'
import Circle from '../shapes/Circle'
import TextShape from '../shapes/TextShape'
import Line from '../shapes/Line'
import Polygon from '../shapes/Polygon'
import Star from '../shapes/Star'
import RoundedRect from '../shapes/RoundedRect'
import Path from '../shapes/Path'
import Group from '../Group'

interface ShapeRendererProps {
  shapes: Shape[]
  groups: GroupType[]
  selectedIds: Set<string>
  viewport: ViewportTransform
  containerWidth: number
  containerHeight: number
  isDrawingLine: boolean
  lineStartPoint: { x: number; y: number } | null
  linePreviewEnd: { x: number; y: number } | null
  isDrawingPath: boolean
  currentPathPoints: number[]
  selectedTool: 'select' | 'pen' | 'pencil' | string
  sortShapesByZIndex: () => Shape[]
  isShapeInGroup: (shapeId: string) => boolean
  calculateBounds: (groupId: string, shapes: Shape[]) => { x: number; y: number; width: number; height: number } | null
  handleShapeSelect: (shapeId: string, shiftKey: boolean) => void
  handleShapeDragStart: (shapeId: string, x: number, y: number) => void
  handleShapeDragEnd: (shapeId: string, x: number, y: number) => void
  handleShapeTransformEnd: (shapeId: string, width: number, height: number, rotation: number, x: number, y: number) => void
  handleTextDoubleClick: (shape: Shape) => void
  updateShape: (shapeId: string, updates: Partial<Shape>) => void
  dragStartPosRef: React.MutableRefObject<{ x: number; y: number } | null>
}

export function ShapeRenderer({
  shapes,
  groups,
  selectedIds,
  viewport,
  containerWidth,
  containerHeight,
  isDrawingLine,
  lineStartPoint,
  linePreviewEnd,
  isDrawingPath,
  currentPathPoints,
  selectedTool,
  sortShapesByZIndex,
  isShapeInGroup,
  calculateBounds,
  handleShapeSelect,
  handleShapeDragStart,
  handleShapeDragEnd,
  handleShapeTransformEnd,
  handleTextDoubleClick,
  updateShape,
  dragStartPosRef,
}: ShapeRendererProps) {
  const getUserColor = () => '#3B82F6'

  const isShapeInViewport = (shape: Shape): boolean => {
    const margin = 500
    const viewportLeft = -viewport.x / viewport.scale - margin
    const viewportTop = -viewport.y / viewport.scale - margin
    const viewportRight = viewportLeft + (containerWidth / viewport.scale) + margin * 2
    const viewportBottom = viewportTop + (containerHeight / viewport.scale) + margin * 2

    if ((shape.type === 'path' || shape.type === 'line') && shape.points && shape.points.length >= 2) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity
      for (let i = 0; i < shape.points.length; i += 2) {
        const x = shape.type === 'line' ? shape.points[i] : shape.points[i] + (shape.x || 0)
        const y = shape.type === 'line' ? shape.points[i + 1] : shape.points[i + 1] + (shape.y || 0)
        minX = Math.min(minX, x)
        minY = Math.min(minY, y)
        maxX = Math.max(maxX, x)
        maxY = Math.max(maxY, y)
      }

      return !(
        maxX < viewportLeft ||
        minX > viewportRight ||
        maxY < viewportTop ||
        minY > viewportBottom
      )
    }

    const shapeRight = shape.x + (shape.width || 0)
    const shapeBottom = shape.y + (shape.height || 0)

    return !(
      shapeRight < viewportLeft ||
      shape.x > viewportRight ||
      shapeBottom < viewportTop ||
      shape.y > viewportBottom
    )
  }

  return (
    <>
      {sortShapesByZIndex()
        .filter((shape) => !isShapeInGroup(shape.id))
        .filter((shape) => {
          if (selectedIds.has(shape.id)) {
            return true
          }
          return isShapeInViewport(shape)
        })
        .map((shape) => {
        const isSelected = selectedIds.has(shape.id)
        const userColor = getUserColor()

        if (shape.type === 'rectangle') {
          return (
            <Rectangle
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'circle') {
          const radius = shape.width / 2
          const centerX = shape.x + radius
          const centerY = shape.y + radius

          return (
            <KonvaCircle
              key={shape.id}
              x={centerX}
              y={centerY}
              radius={radius}
              fill={shape.fill}
              stroke={shape.stroke || '#000000'}
              strokeWidth={shape.strokeWidth || 2}
              draggable
              onClick={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(e) => {
                const node = e.target
                handleShapeDragStart(shape.id, node.x() - radius, node.y() - radius)
              }}
              onDragEnd={(e) => {
                const node = e.target
                handleShapeDragEnd(shape.id, node.x() - radius, node.y() - radius)
              }}
            />
          )
        } else if (shape.type === 'text' && shape.text) {
          return (
            <TextShape
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              text={shape.text}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              fontFamily={shape.fontFamily}
              fontSize={shape.fontSize}
              fontWeight={shape.fontWeight}
              fontStyle={shape.fontStyle}
              textAlign={shape.textAlign}
              textDecoration={shape.textDecoration}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
              onDoubleClick={() => handleTextDoubleClick(shape)}
            />
          )
        } else if (shape.type === 'line' && shape.points) {
          return (
            <Line
              key={shape.id}
              id={shape.id}
              points={shape.points}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              arrows={shape.arrows}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(pts: number[], x: number, y: number) => {
                updateShape(shape.id, { points: pts, x, y })
              }}
            />
          )
        } else if (shape.type === 'polygon' && shape.sides) {
          return (
            <Polygon
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              sides={shape.sides}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'star' && shape.sides) {
          return (
            <Star
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              sides={shape.sides}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'roundRect' && shape.cornerRadius !== undefined) {
          return (
            <RoundedRect
              key={shape.id}
              id={shape.id}
              x={shape.x}
              y={shape.y}
              width={shape.width}
              height={shape.height}
              rotation={shape.rotation}
              fill={shape.fill}
              stroke={shape.stroke}
              strokeWidth={shape.strokeWidth}
              cornerRadius={shape.cornerRadius}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(w, h, r, x, y) => handleShapeTransformEnd(shape.id, w, h, r, x, y)}
            />
          )
        } else if (shape.type === 'path' && shape.points) {
          return (
            <Path
              key={shape.id}
              id={shape.id}
              points={shape.points}
              stroke={shape.stroke || '#3B82F6'}
              strokeWidth={shape.strokeWidth || 2}
              tension={shape.tension}
              closed={shape.closed}
              isSelected={isSelected}
              selectionColor={isSelected ? userColor : undefined}
              onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(shape.id, e.evt.shiftKey)}
              onDragStart={(x: number, y: number) => handleShapeDragStart(shape.id, x, y)}
              onDragEnd={(x: number, y: number) => handleShapeDragEnd(shape.id, x, y)}
              onTransformEnd={(pts: number[], x: number, y: number) => {
                updateShape(shape.id, { points: pts, x, y })
              }}
            />
          )
        }
        return null
      })}

      {}
      {isDrawingLine && lineStartPoint && linePreviewEnd && (
        <KonvaLine
          points={[lineStartPoint.x, lineStartPoint.y, linePreviewEnd.x, linePreviewEnd.y]}
          stroke="#6366F1"
          strokeWidth={2}
          lineCap="round"
          listening={false}
          opacity={0.7}
          dash={[5, 5]}
        />
      )}

      {}
      {isDrawingPath && currentPathPoints.length >= 2 && (
        <KonvaLine
          points={currentPathPoints}
          stroke="#6366F1"
          strokeWidth={2}
          tension={selectedTool === 'pen' ? 0.5 : 0}
          lineCap="round"
          lineJoin="round"
          listening={false}
          opacity={0.7}
        />
      )}

      {}
      {groups.map((group) => {
        const isSelected = selectedIds.has(group.id)
        const userColor = getUserColor()
        const bounds = calculateBounds(group.id, shapes)

        if (!bounds) return null

        const renderGroupMember = (shapeId: string) => {
          const shape = shapes.find((s) => s.id === shapeId)
          if (!shape) return null

          const relativeX = shape.x - bounds.x
          const relativeY = shape.y - bounds.y

          if (shape.type === 'rectangle') {
            return (
              <Rectangle
                key={shape.id}
                id={shape.id}
                x={relativeX}
                y={relativeY}
                width={shape.width}
                height={shape.height}
                rotation={shape.rotation}
                fill={shape.fill}
                stroke={shape.stroke}
                strokeWidth={shape.strokeWidth}
                isSelected={false}
                onSelect={() => {}}
                onDragStart={() => {}}
                onDragEnd={() => {}}
                onTransformEnd={() => {}}
              />
            )
          } else if (shape.type === 'circle') {
            return (
              <Circle
                key={shape.id}
                id={shape.id}
                x={relativeX}
                y={relativeY}
                width={shape.width}
                height={shape.height}
                rotation={shape.rotation}
                fill={shape.fill}
                stroke={shape.stroke}
                strokeWidth={shape.strokeWidth}
                isSelected={false}
                onSelect={() => {}}
                onDragStart={() => {}}
                onDragEnd={() => {}}
                onTransformEnd={() => {}}
              />
            )
          }
          return null
        }

        return (
          <Group
            key={group.id}
            id={group.id}
            x={bounds.x}
            y={bounds.y}
            width={bounds.width}
            height={bounds.height}
            rotation={group.rotation}
            isSelected={isSelected}
            selectionColor={isSelected ? userColor : undefined}
            locked={group.locked}
            visible={group.visible}
            onSelect={(e: Konva.KonvaEventObject<MouseEvent>) => handleShapeSelect(group.id, e.evt.shiftKey)}
            onDragStart={() => {
              dragStartPosRef.current = { x: bounds.x, y: bounds.y }
            }}
            onDragEnd={(x: number, y: number) => {
              if (dragStartPosRef.current) {
                const deltaX = x - dragStartPosRef.current.x
                const deltaY = y - dragStartPosRef.current.y

                group.memberIds.forEach((memberId) => {
                  const shape = shapes.find((s) => s.id === memberId)
                  if (shape) {
                    updateShape(memberId, {
                      x: shape.x + deltaX,
                      y: shape.y + deltaY,
                    })
                  }
                })

                dragStartPosRef.current = null
              }
            }}
          >
            {group.memberIds.map(renderGroupMember)}
          </Group>
        )
      })}
    </>
  )
}
</file>

<file path="src/components/canvas/TilemapCanvas.tsx">
import { useRef, useState, useCallback, useEffect } from 'react'
import { Stage, Layer } from 'react-konva'
import Konva from 'konva'
import type { ViewportTransform } from '../../types/canvas'
import type { TileMode, PaletteColor } from '../../types/tilemap'
import { useAuth } from '../../hooks/useAuth'
import { usePresence } from '../../hooks/usePresence'
import { useCanvasViewport } from '../../hooks/useCanvasViewport'
import { useTilemap } from '../../hooks/useTilemap'
import { coordToKey } from '../../types/tilemap'
import Cursor from '../Cursor'
import TilemapGrid from '../TilemapGrid'
import TileRenderer from '../TileRenderer'
import TilePalette from '../TilePalette'

interface TilemapCanvasProps {
  canvasId: string
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
  onZoomControlsReady?: (zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => void
}

const DEFAULT_PALETTE: PaletteColor[] = [
  { type: 'grass', color: '#4ade80', name: 'Grass' },
  { type: 'dirt', color: '#92400e', name: 'Dirt' },
  { type: 'stone', color: '#6b7280', name: 'Stone' },
  { type: 'water', color: '#3b82f6', name: 'Water' },
  { type: 'sand', color: '#fbbf24', name: 'Sand' },
  { type: 'lava', color: '#ef4444', name: 'Lava' },
  { type: 'wood', color: '#78350f', name: 'Wood' },
  { type: 'metal', color: '#374151', name: 'Metal' },
  { type: 'ice', color: '#bfdbfe', name: 'Ice' },
]

export default function TilemapCanvas({
  canvasId,
  onViewportChange,
  onZoomChange,
  onZoomControlsReady,
}: TilemapCanvasProps) {
  const stageRef = useRef<Konva.Stage>(null)


  const [tileMode, setTileMode] = useState<TileMode>('stamp')
  const [selectedPaletteIndex, setSelectedPaletteIndex] = useState(0)
  const [tileSize, setTileSize] = useState(16)
  const [showGrid, setShowGrid] = useState(true)
  const [isPainting, setIsPainting] = useState(false)
  const [hoverTile, setHoverTile] = useState<{ x: number; y: number } | null>(null)
  const [isSpacePressed, setIsSpacePressed] = useState(false)
  const [lastPanPosition, setLastPanPosition] = useState<{ x: number; y: number } | null>(null)

  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight


  const {
    viewport,
    setViewport,
    handleWheel: baseHandleWheel,
    handleDragEnd,
    handleZoomIn,
    handleZoomOut,
    handleZoomReset,
    handleZoomFit,
  } = useCanvasViewport({
    containerWidth,
    containerHeight,
    onViewportChange,
    onZoomChange,
  })


  const { user } = useAuth()
  const { otherUsers, updateCursorPosition } = usePresence({
    userId: user?.uid || '',
    userName: user?.displayName || user?.email || 'Anonymous',
    canvasId: canvasId,
  })


  const {
    tiles,
    meta,
    isConnected,
    setTile,
    eraseTile,
    fillTiles,
    loadVisibleChunks,
  } = useTilemap({
    canvasId,
    userId: user?.uid || '',
  })

  // Load visible chunks whenever viewport changes
  useEffect(() => {
    if (!meta) return

    // Calculate viewport in canvas coordinates
    const viewportX = -viewport.x / viewport.scale
    const viewportY = -viewport.y / viewport.scale
    const viewportWidth = containerWidth / viewport.scale
    const viewportHeight = containerHeight / viewport.scale

    loadVisibleChunks({
      x: viewportX,
      y: viewportY,
      width: viewportWidth,
      height: viewportHeight,
    })
  }, [viewport.x, viewport.y, viewport.scale, containerWidth, containerHeight, meta, loadVisibleChunks])

  // Expose zoom controls - only on mount to avoid render-during-render
  useEffect(() => {
    if (onZoomControlsReady) {
      onZoomControlsReady(handleZoomIn, handleZoomOut, handleZoomReset, handleZoomFit)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Get current palette selection
  const selectedPalette = DEFAULT_PALETTE[selectedPaletteIndex]

  // Convert screen coordinates to tile coordinates
  const screenToTileCoords = useCallback((screenX: number, screenY: number): { x: number; y: number } => {
    const canvasX = (screenX - viewport.x) / viewport.scale
    const canvasY = (screenY - viewport.y) / viewport.scale
    const tileX = Math.floor(canvasX / tileSize)
    const tileY = Math.floor(canvasY / tileSize)
    return { x: tileX, y: tileY }
  }, [viewport, tileSize])

  // Handle painting/erasing tiles
  const paintTileAt = useCallback((tileX: number, tileY: number) => {
    if (tileMode === 'stamp') {
      setTile(tileX, tileY, {
        type: selectedPalette.type,
        color: selectedPalette.color,
      })
    } else if (tileMode === 'erase') {
      eraseTile(tileX, tileY)
    } else if (tileMode === 'fill') {

      const targetTileKey = coordToKey(tileX, tileY)
      const targetTile = tiles.get(targetTileKey)
      const targetType = targetTile?.type || 'empty'


      fillTiles(tileX, tileY, targetType, selectedPalette.type, selectedPalette.color)
    } else if (tileMode === 'pick') {

      const tileKey = coordToKey(tileX, tileY)
      const tile = tiles.get(tileKey)
      if (tile) {

        const paletteIndex = DEFAULT_PALETTE.findIndex(p => p.type === tile.type)
        if (paletteIndex !== -1) {
          setSelectedPaletteIndex(paletteIndex)
        }
      }

      setTileMode('stamp')
    }
  }, [tileMode, selectedPalette, setTile, eraseTile, fillTiles, tiles])


  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {

      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return
      }


      if (e.key === ' ' && !isSpacePressed) {
        e.preventDefault()
        setIsSpacePressed(true)
        return
      }


      if (e.key >= '1' && e.key <= '9') {
        const index = parseInt(e.key) - 1
        if (index < DEFAULT_PALETTE.length) {
          e.preventDefault()
          setSelectedPaletteIndex(index)
        }
      }


      if (e.key === 'b' || e.key === 'B') {
        e.preventDefault()
        setTileMode('stamp')
      }


      if (e.key === 'e' || e.key === 'E') {
        e.preventDefault()
        setTileMode('erase')
      }


      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault()
        setTileMode('fill')
      }


      if (e.key === 'i' || e.key === 'I') {
        e.preventDefault()
        setTileMode('pick')
      }


      if (e.key === 'g' || e.key === 'G') {
        e.preventDefault()
        setShowGrid(!showGrid)
      }
    }

    const handleKeyUp = (e: KeyboardEvent) => {

      if (e.key === ' ') {
        e.preventDefault()
        setIsSpacePressed(false)
        setLastPanPosition(null)
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)
    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
    }
  }, [showGrid, isSpacePressed])


  const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
    const stage = stageRef.current
    if (stage) {
      baseHandleWheel(e, stage)
    }
  }, [baseHandleWheel])

  const handleStageMouseDown = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    const stage = stageRef.current
    if (!stage) return


    if (e.evt.button !== 0) return

    const pointer = stage.getPointerPosition()
    if (!pointer) return


    if (isSpacePressed) {
      setLastPanPosition({ x: pointer.x, y: pointer.y })
      return
    }


    const { x: tileX, y: tileY } = screenToTileCoords(pointer.x, pointer.y)
    setIsPainting(true)
    paintTileAt(tileX, tileY)
  }, [screenToTileCoords, paintTileAt, isSpacePressed])

  const handleStageMouseMove = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    const stage = stageRef.current
    if (!stage) return

    const pointer = stage.getPointerPosition()
    if (!pointer) return


    if (isSpacePressed) {
      if (lastPanPosition) {

        const dx = pointer.x - lastPanPosition.x
        const dy = pointer.y - lastPanPosition.y

        setViewport(prev => ({
          ...prev,
          x: prev.x + dx,
          y: prev.y + dy
        }))
      }

      setLastPanPosition({ x: pointer.x, y: pointer.y })
      return
    }

    const { x: tileX, y: tileY } = screenToTileCoords(pointer.x, pointer.y)


    setHoverTile({ x: tileX, y: tileY })


    if (isPainting && tileMode !== 'fill') {
      paintTileAt(tileX, tileY)
    }


    const canvasX = (pointer.x - viewport.x) / viewport.scale
    const canvasY = (pointer.y - viewport.y) / viewport.scale
    updateCursorPosition(canvasX, canvasY)
  }, [screenToTileCoords, isPainting, tileMode, paintTileAt, viewport, updateCursorPosition, isSpacePressed, lastPanPosition, setViewport])

  const handleStageMouseUp = useCallback(() => {
    setIsPainting(false)
    setLastPanPosition(null)
  }, [])

  const handleStageMouseLeave = useCallback(() => {
    setIsPainting(false)
    setHoverTile(null)
  }, [])


  const handleContextMenu = useCallback((e: Konva.KonvaEventObject<PointerEvent>) => {
    e.evt.preventDefault()

    const stage = stageRef.current
    if (!stage) return

    const pointer = stage.getPointerPosition()
    if (!pointer) return

    const { x: tileX, y: tileY } = screenToTileCoords(pointer.x, pointer.y)
    eraseTile(tileX, tileY)
  }, [screenToTileCoords, eraseTile])

  return (
    <div className="w-full h-full bg-gray-100 overflow-hidden relative flex flex-row">
      {}
      <TilePalette
        palette={DEFAULT_PALETTE}
        selectedIndex={selectedPaletteIndex}
        onSelectIndex={setSelectedPaletteIndex}
        mode={tileMode}
        onModeChange={setTileMode}
        tileSize={tileSize}
        onTileSizeChange={setTileSize}
        tileCount={tiles.size}
        cursorPosition={hoverTile || undefined}
        showGrid={showGrid}
        onToggleGrid={() => setShowGrid(!showGrid)}
      />

      <div className="flex-1 relative" style={{ cursor: lastPanPosition ? 'grabbing' : (isSpacePressed ? 'grab' : 'default') }}>
        <Stage
          ref={stageRef}
          width={containerWidth}
          height={containerHeight}
          draggable={false}
          onWheel={handleWheel}
          onMouseDown={handleStageMouseDown}
          onMouseMove={handleStageMouseMove}
          onMouseUp={handleStageMouseUp}
          onMouseLeave={handleStageMouseLeave}
          onContextMenu={handleContextMenu}
          x={viewport.x}
          y={viewport.y}
          scaleX={viewport.scale}
          scaleY={viewport.scale}
        >
          {}
          <TilemapGrid
            tileSize={tileSize}
            viewportX={-viewport.x / viewport.scale}
            viewportY={-viewport.y / viewport.scale}
            viewportWidth={containerWidth / viewport.scale}
            viewportHeight={containerHeight / viewport.scale}
            visible={showGrid}
          />

          {}
          <TileRenderer
            tiles={tiles}
            tileSize={tileSize}
            viewportX={-viewport.x / viewport.scale}
            viewportY={-viewport.y / viewport.scale}
            viewportWidth={containerWidth / viewport.scale}
            viewportHeight={containerHeight / viewport.scale}
            previewTile={hoverTile && tileMode === 'stamp' && !isPainting ? {
              x: hoverTile.x,
              y: hoverTile.y,
              tile: { type: selectedPalette.type, color: selectedPalette.color }
            } : null}
            showPreview={tileMode === 'stamp' && !isPainting}
          />

          {}
          <Layer listening={false}>
            {Array.from(otherUsers.entries()).map(([userId, presence]) => (
              <Cursor
                key={userId}
                x={presence.c[0]}
                y={presence.c[1]}
                userName={presence.n}
                color={presence.cl}
              />
            ))}
          </Layer>
        </Stage>
      </div>
    </div>
  )
}
</file>

<file path="src/components/CanvasCard.tsx">
import { useState, useRef, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import type { CanvasMetadata } from '../services/canvasManager'
import { Tooltip } from './Tooltip'

interface CanvasCardProps {
  canvas: CanvasMetadata
  onDelete: (canvasId: string) => void
  onDuplicate: (canvasId: string) => void
  onRename: (canvasId: string, newName: string) => void
}




function getRelativeTime(timestamp: number): string {
  const now = Date.now()
  const diff = now - timestamp
  const seconds = Math.floor(diff / 1000)
  const minutes = Math.floor(seconds / 60)
  const hours = Math.floor(minutes / 60)
  const days = Math.floor(hours / 24)

  if (seconds < 60) return 'Just now'
  if (minutes < 60) return `${minutes} ${minutes === 1 ? 'min' : 'mins'} ago`
  if (hours < 24) return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`
  if (days < 30) return `${days} ${days === 1 ? 'day' : 'days'} ago`

  return new Date(timestamp).toLocaleDateString()
}




export function CanvasCard({ canvas, onDelete, onDuplicate, onRename }: CanvasCardProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [editedName, setEditedName] = useState(canvas.name)
  const [showMenu, setShowMenu] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)
  const navigate = useNavigate()


  useEffect(() => {
    if (!showMenu) return

    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setShowMenu(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [showMenu])

  const handleCardClick = () => {
    if (!isEditing) {
      navigate(`/canvas/${canvas.id}`)
    }
  }

  const handleNameDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setIsEditing(true)
    setEditedName(canvas.name)
  }

  const handleNameSubmit = () => {
    if (editedName.trim() && editedName !== canvas.name) {
      onRename(canvas.id, editedName.trim())
    }
    setIsEditing(false)
  }

  const handleNameCancel = () => {
    setEditedName(canvas.name)
    setIsEditing(false)
  }

  const handleMenuClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowMenu(!showMenu)
  }

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (confirm(`Delete "${canvas.name}"? This cannot be undone.`)) {
      onDelete(canvas.id)
    }
    setShowMenu(false)
  }

  const handleDuplicate = (e: React.MouseEvent) => {
    e.stopPropagation()
    onDuplicate(canvas.id)
    setShowMenu(false)
  }

  const handleRename = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowMenu(false)
    setIsEditing(true)
  }

  return (
    <div
      className="group bg-white rounded-lg border border-neutral-200 hover:border-neutral-300 hover:shadow-medium transition-all duration-150 cursor-pointer overflow-hidden"
      onClick={handleCardClick}
    >
      {}
      <div className="relative w-full h-[180px] bg-neutral-100 overflow-hidden">
        {canvas.thumbnail ? (
          <img
            src={canvas.thumbnail}
            alt={canvas.name}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            <span className="text-neutral-400 text-4xl">📄</span>
          </div>
        )}

        {}
        <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
          <Tooltip content="More options" side="left">
            <button
              onClick={handleMenuClick}
              className="w-8 h-8 bg-white rounded-lg shadow-medium flex items-center justify-center hover:bg-neutral-50 transition-colors"
            >
              <span className="text-neutral-600">•••</span>
            </button>
          </Tooltip>

          {}
          {showMenu && (
            <div
              ref={menuRef}
              className="absolute right-0 top-10 bg-white border border-neutral-200 rounded-lg shadow-hard py-1 z-10 min-w-[140px]"
            >
              <button
                onClick={handleRename}
                className="w-full text-left px-4 py-2 text-sm hover:bg-neutral-100 text-neutral-700"
              >
                Rename
              </button>
              <button
                onClick={handleDuplicate}
                className="w-full text-left px-4 py-2 text-sm hover:bg-neutral-100 text-neutral-700"
              >
                Duplicate
              </button>
              <div className="border-t border-neutral-200 my-1" />
              <button
                onClick={handleDelete}
                className="w-full text-left px-4 py-2 text-sm hover:bg-red-50 text-red-600"
              >
                Delete
              </button>
            </div>
          )}
        </div>
      </div>

      {}
      <div className="p-4">
        {isEditing ? (
          <input
            type="text"
            value={editedName}
            onChange={(e) => setEditedName(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleNameSubmit()
              if (e.key === 'Escape') handleNameCancel()
            }}
            onBlur={handleNameSubmit}
            onClick={(e) => e.stopPropagation()}
            autoFocus
            className="w-full text-sm font-semibold text-neutral-900 bg-neutral-100 px-2 py-1 rounded border-2 border-primary-500 focus:outline-none"
          />
        ) : (
          <h3
            onDoubleClick={handleNameDoubleClick}
            className="text-sm font-semibold text-neutral-900 truncate mb-1"
          >
            {canvas.name}
          </h3>
        )}
        <p className="text-xs text-neutral-500">
          Edited {getRelativeTime(canvas.updatedAt)}
        </p>
      </div>
    </div>
  )
}
</file>

<file path="src/components/ColorPicker.tsx">
import React, { useState, useEffect } from 'react'







interface EyeDropperResult {
  sRGBHex: string
}

interface EyeDropperAPI {
  open: () => Promise<EyeDropperResult>
}

declare global {
  interface Window {
    EyeDropper?: new () => EyeDropperAPI
  }
}

interface ColorPickerProps {
  value: string
  onChange: (color: string) => void
  label: string
  recentColors?: string[]
  showOpacity?: boolean
  onRequestCanvasSample?: () => void
}


const PRESET_COLORS = [

  '#FFFFFFFF', '#F3F4F6FF', '#E5E7EBFF', '#D1D5DBFF', '#9CA3AFFF',
  '#6B7280FF', '#4B5563FF', '#374151FF', '#1F2937FF', '#000000FF',


  '#FEE2E2FF', '#FECACAFF', '#FCA5A5FF', '#F87171FF', '#EF4444FF',
  '#DC2626FF', '#B91C1CFF', '#991B1BFF', '#7F1D1DFF', '#450A0AFF',


  '#FFEDD5FF', '#FED7AAFF', '#FDBA74FF', '#FB923CFF', '#F97316FF',
  '#EA580CFF', '#C2410CFF', '#9A3412FF', '#7C2D12FF', '#431407FF',


  '#FEF3C7FF', '#FDE68AFF', '#FCD34DFF', '#FBBF24FF', '#F59E0BFF',
  '#D97706FF', '#B45309FF', '#92400EFF', '#78350FFF', '#451A03FF',


  '#D1FAE5FF', '#A7F3D0FF', '#6EE7B7FF', '#34D399FF', '#10B981FF',
  '#059669FF', '#047857FF', '#065F46FF', '#064E3BFF', '#022C22FF',


  '#DBEAFEFF', '#BFDBFEFF', '#93C5FDFF', '#60A5FAFF', '#3B82F6FF',
  '#2563EBFF', '#1D4ED8FF', '#1E40AFFF', '#1E3A8AFF', '#172554FF',


  '#F3E8FFFF', '#E9D5FFFF', '#D8B4FEFF', '#C084FCFF', '#A855F7FF',
  '#9333EAFF', '#7E22CEFF', '#6B21A8FF', '#581C87FF', '#3B0764FF',


  '#FCE7F3FF', '#FBCFE8FF', '#F9A8D4FF', '#F472B6FF', '#EC4899FF',
  '#DB2777FF', '#BE185DFF', '#9D174DFF', '#831843FF', '#500724FF',
]


const COLOR_NAMES: Record<string, string> = {
  '#FFFFFFFF': 'White',
  '#F3F4F6FF': 'Gray 100',
  '#E5E7EBFF': 'Gray 200',
  '#D1D5DBFF': 'Gray 300',
  '#9CA3AFFF': 'Gray 400',
  '#6B7280FF': 'Gray 500',
  '#4B5563FF': 'Gray 600',
  '#374151FF': 'Gray 700',
  '#1F2937FF': 'Gray 800',
  '#000000FF': 'Black',
  '#FEE2E2FF': 'Red 100',
  '#EF4444FF': 'Red 500',
  '#450A0AFF': 'Red 950',
  '#FFEDD5FF': 'Orange 100',
  '#F97316FF': 'Orange 500',
  '#431407FF': 'Orange 950',
  '#FEF3C7FF': 'Yellow 100',
  '#F59E0BFF': 'Yellow 500',
  '#451A03FF': 'Yellow 950',
  '#D1FAE5FF': 'Green 100',
  '#10B981FF': 'Green 500',
  '#022C22FF': 'Green 950',
  '#DBEAFEFF': 'Blue 100',
  '#3B82F6FF': 'Blue 500',
  '#172554FF': 'Blue 950',
  '#F3E8FFFF': 'Purple 100',
  '#A855F7FF': 'Purple 500',
  '#3B0764FF': 'Purple 950',
  '#FCE7F3FF': 'Pink 100',
  '#EC4899FF': 'Pink 500',
  '#500724FF': 'Pink 950',
}

export const ColorPicker: React.FC<ColorPickerProps> = ({
  value,
  onChange,
  label,
  recentColors = [],
  showOpacity = true,
  onRequestCanvasSample,
}) => {
  const [hexInput, setHexInput] = useState(value.slice(0, 7))
  const [opacity, setOpacity] = useState(
    parseInt(value.slice(7, 9) || 'FF', 16) / 255
  )
  const [isPickingColor, setIsPickingColor] = useState(false)


  const supportsEyeDropper = typeof window !== 'undefined' && 'EyeDropper' in window


  useEffect(() => {
    setHexInput(value.slice(0, 7))
    setOpacity(parseInt(value.slice(7, 9) || 'FF', 16) / 255)
  }, [value])

  const handleHexInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let input = e.target.value
    setHexInput(input)


    if (/^#[0-9A-Fa-f]{6}$/.test(input)) {
      const alpha = Math.round(opacity * 255)
        .toString(16)
        .padStart(2, '0')
        .toUpperCase()
      onChange(input + alpha)
    }
  }

  const handleOpacityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newOpacity = parseFloat(e.target.value)
    setOpacity(newOpacity)

    const alpha = Math.round(newOpacity * 255)
      .toString(16)
      .padStart(2, '0')
      .toUpperCase()
    onChange(hexInput + alpha)
  }

  const handlePresetClick = (color: string) => {
    setHexInput(color.slice(0, 7))
    setOpacity(parseInt(color.slice(7, 9) || 'FF', 16) / 255)
    onChange(color)
  }


  const handleEyedropper = async () => {
    if (!window.EyeDropper) {

      if (onRequestCanvasSample) {
        onRequestCanvasSample()
      } else {
        alert('Eyedropper not supported in this browser. Try Chrome or Edge.')
      }
      return
    }

    try {
      setIsPickingColor(true)
      const eyeDropper = new window.EyeDropper()
      const result = await eyeDropper.open()


      const pickedHex = result.sRGBHex.toUpperCase()
      const alpha = Math.round(opacity * 255)
        .toString(16)
        .padStart(2, '0')
        .toUpperCase()

      const colorWithAlpha = pickedHex + alpha
      setHexInput(pickedHex)
      onChange(colorWithAlpha)
    } catch (error) {

      console.log('Eyedropper cancelled:', error)
    } finally {
      setIsPickingColor(false)
    }
  }

  return (
    <div className="space-y-3">
      {}
      <div className="text-sm font-medium text-gray-700">{label}</div>

      {}
      <div className="flex items-center gap-2">
        <div
          className="w-12 h-12 rounded border-2 border-gray-300 shadow-sm"
          style={{
            backgroundColor: value,
            backgroundImage:
              'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',
            backgroundSize: '10px 10px',
            backgroundPosition: '0 0, 0 5px, 5px -5px, -5px 0px',
          }}
        />
        <div className="flex-1 flex gap-1">
          <input
            type="text"
            value={hexInput}
            onChange={handleHexInputChange}
            placeholder="#000000"
            className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            maxLength={7}
          />
          <button
            onClick={handleEyedropper}
            disabled={isPickingColor}
            className={`px-2 py-1 border rounded transition-colors ${
              isPickingColor
                ? 'bg-gray-100 text-gray-400 border-gray-300 cursor-wait'
                : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50 hover:border-blue-500'
            }`}
            title={
              supportsEyeDropper
                ? 'Pick color from screen'
                : 'Pick color from canvas (fallback)'
            }
          >
            {isPickingColor ? (
              <span className="text-sm">⏳</span>
            ) : (
              <svg
                className="w-4 h-4"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"
                />
              </svg>
            )}
          </button>
        </div>
      </div>

      {}
      {showOpacity && (
        <div>
          <div className="flex justify-between text-xs text-gray-600 mb-1">
            <span>Opacity</span>
            <span>{Math.round(opacity * 100)}%</span>
          </div>
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={opacity}
            onChange={handleOpacityChange}
            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
      )}

      {}
      <div>
        <div className="text-xs text-gray-600 mb-2">Presets (80 colors)</div>
        <div
          className="grid grid-cols-10 gap-1 max-h-60 overflow-y-auto pr-1"
          style={{ scrollbarWidth: 'thin' }}
        >
          {PRESET_COLORS.map((color, index) => (
            <button
              key={`${color}-${index}`}
              onClick={() => handlePresetClick(color)}
              className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 ${
                value.toUpperCase() === color.toUpperCase()
                  ? 'border-blue-500 ring-2 ring-blue-200'
                  : 'border-gray-300'
              }`}
              style={{
                backgroundColor: color,
              }}
              title={COLOR_NAMES[color] || color}
            />
          ))}
        </div>
      </div>

      {}
      <div>
        <div className="text-xs text-gray-600 mb-2">Recent Colors</div>
        {recentColors.length > 0 ? (
          <div className="flex gap-1">
            {recentColors.map((color, index) => (
              <button
                key={`${color}-${index}`}
                onClick={() => handlePresetClick(color)}
                className={`w-6 h-6 rounded border-2 transition-all hover:scale-110 ${
                  value.toUpperCase() === color.toUpperCase()
                    ? 'border-blue-500 ring-2 ring-blue-200'
                    : 'border-gray-300'
                }`}
                style={{
                  backgroundColor: color,
                  backgroundImage:
                    'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',
                  backgroundSize: '10px 10px',
                  backgroundPosition: '0 0, 0 5px, 5px -5px, -5px 0px',
                }}
                title={color}
              />
            ))}
          </div>
        ) : (
          <div className="text-xs text-gray-400 italic">No recent colors</div>
        )}</div>
    </div>
  )
}
</file>

<file path="src/components/ContextMenu.tsx">
import { useEffect, useRef, useState } from 'react'
import type { AlignmentType } from '../services/alignment'

interface ContextMenuProps {
  x: number
  y: number
  visible: boolean
  onClose: () => void
  hasSelection: boolean
  canCopy: boolean
  canPaste: boolean
  selectedCount: number
  onBringToFront: () => void
  onBringForward: () => void
  onSendBackward: () => void
  onSendToBack: () => void
  onCopy?: () => void
  onPaste?: () => void
  onDuplicate?: () => void
  onDelete?: () => void

  onAlign?: (type: AlignmentType) => void
  onDistributeHorizontally?: () => void
  onDistributeVertically?: () => void
  onCenterInCanvas?: () => void
}





export function ContextMenu({
  x,
  y,
  visible,
  onClose,
  hasSelection,
  canCopy,
  canPaste,
  selectedCount,
  onBringToFront,
  onBringForward,
  onSendBackward,
  onSendToBack,
  onCopy,
  onPaste,
  onDuplicate,
  onDelete,
  onAlign,
  onDistributeHorizontally,
  onDistributeVertically,
  onCenterInCanvas,
}: ContextMenuProps) {
  const menuRef = useRef<HTMLDivElement>(null)
  const [showAlignSubmenu, setShowAlignSubmenu] = useState(false)
  const [showDistributeSubmenu, setShowDistributeSubmenu] = useState(false)


  useEffect(() => {
    if (!visible) return

    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        onClose()
      }
    }


    setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside)
    }, 0)

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [visible, onClose])


  useEffect(() => {
    if (!visible) return

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    document.addEventListener('keydown', handleEscape)
    return () => {
      document.removeEventListener('keydown', handleEscape)
    }
  }, [visible, onClose])

  if (!visible) return null

  const handleMenuAction = (action: () => void) => {
    action()
    onClose()
  }

  const canAlign = selectedCount >= 2
  const canDistribute = selectedCount >= 3

  return (
    <div
      ref={menuRef}
      className="fixed bg-white border border-gray-300 rounded-md py-0.5 z-[9999]"
      style={{
        left: x,
        top: y,
        boxShadow: '0 10px 40px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15)',
      }}
    >
      {}
      {canAlign && onAlign && (
        <>
          <div className="relative">
            <button
              className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
              onMouseEnter={() => setShowAlignSubmenu(true)}
              onMouseLeave={() => setShowAlignSubmenu(false)}
            >
              <span>Align</span>
              <span className="text-neutral-400">›</span>
            </button>
            {showAlignSubmenu && (
              <div
                className="absolute left-full top-0 bg-white border border-gray-300 rounded-md py-0.5 ml-1"
                style={{
                  boxShadow: '0 10px 40px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15)',
                }}
                onMouseEnter={() => setShowAlignSubmenu(true)}
                onMouseLeave={() => setShowAlignSubmenu(false)}
              >
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('left'))}
                >
                  Left
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('center'))}
                >
                  Center
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('right'))}
                >
                  Right
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('top'))}
                >
                  Top
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('middle'))}
                >
                  Middle
                </button>
                <button
                  className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                  onClick={() => handleMenuAction(() => onAlign('bottom'))}
                >
                  Bottom
                </button>
              </div>
            )}
          </div>
        </>
      )}

      {}
      {canDistribute && onDistributeHorizontally && onDistributeVertically && (
        <div className="relative">
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
            onMouseEnter={() => setShowDistributeSubmenu(true)}
            onMouseLeave={() => setShowDistributeSubmenu(false)}
          >
            <span>Distribute</span>
            <span className="text-neutral-400">›</span>
          </button>
          {showDistributeSubmenu && (
            <div
              className="absolute left-full top-0 bg-white border border-gray-300 rounded-md py-0.5 ml-1"
              style={{
                boxShadow: '0 10px 40px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15)',
              }}
              onMouseEnter={() => setShowDistributeSubmenu(true)}
              onMouseLeave={() => setShowDistributeSubmenu(false)}
            >
              <button
                className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                onClick={() => handleMenuAction(onDistributeHorizontally)}
              >
                Horizontally
              </button>
              <button
                className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
                onClick={() => handleMenuAction(onDistributeVertically)}
              >
                Vertically
              </button>
            </div>
          )}
        </div>
      )}

      {}
      {hasSelection && onCenterInCanvas && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
          onClick={() => handleMenuAction(onCenterInCanvas)}
        >
          Center in Canvas
        </button>
      )}

      {}
      {(canAlign || canDistribute || (hasSelection && onCenterInCanvas)) && (
        <div className="border-t border-neutral-200" />
      )}

      {}
      {hasSelection && (
        <>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onBringToFront)}
          >
            Bring to Front
          </button>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onBringForward)}
          >
            Bring Forward
          </button>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onSendBackward)}
          >
            Send Backward
          </button>
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 whitespace-nowrap"
            onClick={() => handleMenuAction(onSendToBack)}
          >
            Send to Back
          </button>
          <div className="border-t border-neutral-200" />
        </>
      )}

      {}
      {canCopy && onCopy && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
          onClick={() => handleMenuAction(onCopy)}
        >
          <span>Copy</span>
          <span className="text-neutral-400">⌘C</span>
        </button>
      )}
      {canPaste && onPaste && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
          onClick={() => handleMenuAction(onPaste)}
        >
          <span>Paste</span>
          <span className="text-neutral-400">⌘V</span>
        </button>
      )}
      {canCopy && onDuplicate && (
        <button
          className="w-full text-left px-2 py-1 text-xs hover:bg-neutral-100 text-neutral-700 flex items-center justify-between gap-2"
          onClick={() => handleMenuAction(onDuplicate)}
        >
          <span>Duplicate</span>
          <span className="text-neutral-400">⌘D</span>
        </button>
      )}

      {}
      {hasSelection && onDelete && (
        <>
          <div className="border-t border-neutral-200" />
          <button
            className="w-full text-left px-2 py-1 text-xs hover:bg-red-50 text-red-600 flex items-center justify-between gap-2"
            onClick={() => handleMenuAction(onDelete)}
          >
            <span>Delete</span>
            <span className="text-red-400">⌫</span>
          </button>
        </>
      )}
    </div>
  )
}
</file>

<file path="src/components/Cursor.tsx">
import { Group, Path, Text, Rect } from 'react-konva'

interface CursorProps {
  x: number
  y: number
  userName: string
  color: string
}






export default function Cursor({ x, y, userName, color }: CursorProps) {

  const arrowPath =
    'M 0 0 L 0 18 L 5 13 L 9 20 L 11 19 L 7 12 L 13 11 Z'


  const textWidth = userName.length * 6.5 + 8
  const textHeight = 19

  return (
    <Group x={x} y={y}>
      {}
      <Path
        data={arrowPath}
        fill={color}
        stroke="#FFFFFF"
        strokeWidth={1}
        shadowColor="rgba(0, 0, 0, 0.2)"
        shadowBlur={2}
        shadowOffsetX={1}
        shadowOffsetY={1}
      />

      {}
      <Rect
        x={15}
        y={3}
        width={textWidth}
        height={textHeight}
        fill={color}
        cornerRadius={4}
        shadowColor="rgba(0, 0, 0, 0.2)"
        shadowBlur={2}
        shadowOffsetX={1}
        shadowOffsetY={1}
      />

      {}
      <Text
        x={19}
        y={6}
        text={userName}
        fontSize={11}
        fontFamily="Inter, system-ui, sans-serif"
        fill="#FFFFFF"
        fontStyle="normal"
      />
    </Group>
  )
}
</file>

<file path="src/components/ErrorBoundary.tsx">
import { Component, type ReactNode, type ErrorInfo } from 'react'

interface ErrorBoundaryProps {
  children: ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
}





class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    }
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {

    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {

    console.error('ErrorBoundary caught an error:', error, errorInfo)
    this.setState({
      error,
      errorInfo,
    })
  }

  handleReset = (): void => {

    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    })
    window.location.reload()
  }

  render(): ReactNode {
    if (this.state.hasError) {

      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-100 p-4">
          <div className="max-w-2xl w-full bg-white rounded-lg shadow-lg p-8">
            <div className="flex items-center justify-center mb-6">
              <svg
                className="h-16 w-16 text-red-500"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                />
              </svg>
            </div>

            <h1 className="text-2xl font-bold text-gray-900 text-center mb-4">
              Oops! Something went wrong
            </h1>

            <p className="text-gray-600 text-center mb-6">
              We encountered an unexpected error. Don't worry, your work is saved
              in Firebase. Try refreshing the page to continue.
            </p>

            {}
            {import.meta.env.DEV && this.state.error && (
              <details className="mb-6 p-4 bg-gray-50 rounded border border-gray-200">
                <summary className="cursor-pointer font-semibold text-gray-700 mb-2">
                  Error Details (Development Only)
                </summary>
                <div className="text-sm">
                  <p className="font-mono text-red-600 mb-2">
                    {this.state.error.toString()}
                  </p>
                  {this.state.errorInfo && (
                    <pre className="overflow-auto text-xs text-gray-700 bg-white p-2 rounded">
                      {this.state.errorInfo.componentStack}
                    </pre>
                  )}
                </div>
              </details>
            )}

            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <button
                onClick={this.handleReset}
                className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Reload Application
              </button>
              <a
                href="/"
                className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium text-center"
              >
                Go to Home
              </a>
            </div>

            <div className="mt-8 pt-6 border-t border-gray-200">
              <p className="text-sm text-gray-500 text-center">
                If this problem persists, please try:
              </p>
              <ul className="mt-2 text-sm text-gray-600 space-y-1">
                <li className="flex items-center justify-center">
                  <span className="mr-2">•</span>
                  Clearing your browser cache and cookies
                </li>
                <li className="flex items-center justify-center">
                  <span className="mr-2">•</span>
                  Using a different browser
                </li>
                <li className="flex items-center justify-center">
                  <span className="mr-2">•</span>
                  Checking your internet connection
                </li>
              </ul>
            </div>
          </div>
        </div>
      )
    }


    return this.props.children
  }
}

export default ErrorBoundary
</file>

<file path="src/components/Group.tsx">
import { useRef, useEffect } from 'react'
import { Group as KonvaGroup, Rect } from 'react-konva'
import type Konva from 'konva'

interface GroupProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  isSelected: boolean
  selectionColor?: string
  locked?: boolean
  visible?: boolean
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  children: React.ReactNode
}






export default function Group({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  isSelected,
  selectionColor = '#6366F1',
  locked = false,
  visible = true,
  onSelect,
  onDragStart,
  onDragEnd,
  children,
}: GroupProps) {
  const groupRef = useRef<Konva.Group>(null)

  useEffect(() => {
    if (groupRef.current) {
      groupRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  if (!visible) {
    return null
  }

  return (
    <KonvaGroup
      ref={groupRef}
      x={x}
      y={y}
      rotation={rotation}
      draggable={!locked}
      onClick={onSelect}
      onTap={onSelect}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      {}
      {children}

      {}
      {isSelected && (
        <Rect
          x={0}
          y={0}
          width={width}
          height={height}
          stroke={selectionColor}
          strokeWidth={2}
          dash={[10, 5]}
          fill="transparent"
          listening={false}
        />
      )}

      {}
      {locked && (
        <Rect
          x={width - 20}
          y={-20}
          width={16}
          height={16}
          fill="#EF4444"
          cornerRadius={2}
          listening={false}
        />
      )}
    </KonvaGroup>
  )
}
</file>

<file path="src/components/KeyboardShortcuts.tsx">
import { useEffect } from 'react'
import { getShortcutsByCategory, formatShortcut } from '../constants/shortcuts'

interface KeyboardShortcutsProps {
  visible: boolean
  onClose: () => void
}





export function KeyboardShortcuts({ visible, onClose }: KeyboardShortcutsProps) {

  useEffect(() => {
    if (!visible) return

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [visible, onClose])

  if (!visible) return null

  const shortcutsByCategory = getShortcutsByCategory()

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]">
      {}
      <div className="bg-white rounded-lg shadow-hard max-w-3xl w-full max-h-[80vh] overflow-hidden">
        {}
        <div className="flex items-center justify-between px-6 py-4 border-b border-neutral-200">
          <h2 className="text-lg font-semibold text-neutral-900">
            Keyboard Shortcuts
          </h2>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center rounded hover:bg-neutral-100 transition-colors"
          >
            <span className="text-neutral-500 text-xl">×</span>
          </button>
        </div>

        {}
        <div className="overflow-y-auto max-h-[calc(80vh-5rem)] px-6 py-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
            {Object.entries(shortcutsByCategory).map(([category, shortcuts]) => (
              <div key={category}>
                <h3 className="text-sm font-semibold text-neutral-700 mb-3">
                  {category}
                </h3>
                <div className="space-y-2">
                  {shortcuts.map((shortcut, index) => (
                    <div
                      key={`${shortcut.action}-${index}`}
                      className="flex items-center justify-between text-sm"
                    >
                      <span className="text-neutral-600">
                        {shortcut.description}
                      </span>
                      <kbd className="px-2 py-1 bg-neutral-100 border border-neutral-300 rounded text-neutral-700 font-mono text-xs">
                        {formatShortcut(shortcut)}
                      </kbd>
                    </div>
                  ))}
                </div>
              </div>
            ))}
          </div>
        </div>

        {}
        <div className="px-6 py-4 border-t border-neutral-200 bg-neutral-50">
          <p className="text-xs text-neutral-500 text-center">
            Press <kbd className="px-1.5 py-0.5 bg-white border border-neutral-300 rounded text-neutral-700 font-mono">Esc</kbd> or click outside to close
          </p>
        </div>
      </div>

      {}
      <div
        className="absolute inset-0 -z-10"
        onClick={onClose}
      />
    </div>
  )
}
</file>

<file path="src/components/LayerItem.tsx">
import { useState } from 'react'
import type { Layer } from '../types/layer'

interface LayerItemProps {
  layer: Layer
  isSelected: boolean
  level: number
  onSelect: (id: string) => void
  onToggleVisibility: (id: string) => void
  onToggleLock: (id: string) => void
  onRename: (id: string, newName: string) => void
  onDelete?: (id: string) => void
  children?: React.ReactNode
  isExpanded?: boolean
  onToggleExpand?: () => void
  themed?: boolean
}





export function LayerItem({
  layer,
  isSelected,
  level,
  onSelect,
  onToggleVisibility,
  onToggleLock,
  onRename,
  onDelete,
  children,
  isExpanded = true,
  onToggleExpand,
  themed = false,
}: LayerItemProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [editName, setEditName] = useState(layer.name)

  const handleDoubleClick = () => {
    setIsEditing(true)
    setEditName(layer.name)
  }

  const handleRename = () => {
    if (editName.trim() && editName !== layer.name) {
      onRename(layer.id, editName.trim())
    }
    setIsEditing(false)
  }

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleRename()
    } else if (e.key === 'Escape') {
      setIsEditing(false)
      setEditName(layer.name)
    }
  }

  const getIconForType = (type: string) => {
    switch (type) {
      case 'rectangle':
        return '▭'
      case 'circle':
        return '○'
      case 'text':
        return 'T'
      case 'line':
        return '—'
      case 'path':
        return '✎'
      case 'polygon':
        return '⬟'
      case 'star':
        return '★'
      case 'roundRect':
        return '▢'
      case 'group':
        return '◫'
      default:
        return '□'
    }
  }

  return (
    <div className={themed ? 'px-2 py-0.5' : ''}>
      <div
        className={`flex items-center px-2 py-1.5 cursor-pointer rounded-md transition-colors ${
          themed
            ? isSelected
              ? 'bg-white/50 border-l-4 border-white shadow-md'
              : 'bg-white/15 hover:bg-white/25'
            : isSelected
              ? 'bg-blue-100 border-l-4 border-blue-600 shadow-sm'
              : 'hover:bg-gray-100'
        }`}
        style={{ paddingLeft: `${8 + level * 16}px` }}
        onClick={() => onSelect(layer.id)}
      >
        {}
        {layer.type === 'group' && onToggleExpand && (
          <button
            className={`mr-1 rounded p-0.5 ${
              themed ? 'hover:bg-white/30 text-white' : 'hover:bg-gray-200'
            }`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleExpand()
            }}
          >
            {isExpanded ? (
              <span className="text-xs">▼</span>
            ) : (
              <span className="text-xs">▶</span>
            )}
          </button>
        )}

        {}
        <span className={`mr-2 text-xs font-mono ${
          themed ? 'text-white/80' : 'text-gray-600'
        }`}>
          {getIconForType(layer.type)}
        </span>

        {}
        {isEditing ? (
          <input
            type="text"
            value={editName}
            onChange={(e) => setEditName(e.target.value)}
            onKeyDown={handleKeyDown}
            onBlur={handleRename}
            className={`flex-1 px-1 py-0 text-sm rounded focus:outline-none ${
              themed
                ? 'bg-white/80 text-gray-900 border border-white/60'
                : 'border border-blue-500'
            }`}
            autoFocus
            onClick={(e) => e.stopPropagation()}
          />
        ) : (
          <span
            className={`flex-1 text-sm ${
              themed
                ? layer.visible ? 'text-white' : 'text-white/40'
                : layer.visible ? 'text-gray-900' : 'text-gray-400'
            }`}
            onDoubleClick={handleDoubleClick}
          >
            {layer.name}
          </span>
        )}

        {}
        <div className="flex items-center gap-0 ml-auto">
          {}
          <button
            className={`w-7 h-7 flex items-center justify-center rounded ${
              themed ? 'hover:bg-white/30' : 'hover:bg-gray-200'
            }`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleLock(layer.id)
            }}
          >
            {layer.locked ? (
              <span className="text-sm text-red-500">🔒</span>
            ) : (
              <span className={`text-sm ${themed ? 'text-white/60' : 'text-gray-400'}`}>🔓</span>
            )}
          </button>

          {}
          <button
            className={`w-7 h-7 flex items-center justify-center rounded ${
              themed ? 'hover:bg-white/30' : 'hover:bg-gray-200'
            }`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleVisibility(layer.id)
            }}
          >
            {layer.visible ? (
              <span className={`text-sm ${themed ? 'text-white/80' : 'text-gray-600'}`}>👁️</span>
            ) : (
              <span className={`text-sm ${themed ? 'text-white/40' : 'text-gray-400'}`}>👁️‍🗨️</span>
            )}
          </button>

          {}
          {onDelete && (
            <button
              className={`w-7 h-7 flex items-center justify-center rounded ${
                themed ? 'hover:bg-red-500/30 text-red-400' : 'hover:bg-red-100 text-red-600'
              }`}
              onClick={(e) => {
                e.stopPropagation()
                onDelete(layer.id)
              }}
              title="Delete layer"
            >
              <span className="text-sm">🗑️</span>
            </button>
          )}
        </div>
      </div>

      {}
      {layer.type === 'group' && isExpanded && children && (
        <div>{children}</div>
      )}
    </div>
  )
}
</file>

<file path="src/components/LayerPanel.tsx">
import { useState, useMemo } from 'react'
import { LayerItem } from './LayerItem'
import { ColorPicker } from './ColorPicker'
import type { Layer } from '../types/layer'
import type { Shape } from '../types/canvas'
import type { Group } from '../types/group'

interface LayerPanelProps {
  shapes: Shape[]
  groups: Group[]
  selectedIds: Set<string>
  onSelectLayer: (id: string) => void
  onToggleVisibility: (id: string) => void
  onToggleLock: (id: string) => void
  onRenameLayer: (id: string, newName: string) => void
  onDelete?: (id: string) => void

  onUpdateColors?: (fill: string, stroke: string, strokeWidth: number) => void
  onUpdateShapeProps?: (id: string, updates: Partial<Shape>) => void
  recentColors?: string[]
  onRequestColorSample?: (callback: (color: string) => void) => void

  collabTheme?: {
    primary: string
    secondary: string
    gradient: string
    displayName: string
    softBg: string
    softBorder: string
  } | null
}





export function LayerPanel({
  shapes,
  groups,
  selectedIds,
  onSelectLayer,
  onToggleVisibility,
  onToggleLock,
  onRenameLayer,
  onDelete,
  onUpdateColors,
  onUpdateShapeProps,
  recentColors = [],
  onRequestColorSample,
  collabTheme,
}: LayerPanelProps) {
  const [activeTab, setActiveTab] = useState<'layers' | 'design'>('layers')
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set())
  const [panelState, setPanelState] = useState<'hidden' | 'expanded'>('expanded')


  const [showFillPicker, setShowFillPicker] = useState(false)
  const [showStrokePicker, setShowStrokePicker] = useState(false)


  const selectedShapes = Array.from(selectedIds)
    .map(id => shapes.find(s => s.id === id))
    .filter((s): s is Shape => s !== undefined)


  const isTextSelected = selectedShapes.length === 1 && selectedShapes[0].type === 'text'


  const commonFill = useMemo(() => {
    if (selectedShapes.length === 0) return '#3B82F6FF'
    const fills = selectedShapes.map(s => s.fill || '#3B82F6FF')
    return fills.every(f => f === fills[0]) ? fills[0] : 'multiple'
  }, [selectedShapes])


  const commonStroke = useMemo(() => {
    if (selectedShapes.length === 0) return '#000000FF'
    const strokes = selectedShapes.map(s => s.stroke || '#000000FF')
    return strokes.every(s => s === strokes[0]) ? strokes[0] : 'multiple'
  }, [selectedShapes])


  const commonStrokeWidth = useMemo(() => {
    if (selectedShapes.length === 0) return 2
    const widths = selectedShapes.map(s => s.strokeWidth || 2)
    return widths.every(w => w === widths[0]) ? widths[0] : 2
  }, [selectedShapes])


  const FONT_FAMILIES = [
    'Inter, sans-serif',
    'Arial, sans-serif',
    'Georgia, serif',
    'Times New Roman, serif',
    'Courier New, monospace',
    'Comic Sans MS, cursive',
    'Impact, fantasy',
  ]




  const layerTree = useMemo(() => {
    const layers: Layer[] = []


    shapes.forEach((shape) => {
      const isInGroup = groups.some((g) => g.memberIds.includes(shape.id))
      if (!isInGroup) {

        let layerName = ''

        switch (shape.type) {
          case 'rectangle':
            layerName = `Rectangle ${shape.id.slice(-4)}`
            break
          case 'circle':
            layerName = `Circle ${shape.id.slice(-4)}`
            break
          case 'text':
            layerName = shape.text ? `"${shape.text.slice(0, 15)}"` : `Text ${shape.id.slice(-4)}`
            break
          case 'line':
            layerName = `Line ${shape.id.slice(-4)}`
            break
          case 'path':
            layerName = `Path ${shape.id.slice(-4)}`
            break
          case 'polygon':
            layerName = `Polygon ${shape.id.slice(-4)}`
            break
          case 'star':
            layerName = `Star ${shape.id.slice(-4)}`
            break
          case 'roundRect':
            layerName = `Rounded Rect ${shape.id.slice(-4)}`
            break
          default:
            layerName = `${shape.type} ${shape.id.slice(-4)}`
        }

        layers.push({
          id: shape.id,
          name: layerName,
          type: 'shape',
          visible: true,
          locked: false,
          zIndex: shape.zIndex || 0,
        })
      }
    })


    groups.forEach((group) => {

      const isInGroup = groups.some((g) => g.memberIds.includes(group.id))
      if (!isInGroup) {
        const children: Layer[] = []


        group.memberIds.forEach((memberId) => {
          const shape = shapes.find((s) => s.id === memberId)
          const childGroup = groups.find((g) => g.id === memberId)

          if (shape) {

            let childName = ''
            switch (shape.type) {
              case 'rectangle': childName = `Rectangle ${shape.id.slice(-4)}`; break
              case 'circle': childName = `Circle ${shape.id.slice(-4)}`; break
              case 'text': childName = shape.text ? `"${shape.text.slice(0, 15)}"` : `Text ${shape.id.slice(-4)}`; break
              case 'line': childName = `Line ${shape.id.slice(-4)}`; break
              case 'path': childName = `Path ${shape.id.slice(-4)}`; break
              case 'polygon': childName = `Polygon ${shape.id.slice(-4)}`; break
              case 'star': childName = `Star ${shape.id.slice(-4)}`; break
              case 'roundRect': childName = `Rounded Rect ${shape.id.slice(-4)}`; break
              default: childName = `${shape.type} ${shape.id.slice(-4)}`
            }

            children.push({
              id: shape.id,
              name: childName,
              type: 'shape',
              visible: true,
              locked: false,
              zIndex: shape.zIndex || 0,
              parentId: group.id,
            })
          } else if (childGroup) {

            children.push({
              id: childGroup.id,
              name: childGroup.name,
              type: 'group',
              visible: childGroup.visible,
              locked: childGroup.locked,
              zIndex: childGroup.zIndex || 0,
              parentId: group.id,
            })
          }
        })

        layers.push({
          id: group.id,
          name: group.name,
          type: 'group',
          visible: group.visible,
          locked: group.locked,
          zIndex: group.zIndex || 0,
          children,
        })
      }
    })


    return layers.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0))
  }, [shapes, groups])

  const toggleGroupExpand = (groupId: string) => {
    const newExpanded = new Set(expandedGroups)
    if (newExpanded.has(groupId)) {
      newExpanded.delete(groupId)
    } else {
      newExpanded.add(groupId)
    }
    setExpandedGroups(newExpanded)
  }

  const renderLayer = (layer: Layer, level: number = 0): React.ReactNode => {
    const isSelected = selectedIds.has(layer.id)
    const isExpanded = expandedGroups.has(layer.id)

    return (
      <LayerItem
        key={layer.id}
        layer={layer}
        isSelected={isSelected}
        level={level}
        onSelect={onSelectLayer}
        onToggleVisibility={onToggleVisibility}
        onToggleLock={onToggleLock}
        onRename={onRenameLayer}
        onDelete={onDelete}
        isExpanded={isExpanded}
        onToggleExpand={
          layer.type === 'group' ? () => toggleGroupExpand(layer.id) : undefined
        }
        themed={!!collabTheme}
      >
        {layer.children?.map((child) => renderLayer(child, level + 1))}
      </LayerItem>
    )
  }

  const togglePanelState = () => {
    if (panelState === 'expanded') setPanelState('hidden')
    else setPanelState('expanded')
  }

  if (panelState === 'hidden') {

    return (
      <button
        onClick={togglePanelState}
        className="fixed right-4 bottom-4 z-30 w-10 h-10 bg-white rounded-full shadow-lg border border-gray-300 hover:bg-gray-50 flex items-center justify-center"
        title="Show layers panel"
      >
        <span className="text-lg text-gray-700">☰</span>
      </button>
    )
  }

  return (
    <div
      className="w-80 h-[calc(100%-16px)] my-2 mr-2 rounded-lg shadow-lg flex flex-col transition-all duration-200 relative overflow-hidden"
      style={{
        background: 'linear-gradient(to bottom right, #475569, #374151)'
      }}
    >
      {}
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>

      {}
      <div className="relative z-10 flex flex-col h-full">
      {}
      <div className="flex items-center justify-between px-3 py-2 border-b border-white/20">
        <h3 className="text-sm font-semibold text-white">
          Layers
        </h3>
        <button
          onClick={togglePanelState}
          className="p-1 rounded transition-colors hover:bg-white/20 text-white"
          title="Hide layers panel"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>

      {}
      <div className="flex border-b border-white/20">
        <button
          className={`flex-1 px-4 py-2.5 text-sm font-medium flex items-center justify-center gap-2 transition-colors ${
            activeTab === 'layers'
              ? 'text-white border-b-2 border-white'
              : 'text-white/70 hover:text-white'
          }`}
          onClick={() => setActiveTab('layers')}
        >
          <span className="text-base">☰</span>
          Layers
        </button>
        <button
          className={`flex-1 px-4 py-2.5 text-sm font-medium flex items-center justify-center gap-2 transition-colors ${
            activeTab === 'design'
              ? 'text-white border-b-2 border-white'
              : 'text-white/70 hover:text-white'
          }`}
          onClick={() => setActiveTab('design')}
        >
          <span className="text-base">◐</span>
          Design
        </button>
      </div>

      {}
      <div className="flex-1 overflow-y-auto" id="layers-content">
        {activeTab === 'layers' ? (
          <div className="py-2">
            {layerTree.length === 0 ? (
              <div className="px-4 py-8 text-center text-sm text-white/60">
                No layers yet
              </div>
            ) : (
              layerTree.map((layer) => renderLayer(layer))
            )}
          </div>
        ) : (
          <div className="p-4 space-y-4 overflow-y-auto">
            {selectedShapes.length === 0 ? (
              <div className="text-center text-sm py-8 text-white/60">
                Select a shape to edit properties
              </div>
            ) : (
              <>
                {}
                {isTextSelected && (
                  <div className="space-y-3 pb-4 rounded-lg p-3 bg-white/10 border-b border-white/20">
                    <h4 className="text-xs font-semibold uppercase text-white/90">Text</h4>

                    {}
                    <div>
                      <label className="text-xs font-medium block mb-1 text-white/90">Font</label>
                      <select
                        value={selectedShapes[0].fontFamily || 'Inter, sans-serif'}
                        onChange={(e) => onUpdateShapeProps?.(selectedShapes[0].id, {
                          fontFamily: e.target.value
                        })}
                        className="w-full px-2 py-1.5 border rounded text-xs focus:outline-none focus:ring-1 bg-white/20 border-white/30 text-white focus:ring-white/50"
                      >
                        {FONT_FAMILIES.map(font => (
                          <option key={font} value={font}>
                            {font.split(',')[0]}
                          </option>
                        ))}
                      </select>
                    </div>

                    {}
                    <div>
                      <div className="flex justify-between items-center mb-1">
                        <label className="text-xs font-medium text-white/90">Size</label>
                        <span className="text-xs text-white/70">{selectedShapes[0].fontSize || 20}px</span>
                      </div>
                      <input
                        type="range"
                        min="12"
                        max="72"
                        value={selectedShapes[0].fontSize || 20}
                        onChange={(e) => onUpdateShapeProps?.(selectedShapes[0].id, {
                          fontSize: parseInt(e.target.value)
                        })}
                        className="w-full"
                      />
                    </div>

                    {}
                    <div>
                      <label className="text-xs font-medium block mb-1 text-white/90">Style</label>
                      <div className="flex gap-1">
                        <button
                          onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                            fontWeight: selectedShapes[0].fontWeight === 'bold' ? 'normal' : 'bold'
                          })}
                          className={`px-2 py-1 text-xs font-bold border rounded transition-colors ${
                            selectedShapes[0].fontWeight === 'bold'
                              ? 'bg-blue-500 text-white border-blue-500'
                              : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                          }`}
                        >
                          B
                        </button>
                        <button
                          onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                            fontStyle: selectedShapes[0].fontStyle === 'italic' ? 'normal' : 'italic'
                          })}
                          className={`px-2 py-1 text-xs italic border rounded transition-colors ${
                            selectedShapes[0].fontStyle === 'italic'
                              ? 'bg-blue-500 text-white border-blue-500'
                              : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                          }`}
                        >
                          I
                        </button>
                        <button
                          onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                            textDecoration: selectedShapes[0].textDecoration === 'underline' ? '' : 'underline'
                          })}
                          className={`px-2 py-1 text-xs underline border rounded transition-colors ${
                            selectedShapes[0].textDecoration === 'underline'
                              ? 'bg-blue-500 text-white border-blue-500'
                              : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                          }`}
                        >
                          U
                        </button>
                      </div>
                    </div>

                    {}
                    <div>
                      <label className="text-xs font-medium block mb-1 text-white/90">Align</label>
                      <div className="flex gap-1">
                        {(['left', 'center', 'right'] as const).map(align => (
                          <button
                            key={align}
                            onClick={() => onUpdateShapeProps?.(selectedShapes[0].id, {
                              textAlign: align
                            })}
                            className={`flex-1 px-2 py-1 text-xs border rounded transition-colors ${
                              (selectedShapes[0].textAlign || 'left') === align
                                ? 'bg-blue-500 text-white border-blue-500'
                                : 'bg-white/20 text-white border-white/30 hover:bg-white/30'
                            }`}
                          >
                            {align === 'left' ? '⬅' : align === 'center' ? '↔' : '➡'}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>
                )}

                {}
                <div className="rounded-lg p-2 bg-white/10">
                  <button
                    onClick={() => setShowFillPicker(!showFillPicker)}
                    className="w-full flex items-center justify-between p-2 rounded hover:bg-white/20 transition-colors"
                  >
                    <div className="flex items-center gap-2">
                      <div
                        className="w-5 h-5 rounded border border-white/40"
                        style={{ backgroundColor: commonFill === 'multiple' ? '#CCCCCC' : commonFill }}
                      />
                      <span className="text-xs font-medium text-white/90">Fill</span>
                    </div>
                    <svg className={`w-3 h-3 transition-transform text-white/80 ${showFillPicker ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>
                  {showFillPicker && (
                    <div className="mt-2">
                      <ColorPicker
                        value={commonFill === 'multiple' ? '#3B82F6FF' : commonFill}
                        onChange={(color) => onUpdateColors?.(color, commonStroke === 'multiple' ? '#000000FF' : commonStroke, commonStrokeWidth)}
                        label="Fill"
                        recentColors={recentColors}
                        onRequestCanvasSample={onRequestColorSample ? () => onRequestColorSample((color) => {
                          onUpdateColors?.(color, commonStroke === 'multiple' ? '#000000FF' : commonStroke, commonStrokeWidth)
                        }) : undefined}
                      />
                    </div>
                  )}
                </div>

                {}
                <div className="rounded-lg p-2 bg-white/10">
                  <button
                    onClick={() => setShowStrokePicker(!showStrokePicker)}
                    className="w-full flex items-center justify-between p-2 rounded hover:bg-white/20 transition-colors"
                  >
                    <div className="flex items-center gap-2">
                      <div
                        className="w-5 h-5 rounded border border-white/40"
                        style={{ backgroundColor: commonStroke === 'multiple' ? '#CCCCCC' : commonStroke }}
                      />
                      <span className="text-xs font-medium text-white/90">Stroke</span>
                    </div>
                    <svg className={`w-3 h-3 transition-transform text-white/80 ${showStrokePicker ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>
                  {showStrokePicker && (
                    <div className="mt-2">
                      <ColorPicker
                        value={commonStroke === 'multiple' ? '#000000FF' : commonStroke}
                        onChange={(color) => onUpdateColors?.(commonFill === 'multiple' ? '#3B82F6FF' : commonFill, color, commonStrokeWidth)}
                        label="Stroke"
                        recentColors={recentColors}
                        onRequestCanvasSample={onRequestColorSample ? () => onRequestColorSample((color) => {
                          onUpdateColors?.(commonFill === 'multiple' ? '#3B82F6FF' : commonFill, color, commonStrokeWidth)
                        }) : undefined}
                      />
                    </div>
                  )}
                </div>

                {}
                <div className="rounded-lg p-3 bg-white/10">
                  <div className="flex justify-between items-center mb-1">
                    <label className="text-xs font-medium text-white/90">Stroke Width</label>
                    <span className="text-xs text-white/70">{commonStrokeWidth}px</span>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="20"
                    value={commonStrokeWidth}
                    onChange={(e) => onUpdateColors?.(
                      commonFill === 'multiple' ? '#3B82F6FF' : commonFill,
                      commonStroke === 'multiple' ? '#000000FF' : commonStroke,
                      parseInt(e.target.value)
                    )}
                    className="w-full"
                  />
                </div>
              </>
            )}
          </div>
        )}
      </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/Login.tsx">
import { useState } from 'react'
import type { FormEvent } from 'react'
import { signUp, signIn } from '../services/auth'

export default function Login() {
  const [isSignUp, setIsSignUp] = useState(false)
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [displayName, setDisplayName] = useState('')
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()
    setError('')

    // Validation
    if (!email || !password) {
      setError('Please fill in all required fields')
      return
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters')
      return
    }

    if (isSignUp && !displayName) {
      setError('Please enter your display name')
      return
    }

    setLoading(true)

    try {
      if (isSignUp) {
        await signUp(email, password, displayName)
      } else {
        await signIn(email, password)
      }

    } catch (err: any) {
      setError(err.message || 'Authentication failed')
    } finally {
      setLoading(false)
    }
  }

  const toggleMode = () => {
    setIsSignUp(!isSignUp)
    setError('')
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100">
      <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-md">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            CollabCanvas
          </h1>
          <p className="text-gray-600">
            {isSignUp ? 'Create your account' : 'Sign in to continue'}
          </p>
        </div>

        {}
        {error && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
            {error}
          </div>
        )}

        {}
        <form onSubmit={handleSubmit} className="space-y-4">
          {}
          {isSignUp && (
            <div>
              <label
                htmlFor="displayName"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Display Name
              </label>
              <input
                id="displayName"
                type="text"
                value={displayName}
                onChange={(e) => setDisplayName(e.target.value)}
                placeholder="Enter your name"
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                required={isSignUp}
                disabled={loading}
              />
            </div>
          )}

          {}
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700 mb-1"
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Enter your email"
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
              required
              disabled={loading}
            />
          </div>

          {}
          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700 mb-1"
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Enter your password"
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
              required
              minLength={6}
              disabled={loading}
            />
            <p className="text-xs text-gray-500 mt-1">
              Must be at least 6 characters
            </p>
          </div>

          {}
          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 px-4 rounded-lg font-medium hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition"
          >
            {loading ? (
              <span className="flex items-center justify-center">
                <svg
                  className="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    className="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    strokeWidth="4"
                  ></circle>
                  <path
                    className="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  ></path>
                </svg>
                Processing...
              </span>
            ) : isSignUp ? (
              'Sign Up'
            ) : (
              'Sign In'
            )}
          </button>
        </form>

        {}
        <div className="mt-6 text-center">
          <button
            type="button"
            onClick={toggleMode}
            disabled={loading}
            className="text-blue-600 hover:text-blue-700 font-medium text-sm disabled:opacity-50"
          >
            {isSignUp
              ? 'Already have an account? Sign In'
              : "Don't have an account? Sign Up"}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/PresenceBar.tsx">
import { useState } from 'react'
import { logOut } from '../services/auth'
import type { Presence } from '../types/firebase'
import { ZoomControls } from './ZoomControls'
import { Tooltip } from './Tooltip'

interface PresenceBarProps {
  currentUser: {
    displayName: string | null
    email: string | null
  }
  otherUsers: Map<string, Presence>

  scale?: number
  onZoomIn?: () => void
  onZoomOut?: () => void
  onZoomReset?: () => void
  onZoomFit?: () => void

  canvasName?: string
  onCanvasNameChange?: (name: string) => void
  lastEdited?: string
  onBack?: () => void

  snapToGrid?: boolean
  onSnapToggle?: () => void

  isTilemapMode?: boolean
  onToggleTilemapMode?: () => void

  collabTheme?: {
    primary: string
    secondary: string
    gradient: string
    displayName: string
    softBg: string
    softBorder: string
  } | null
}





export default function PresenceBar({
  currentUser,
  otherUsers,
  scale = 1,
  onZoomIn = () => {},
  onZoomOut = () => {},
  onZoomReset = () => {},
  onZoomFit = () => {},
  canvasName = 'Untitled',
  onCanvasNameChange,
  lastEdited = 'Just now',
  onBack,
  snapToGrid = false,
  onSnapToggle,
  isTilemapMode = false,
  onToggleTilemapMode,
  collabTheme = {
    primary: '#475569',
    secondary: '#374151',
    gradient: 'from-slate-600 to-gray-700',
    displayName: '',
    softBg: 'rgba(71, 85, 105, 0.3)',
    softBorder: 'rgba(71, 85, 105, 0.4)'
  },
}: PresenceBarProps) {
  const [isEditingName, setIsEditingName] = useState(false)
  const [editedName, setEditedName] = useState(canvasName)

  const handleLogout = async () => {
    try {
      await logOut()
    } catch (error) {
      console.error('Logout failed:', error)
    }
  }

  const handleNameClick = () => {
    if (onCanvasNameChange) {
      setIsEditingName(true)
      setEditedName(canvasName)
    }
  }

  const handleNameSubmit = () => {
    if (onCanvasNameChange && editedName.trim()) {
      onCanvasNameChange(editedName.trim())
    }
    setIsEditingName(false)
  }

  const handleNameCancel = () => {
    setEditedName(canvasName)
    setIsEditingName(false)
  }

  // Combine current user with other users for display
  const allUsers = [
    {
      name: currentUser.displayName || currentUser.email || 'You',
      color: '#3B82F6',
      isSelf: true,
    },
    ...Array.from(otherUsers.values()).map((presence) => ({
      name: presence.n,
      color: presence.cl,
      isSelf: false,
    })),
  ]

  return (
    <div
      className="fixed top-0 left-0 right-0 h-16 shadow-lg z-50 flex items-center justify-between px-4 relative overflow-hidden"
      style={{
        background: 'linear-gradient(to bottom right, #475569, #374151)'
      }}
    >
      {}
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.08) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>

      {}
      <div className="relative z-10 w-full flex items-center justify-between gap-4">
      {}
      <div className="flex items-center gap-3 min-w-0 flex-1">
        {onBack && (
              <button
                type="button"
                onClick={onBack}
                className={`w-8 h-8 flex items-center justify-center rounded transition-colors ${
              collabTheme
                ? 'hover:bg-white/20 text-white'
                : 'hover:bg-neutral-100 text-neutral-700'
            }`}
            title="Back to dashboard"
          >
            <span className="text-xl">←</span>
          </button>
        )}

        <div className="flex flex-col min-w-0">
          {isEditingName ? (
            <input
              type="text"
              value={editedName}
              onChange={(e) => setEditedName(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') handleNameSubmit()
                if (e.key === 'Escape') handleNameCancel()
              }}
              onBlur={handleNameSubmit}
              autoFocus
              className={`text-sm font-semibold px-2 py-1 rounded border-2 focus:outline-none ${
                collabTheme
                  ? 'bg-white/80 text-gray-900 placeholder-gray-600 border-white/60'
                  : 'text-neutral-900 bg-neutral-100 border-primary-500'
              }`}
              style={{ width: Math.max(120, editedName.length * 8) + 'px' }}
            />
          ) : (
            <button
              onClick={handleNameClick}
              className={`text-sm font-semibold transition-colors text-left truncate ${
                collabTheme
                  ? 'text-white hover:text-white/90'
                  : 'text-neutral-900 hover:text-primary-600'
              }`}
              disabled={!onCanvasNameChange}
            >
              {canvasName}
            </button>
          )}
          <span className={`text-xs ${collabTheme ? 'text-white/80' : 'text-neutral-500'}`}>
            {lastEdited}
          </span>
        </div>
      </div>

      {}
      <div className="flex items-center gap-3">
        <ZoomControls
          scale={scale}
          onZoomIn={onZoomIn}
          onZoomOut={onZoomOut}
          onZoomReset={onZoomReset}
          onZoomFit={onZoomFit}
          collabTheme={collabTheme}
        />

        {}
        {onToggleTilemapMode && (
          <button
            onClick={onToggleTilemapMode}
            className={`px-3 py-1.5 rounded-md font-medium text-sm transition-all ${
              isTilemapMode
                ? 'bg-purple-600 text-white hover:bg-purple-700 shadow-md'
                : 'bg-white/20 text-white hover:bg-white/30'
            }`}
            title={isTilemapMode ? 'Switch to Shape Mode' : 'Switch to Tilemap Mode'}
          >
            {isTilemapMode ? '🎨 Shapes' : '🎮 Tilemap'}
          </button>
        )}
      </div>

      {}
      <div className="flex items-center gap-3 flex-1 justify-end">
        {}
        {onSnapToggle && (
          <button
            onClick={onSnapToggle}
            className={`px-3 py-1.5 rounded-lg transition-all text-sm font-medium ${
              snapToGrid
                ? collabTheme
                  ? 'bg-white/80 text-gray-900 shadow-sm'
                  : 'bg-blue-500 text-white shadow-sm'
                : collabTheme
                  ? 'bg-white/60 hover:bg-white/70 text-gray-900'
                  : 'bg-neutral-100 hover:bg-neutral-200 text-neutral-700'
            }`}
            title={snapToGrid ? 'Snap to Grid: ON (20px)' : 'Snap to Grid: OFF'}
          >
            <div className="flex items-center gap-1.5">
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4 8h4M4 12h4M4 16h4M12 8h4M12 12h4M12 16h4"
                />
              </svg>
              <span>{snapToGrid ? 'Snap' : 'Snap'}</span>
            </div>
          </button>
        )}

        {}
        <div className="flex items-center -space-x-2">
          {allUsers.slice(0, 5).map((user, index) => (
            <Tooltip key={index} content={user.name + (user.isSelf ? ' (You)' : '')} side="bottom">
              <div
                className="w-8 h-8 rounded-full border-2 border-white flex items-center justify-center text-white text-xs font-semibold shadow-medium"
                style={{
                  backgroundColor: user.color,
                  zIndex: allUsers.length - index
                }}
              >
                {user.name.charAt(0).toUpperCase()}
              </div>
            </Tooltip>
          ))}
          {allUsers.length > 5 && (
            <div className="w-8 h-8 rounded-full border-2 border-white bg-neutral-200 flex items-center justify-center text-neutral-700 text-xs font-semibold shadow-medium">
              +{allUsers.length - 5}
            </div>
          )}
        </div>

        {/* Share Button - placeholder for PR-23 */}
        <button className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors ${
          collabTheme
            ? 'bg-white/80 hover:bg-white/90 text-gray-900 shadow-sm'
            : 'bg-primary-600 hover:bg-primary-700 text-white'
        }`}>
          Share
        </button>

        {/* Logout Button */}
        <button
          onClick={handleLogout}
          className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors ${
            collabTheme
              ? 'bg-white/60 hover:bg-white/70 text-gray-900'
              : 'bg-neutral-100 hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          Logout
        </button>
      </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/PropertiesPanel.tsx">
import React, { useState } from 'react'
import { ColorPicker } from './ColorPicker'
import type { Shape } from '../types/canvas'






interface PropertiesPanelProps {
  selectedShapes: Shape[]
  onUpdateColors: (
    fill?: string,
    stroke?: string,
    strokeWidth?: number
  ) => void
  onUpdateShapeProps?: (id: string, updates: Partial<Shape>) => void
  recentColors: string[]
  onRequestColorSample?: (callback: (color: string) => void) => void
  onClose?: () => void
}

export const PropertiesPanel: React.FC<PropertiesPanelProps> = ({
  selectedShapes,
  onUpdateColors,
  onUpdateShapeProps,
  recentColors,
  onRequestColorSample,
  onClose,
}) => {
  const [showFillPicker, setShowFillPicker] = useState(false)
  const [showStrokePicker, setShowStrokePicker] = useState(false)

  if (selectedShapes.length === 0) {
    return null
  }


  const getCommonValue = <T,>(
    getValue: (shape: Shape) => T | undefined
  ): T | 'multiple' | undefined => {
    const values = selectedShapes.map(getValue)
    const firstValue = values[0]


    const allSame = values.every(
      (val) => JSON.stringify(val) === JSON.stringify(firstValue)
    )

    return allSame ? firstValue : 'multiple'
  }

  const commonFill = getCommonValue((s) => s.fill)
  const commonStroke = getCommonValue((s) => s.stroke)
  const commonStrokeWidth = getCommonValue((s) => s.strokeWidth || 0)

  const handleFillChange = (color: string) => {
    onUpdateColors(color, undefined, undefined)
  }

  const handleStrokeChange = (color: string) => {
    onUpdateColors(undefined, color, undefined)
  }

  const handleStrokeWidthChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const width = parseInt(e.target.value)
    onUpdateColors(undefined, undefined, width)
  }

  const handleRemoveStroke = () => {
    onUpdateColors(undefined, undefined, 0)
  }


  const isTextSelected = selectedShapes.length === 1 && selectedShapes[0].type === 'text'


  const FONT_FAMILIES = [
    'Inter, sans-serif',
    'Arial, sans-serif',
    'Georgia, serif',
    'Courier New, monospace',
    'Comic Sans MS, cursive',
    'Impact, fantasy',
  ]

  return (
    <div className="absolute right-0 top-0 h-full w-64 bg-white border-l border-gray-200 shadow-lg overflow-y-auto z-10">
      <div className="p-4 space-y-6">
        {}
        <div className="border-b pb-2 flex justify-between items-start">
          <div>
            <h3 className="text-sm font-semibold text-purple-700 flex items-center gap-2">
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
              </svg>
              Design Properties
            </h3>
            <p className="text-xs text-gray-500 mt-1">
              {selectedShapes.length === 1
                ? '1 shape selected'
                : `${selectedShapes.length} shapes selected`}
            </p>
          </div>
          {onClose && (
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors p-1 hover:bg-gray-100 rounded"
              title="Close design panel (Esc)"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>

        {}
        {isTextSelected && (
          <div className="space-y-4 pb-4 border-b">
            <h4 className="text-xs font-semibold text-gray-500 uppercase">Text Formatting</h4>

            {}
            <div>
              <label className="text-sm font-medium text-gray-700 block mb-1">
                Font Family
              </label>
              <select
                value={selectedShapes[0].fontFamily || 'Inter, sans-serif'}
                onChange={(e) => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                  fontFamily: e.target.value
                })}
                className="w-full px-2 py-1 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
              >
                {FONT_FAMILIES.map(font => (
                  <option key={font} value={font} style={{ fontFamily: font }}>
                    {font.split(',')[0]}
                  </option>
                ))}
              </select>
            </div>

            {}
            <div>
              <div className="flex justify-between items-center mb-1">
                <label className="text-sm font-medium text-gray-700">Font Size</label>
                <span className="text-xs text-gray-500">{selectedShapes[0].fontSize || 20}px</span>
              </div>
              <input
                type="range"
                min="12"
                max="72"
                step="1"
                value={selectedShapes[0].fontSize || 20}
                onChange={(e) => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                  fontSize: parseInt(e.target.value)
                })}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>12px</span>
                <span>72px</span>
              </div>
            </div>

            {}
            <div>
              <label className="text-sm font-medium text-gray-700 block mb-1">Style</label>
              <div className="flex gap-1">
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    fontWeight: selectedShapes[0].fontWeight === 'bold' ? 'normal' : 'bold'
                  })}
                  className={`px-3 py-1 font-bold border rounded text-sm ${
                    selectedShapes[0].fontWeight === 'bold'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Bold"
                >
                  B
                </button>
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    fontStyle: selectedShapes[0].fontStyle === 'italic' ? 'normal' : 'italic'
                  })}
                  className={`px-3 py-1 italic border rounded text-sm ${
                    selectedShapes[0].fontStyle === 'italic'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Italic"
                >
                  I
                </button>
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    textDecoration: selectedShapes[0].textDecoration === 'underline' ? '' : 'underline'
                  })}
                  className={`px-3 py-1 underline border rounded text-sm ${
                    selectedShapes[0].textDecoration === 'underline'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Underline"
                >
                  U
                </button>
                <button
                  onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                    textDecoration: selectedShapes[0].textDecoration === 'line-through' ? '' : 'line-through'
                  })}
                  className={`px-3 py-1 line-through border rounded text-sm ${
                    selectedShapes[0].textDecoration === 'line-through'
                      ? 'bg-blue-500 text-white border-blue-500'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                  title="Strikethrough"
                >
                  S
                </button>
              </div>
            </div>

            {}
            <div>
              <label className="text-sm font-medium text-gray-700 block mb-1">Align</label>
              <div className="flex gap-1">
                {['left', 'center', 'right'].map(align => (
                  <button
                    key={align}
                    onClick={() => onUpdateShapeProps && onUpdateShapeProps(selectedShapes[0].id, {
                      textAlign: align as 'left' | 'center' | 'right'
                    })}
                    className={`flex-1 px-3 py-1 border rounded text-sm ${
                      (selectedShapes[0].textAlign || 'left') === align
                        ? 'bg-blue-500 text-white border-blue-500'
                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                    }`}
                    title={`Align ${align}`}
                  >
                    {align === 'left' ? '⬅' : align === 'center' ? '↔' : '➡'}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}

        {}
        <div>
          <button
            onClick={() => setShowFillPicker(!showFillPicker)}
            className="w-full flex items-center justify-between p-2 rounded hover:bg-gray-50 transition-colors"
          >
            <div className="flex items-center gap-2">
              <div
                className="w-6 h-6 rounded border-2 border-gray-300"
                style={{
                  backgroundColor:
                    commonFill === 'multiple' ? '#CCCCCC' : commonFill,
                  backgroundImage:
                    commonFill === 'multiple'
                      ? 'repeating-linear-gradient(45deg, #999 0, #999 2px, #CCC 2px, #CCC 4px)'
                      : undefined,
                }}
              />
              <span className="text-sm font-medium text-gray-700">
                {commonFill === 'multiple' ? 'Fill (Multiple)' : 'Fill'}
              </span>
            </div>
            <svg
              className={`w-4 h-4 text-gray-500 transition-transform ${
                showFillPicker ? 'rotate-180' : ''
              }`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>

          {showFillPicker && (
            <div className="mt-2 p-3 bg-gray-50 rounded">
              <ColorPicker
                value={
                  commonFill === 'multiple' ? '#3B82F6FF' : (commonFill as string)
                }
                onChange={handleFillChange}
                label=""
                recentColors={recentColors}
                showOpacity={true}
                onRequestCanvasSample={
                  onRequestColorSample
                    ? () => onRequestColorSample(handleFillChange)
                    : undefined
                }
              />
            </div>
          )}
        </div>

        {/* Stroke Color */}
        <div>
          <button
            onClick={() => setShowStrokePicker(!showStrokePicker)}
            className="w-full flex items-center justify-between p-2 rounded hover:bg-gray-50 transition-colors"
          >
            <div className="flex items-center gap-2">
              <div
                className="w-6 h-6 rounded border-2 border-gray-300"
                style={{
                  backgroundColor:
                    commonStroke === 'multiple'
                      ? '#CCCCCC'
                      : commonStroke || 'transparent',
                  backgroundImage:
                    commonStroke === 'multiple'
                      ? 'repeating-linear-gradient(45deg, #999 0, #999 2px, #CCC 2px, #CCC 4px)'
                      : !commonStroke
                      ? 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)'
                      : undefined,
                  backgroundSize: '10px 10px',
                  backgroundPosition: '0 0, 0 5px, 5px -5px, -5px 0px',
                }}
              />
              <span className="text-sm font-medium text-gray-700">
                {commonStroke === 'multiple' ? 'Stroke (Multiple)' : 'Stroke'}
              </span>
            </div>
            <svg
              className={`w-4 h-4 text-gray-500 transition-transform ${
                showStrokePicker ? 'rotate-180' : ''
              }`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>

          {showStrokePicker && (
            <div className="mt-2 p-3 bg-gray-50 rounded">
              <ColorPicker
                value={
                  commonStroke === 'multiple'
                    ? '#000000FF'
                    : (commonStroke as string) || '#000000FF'
                }
                onChange={handleStrokeChange}
                label=""
                recentColors={recentColors}
                showOpacity={true}
                onRequestCanvasSample={
                  onRequestColorSample
                    ? () => onRequestColorSample(handleStrokeChange)
                    : undefined
                }
              />
              {commonStroke && commonStroke !== 'multiple' && (
                <button
                  onClick={handleRemoveStroke}
                  className="mt-2 w-full px-3 py-1 text-xs bg-red-50 text-red-600 rounded hover:bg-red-100 transition-colors"
                >
                  Remove Stroke
                </button>
              )}
            </div>
          )}
        </div>

        {}
        {(commonStroke || commonStroke === 'multiple') && (
          <div>
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-medium text-gray-700">
                Stroke Width
              </span>
              <span className="text-xs text-gray-500">
                {commonStrokeWidth === 'multiple'
                  ? 'Multiple'
                  : `${commonStrokeWidth}px`}
              </span>
            </div>
            <input
              type="range"
              min="0"
              max="20"
              step="1"
              value={
                commonStrokeWidth === 'multiple' ? 2 : (commonStrokeWidth as number)
              }
              onChange={handleStrokeWidthChange}
              className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-1">
              <span>0px</span>
              <span>20px</span>
            </div>
          </div>
        )}

        {}
        {selectedShapes.length === 1 && onUpdateShapeProps && (
          <>
            {}
            {selectedShapes[0].type === 'line' && selectedShapes[0].arrows && (
              <div className="pt-4 border-t">
                <h4 className="text-sm font-semibold text-gray-800 mb-3">
                  Arrows
                </h4>
                <div className="space-y-2">
                  <label className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      checked={selectedShapes[0].arrows.start || false}
                      onChange={(e) =>
                        onUpdateShapeProps(selectedShapes[0].id, {
                          arrows: {
                            ...selectedShapes[0].arrows,
                            start: e.target.checked,
                          },
                        })
                      }
                      className="rounded border-gray-300"
                    />
                    <span className="text-sm text-gray-700">Start Arrow</span>
                  </label>
                  <label className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      checked={selectedShapes[0].arrows.end || false}
                      onChange={(e) =>
                        onUpdateShapeProps(selectedShapes[0].id, {
                          arrows: {
                            ...selectedShapes[0].arrows,
                            end: e.target.checked,
                          },
                        })
                      }
                      className="rounded border-gray-300"
                    />
                    <span className="text-sm text-gray-700">End Arrow</span>
                  </label>
                </div>
              </div>
            )}

            {}
            {selectedShapes[0].type === 'polygon' && selectedShapes[0].sides !== undefined && (
              <div className="pt-4 border-t">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-semibold text-gray-800">
                    Sides
                  </span>
                  <span className="text-xs text-gray-500">
                    {selectedShapes[0].sides}
                  </span>
                </div>
                <input
                  type="range"
                  min="3"
                  max="12"
                  step="1"
                  value={selectedShapes[0].sides}
                  onChange={(e) =>
                    onUpdateShapeProps(selectedShapes[0].id, {
                      sides: parseInt(e.target.value),
                    })
                  }
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>3</span>
                  <span>12</span>
                </div>
              </div>
            )}

            {}
            {selectedShapes[0].type === 'star' && selectedShapes[0].sides !== undefined && (
              <div className="pt-4 border-t">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-semibold text-gray-800">
                    Points
                  </span>
                  <span className="text-xs text-gray-500">
                    {selectedShapes[0].sides}
                  </span>
                </div>
                <input
                  type="range"
                  min="3"
                  max="12"
                  step="1"
                  value={selectedShapes[0].sides}
                  onChange={(e) =>
                    onUpdateShapeProps(selectedShapes[0].id, {
                      sides: parseInt(e.target.value),
                    })
                  }
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>3</span>
                  <span>12</span>
                </div>
              </div>
            )}

            {}
            {selectedShapes[0].type === 'roundRect' && selectedShapes[0].cornerRadius !== undefined && (
              <div className="pt-4 border-t">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-semibold text-gray-800">
                    Corner Radius
                  </span>
                  <span className="text-xs text-gray-500">
                    {selectedShapes[0].cornerRadius}px
                  </span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="50"
                  step="1"
                  value={selectedShapes[0].cornerRadius}
                  onChange={(e) =>
                    onUpdateShapeProps(selectedShapes[0].id, {
                      cornerRadius: parseInt(e.target.value),
                    })
                  }
                  className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  <span>0px</span>
                  <span>50px</span>
                </div>
              </div>
            )}
          </>
        )}

        {}
        <div className="pt-4 border-t">
          <div className="text-xs text-gray-500 space-y-1">
            {selectedShapes.length === 1 && (
              <>
                <div className="flex justify-between">
                  <span>Type:</span>
                  <span className="font-medium text-gray-700 capitalize">
                    {selectedShapes[0].type}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Size:</span>
                  <span className="font-medium text-gray-700">
                    {Math.round(selectedShapes[0].width)} ×{' '}
                    {Math.round(selectedShapes[0].height)}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Position:</span>
                  <span className="font-medium text-gray-700">
                    {Math.round(selectedShapes[0].x)},{' '}
                    {Math.round(selectedShapes[0].y)}
                  </span>
                </div>
                {selectedShapes[0].rotation && (
                  <div className="flex justify-between">
                    <span>Rotation:</span>
                    <span className="font-medium text-gray-700">
                      {Math.round(selectedShapes[0].rotation)}°
                    </span>
                  </div>
                )}
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/ProtectedRoute.tsx">
import type { ReactNode } from 'react'
import { useAuth } from '../hooks/useAuth'
import Login from './Login'

interface ProtectedRouteProps {
  children: ReactNode
}






export default function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { user, loading } = useAuth()


  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100">
        <div className="text-center">
          <svg
            className="animate-spin h-12 w-12 text-blue-600 mx-auto mb-4"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          <p className="text-gray-600 text-lg">Loading...</p>
        </div>
      </div>
    )
  }


  if (!user) {
    return <Login />
  }


  return <>{children}</>
}
</file>

<file path="src/components/QuickActionsPopup.tsx">
import { useEffect, useRef } from 'react'

interface QuickActionsPopupProps {
  screenX: number
  screenY: number
  selectedCount: number
  canGroup: boolean
  onBringToFront: () => void
  onSendToBack: () => void
  onBringForward: () => void
  onSendBackward: () => void
  onGroup: () => void
  onUngroup: () => void
  onDuplicate: () => void
  onDelete: () => void
  onClose: () => void
}

export function QuickActionsPopup({
  screenX,
  screenY,
  selectedCount,
  canGroup,
  onBringToFront,
  onSendToBack,
  onBringForward,
  onSendBackward,
  onGroup,
  onUngroup,
  onDuplicate,
  onDelete,
  onClose,
}: QuickActionsPopupProps) {
  const popupRef = useRef<HTMLDivElement>(null)


  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (popupRef.current && !popupRef.current.contains(e.target as Node)) {
        onClose()
      }
    }
    setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside)
    }, 0)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [onClose])


  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [onClose])

  const handleAction = (action: () => void) => {
    action()
    onClose()
  }

  return (
    <div
      ref={popupRef}
      className="fixed bg-white rounded-md shadow-2xl border border-gray-300 z-50 py-0.5"
      style={{
        left: Math.min(screenX + 10, window.innerWidth - 150),
        top: Math.min(screenY - 10, window.innerHeight - 300),
      }}
    >
      {}
      <button
        onClick={() => handleAction(onBringToFront)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">⬆️</span>
        Bring to Front
      </button>
      <button
        onClick={() => handleAction(onBringForward)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">↑</span>
        Bring Forward
      </button>
      <button
        onClick={() => handleAction(onSendBackward)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">↓</span>
        Send Backward
      </button>
      <button
        onClick={() => handleAction(onSendToBack)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">⬇️</span>
        Send to Back
      </button>

      <div className="border-t border-gray-200" />

      {}
      {selectedCount >= 2 && (
        <>
          {canGroup && (
            <button
              onClick={() => handleAction(onGroup)}
              className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
            >
              <span className="text-xs">📦</span>
              Group
            </button>
          )}
          <button
            onClick={() => handleAction(onUngroup)}
            className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
          >
            <span className="text-xs">📂</span>
            Ungroup
          </button>
          <div className="border-t border-gray-200" />
        </>
      )}

      {}
      <button
        onClick={() => handleAction(onDuplicate)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-blue-50 flex items-center gap-1.5"
      >
        <span className="text-xs">📋</span>
        Duplicate
      </button>
      <button
        onClick={() => handleAction(onDelete)}
        className="w-full text-left px-2 py-1 text-xs hover:bg-red-50 text-red-600 flex items-center gap-1.5"
      >
        <span className="text-xs">🗑️</span>
        Delete
      </button>
    </div>
  )
}
</file>

<file path="src/components/QuickPropertiesPopup.tsx">
import { useState, useEffect, useRef } from 'react'
import type { Shape } from '../types/canvas'

interface QuickPropertiesPopupProps {
  shape: Shape
  screenX: number
  screenY: number
  onUpdateColors: (fill?: string, stroke?: string, strokeWidth?: number) => void
  onOpenFullPanel: () => void
  onClose: () => void
}

export function QuickPropertiesPopup({
  shape,
  screenX,
  screenY,
  onUpdateColors,
  onOpenFullPanel,
  onClose,
}: QuickPropertiesPopupProps) {
  const [localFill, setLocalFill] = useState(shape.fill || '#3B82F6FF')
  const [localStroke, setLocalStroke] = useState(shape.stroke || '#000000FF')
  const [localStrokeWidth, setLocalStrokeWidth] = useState(shape.strokeWidth || 0)
  const popupRef = useRef<HTMLDivElement>(null)


  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (popupRef.current && !popupRef.current.contains(e.target as Node)) {
        onClose()
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [onClose])


  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [onClose])

  const handleFillChange = (color: string) => {
    setLocalFill(color)
    onUpdateColors(color, undefined, undefined)
  }

  const handleStrokeChange = (color: string) => {
    setLocalStroke(color)
    onUpdateColors(undefined, color, undefined)
  }

  const handleStrokeWidthChange = (width: number) => {
    setLocalStrokeWidth(width)
    onUpdateColors(undefined, undefined, width)
  }


  const getRGBFromHex = (hex: string) => {
    const rgb = hex.slice(1, 7)
    const alpha = hex.slice(7, 9) || 'FF'
    return { rgb: `#${rgb}`, opacity: parseInt(alpha, 16) / 255 }
  }

  const fillData = getRGBFromHex(localFill)
  const strokeData = getRGBFromHex(localStroke)

  return (
    <div
      ref={popupRef}
      className="fixed bg-white rounded-lg shadow-2xl border border-gray-300 z-50 p-2"
      style={{
        left: Math.min(screenX + 10, window.innerWidth - 220),
        top: Math.min(screenY - 10, window.innerHeight - 200),
        width: '200px',
      }}
    >
      {}
      <div className="flex items-center justify-between mb-2 pb-1 border-b border-gray-200">
        <span className="text-xs font-semibold text-gray-700 uppercase tracking-wide">
          {shape.type}
        </span>
        <button
          onClick={onClose}
          className="text-gray-400 hover:text-gray-600 p-0.5"
          title="Close (Esc)"
        >
          <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {}
      <div className="mb-2">
        <label className="text-xs font-medium text-gray-600 block mb-1">Fill</label>
        <div className="flex items-center gap-1.5">
          <input
            type="color"
            value={fillData.rgb}
            onChange={(e) => handleFillChange(e.target.value + localFill.slice(7))}
            className="w-8 h-6 rounded border border-gray-300 cursor-pointer"
          />
          <input
            type="text"
            value={localFill.slice(0, 7).toUpperCase()}
            onChange={(e) => {
              if (/^#[0-9A-F]{0,6}$/i.test(e.target.value)) {
                handleFillChange(e.target.value.padEnd(7, '0') + localFill.slice(7))
              }
            }}
            className="flex-1 px-1.5 py-0.5 text-xs border border-gray-300 rounded"
            maxLength={7}
          />
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={fillData.opacity}
            onChange={(e) => {
              const alpha = Math.round(parseFloat(e.target.value) * 255).toString(16).padStart(2, '0')
              handleFillChange(localFill.slice(0, 7) + alpha.toUpperCase())
            }}
            className="w-12 h-1"
            title={`Opacity: ${Math.round(fillData.opacity * 100)}%`}
          />
        </div>
      </div>

      {}
      <div className="mb-2">
        <label className="text-xs font-medium text-gray-600 block mb-1">Stroke</label>
        <div className="flex items-center gap-1.5">
          <input
            type="color"
            value={strokeData.rgb}
            onChange={(e) => handleStrokeChange(e.target.value + localStroke.slice(7))}
            className="w-8 h-6 rounded border border-gray-300 cursor-pointer"
          />
          <input
            type="text"
            value={localStroke.slice(0, 7).toUpperCase()}
            onChange={(e) => {
              if (/^#[0-9A-F]{0,6}$/i.test(e.target.value)) {
                handleStrokeChange(e.target.value.padEnd(7, '0') + localStroke.slice(7))
              }
            }}
            className="flex-1 px-1.5 py-0.5 text-xs border border-gray-300 rounded"
            maxLength={7}
          />
        </div>
      </div>

      {}
      <div className="mb-2">
        <label className="text-xs font-medium text-gray-600 block mb-1">
          Width: {localStrokeWidth}px
        </label>
        <input
          type="range"
          min="0"
          max="20"
          step="1"
          value={localStrokeWidth}
          onChange={(e) => handleStrokeWidthChange(parseInt(e.target.value))}
          className="w-full h-1"
        />
      </div>

      {}
      <div className="mb-2 pb-2 border-b border-gray-200">
        <div className="text-xs text-gray-500 flex justify-between">
          <span>X: {Math.round(shape.x)}</span>
          <span>Y: {Math.round(shape.y)}</span>
          <span>W: {Math.round(shape.width || 0)}</span>
          <span>H: {Math.round(shape.height || 0)}</span>
        </div>
      </div>

      {}
      <button
        onClick={onOpenFullPanel}
        className="w-full py-1 text-xs font-medium text-blue-600 hover:bg-blue-50 rounded transition-colors"
      >
        More Options →
      </button>
    </div>
  )
}
</file>

<file path="src/components/shapes/Circle.tsx">
import { useRef, useEffect } from 'react'
import { Circle as KonvaCircle, Transformer } from 'react-konva'
import type Konva from 'konva'

interface CircleProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}






export default function Circle({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: CircleProps) {
  const shapeRef = useRef<Konva.Circle>(null)
  const trRef = useRef<Konva.Transformer>(null)

  const radiusX = width / 2
  const radiusY = height / 2


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)

    const radius = node.radius()
    onTransformEnd(
      Math.max(10, radius * 2 * scaleX),
      Math.max(10, radius * 2 * scaleY),
      node.rotation(),
      node.x() - radius * scaleX,
      node.y() - radius * scaleY
    )
  }

  return (
    <>
      {}
      <KonvaCircle
        ref={shapeRef}
        x={x + radiusX}
        y={y + radiusY}
        radiusX={radiusX}
        radiusY={radiusY}
        rotation={rotation}
        fill={fill}
        stroke={stroke || '#000000'}
        strokeWidth={strokeWidth || 0}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {

            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }

            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Line.tsx">
import { useRef, useEffect } from 'react'
import { Line as KonvaLine, Arrow, Transformer } from 'react-konva'
import type Konva from 'konva'

interface LineProps {
  id: string
  points: number[]
  fill: string
  stroke?: string
  strokeWidth?: number
  arrows?: { start?: boolean; end?: boolean }
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (points: number[], x: number, y: number) => void
}






export default function Line({
  id: _id,
  points,
  fill,
  stroke: _stroke,
  strokeWidth = 2,
  arrows,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: LineProps) {
  const shapeRef = useRef<Konva.Line | Konva.Arrow>(null)
  const trRef = useRef<Konva.Transformer>(null)


  const x = points[0]
  const y = points[1]


  const relativePoints = [0, 0, points[2] - points[0], points[3] - points[1]]


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)


    const currentPoints = (node as any).points() || relativePoints
    const newPoints = [
      currentPoints[0],
      currentPoints[1],
      currentPoints[2] * scaleX,
      currentPoints[3] * scaleY,
    ]


    const absPoints = [
      node.x() + newPoints[0],
      node.y() + newPoints[1],
      node.x() + newPoints[2],
      node.y() + newPoints[3],
    ]

    onTransformEnd(absPoints, node.x(), node.y())
  }


  const hasArrows = arrows?.start || arrows?.end


  const lineColor = _stroke || fill

  return (
    <>
      {hasArrows ? (
        <Arrow
          ref={shapeRef as any}
          x={x}
          y={y}
          points={relativePoints}
          stroke={lineColor}
          strokeWidth={strokeWidth}
          fill={lineColor}
          pointerAtBeginning={arrows.start}
          pointerAtEnding={arrows.end}
          pointerLength={10}
          pointerWidth={10}
          draggable
          onClick={onSelect}
          onTap={onSelect}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
          onTransformEnd={handleTransformEnd}
        />
      ) : (
        <KonvaLine
          ref={shapeRef as any}
          x={x}
          y={y}
          points={relativePoints}
          stroke={lineColor}
          strokeWidth={strokeWidth}
          lineCap="round"
          lineJoin="round"
          draggable
          onClick={onSelect}
          onTap={onSelect}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
          onTransformEnd={handleTransformEnd}
        />
      )}

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(_oldBox, newBox) => {

            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={false}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Path.tsx">
import { useRef, useEffect } from 'react'
import { Line, Transformer } from 'react-konva'
import type Konva from 'konva'

interface PathProps {
  id: string
  points: number[]
  stroke: string
  strokeWidth: number
  tension?: number
  closed?: boolean
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (points: number[], x: number, y: number) => void
}





export default function Path({
  id: _id,
  points,
  stroke,
  strokeWidth,
  tension = 0,
  closed = false,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: PathProps) {
  const shapeRef = useRef<Konva.Line>(null)
  const trRef = useRef<Konva.Transformer>(null)


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)


    const currentPoints = node.points()
    const scaledPoints = currentPoints.map((point, index) => {
      if (index % 2 === 0) {

        return point * scaleX
      } else {

        return point * scaleY
      }
    })

    onTransformEnd(scaledPoints, node.x(), node.y())
  }

  return (
    <>
      {}
      <Line
        ref={shapeRef}
        points={points}
        stroke={stroke}
        strokeWidth={strokeWidth}
        tension={tension}
        closed={closed}
        lineCap="round"
        lineJoin="round"
        bezier={tension > 0}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Polygon.tsx">
import { useRef, useEffect } from 'react'
import { RegularPolygon, Transformer } from 'react-konva'
import type Konva from 'konva'

interface PolygonProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  sides: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}






export default function Polygon({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  sides,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: PolygonProps) {
  const shapeRef = useRef<Konva.RegularPolygon>(null)
  const trRef = useRef<Konva.Transformer>(null)


  const radius = (width + height) / 4


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])


  useEffect(() => {
    if (shapeRef.current && sides > 6) {
      shapeRef.current.cache()
    }
  }, [sides])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)


    const newRadius = node.radius() * Math.max(scaleX, scaleY)
    const newWidth = newRadius * 2
    const newHeight = newRadius * 2

    onTransformEnd(
      Math.max(10, newWidth),
      Math.max(10, newHeight),
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {}
      <RegularPolygon
        ref={shapeRef}
        x={x + radius}
        y={y + radius}
        sides={Math.max(3, Math.min(12, sides))}
        radius={radius}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {

            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }

            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/Rectangle.tsx">
import { useRef, useEffect } from 'react'
import { Rect, Transformer } from 'react-konva'
import type Konva from 'konva'

interface RectangleProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}






export default function Rectangle({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: RectangleProps) {
  const shapeRef = useRef<Konva.Rect>(null)
  const trRef = useRef<Konva.Transformer>(null)


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)

    onTransformEnd(
      Math.max(10, node.width() * scaleX),
      Math.max(10, node.height() * scaleY),
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {}
      <Rect
        ref={shapeRef}
        x={x}
        y={y}
        width={width}
        height={height}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {

            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }

            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/RoundedRect.tsx">
import { useRef, useEffect } from 'react'
import { Rect, Transformer } from 'react-konva'
import type Konva from 'konva'

interface RoundedRectProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  cornerRadius: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}






export default function RoundedRect({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  cornerRadius,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: RoundedRectProps) {
  const shapeRef = useRef<Konva.Rect>(null)
  const trRef = useRef<Konva.Transformer>(null)


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)

    onTransformEnd(
      Math.max(10, node.width() * scaleX),
      Math.max(10, node.height() * scaleY),
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {}
      <Rect
        ref={shapeRef}
        x={x}
        y={y}
        width={width}
        height={height}
        cornerRadius={Math.max(0, Math.min(50, cornerRadius))}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {

            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }

            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/SelectionBox.tsx">
import { memo } from 'react'
import { Rect } from 'react-konva'
import { getSelectionBoxBounds } from '../../types/selection'
import type { SelectionBox as SelectionBoxType } from '../../types/selection'

interface SelectionBoxProps {
  selectionBox: SelectionBoxType
}








export const SelectionBox = memo(function SelectionBox({ selectionBox }: SelectionBoxProps) {

  if (!selectionBox.visible) {
    return null
  }


  const bounds = getSelectionBoxBounds(selectionBox)

  return (
    <Rect
      x={bounds.x}
      y={bounds.y}
      width={bounds.width}
      height={bounds.height}
      fill="rgba(59, 130, 246, 0.1)"
      stroke="#3B82F6"
      strokeWidth={1}
      dash={[5, 5]}
      listening={false}
      perfectDrawEnabled={false}
    />
  )
})
</file>

<file path="src/components/shapes/Star.tsx">
import { useRef, useEffect } from 'react'
import { Star as KonvaStar, Transformer } from 'react-konva'
import type Konva from 'konva'

interface StarProps {
  id: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  fill: string
  stroke?: string
  strokeWidth?: number
  sides: number
  isSelected: boolean
  selectionColor?: string
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
}






export default function Star({
  id: _id,
  x,
  y,
  width,
  height,
  rotation = 0,
  fill,
  stroke,
  strokeWidth = 0,
  sides,
  isSelected,
  selectionColor: _selectionColor,
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
}: StarProps) {
  const shapeRef = useRef<Konva.Star>(null)
  const trRef = useRef<Konva.Transformer>(null)


  const outerRadius = (width + height) / 4
  const innerRadius = outerRadius * 0.5


  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])


  useEffect(() => {
    if (shapeRef.current && sides > 6) {
      shapeRef.current.cache()
    }
  }, [sides])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()
    const scaleY = node.scaleY()


    node.scaleX(1)
    node.scaleY(1)


    const newOuterRadius = node.outerRadius() * Math.max(scaleX, scaleY)
    const newWidth = newOuterRadius * 2
    const newHeight = newOuterRadius * 2

    onTransformEnd(
      Math.max(10, newWidth),
      Math.max(10, newHeight),
      node.rotation(),
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {}
      <KonvaStar
        ref={shapeRef}
        x={x + outerRadius}
        y={y + outerRadius}
        numPoints={Math.max(3, Math.min(12, sides))}
        innerRadius={innerRadius}
        outerRadius={outerRadius}
        rotation={rotation}
        fill={fill}
        stroke={strokeWidth && strokeWidth > 0 ? stroke : undefined}
        strokeWidth={strokeWidth}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {

            if (newBox.width < 10 || newBox.height < 10) {
              return oldBox
            }

            if (newBox.width > 5000 || newBox.height > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
          ]}
          rotateEnabled={true}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/shapes/TextShape.tsx">
import { useRef, useEffect } from 'react'
import { Text, Transformer } from 'react-konva'
import type Konva from 'konva'

interface TextShapeProps {
  id: string
  x: number
  y: number
  text: string
  width: number
  height: number
  rotation?: number
  fill: string
  isSelected: boolean
  selectionColor?: string

  fontFamily?: string
  fontSize?: number
  fontWeight?: 'normal' | 'bold'
  fontStyle?: 'normal' | 'italic'
  textAlign?: 'left' | 'center' | 'right'
  textDecoration?: '' | 'underline' | 'line-through'
  onSelect: (e: Konva.KonvaEventObject<MouseEvent>) => void
  onDragStart: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  onTransformEnd: (width: number, height: number, rotation: number, x: number, y: number) => void
  onDoubleClick?: () => void
}







export default function TextShape({
  id: _id,
  x,
  y,
  text,
  width,
  height: _height,
  rotation = 0,
  fill,
  isSelected,
  selectionColor: _selectionColor,
  fontFamily = 'Inter, sans-serif',
  fontSize = 20,
  fontWeight = 'normal',
  fontStyle = 'normal',
  textAlign = 'left',
  textDecoration = '',
  onSelect,
  onDragStart,
  onDragEnd,
  onTransformEnd,
  onDoubleClick,
}: TextShapeProps) {
  const shapeRef = useRef<Konva.Text>(null)
  const trRef = useRef<Konva.Transformer>(null)

  // Attach transformer to shape when selected
  useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current])
      trRef.current.getLayer()?.batchDraw()
    }
  }, [isSelected])

  const handleDragStart = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragStart(node.x(), node.y())
  }

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target
    onDragEnd(node.x(), node.y())
  }

  const handleTransformEnd = () => {
    const node = shapeRef.current
    if (!node) return

    const scaleX = node.scaleX()

    // Reset scale to 1 and apply to width instead
    node.scaleX(1)
    node.scaleY(1)

    // Text height auto-adjusts based on content and width
    onTransformEnd(
      Math.max(50, node.width() * scaleX), // min width 50px
      node.height(), // auto-calculated by Konva
      0, // no rotation for text
      node.x(),
      node.y()
    )
  }

  return (
    <>
      {/* Main Text - PR-25: Now with font properties and double-click */}
      <Text
        ref={shapeRef}
        x={x}
        y={y}
        text={text}
        fontSize={fontSize}
        fontFamily={fontFamily}
        fontStyle={`${fontStyle} ${fontWeight}`} // Konva combines style and weight
        textDecoration={textDecoration}
        align={textAlign}
        fill={fill}
        width={width}
        rotation={rotation}
        draggable
        onClick={onSelect}
        onTap={onSelect}
        onDblClick={onDoubleClick}
        onDblTap={onDoubleClick}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onTransformEnd={handleTransformEnd}
      />

      {/* Transformer for width resize only (no rotation for text) - Figma style (PR-20) */}
      {isSelected && (
        <Transformer
          ref={trRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit minimum width
            if (newBox.width < 50) {
              return oldBox
            }
            // Limit maximum width to canvas bounds
            if (newBox.width > 5000) {
              return oldBox
            }
            return newBox
          }}
          enabledAnchors={[
            'middle-left',
            'middle-right',
          ]}
          rotateEnabled={false}
          borderStroke="#6366F1"
          borderStrokeWidth={2}
          anchorFill="#FFFFFF"
          anchorStroke="#6366F1"
          anchorStrokeWidth={2}
          anchorSize={8}
          anchorCornerRadius={2}
        />
      )}
    </>
  )
}
</file>

<file path="src/components/Skeleton.tsx">
interface SkeletonProps {
  width?: string | number
  height?: string | number
  className?: string
  circle?: boolean
  count?: number
}





export function Skeleton({
  width,
  height,
  className = '',
  circle = false,
  count = 1,
}: SkeletonProps) {
  const skeletonStyle: React.CSSProperties = {
    width: typeof width === 'number' ? `${width}px` : width,
    height: typeof height === 'number' ? `${height}px` : height,
  }

  const baseClasses = `bg-neutral-200 animate-pulse ${circle ? 'rounded-full' : 'rounded'} ${className}`

  if (count > 1) {
    return (
      <>
        {Array.from({ length: count }).map((_, index) => (
          <div key={index} className={baseClasses} style={skeletonStyle} />
        ))}
      </>
    )
  }

  return <div className={baseClasses} style={skeletonStyle} />
}




export function SkeletonText({ lines = 1 }: { lines?: number }) {
  return (
    <div className="space-y-2">
      {Array.from({ length: lines }).map((_, index) => (
        <div
          key={index}
          className="h-4 bg-neutral-200 animate-pulse rounded"
          style={{
            width: index === lines - 1 ? '80%' : '100%',
          }}
        />
      ))}
    </div>
  )
}




export function SkeletonCard() {
  return (
    <div className="bg-white rounded-lg border border-neutral-200 p-4 space-y-3">
      {}
      <Skeleton height={180} className="w-full" />
      {}
      <Skeleton height={20} width="70%" />
      {}
      <Skeleton height={16} width="50%" />
    </div>
  )
}




export function SkeletonList({ count = 5 }: { count?: number }) {
  return (
    <div className="space-y-2">
      {Array.from({ length: count }).map((_, index) => (
        <div key={index} className="flex items-center gap-2 px-2 py-1.5">
          <Skeleton width={16} height={16} />
          <Skeleton height={20} className="flex-1" />
          <Skeleton width={16} height={16} />
        </div>
      ))}
    </div>
  )
}




export function SkeletonCanvas() {
  return (
    <div className="w-full h-full bg-neutral-100 flex items-center justify-center">
      <div className="text-center space-y-4">
        <div className="inline-block">
          <Skeleton width={64} height={64} circle />
        </div>
        <SkeletonText lines={2} />
      </div>
    </div>
  )
}




export function LoadingSpinner({ size = 24 }: { size?: number }) {
  return (
    <div
      className="inline-block animate-spin rounded-full border-2 border-neutral-300 border-t-primary-600"
      style={{ width: size, height: size }}
    />
  )
}
</file>

<file path="src/components/TextEditor.tsx">
import React, { useState, useRef, useEffect } from 'react'






interface TextEditorProps {
  initialText: string
  x: number
  y: number
  width: number
  fontFamily?: string
  fontSize?: number
  fontWeight?: 'normal' | 'bold'
  fontStyle?: 'normal' | 'italic'
  textAlign?: 'left' | 'center' | 'right'
  fill: string
  onSave: (newText: string) => void
  onCancel: () => void
}

export const TextEditor: React.FC<TextEditorProps> = ({
  initialText,
  x,
  y,
  width,
  fontFamily = 'Inter, sans-serif',
  fontSize = 20,
  fontWeight = 'normal',
  fontStyle = 'normal',
  textAlign = 'left',
  fill,
  onSave,
  onCancel,
}) => {
  const [text, setText] = useState(initialText)
  const editorRef = useRef<HTMLDivElement>(null)

  useEffect(() => {

    if (editorRef.current) {
      editorRef.current.focus()


      const range = document.createRange()
      range.selectNodeContents(editorRef.current)
      const selection = window.getSelection()
      selection?.removeAllRanges()
      selection?.addRange(range)
    }
  }, [])

  const handleBlur = () => {
    const trimmedText = text.trim()
    if (trimmedText && trimmedText !== initialText.trim()) {
      onSave(trimmedText)
    } else if (trimmedText) {

      onCancel()
    } else {

      onCancel()
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      e.preventDefault()
      onCancel()
    }

  }

  const handleInput = (e: React.FormEvent<HTMLDivElement>) => {
    setText(e.currentTarget.textContent || '')
  }

  return (
    <div
      className="absolute bg-white border-2 border-blue-500 rounded shadow-lg z-[1000]"
      style={{
        left: x,
        top: y,
        width: width,
      }}
    >
      <div
        ref={editorRef}
        contentEditable
        suppressContentEditableWarning
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
        onInput={handleInput}
        className="px-2 py-1 min-h-[30px] outline-none whitespace-pre-wrap break-words overflow-hidden"
        style={{
          fontFamily,
          fontSize: `${fontSize}px`,
          fontWeight,
          fontStyle,
          textAlign: textAlign as any,
          color: fill.slice(0, 7), // Remove alpha for text color
          lineHeight: '1.2',
        }}
      >
        {initialText}
      </div>
      <div className="text-xs text-gray-500 px-2 pb-1 border-t bg-gray-50">
        Press Esc to cancel • Click outside to save
      </div>
    </div>
  )
}
</file>

<file path="src/components/TilemapGrid.tsx">
import { useMemo } from 'react'
import { Layer, Line } from 'react-konva'

interface TilemapGridProps {
  tileSize: number
  viewportX: number
  viewportY: number
  viewportWidth: number
  viewportHeight: number
  visible?: boolean
  opacity?: number
  color?: string
}





export default function TilemapGrid({
  tileSize,
  viewportX,
  viewportY,
  viewportWidth,
  viewportHeight,
  visible = true,
  opacity = 0.3,
  color = '#94a3b8',
}: TilemapGridProps) {

  const gridLines = useMemo(() => {
    if (!visible) return { vertical: [], horizontal: [] }


    const startX = Math.floor(viewportX / tileSize) * tileSize
    const endX = Math.ceil((viewportX + viewportWidth) / tileSize) * tileSize
    const startY = Math.floor(viewportY / tileSize) * tileSize
    const endY = Math.ceil((viewportY + viewportHeight) / tileSize) * tileSize

    const vertical: number[][] = []
    const horizontal: number[][] = []


    for (let x = startX; x <= endX; x += tileSize) {
      if (x >= 0) {
        vertical.push([x, Math.max(0, startY), x, endY])
      }
    }


    for (let y = startY; y <= endY; y += tileSize) {
      if (y >= 0) {
        horizontal.push([Math.max(0, startX), y, endX, y])
      }
    }

    return { vertical, horizontal }
  }, [tileSize, viewportX, viewportY, viewportWidth, viewportHeight, visible])

  return (
    <Layer
      listening={false}
      perfectDrawEnabled={false}
      visible={visible}
    >
      {}
      {gridLines.vertical.map((points, index) => (
        <Line
          key={`v-${index}`}
          points={points}
          stroke={color}
          strokeWidth={1}
          opacity={opacity}
          listening={false}
          perfectDrawEnabled={false}
        />
      ))}

      {}
      {gridLines.horizontal.map((points, index) => (
        <Line
          key={`h-${index}`}
          points={points}
          stroke={color}
          strokeWidth={1}
          opacity={opacity}
          listening={false}
          perfectDrawEnabled={false}
        />
      ))}
    </Layer>
  )
}
</file>

<file path="src/components/TilemapLayer.tsx">
import { useEffect } from 'react'
import TilemapGrid from './TilemapGrid'
import TileRenderer from './TileRenderer'
import type { TileData } from '../types/tilemap'

interface TilemapLayerProps {
  tiles: Map<string, TileData>
  tileSize: number
  showGrid: boolean
  previewTile?: { x: number; y: number; tile: TileData } | null
  viewportX: number
  viewportY: number
  viewportWidth: number
  viewportHeight: number
  onViewportChange?: (viewport: { x: number; y: number; width: number; height: number }) => void
}






export default function TilemapLayer({
  tiles,
  tileSize,
  showGrid,
  previewTile,
  viewportX,
  viewportY,
  viewportWidth,
  viewportHeight,
  onViewportChange,
}: TilemapLayerProps) {

  useEffect(() => {
    if (onViewportChange) {
      onViewportChange({ x: viewportX, y: viewportY, width: viewportWidth, height: viewportHeight })
    }
  }, [viewportX, viewportY, viewportWidth, viewportHeight, onViewportChange])

  return (
    <>
      {}
      <TilemapGrid
        tileSize={tileSize}
        viewportX={viewportX}
        viewportY={viewportY}
        viewportWidth={viewportWidth}
        viewportHeight={viewportHeight}
        visible={showGrid}
      />

      {}
      <TileRenderer
        tiles={tiles}
        tileSize={tileSize}
        viewportX={viewportX}
        viewportY={viewportY}
        viewportWidth={viewportWidth}
        viewportHeight={viewportHeight}
        previewTile={previewTile}
      />
    </>
  )
}
</file>

<file path="src/components/TilePalette.tsx">
import { useEffect } from 'react'
import type { TileMode, PaletteColor } from '../types/tilemap'
import { ToolButton } from './ToolButton'

interface TilePaletteProps {
  palette: PaletteColor[]
  selectedIndex: number
  onSelectIndex: (index: number) => void
  mode: TileMode
  onModeChange: (mode: TileMode) => void
  tileSize: number
  onTileSizeChange: (size: number) => void
  tileCount: number
  cursorPosition?: { x: number; y: number }
  showGrid?: boolean
  onToggleGrid?: () => void
}





export default function TilePalette({
  palette,
  selectedIndex,
  onSelectIndex,
  mode,
  onModeChange,
  tileSize,
  onTileSizeChange,
  tileCount,
  cursorPosition,
  showGrid = true,
  onToggleGrid,
}: TilePaletteProps) {

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {

      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return
      }


      const key = parseInt(e.key)
      if (key >= 1 && key <= Math.min(9, palette.length)) {
        onSelectIndex(key - 1)
        e.preventDefault()
      }


      switch (e.key.toLowerCase()) {
        case 'b':
          onModeChange('stamp')
          e.preventDefault()
          break
        case 'e':
          onModeChange('erase')
          e.preventDefault()
          break
        case 'f':
          onModeChange('fill')
          e.preventDefault()
          break
        case 'i':
          onModeChange('pick')
          e.preventDefault()
          break
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [palette.length, onSelectIndex, onModeChange])

  const modes: Array<{
    mode: TileMode
    icon: JSX.Element
    label: string
    shortcut: string
  }> = [
    {
      mode: 'stamp',
      icon: <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>,
      label: 'Paint',
      shortcut: 'B'
    },
    {
      mode: 'erase',
      icon: <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
      label: 'Erase',
      shortcut: 'E'
    },
    {
      mode: 'fill',
      icon: <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M10 3.5a1.5 1.5 0 013 0V4a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-.5a1.5 1.5 0 000 3h.5a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-.5a1.5 1.5 0 00-3 0v.5a1 1 0 01-1 1H6a1 1 0 01-1-1v-3a1 1 0 00-1-1h-.5a1.5 1.5 0 010-3H4a1 1 0 001-1V6a1 1 0 011-1h3a1 1 0 001-1v-.5z" /></svg>,
      label: 'Fill',
      shortcut: 'F'
    },
    {
      mode: 'pick',
      icon: <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" /></svg>,
      label: 'Eyedropper',
      shortcut: 'I'
    },
  ]

  const tileSizes = [8, 16, 32]

  return (
    <div
      className="w-56 h-full rounded-r-lg shadow-lg flex flex-col relative overflow-hidden flex-shrink-0"
      style={{
        background: 'linear-gradient(to bottom right, #475569, #374151)',
        minWidth: '224px'
      }}
    >
      {}
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>

      {}
      <div className="relative z-10 flex flex-col h-full p-2 gap-1.5 overflow-hidden">
        {}
        <div className="text-white/90 font-semibold text-xs flex-shrink-0">
          Tilemap Tools
        </div>

        {}
        <div className="flex flex-col gap-1 flex-shrink-0">
          <div className="text-white/70 text-[10px] uppercase tracking-wide">Mode</div>
          <div className="grid grid-cols-2 gap-1">
            {modes.map((modeOption) => (
              <button
                key={modeOption.mode}
                onClick={() => onModeChange(modeOption.mode)}
                className={`
                  px-2 py-2 rounded text-[10px] font-medium transition-all
                  ${mode === modeOption.mode
                    ? 'bg-blue-500 text-white shadow-md'
                    : 'bg-white/10 text-white/80 hover:bg-white/20'
                  }
                `}
                title={`${modeOption.label} (${modeOption.shortcut})`}
              >
                <div className="flex flex-col items-center gap-1">
                  {modeOption.icon}
                  <span>{modeOption.label}</span>
                </div>
              </button>
            ))}
          </div>
        </div>

        {}
        <div className="flex flex-col gap-1 flex-shrink-0">
          <div className="text-white/70 text-[10px] uppercase tracking-wide">Tile Size</div>
          <div className="flex gap-1">
            {tileSizes.map((size) => (
              <button
                key={size}
                onClick={() => onTileSizeChange(size)}
                className={`
                  flex-1 px-2 py-1.5 rounded text-[10px] font-medium transition-all
                  ${tileSize === size
                    ? 'bg-blue-500 text-white shadow-md'
                    : 'bg-white/10 text-white/80 hover:bg-white/20'
                  }
                `}
              >
                {size}×{size}
              </button>
            ))}
          </div>
        </div>

        {}
        {onToggleGrid && (
          <div className="flex flex-col gap-1 flex-shrink-0">
            <div className="text-white/70 text-[10px] uppercase tracking-wide">View</div>
            <button
              onClick={onToggleGrid}
              className={`
                px-2 py-1.5 rounded text-[10px] font-medium transition-all flex items-center gap-2
                ${showGrid
                  ? 'bg-blue-500 text-white shadow-md'
                  : 'bg-white/10 text-white/80 hover:bg-white/20'
                }
              `}
              title="Toggle Grid (G)"
            >
              <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 5a1 1 0 011-1h4a1 1 0 011 1v7H4V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v7h-6V5zM4 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3zM14 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1h-4a1 1 0 01-1-1v-3z" />
              </svg>
              <span className="flex-1 text-left">{showGrid ? 'Hide Grid' : 'Show Grid'}</span>
              <span className="text-white/50 text-[10px] font-mono">G</span>
            </button>
          </div>
        )}

        {}
        <div className="flex flex-col gap-1 flex-shrink-0">
          <div className="text-white/70 text-[10px] uppercase tracking-wide">
            Colors
          </div>
          <div className="grid grid-cols-3 gap-0.5">
            {palette.map((paletteColor, index) => (
              <button
                key={index}
                onClick={() => onSelectIndex(index)}
                className={`
                  w-full aspect-square rounded transition-all relative group
                  ${selectedIndex === index
                    ? 'ring-2 ring-blue-400 scale-105'
                    : 'ring-1 ring-white/30 hover:ring-white/50'
                  }
                `}
                style={{ backgroundColor: paletteColor.color }}
                title={`${paletteColor.name}${index < 9 ? ` (${index + 1})` : ''}`}
              >
                {}
                {index < 9 && (
                  <div className="absolute top-0.5 right-0.5 text-[8px] font-mono bg-black/50 text-white px-1 rounded">
                    {index + 1}
                  </div>
                )}
              </button>
            ))}
          </div>
        </div>

        {}
        <div className="flex flex-col gap-0.5 text-[9px] flex-shrink-0 mt-auto">
          {cursorPosition && (
            <div className="flex justify-between text-white/70">
              <span>Pos:</span>
              <span className="font-mono text-white/90">
                {cursorPosition.x}, {cursorPosition.y}
              </span>
            </div>
          )}
          <div className="flex justify-between text-white/70">
            <span>Tiles:</span>
            <span className="font-mono text-white/90">{tileCount}</span>
          </div>
          <div className="flex justify-between text-white/70">
            <span>Mode:</span>
            <span className="font-mono text-white/90 capitalize">{mode}</span>
          </div>
        </div>

        {}
        <div className="flex flex-col gap-1 text-[9px] flex-shrink-0">
          <div className="text-white/70 text-[10px] uppercase tracking-wide">Shortcuts</div>
          <div className="flex items-center gap-1.5 text-white/60">
            <kbd className="px-1 py-0.5 bg-white/10 rounded font-mono text-[8px]">Space</kbd>
            <span>Pan</span>
          </div>
          <div className="flex items-center gap-1.5 text-white/60">
            <kbd className="px-1 py-0.5 bg-white/10 rounded font-mono text-[8px]">Scroll</kbd>
            <span>Zoom</span>
          </div>
          <div className="flex items-center gap-1.5 text-white/60">
            <kbd className="px-1 py-0.5 bg-white/10 rounded font-mono text-[8px]">Drag</kbd>
            <span>Paint</span>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/TileRenderer.tsx">
import { useMemo } from 'react'
import { Layer, Rect } from 'react-konva'
import type { TileData } from '../types/tilemap'
import { coordToKey } from '../types/tilemap'

interface TileRendererProps {
  tiles: Map<string, TileData>
  tileSize: number
  viewportX: number
  viewportY: number
  viewportWidth: number
  viewportHeight: number
  previewTile?: { x: number; y: number; tile: TileData } | null
  showPreview?: boolean
}





export default function TileRenderer({
  tiles,
  tileSize,
  viewportX,
  viewportY,
  viewportWidth,
  viewportHeight,
  previewTile,
  showPreview = true,
}: TileRendererProps) {

  const visibleTiles = useMemo(() => {
    const visible: Array<{ key: string; x: number; y: number; tile: TileData }> = []


    const padding = 2
    const startX = Math.max(0, Math.floor(viewportX / tileSize) - padding)
    const endX = Math.ceil((viewportX + viewportWidth) / tileSize) + padding
    const startY = Math.max(0, Math.floor(viewportY / tileSize) - padding)
    const endY = Math.ceil((viewportY + viewportHeight) / tileSize) + padding


    tiles.forEach((tile, key) => {
      const [xStr, yStr] = key.split('_')
      const x = parseInt(xStr, 10)
      const y = parseInt(yStr, 10)


      if (x >= startX && x <= endX && y >= startY && y <= endY) {
        visible.push({ key, x, y, tile })
      }
    })

    return visible
  }, [tiles, tileSize, viewportX, viewportY, viewportWidth, viewportHeight])

  return (
    <Layer
      listening={false}
      perfectDrawEnabled={false}
    >
      {}
      {visibleTiles.map(({ key, x, y, tile }) => (
        <Rect
          key={key}
          x={x * tileSize}
          y={y * tileSize}
          width={tileSize}
          height={tileSize}
          fill={tile.color}
          stroke="rgba(0, 0, 0, 0.1)"
          strokeWidth={1}
          listening={false}
          perfectDrawEnabled={false}
        />
      ))}

      {}
      {showPreview && previewTile && (
        <Rect
          x={previewTile.x * tileSize}
          y={previewTile.y * tileSize}
          width={tileSize}
          height={tileSize}
          fill={previewTile.tile.color}
          opacity={0.5}
          stroke="#3b82f6"
          strokeWidth={2}
          dash={[4, 4]}
          listening={false}
          perfectDrawEnabled={false}
        />
      )}
    </Layer>
  )
}
</file>

<file path="src/components/TileStatusBar.tsx">
import type { TileMode, ConnectionStatus } from '../types/tilemap'

interface TileStatusBarProps {
  cursorPosition?: { x: number; y: number }
  tileCount: number
  mode: TileMode
  tileSize: number
  zoom: number
  connectionStatus: ConnectionStatus
}





export default function TileStatusBar({
  cursorPosition,
  tileCount,
  mode,
  tileSize,
  zoom,
  connectionStatus,
}: TileStatusBarProps) {
  const connectionIndicators = {
    connected: { icon: '🟢', text: 'Connected', color: 'text-green-400' },
    disconnected: { icon: '🔴', text: 'Disconnected', color: 'text-red-400' },
    reconnecting: { icon: '🟡', text: 'Reconnecting...', color: 'text-yellow-400' },
  }

  const modeIcons: Record<TileMode, string> = {
    stamp: '🖌️',
    erase: '🧽',
    fill: '🪣',
    pick: '💧',
  }

  const indicator = connectionIndicators[connectionStatus]

  return (
    <div className="absolute bottom-0 left-0 right-0 h-8 bg-slate-800/95 backdrop-blur-sm border-t border-slate-700 flex items-center px-4 gap-6 text-xs text-white/80 font-mono">
      {}
      {cursorPosition && (
        <div className="flex items-center gap-2">
          <span className="text-white/50">Tile:</span>
          <span className="text-white/90 font-semibold">
            X: {cursorPosition.x}, Y: {cursorPosition.y}
          </span>
        </div>
      )}

      {}
      {cursorPosition && <div className="h-4 w-px bg-white/20" />}

      {}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Tiles:</span>
        <span className="text-white/90 font-semibold">{tileCount}</span>
      </div>

      {}
      <div className="h-4 w-px bg-white/20" />

      {}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Mode:</span>
        <span className="text-white/90 font-semibold flex items-center gap-1">
          <span>{modeIcons[mode]}</span>
          <span className="capitalize">{mode}</span>
        </span>
      </div>

      {}
      <div className="h-4 w-px bg-white/20" />

      {}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Tile Size:</span>
        <span className="text-white/90 font-semibold">{tileSize}×{tileSize}px</span>
      </div>

      {}
      <div className="h-4 w-px bg-white/20" />

      {}
      <div className="flex items-center gap-2">
        <span className="text-white/50">Zoom:</span>
        <span className="text-white/90 font-semibold">{Math.round(zoom * 100)}%</span>
      </div>

      {}
      <div className="flex-1" />

      {}
      <div className={`flex items-center gap-2 ${indicator.color}`}>
        <span>{indicator.icon}</span>
        <span className="font-semibold">{indicator.text}</span>
      </div>
    </div>
  )
}
</file>

<file path="src/components/Toolbar.tsx">
import type { ToolType } from '../types/canvas'
import { ToolButton } from './ToolButton'

interface ToolbarProps {
  selectedTool: ToolType
  onToolSelect: (tool: ToolType) => void
  hasSelection: boolean
  onDelete: () => void

  canUndo?: boolean
  canRedo?: boolean
  onUndo?: () => void
  onRedo?: () => void
}





export default function Toolbar({
  selectedTool,
  onToolSelect,
  hasSelection,
  onDelete,
  canUndo = false,
  canRedo = false,
  onUndo,
  onRedo,
}: ToolbarProps) {
  const tools: Array<{
    type: ToolType
    icon: string
    label: string
    shortcut?: string
  }> = [

    { type: 'select', icon: '➤', label: 'Select', shortcut: 'V' },
    { type: 'hand', icon: '✥', label: 'Hand', shortcut: 'H' },


    { type: 'rectangle', icon: '▭', label: 'Rectangle', shortcut: 'R' },
    { type: 'circle', icon: '●', label: 'Circle', shortcut: 'O' },
    { type: 'roundRect', icon: '▢', label: 'Rounded Rectangle' },


    { type: 'polygon', icon: '⬡', label: 'Polygon' },
    { type: 'star', icon: '★', label: 'Star' },
    { type: 'line', icon: '/', label: 'Line', shortcut: 'L' },


    { type: 'pencil', icon: '✎', label: 'Pencil', shortcut: 'P' },
    { type: 'pen', icon: '✒', label: 'Pen', shortcut: 'N' },


    { type: 'text', icon: 'T', label: 'Text', shortcut: 'T' },
  ]

  return (
    <div
      className="w-12 h-[calc(100%-16px)] my-2 ml-2 rounded-lg shadow-lg flex flex-col items-center py-3 gap-1 relative overflow-hidden"
      style={{
        background: 'linear-gradient(to bottom right, #475569, #374151)'
      }}
    >
      {}
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
          backgroundSize: '16px 16px'
        }}
      ></div>

      {}
      <div className="relative z-10 w-full flex flex-col items-center gap-1">
      {}
      {tools.map((tool, index) => (
        <div key={tool.type}>
          <ToolButton
            icon={tool.icon}
            label={tool.label}
            shortcut={tool.shortcut}
            active={selectedTool === tool.type}
            onClick={() => onToolSelect(tool.type)}
            themed={true}
          />

          {}
          {(index === 1 || index === 7 || index === 9) && (
            <div className="w-9 h-px my-1 bg-white/20" />
          )}
        </div>
      ))}

      {}
      <div className="flex-1" />

      {}
      {onUndo && (
        <ToolButton
          icon="↶"
          label="Undo"
          shortcut="Ctrl+Z"
          disabled={!canUndo}
          onClick={onUndo}
          themed={true}
        />
      )}

      {onRedo && (
        <ToolButton
          icon="↷"
          label="Redo"
          shortcut="Ctrl+Shift+Z"
          disabled={!canRedo}
          onClick={onRedo}
          themed={true}
        />
      )}

      {}
      <div className="w-9 h-px my-1 bg-white/20" />

      {}
      <ToolButton
        icon="🗑"
        label="Delete"
        shortcut="Del"
        disabled={!hasSelection}
        onClick={onDelete}
        themed={true}
      />
      </div>
    </div>
  )
}
</file>

<file path="src/components/ToolButton.tsx">
import type { ReactNode } from 'react'
import { Tooltip } from './Tooltip'

interface ToolButtonProps {
  icon: ReactNode
  label: string
  shortcut?: string
  active?: boolean
  disabled?: boolean
  onClick: () => void
  themed?: boolean
}





export function ToolButton({
  icon,
  label,
  shortcut,
  active = false,
  disabled = false,
  onClick,
  themed = false,
}: ToolButtonProps) {
  const tooltipContent = shortcut ? `${label} (${shortcut})` : label

  return (
    <Tooltip content={tooltipContent} side="right">
      <button
        onClick={onClick}
        disabled={disabled}
        className={`
          w-9 h-9 rounded-lg flex items-center justify-center
          transition-all duration-150 relative
          focus:outline-none
          ${
            active
              ? themed
                ? 'bg-white/30 text-white shadow-sm'
                : 'bg-blue-500 text-white shadow-md'
              : disabled
              ? themed
                ? 'bg-white/10 text-white/40 cursor-not-allowed'
                : 'bg-neutral-50 text-neutral-400 cursor-not-allowed'
              : themed
                ? 'bg-white/15 text-white hover:bg-white/25'
                : 'bg-neutral-50 text-neutral-700 hover:bg-neutral-100'
          }
        `}
      >
        <span className="text-lg">{icon}</span>
        {active && (
          <div className="absolute inset-0 rounded-lg ring-2 ring-white ring-opacity-50" />
        )}
      </button>
    </Tooltip>
  )
}
</file>

<file path="src/components/Tooltip.tsx">
import { useState, useRef, useEffect, type ReactNode } from 'react'

interface TooltipProps {
  content: string
  children: ReactNode
  side?: 'top' | 'right' | 'bottom' | 'left'
  delay?: number
}





export function Tooltip({
  content,
  children,
  side = 'right',
  delay = 300
}: TooltipProps) {
  const [visible, setVisible] = useState(false)
  const [position, setPosition] = useState({ x: 0, y: 0 })
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined)
  const triggerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    return () => {
      if (timeoutRef.current !== undefined) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [])

  const handleMouseEnter = () => {
    timeoutRef.current = window.setTimeout(() => {
      if (triggerRef.current) {
        const rect = triggerRef.current.getBoundingClientRect()


        let x = 0
        let y = 0

        switch (side) {
          case 'right':
            x = rect.right + 8
            y = rect.top + rect.height / 2
            break
          case 'left':
            x = rect.left - 8
            y = rect.top + rect.height / 2
            break
          case 'top':
            x = rect.left + rect.width / 2
            y = rect.top - 8
            break
          case 'bottom':
            x = rect.left + rect.width / 2
            y = rect.bottom + 8
            break
        }

        setPosition({ x, y })
        setVisible(true)
      }
    }, delay)
  }

  const handleMouseLeave = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }
    setVisible(false)
  }

  return (
    <>
      <div
        ref={triggerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        style={{ display: 'inline-block' }}
      >
        {children}
      </div>

      {visible && (
        <div
          className="fixed z-[9999] pointer-events-none"
          style={{
            left: `${position.x}px`,
            top: `${position.y}px`,
            transform: side === 'right' || side === 'left'
              ? 'translateY(-50%)'
              : 'translateX(-50%)',
          }}
        >
          <div className="bg-neutral-800 text-white text-xs px-2 py-1 rounded shadow-cursor whitespace-nowrap">
            {content}
          </div>
        </div>
      )}
    </>
  )
}
</file>

<file path="src/components/ZoomControls.tsx">
import { Tooltip } from './Tooltip'

interface ZoomControlsProps {
  scale: number
  onZoomIn: () => void
  onZoomOut: () => void
  onZoomReset: () => void
  onZoomFit: () => void
  collabTheme?: {
    primary: string
    secondary: string
    gradient: string
    displayName: string
    softBg: string
    softBorder: string
  } | null
}





export function ZoomControls({
  scale,
  onZoomIn,
  onZoomOut,
  onZoomReset,
  onZoomFit,
  collabTheme,
}: ZoomControlsProps) {
  const percentage = Math.round(scale * 100)

  return (
    <div className={`flex items-center gap-1 rounded-lg px-1 py-1 ${
      collabTheme ? 'bg-white/60' : 'bg-neutral-100'
    }`}>
      {}
      <Tooltip content="Zoom out" side="bottom">
        <button
          onClick={onZoomOut}
          className={`w-7 h-7 flex items-center justify-center rounded transition-colors ${
            collabTheme ? 'hover:bg-white/80 text-gray-900' : 'hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          <span>−</span>
        </button>
      </Tooltip>

      {}
      <Tooltip content="Reset zoom to 100%" side="bottom">
        <button
          onClick={onZoomReset}
          className={`min-w-[52px] h-7 px-2 flex items-center justify-center rounded transition-colors ${
            collabTheme ? 'hover:bg-white/80' : 'hover:bg-neutral-200'
          }`}
        >
          <span className={`text-xs font-medium ${
            collabTheme ? 'text-gray-900' : 'text-neutral-700'
          }`}>
            {percentage}%
          </span>
        </button>
      </Tooltip>

      {}
      <Tooltip content="Zoom in" side="bottom">
        <button
          onClick={onZoomIn}
          className={`w-7 h-7 flex items-center justify-center rounded transition-colors ${
            collabTheme ? 'hover:bg-white/80 text-gray-900' : 'hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          <span>+</span>
        </button>
      </Tooltip>

      {}
      <div className={`w-px h-5 mx-0.5 ${
        collabTheme ? 'bg-gray-400' : 'bg-neutral-300'
      }`} />

      {}
      <Tooltip content="Fit to screen" side="bottom">
        <button
          onClick={onZoomFit}
          className={`w-7 h-7 flex items-center justify-center rounded transition-colors ${
            collabTheme ? 'hover:bg-white/80 text-gray-900' : 'hover:bg-neutral-200 text-neutral-700'
          }`}
        >
          <span className="text-sm">⊡</span>
        </button>
      </Tooltip>
    </div>
  )
}
</file>

<file path="src/constants/shortcuts.ts">
export interface KeyboardShortcut {
  key: string
  modifiers?: {
    ctrl?: boolean
    shift?: boolean
    alt?: boolean
  }
  description: string
  action: string
  category: string
}

export const KEYBOARD_SHORTCUTS: KeyboardShortcut[] = [

  {
    key: 'V',
    description: 'Select tool',
    action: 'selectTool',
    category: 'Tools',
  },
  {
    key: 'H',
    description: 'Hand tool (pan)',
    action: 'handTool',
    category: 'Tools',
  },
  {
    key: 'R',
    description: 'Rectangle',
    action: 'rectangleTool',
    category: 'Tools',
  },
  {
    key: 'O',
    description: 'Circle',
    action: 'circleTool',
    category: 'Tools',
  },
  {
    key: 'T',
    description: 'Text',
    action: 'textTool',
    category: 'Tools',
  },
  {
    key: 'L',
    description: 'Line',
    action: 'lineTool',
    category: 'Tools',
  },
  {
    key: 'P',
    description: 'Pencil (freehand)',
    action: 'pencilTool',
    category: 'Tools',
  },
  {
    key: 'N',
    description: 'Pen (smooth)',
    action: 'penTool',
    category: 'Tools',
  },
  {
    key: 'Space',
    description: 'Temporary hand tool',
    action: 'tempHandTool',
    category: 'Tools',
  },


  {
    key: 'C',
    modifiers: { ctrl: true },
    description: 'Copy',
    action: 'copy',
    category: 'Edit',
  },
  {
    key: 'V',
    modifiers: { ctrl: true },
    description: 'Paste',
    action: 'paste',
    category: 'Edit',
  },
  {
    key: 'D',
    modifiers: { ctrl: true },
    description: 'Duplicate',
    action: 'duplicate',
    category: 'Edit',
  },
  {
    key: 'A',
    modifiers: { ctrl: true },
    description: 'Select all',
    action: 'selectAll',
    category: 'Edit',
  },
  {
    key: 'Z',
    modifiers: { ctrl: true },
    description: 'Undo',
    action: 'undo',
    category: 'Edit',
  },
  {
    key: 'Z',
    modifiers: { ctrl: true, shift: true },
    description: 'Redo',
    action: 'redo',
    category: 'Edit',
  },
  {
    key: 'Delete',
    description: 'Delete',
    action: 'delete',
    category: 'Edit',
  },
  {
    key: 'Backspace',
    description: 'Delete',
    action: 'delete',
    category: 'Edit',
  },
  {
    key: 'Escape',
    description: 'Clear selection',
    action: 'clearSelection',
    category: 'Edit',
  },


  {
    key: 'G',
    modifiers: { ctrl: true },
    description: 'Group',
    action: 'group',
    category: 'Arrange',
  },
  {
    key: 'G',
    modifiers: { ctrl: true, shift: true },
    description: 'Ungroup',
    action: 'ungroup',
    category: 'Arrange',
  },
  {
    key: ']',
    modifiers: { ctrl: true },
    description: 'Bring forward',
    action: 'bringForward',
    category: 'Arrange',
  },
  {
    key: '[',
    modifiers: { ctrl: true },
    description: 'Send backward',
    action: 'sendBackward',
    category: 'Arrange',
  },
  {
    key: ']',
    modifiers: { ctrl: true, shift: true },
    description: 'Bring to front',
    action: 'bringToFront',
    category: 'Arrange',
  },
  {
    key: '[',
    modifiers: { ctrl: true, shift: true },
    description: 'Send to back',
    action: 'sendToBack',
    category: 'Arrange',
  },


  {
    key: 'E',
    modifiers: { ctrl: true },
    description: 'Export',
    action: 'export',
    category: 'View',
  },
  {
    key: '?',
    description: 'Show keyboard shortcuts',
    action: 'showShortcuts',
    category: 'View',
  },
]




export function formatShortcut(shortcut: KeyboardShortcut): string {
  const parts: string[] = []

  if (shortcut.modifiers?.ctrl) {
    parts.push(navigator.platform.includes('Mac') ? '⌘' : 'Ctrl')
  }
  if (shortcut.modifiers?.shift) {
    parts.push('Shift')
  }
  if (shortcut.modifiers?.alt) {
    parts.push(navigator.platform.includes('Mac') ? '⌥' : 'Alt')
  }

  parts.push(shortcut.key)

  return parts.join(' + ')
}




export function getShortcutsByCategory(): Record<string, KeyboardShortcut[]> {
  const grouped: Record<string, KeyboardShortcut[]> = {}

  KEYBOARD_SHORTCUTS.forEach(shortcut => {
    if (!grouped[shortcut.category]) {
      grouped[shortcut.category] = []
    }
    grouped[shortcut.category].push(shortcut)
  })

  return grouped
}
</file>

<file path="src/hooks/useAuth.ts">
import { useState, useEffect } from 'react'
import { onAuthStateChanged } from 'firebase/auth'
import type { User as FirebaseUser } from 'firebase/auth'
import { auth } from '../services/firebase'
import type { User } from '../types/firebase'

interface UseAuthReturn {
  user: User | null
  loading: boolean
}





export function useAuth(): UseAuthReturn {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(
      auth,
      (firebaseUser: FirebaseUser | null) => {
        if (firebaseUser) {

          setUser({
            uid: firebaseUser.uid,
            email: firebaseUser.email,
            displayName: firebaseUser.displayName,
          })
        } else {
          setUser(null)
        }
        setLoading(false)
      },
      (error) => {
        console.error('Auth state change error:', error)
        setUser(null)
        setLoading(false)
      }
    )


    return () => unsubscribe()
  }, [])

  return { user, loading }
}
</file>

<file path="src/hooks/useCanvas.ts">
import { useState, useCallback, useEffect, useRef, useMemo } from 'react'
import { v4 as uuidv4 } from 'uuid'
import type { Shape } from '../types/canvas'
import { DEFAULT_CANVAS_CONFIG } from '../types/canvas'
import {
  syncCreateShape,
  syncUpdateShape,
  syncDeleteShape,
  syncBulkMove,
  syncBulkDelete,
  syncBatchCreate,
  syncZIndex,
  subscribeToCanvas,
} from '../services/canvasSync'
import {
  copyShapes as copyShapesToClipboard,
  pasteShapes as pasteShapesFromClipboard,
  duplicateShapes as duplicateShapesInternal,
} from '../services/clipboard'
import { createHistoryManager } from '../services/commandHistory'
import { CreateCommand } from '../commands/CreateCommand'
import { DeleteCommand } from '../commands/DeleteCommand'
import { ZIndexCommand } from '../commands/ZIndexCommand'
import { AlignmentCommand } from '../commands/AlignmentCommand'
import {
  loadRecentColors,
  saveRecentColors,
} from '../services/colorStorage'
import {
  alignShapes,
  distributeHorizontally,
  distributeVertically,
  centerInCanvas,
  type AlignmentType,
} from '../services/alignment'

interface UseCanvasOptions {
  canvasId: string
  userId: string
  enableSync?: boolean
}

interface UseCanvasReturn {
  shapes: Shape[]
  selectedId: string | null
  selectedIds: Set<string>
  addShape: (type: 'rectangle' | 'circle', x: number, y: number) => string
  addText: (text: string, x: number, y: number) => string | null
  updateShape: (id: string, updates: Partial<Shape>) => void
  deleteShape: (id: string) => void
  setSelection: (id: string | null) => void

  toggleSelection: (id: string) => void
  selectMultiple: (ids: string[]) => void
  clearSelection: () => void
  selectAll: () => void
  getSelectedShapes: () => Shape[]
  bulkMove: (deltaX: number, deltaY: number) => void
  bulkDelete: () => void

  copySelected: () => void
  paste: () => void
  duplicateSelected: () => void

  undo: () => void
  redo: () => void
  canUndo: boolean
  canRedo: boolean

  updateColors: (fill?: string, stroke?: string, strokeWidth?: number) => void
  getRecentColors: () => string[]
  addRecentColor: (color: string) => void

  addLine: (x1: number, y1: number, x2: number, y2: number, arrows?: { start?: boolean; end?: boolean }) => string
  addPolygon: (x: number, y: number, sides?: number) => string
  addStar: (x: number, y: number, points?: number) => string
  addRoundedRect: (x: number, y: number, cornerRadius?: number) => string

  addPath: (points: number[], tension?: number, strokeColor?: string, strokeWidth?: number) => string

  bringToFront: (ids?: string[]) => void
  sendToBack: (ids?: string[]) => void
  bringForward: (ids?: string[]) => void
  sendBackward: (ids?: string[]) => void
  sortShapesByZIndex: () => Shape[]

  alignSelected: (type: AlignmentType) => void
  distributeSelectedHorizontally: () => void
  distributeSelectedVertically: () => void
  centerSelectedInCanvas: (canvasWidth: number, canvasHeight: number) => void
}





export function useCanvas(options?: UseCanvasOptions): UseCanvasReturn {
  const [shapes, setShapes] = useState<Shape[]>([])
  const [selectedId, setSelectedId] = useState<string | null>(null)
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set())
  const syncEnabled = options?.enableSync ?? true
  const canvasId = options?.canvasId ?? 'default-canvas'
  const userId = options?.userId ?? ''

  // Track locally created shapes to avoid duplicate onCreate from Firebase
  const localShapesRef = useRef(new Set<string>())

  // Command history for undo/redo (PR-14)
  const historyManager = useMemo(() => createHistoryManager(), [])
  const [canUndo, setCanUndo] = useState(false)
  const [canRedo, setCanRedo] = useState(false)

  // Recent colors for color picker (PR-15)
  const [recentColors, setRecentColors] = useState<string[]>(() => loadRecentColors())
  const DEFAULT_FILL = '#3B82F6FF'




  const addShapeToState = useCallback((shape: Shape): void => {
    setShapes((prev) => [...prev, shape])
    localShapesRef.current.add(shape.id)
  }, [])




  const removeShapeFromState = useCallback((id: string): void => {
    setShapes((prev) => prev.filter((shape) => shape.id !== id))
    localShapesRef.current.delete(id)
  }, [])




  const syncShapeCreate = useCallback(
    (shape: Shape): Promise<void> => {
      if (syncEnabled && userId) {
        return syncCreateShape(canvasId, shape.id, shape)
      }
      return Promise.resolve()
    },
    [syncEnabled, userId, canvasId]
  )




  const syncShapeDelete = useCallback(
    (id: string): Promise<void> => {
      if (syncEnabled && userId) {
        return syncDeleteShape(canvasId, id)
      }
      return Promise.resolve()
    },
    [syncEnabled, userId, canvasId]
  )




  const updateHistoryState = useCallback((): void => {
    setCanUndo(historyManager.canUndo())
    setCanRedo(historyManager.canRedo())
  }, [historyManager])







  const addShape = useCallback(
    (type: 'rectangle' | 'circle', x: number, y: number): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize
      const newShape: Shape = {
        id,
        type,
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        stroke: '#000000FF',
        strokeWidth: 2,
        zIndex: Date.now(),
      }


      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )


      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState]
  )







  const addText = useCallback(
    (text: string, x: number, y: number): string | null => {

      if (!text || text.trim().length === 0) {
        return null
      }

      const id = uuidv4()


      const fontSize = 20
      const charWidth = fontSize * 0.6
      const width = Math.max(text.length * charWidth, 50)
      const height = fontSize + 10

      const newShape: Shape = {
        id,
        type: 'text',
        x,
        y,
        width,
        height,
        text,
        fill: DEFAULT_FILL,
        zIndex: Date.now(),
      }


      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )


      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState]
  )





  const addLine = useCallback(
    (x1: number, y1: number, x2: number, y2: number, arrows?: { start?: boolean; end?: boolean }): string => {
      const id = uuidv4()
      const newShape: Shape = {
        id,
        type: 'line',
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1),
        points: [x1, y1, x2, y2],
        fill: DEFAULT_FILL,
        stroke: '#000000FF',
        strokeWidth: 2,
        arrows: arrows || { start: false, end: false },
        zIndex: Date.now(),
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )

      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )





  const addPolygon = useCallback(
    (x: number, y: number, sides: number = 5): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize

      const newShape: Shape = {
        id,
        type: 'polygon',
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        sides: Math.max(3, Math.min(12, sides)),
        zIndex: Date.now(),
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )

      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )





  const addStar = useCallback(
    (x: number, y: number, points: number = 5): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize

      const newShape: Shape = {
        id,
        type: 'star',
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        sides: Math.max(3, Math.min(12, points)),
        zIndex: Date.now(),
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )

      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )





  const addRoundedRect = useCallback(
    (x: number, y: number, cornerRadius: number = 10): string => {
      const id = uuidv4()
      const size = DEFAULT_CANVAS_CONFIG.defaultShapeSize

      const newShape: Shape = {
        id,
        type: 'roundRect',
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        fill: DEFAULT_FILL,
        cornerRadius: Math.max(0, Math.min(50, cornerRadius)),
        zIndex: Date.now(),
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )

      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )





  const addPath = useCallback(
    (points: number[], tension: number = 0, strokeColor?: string, strokeWidth: number = 2): string => {
      const id = uuidv4()

      const newShape: Shape = {
        id,
        type: 'path',
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        points,
        stroke: strokeColor || DEFAULT_FILL,
        strokeWidth,
        fill: 'transparent',
        tension,
        closed: false,
        zIndex: Date.now(),
      }

      const command = new CreateCommand(
        newShape,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )

      historyManager.executeCommand(command)
      updateHistoryState()

      return id
    },
    [historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState, DEFAULT_FILL]
  )




  const updateShape = useCallback(
    (id: string, updates: Partial<Shape>): void => {

      setShapes((prev) =>
        prev.map((shape) =>
          shape.id === id ? { ...shape, ...updates } : shape
        )
      )


      const hasSyncableUpdate =
        updates.x !== undefined ||
        updates.y !== undefined ||
        updates.width !== undefined ||
        updates.height !== undefined ||
        updates.rotation !== undefined ||
        updates.fill !== undefined ||
        updates.stroke !== undefined ||
        updates.strokeWidth !== undefined ||
        updates.zIndex !== undefined

      if (syncEnabled && userId && hasSyncableUpdate) {
        syncUpdateShape(canvasId, id, updates).catch((error) => {
          console.error('Failed to sync shape update:', error)
        })
      }
    },
    [syncEnabled, canvasId, userId]
  )





  const deleteShape = useCallback(
    (id: string): void => {

      const shapeToDelete = shapes.find((shape) => shape.id === id)
      if (!shapeToDelete) return


      setSelectedId((prev) => (prev === id ? null : prev))
      setSelectedIds((prev) => {
        const next = new Set(prev)
        next.delete(id)
        return next
      })


      const command = new DeleteCommand(
        shapeToDelete,
        addShapeToState,
        removeShapeFromState,
        syncShapeCreate,
        syncShapeDelete
      )


      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [shapes, historyManager, addShapeToState, removeShapeFromState, syncShapeCreate, syncShapeDelete, updateHistoryState]
  )





  const setSelection = useCallback((id: string | null): void => {
    setSelectedId(id)

    if (id === null) {
      setSelectedIds(new Set())
    } else {
      setSelectedIds(new Set([id]))
    }
  }, [])





  const toggleSelection = useCallback((id: string): void => {
    setSelectedIds((prev) => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }

      setSelectedId(next.size > 0 ? id : null)
      return next
    })
  }, [])





  const selectMultiple = useCallback((ids: string[]): void => {
    const newSelection = new Set(ids)
    setSelectedIds(newSelection)

    setSelectedId(ids.length > 0 ? ids[ids.length - 1] : null)
  }, [])




  const clearSelection = useCallback((): void => {
    setSelectedIds(new Set())
    setSelectedId(null)
  }, [])




  const selectAll = useCallback((): void => {
    const allIds = shapes.map((shape) => shape.id)
    selectMultiple(allIds)
  }, [shapes, selectMultiple])




  const getSelectedShapes = useCallback((): Shape[] => {
    return shapes.filter((shape) => selectedIds.has(shape.id))
  }, [shapes, selectedIds])





  const bulkMove = useCallback(
    (deltaX: number, deltaY: number): void => {
      const updates: Record<string, { x: number; y: number }> = {}


      shapes.forEach((shape) => {
        if (selectedIds.has(shape.id)) {
          updates[shape.id] = {
            x: shape.x + deltaX,
            y: shape.y + deltaY,
          }
        }
      })


      setShapes((prev) =>
        prev.map((shape) =>
          updates[shape.id]
            ? { ...shape, ...updates[shape.id] }
            : shape
        )
      )


      if (syncEnabled && userId && Object.keys(updates).length > 0) {
        syncBulkMove(canvasId, updates).catch((error) => {
          console.error('Failed to sync bulk move:', error)
        })
      }
    },
    [shapes, selectedIds, syncEnabled, canvasId, userId]
  )




  const bulkDelete = useCallback((): void => {
    const idsToDelete = Array.from(selectedIds)


    setShapes((prev) => prev.filter((shape) => !selectedIds.has(shape.id)))


    clearSelection()


    idsToDelete.forEach((id) => localShapesRef.current.delete(id))


    if (syncEnabled && userId && idsToDelete.length > 0) {
      syncBulkDelete(canvasId, idsToDelete).catch((error) => {
        console.error('Failed to sync bulk delete:', error)
      })
    }
  }, [selectedIds, syncEnabled, canvasId, userId, clearSelection])




  const copySelected = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    if (selectedShapes.length > 0) {
      copyShapesToClipboard(selectedShapes)
    }
  }, [getSelectedShapes])





  const paste = useCallback((): void => {
    const pastedShapes = pasteShapesFromClipboard()

    if (pastedShapes.length === 0) {
      return
    }


    setShapes((prev) => [...prev, ...pastedShapes])


    pastedShapes.forEach((shape) => {
      localShapesRef.current.add(shape.id)
    })


    selectMultiple(pastedShapes.map((s) => s.id))


    if (syncEnabled && userId) {

      syncBatchCreate(canvasId, pastedShapes).catch((error) => {
        console.error('Failed to sync pasted shapes:', error)
      })
    }
  }, [syncEnabled, canvasId, userId, selectMultiple])





  const duplicateSelected = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    const duplicatedShapes = duplicateShapesInternal(selectedShapes)

    if (duplicatedShapes.length === 0) {
      return
    }


    setShapes((prev) => [...prev, ...duplicatedShapes])


    duplicatedShapes.forEach((shape) => {
      localShapesRef.current.add(shape.id)
    })


    selectMultiple(duplicatedShapes.map((s) => s.id))


    if (syncEnabled && userId) {

      syncBatchCreate(canvasId, duplicatedShapes).catch((error) => {
        console.error('Failed to sync duplicated shapes:', error)
      })
    }
  }, [getSelectedShapes, syncEnabled, canvasId, userId, selectMultiple])





  const addRecentColor = useCallback((color: string): void => {
    setRecentColors((prev) => {

      const filtered = prev.filter((c) => c.toUpperCase() !== color.toUpperCase())

      return [color, ...filtered].slice(0, 5)
    })
  }, [])




  const getRecentColors = useCallback((): string[] => {
    return recentColors
  }, [recentColors])





  const updateColors = useCallback(
    (fill?: string, stroke?: string, strokeWidth?: number): void => {
      const selectedShapesList = getSelectedShapes()
      if (selectedShapesList.length === 0) return


      const updates: Partial<Shape> = {}
      if (fill !== undefined) updates.fill = fill
      if (stroke !== undefined) updates.stroke = stroke
      if (strokeWidth !== undefined) updates.strokeWidth = strokeWidth


      selectedShapesList.forEach((shape) => {
        updateShape(shape.id, updates)
      })


      if (fill !== undefined) {
        addRecentColor(fill)
      }
    },
    [getSelectedShapes, updateShape, addRecentColor]
  )




  const undo = useCallback((): void => {
    historyManager.undo()

    setCanUndo(historyManager.canUndo())
    setCanRedo(historyManager.canRedo())
  }, [historyManager])




  const redo = useCallback((): void => {
    historyManager.redo()

    setCanUndo(historyManager.canUndo())
    setCanRedo(historyManager.canRedo())
  }, [historyManager])





  const sortShapesByZIndex = useCallback((): Shape[] => {
    return [...shapes].sort((a, b) => {
      const aZ = a.zIndex ?? 0
      const bZ = b.zIndex ?? 0
      return aZ - bZ
    })
  }, [shapes])






  const bringToFront = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return


      const maxZ = Math.max(...shapes.map((s) => s.zIndex ?? 0))


      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()


      const targetShapes = shapes.filter((s) => targetIds.includes(s.id))
        .sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0))


      targetShapes.forEach((shape, index) => {
        oldZIndices.set(shape.id, shape.zIndex ?? 0)
        newZIndices.set(shape.id, maxZ + 1 + index)
      })


      const command = new ZIndexCommand(
        targetIds,
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )

      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )






  const sendToBack = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return


      const minZ = Math.min(...shapes.map((s) => s.zIndex ?? 0))


      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()


      const targetShapes = shapes.filter((s) => targetIds.includes(s.id))
        .sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0))


      targetShapes.forEach((shape, index) => {
        oldZIndices.set(shape.id, shape.zIndex ?? 0)
        newZIndices.set(shape.id, minZ - targetShapes.length + index)
      })


      const command = new ZIndexCommand(
        targetIds,
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )

      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )





  const bringForward = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return


      const sortedShapes = sortShapesByZIndex()


      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()


      targetIds.forEach((id) => {
        const currentIndex = sortedShapes.findIndex((s) => s.id === id)
        if (currentIndex < sortedShapes.length - 1) {
          const currentShape = sortedShapes[currentIndex]
          const nextShape = sortedShapes[currentIndex + 1]

          if (!targetIds.includes(nextShape.id)) {

            oldZIndices.set(currentShape.id, currentShape.zIndex ?? 0)
            newZIndices.set(currentShape.id, nextShape.zIndex ?? 0)
            oldZIndices.set(nextShape.id, nextShape.zIndex ?? 0)
            newZIndices.set(nextShape.id, currentShape.zIndex ?? 0)
          }
        }
      })

      if (newZIndices.size === 0) return


      const command = new ZIndexCommand(
        Array.from(newZIndices.keys()),
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )

      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, sortShapesByZIndex, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )





  const sendBackward = useCallback(
    (ids?: string[]): void => {
      const targetIds = ids || Array.from(selectedIds)
      if (targetIds.length === 0) return


      const sortedShapes = sortShapesByZIndex()


      const oldZIndices = new Map<string, number>()
      const newZIndices = new Map<string, number>()


      targetIds.forEach((id) => {
        const currentIndex = sortedShapes.findIndex((s) => s.id === id)
        if (currentIndex > 0) {
          const currentShape = sortedShapes[currentIndex]
          const prevShape = sortedShapes[currentIndex - 1]

          if (!targetIds.includes(prevShape.id)) {

            oldZIndices.set(currentShape.id, currentShape.zIndex ?? 0)
            newZIndices.set(currentShape.id, prevShape.zIndex ?? 0)
            oldZIndices.set(prevShape.id, prevShape.zIndex ?? 0)
            newZIndices.set(prevShape.id, currentShape.zIndex ?? 0)
          }
        }
      })

      if (newZIndices.size === 0) return


      const command = new ZIndexCommand(
        Array.from(newZIndices.keys()),
        oldZIndices,
        newZIndices,
        (id, updates) => updateShape(id, updates),
        (id, zIndex) => syncEnabled && userId ? syncZIndex(canvasId, id, zIndex) : Promise.resolve()
      )

      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [selectedIds, shapes, sortShapesByZIndex, historyManager, updateShape, syncEnabled, userId, canvasId, updateHistoryState]
  )





  const alignSelected = useCallback(
    (type: AlignmentType): void => {
      const selectedShapes = getSelectedShapes()
      if (selectedShapes.length < 2) return


      const alignmentResult = alignShapes(selectedShapes, type)

      if (Object.keys(alignmentResult).length === 0) return


      const oldPositions = new Map<string, { x: number; y: number }>()
      const newPositions = new Map<string, { x: number; y: number }>()

      selectedShapes.forEach(shape => {
        oldPositions.set(shape.id, { x: shape.x, y: shape.y })
        if (alignmentResult[shape.id]) {
          newPositions.set(shape.id, alignmentResult[shape.id])
        }
      })


      const command = new AlignmentCommand(
        Array.from(newPositions.keys()),
        oldPositions,
        newPositions,
        (id, updates) => updateShape(id, updates),
        (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
      )

      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState]
  )




  const distributeSelectedHorizontally = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    if (selectedShapes.length < 3) return


    const distributionResult = distributeHorizontally(selectedShapes)

    if (Object.keys(distributionResult).length === 0) return


    const oldPositions = new Map<string, { x: number; y: number }>()
    const newPositions = new Map<string, { x: number; y: number }>()

    selectedShapes.forEach(shape => {
      oldPositions.set(shape.id, { x: shape.x, y: shape.y })
      if (distributionResult[shape.id]) {
        newPositions.set(shape.id, distributionResult[shape.id])
      }
    })


    const command = new AlignmentCommand(
      Array.from(newPositions.keys()),
      oldPositions,
      newPositions,
      (id, updates) => updateShape(id, updates),
      (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
    )

    historyManager.executeCommand(command)
    updateHistoryState()
  }, [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState])




  const distributeSelectedVertically = useCallback((): void => {
    const selectedShapes = getSelectedShapes()
    if (selectedShapes.length < 3) return


    const distributionResult = distributeVertically(selectedShapes)

    if (Object.keys(distributionResult).length === 0) return


    const oldPositions = new Map<string, { x: number; y: number }>()
    const newPositions = new Map<string, { x: number; y: number }>()

    selectedShapes.forEach(shape => {
      oldPositions.set(shape.id, { x: shape.x, y: shape.y })
      if (distributionResult[shape.id]) {
        newPositions.set(shape.id, distributionResult[shape.id])
      }
    })


    const command = new AlignmentCommand(
      Array.from(newPositions.keys()),
      oldPositions,
      newPositions,
      (id, updates) => updateShape(id, updates),
      (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
    )

    historyManager.executeCommand(command)
    updateHistoryState()
  }, [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState])




  const centerSelectedInCanvas = useCallback(
    (canvasWidth: number, canvasHeight: number): void => {
      const selectedShapes = getSelectedShapes()
      if (selectedShapes.length === 0) return


      const centerResult = centerInCanvas(selectedShapes, canvasWidth, canvasHeight)

      if (Object.keys(centerResult).length === 0) return


      const oldPositions = new Map<string, { x: number; y: number }>()
      const newPositions = new Map<string, { x: number; y: number }>()

      selectedShapes.forEach(shape => {
        oldPositions.set(shape.id, { x: shape.x, y: shape.y })
        if (centerResult[shape.id]) {
          newPositions.set(shape.id, centerResult[shape.id])
        }
      })


      const command = new AlignmentCommand(
        Array.from(newPositions.keys()),
        oldPositions,
        newPositions,
        (id, updates) => updateShape(id, updates),
        (id, x, y) => syncEnabled && userId ? syncUpdateShape(canvasId, id, { x, y }) : Promise.resolve()
      )

      historyManager.executeCommand(command)
      updateHistoryState()
    },
    [getSelectedShapes, updateShape, syncEnabled, userId, canvasId, historyManager, updateHistoryState]
  )




  useEffect(() => {
    saveRecentColors(recentColors)
  }, [recentColors])




  useEffect(() => {

    if (!syncEnabled || !userId) return

    const unsubscribe = subscribeToCanvas(canvasId, {
      onCreate: (shape) => {

        if (!localShapesRef.current.has(shape.id)) {
          setShapes((prev) => {

            if (prev.some((s) => s.id === shape.id)) {
              return prev
            }
            return [...prev, shape]
          })
        }
      },
      onUpdate: (shapeId, updates) => {
        setShapes((prev) =>
          prev.map((shape) =>
            shape.id === shapeId ? { ...shape, ...updates } : shape
          )
        )
      },
      onDelete: (shapeId) => {
        setShapes((prev) => prev.filter((shape) => shape.id !== shapeId))
        setSelectedId((prev) => (prev === shapeId ? null : prev))

        setSelectedIds((prev) => {
          const next = new Set(prev)
          next.delete(shapeId)
          return next
        })
        localShapesRef.current.delete(shapeId)
      },
    })

    return () => {
      unsubscribe()
    }
  }, [syncEnabled, canvasId, userId])

  return {
    shapes,
    selectedId,
    selectedIds,
    addShape,
    addText,
    updateShape,
    deleteShape,
    setSelection,
    toggleSelection,
    selectMultiple,
    clearSelection,
    selectAll,
    getSelectedShapes,
    bulkMove,
    bulkDelete,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    canUndo,
    canRedo,
    updateColors,
    getRecentColors,
    addRecentColor,
    addLine,
    addPolygon,
    addStar,
    addRoundedRect,
    addPath,
    bringToFront,
    sendToBack,
    bringForward,
    sendBackward,
    sortShapesByZIndex,
    alignSelected,
    distributeSelectedHorizontally,
    distributeSelectedVertically,
    centerSelectedInCanvas,
  }
}
</file>

<file path="src/hooks/useCanvasList.ts">
import { useState, useEffect, useCallback } from 'react'
import { ref, onValue, off } from 'firebase/database'
import { db } from '../services/firebase'
import {
  createCanvas as createCanvasService,
  deleteCanvas as deleteCanvasService,
  duplicateCanvas as duplicateCanvasService,
  updateCanvas as updateCanvasService,
  type CanvasMetadata,
} from '../services/canvasManager'
import { useNavigate } from 'react-router-dom'

interface UseCanvasListReturn {
  canvases: CanvasMetadata[]
  loading: boolean
  error: string | null
  createCanvas: (name: string) => Promise<void>
  deleteCanvas: (canvasId: string) => Promise<void>
  duplicateCanvas: (canvasId: string) => Promise<void>
  updateCanvasName: (canvasId: string, name: string) => Promise<void>
  refreshCanvases: () => void
}





export function useCanvasList(userId: string): UseCanvasListReturn {
  const [canvases, setCanvases] = useState<CanvasMetadata[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const navigate = useNavigate()


  useEffect(() => {
    if (!userId) {
      setLoading(false)
      return
    }

    setLoading(true)
    const canvasesRef = ref(db, `users/${userId}/canvases`)

    const handleValue = (snapshot: any) => {
      try {
        if (!snapshot.exists()) {
          setCanvases([])
          setLoading(false)
          return
        }

        const canvasesData = snapshot.val()
        const canvasList: CanvasMetadata[] = Object.values(canvasesData)


        canvasList.sort((a, b) => b.updatedAt - a.updatedAt)

        setCanvases(canvasList)
        setError(null)
      } catch (err) {
        console.error('Error processing canvases:', err)
        setError('Failed to load canvases')
      } finally {
        setLoading(false)
      }
    }

    const handleError = (err: Error) => {
      console.error('Firebase error:', err)
      setError('Failed to connect to database')
      setLoading(false)
    }

    onValue(canvasesRef, handleValue, handleError)


    return () => {
      off(canvasesRef, 'value', handleValue)
    }
  }, [userId])




  const createCanvas = useCallback(
    async (name: string) => {
      try {
        setError(null)
        const canvas = await createCanvasService(name, userId)
        console.log('Canvas created:', canvas.id)


        navigate(`/canvas/${canvas.id}`)
      } catch (err) {
        console.error('Error creating canvas:', err)
        setError('Failed to create canvas')
        throw err
      }
    },
    [userId, navigate]
  )




  const deleteCanvas = useCallback(
    async (canvasId: string) => {
      try {
        setError(null)
        await deleteCanvasService(canvasId, userId)
        console.log('Canvas deleted:', canvasId)
      } catch (err) {
        console.error('Error deleting canvas:', err)
        setError('Failed to delete canvas')
        throw err
      }
    },
    [userId]
  )




  const duplicateCanvas = useCallback(
    async (canvasId: string) => {
      try {
        setError(null)
        const duplicatedCanvas = await duplicateCanvasService(canvasId, userId)
        console.log('Canvas duplicated:', duplicatedCanvas.id)
      } catch (err) {
        console.error('Error duplicating canvas:', err)
        setError('Failed to duplicate canvas')
        throw err
      }
    },
    [userId]
  )




  const updateCanvasName = useCallback(
    async (canvasId: string, name: string) => {
      try {
        setError(null)
        await updateCanvasService(canvasId, userId, { name })
        console.log('Canvas renamed:', canvasId)
      } catch (err) {
        console.error('Error updating canvas name:', err)
        setError('Failed to update canvas name')
        throw err
      }
    },
    [userId]
  )




  const refreshCanvases = useCallback(() => {

    setLoading(true)
  }, [])

  return {
    canvases,
    loading,
    error,
    createCanvas,
    deleteCanvas,
    duplicateCanvas,
    updateCanvasName,
    refreshCanvases,
  }
}
</file>

<file path="src/hooks/useCanvasViewport.ts">
import { useState, useCallback, useEffect, useRef } from 'react'
import Konva from 'konva'
import type { ViewportTransform } from '../types/canvas'
import { DEFAULT_CANVAS_CONFIG, DEFAULT_CANVAS_BOUNDS } from '../types/canvas'

const CANVAS_CONFIG = DEFAULT_CANVAS_CONFIG
const CANVAS_BOUNDS = DEFAULT_CANVAS_BOUNDS

interface UseCanvasViewportProps {
  containerWidth: number
  containerHeight: number
  onViewportChange?: (viewport: ViewportTransform) => void
  onZoomChange?: (scale: number) => void
}

export function useCanvasViewport({
  containerWidth,
  containerHeight,
  onViewportChange,
  onZoomChange,
}: UseCanvasViewportProps) {
  const [viewport, setViewport] = useState<ViewportTransform>({
    x: 0,
    y: 0,
    scale: 1,
  })


  useEffect(() => {
    const centerX = (containerWidth / 2) - (CANVAS_BOUNDS.maxX / 2)
    const centerY = (containerHeight / 2) - (CANVAS_BOUNDS.maxY / 2)

    const initialViewport = {
      x: centerX,
      y: centerY,
      scale: 1,
    }
    setViewport(initialViewport)
    onViewportChange?.(initialViewport)
    onZoomChange?.(1)
  }, [containerWidth, containerHeight])


  const viewportCallbacksRef = useRef({ onViewportChange, onZoomChange })
  useEffect(() => {
    viewportCallbacksRef.current = { onViewportChange, onZoomChange }
  }, [onViewportChange, onZoomChange])

  useEffect(() => {
    viewportCallbacksRef.current.onViewportChange?.(viewport)
    viewportCallbacksRef.current.onZoomChange?.(viewport.scale)
  }, [viewport])




  const zoomToPoint = useCallback((newScale: number, pointX: number, pointY: number) => {
    const clampedScale = Math.max(
      CANVAS_CONFIG.minScale,
      Math.min(CANVAS_CONFIG.maxScale, newScale)
    )

    const mousePointTo = {
      x: (pointX - viewport.x) / viewport.scale,
      y: (pointY - viewport.y) / viewport.scale,
    }

    const newX = pointX - mousePointTo.x * clampedScale
    const newY = pointY - mousePointTo.y * clampedScale

    setViewport({
      x: newX,
      y: newY,
      scale: clampedScale,
    })
  }, [viewport])




  const handleWheel = useCallback(
    (e: Konva.KonvaEventObject<WheelEvent>, stageRef: Konva.Stage) => {
      e.evt.preventDefault()

      const pointer = stageRef.getPointerPosition()
      if (!pointer) return

      const scaleBy = 1.05
      const newScale =
        e.evt.deltaY > 0 ? viewport.scale / scaleBy : viewport.scale * scaleBy

      zoomToPoint(newScale, pointer.x, pointer.y)
    },
    [viewport.scale, zoomToPoint]
  )




  const handleDragEnd = useCallback(
    (e: Konva.KonvaEventObject<DragEvent>) => {
      const stage = e.target.getStage()
      if (e.target !== stage) {
        return
      }

      const newX = stage.x()
      const newY = stage.y()
      const scale = stage.scaleX()


      const clampedX = Math.min(
        0,
        Math.max(newX, containerWidth - CANVAS_BOUNDS.maxX * scale)
      )
      const clampedY = Math.min(
        0,
        Math.max(newY, containerHeight - CANVAS_BOUNDS.maxY * scale)
      )

      if (clampedX !== newX || clampedY !== newY) {
        stage.position({ x: clampedX, y: clampedY })
      }

      setViewport({
        x: clampedX,
        y: clampedY,
        scale,
      })
    },
    [containerWidth, containerHeight]
  )




  const handleZoomIn = useCallback(() => {
    const newScale = Math.min(viewport.scale * 1.2, CANVAS_CONFIG.maxScale)
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    zoomToPoint(newScale, centerX, centerY)
  }, [viewport.scale, containerWidth, containerHeight, zoomToPoint])

  const handleZoomOut = useCallback(() => {
    const newScale = Math.max(viewport.scale / 1.2, CANVAS_CONFIG.minScale)
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    zoomToPoint(newScale, centerX, centerY)
  }, [viewport.scale, containerWidth, containerHeight, zoomToPoint])

  const handleZoomReset = useCallback(() => {
    setViewport((prev) => ({
      ...prev,
      scale: 1,
    }))
  }, [])

  const handleZoomFit = useCallback(() => {
    const scaleX = containerWidth / CANVAS_BOUNDS.maxX
    const scaleY = containerHeight / CANVAS_BOUNDS.maxY
    const newScale = Math.min(scaleX, scaleY) * 0.9

    const newX = (containerWidth - CANVAS_BOUNDS.maxX * newScale) / 2
    const newY = (containerHeight - CANVAS_BOUNDS.maxY * newScale) / 2

    setViewport({
      x: newX,
      y: newY,
      scale: Math.max(CANVAS_CONFIG.minScale, Math.min(CANVAS_CONFIG.maxScale, newScale)),
    })
  }, [containerWidth, containerHeight])

  return {
    viewport,
    setViewport,
    handleWheel,
    handleDragEnd,
    handleZoomIn,
    handleZoomOut,
    handleZoomReset,
    handleZoomFit,
    zoomToPoint,
  }
}
</file>

<file path="src/hooks/useContextMenu.ts">
import { useState, useCallback } from 'react'

interface ContextMenuState {
  x: number
  y: number
  visible: boolean
}





export function useContextMenu() {
  const [contextMenu, setContextMenu] = useState<ContextMenuState>({
    x: 0,
    y: 0,
    visible: false,
  })

  const show = useCallback((x: number, y: number) => {
    setContextMenu({ x, y, visible: true })
  }, [])

  const hide = useCallback(() => {
    setContextMenu((prev) => ({ ...prev, visible: false }))
  }, [])

  const toggle = useCallback((x: number, y: number) => {
    setContextMenu((prev) =>
      prev.visible ? { ...prev, visible: false } : { x, y, visible: true }
    )
  }, [])

  return {
    contextMenu,
    show,
    hide,
    toggle,
  }
}
</file>

<file path="src/hooks/useGroups.ts">
import { useState, useCallback, useEffect } from 'react'
import { ref, onValue, off } from 'firebase/database'
import { db } from '../services/firebase'
import type { Group } from '../types/group'
import type { Shape } from '../types/canvas'
import {
  syncCreateGroup,
  syncUpdateGroup,
  syncDeleteGroup,
  syncAddToGroup,
  syncRemoveFromGroup,
} from '../services/groupSync'
import {
  isInAnyGroup,
  getAllGroupMembers,
  getGroupShapes,
  hasCircularDependency,
  updateGroupBounds,
} from '../utils/groupHelpers'

interface UseGroupsOptions {
  canvasId: string
  userId: string
  enableSync?: boolean
}

interface UseGroupsReturn {
  groups: Group[]
  createGroup: (shapeIds: string[], name?: string) => Promise<string | null>
  ungroup: (groupId: string) => Promise<void>
  addToGroup: (groupId: string, shapeId: string) => Promise<void>
  removeFromGroup: (groupId: string, shapeId: string) => Promise<void>
  updateGroup: (groupId: string, updates: Partial<Omit<Group, 'id' | 'createdAt' | 'createdBy'>>) => Promise<void>
  getGroupById: (groupId: string) => Group | undefined
  isShapeInGroup: (shapeId: string) => string | null
  getGroupMembers: (groupId: string) => string[]
  calculateBounds: (groupId: string, shapes: Shape[]) => { x: number; y: number; width: number; height: number } | null
}





export function useGroups(options?: UseGroupsOptions): UseGroupsReturn {
  const [groups, setGroups] = useState<Group[]>([])
  const syncEnabled = options?.enableSync ?? true
  const canvasId = options?.canvasId ?? 'default-canvas'
  const userId = options?.userId ?? 'anonymous'




  useEffect(() => {
    if (!syncEnabled) return

    const groupsRef = ref(db, `canvases/${canvasId}/groups`)

    const handleGroupsChange = (snapshot: any) => {
      if (snapshot.exists()) {
        const groupsData = snapshot.val()
        const groupsArray = Object.values(groupsData) as Group[]
        setGroups(groupsArray)
      } else {
        setGroups([])
      }
    }

    onValue(groupsRef, handleGroupsChange)

    return () => {
      off(groupsRef, 'value', handleGroupsChange)
    }
  }, [canvasId, syncEnabled])




  const createGroup = useCallback(
    async (shapeIds: string[], name?: string): Promise<string | null> => {
      if (shapeIds.length < 2) {
        console.warn('Cannot create group with less than 2 shapes')
        return null
      }


      for (const shapeId of shapeIds) {

        const potentialGroup = groups.find((g) => g.id === shapeId)
        if (potentialGroup) {
          for (const otherShapeId of shapeIds) {
            if (shapeId !== otherShapeId && hasCircularDependency(shapeId, otherShapeId, groups)) {
              console.error('Cannot create group: circular dependency detected')
              return null
            }
          }
        }
      }

      try {
        const group = await syncCreateGroup(canvasId, shapeIds, userId, name)
        console.log(`Group created: ${group.id}`)
        return group.id
      } catch (error) {
        console.error('Error creating group:', error)
        return null
      }
    },
    [canvasId, userId, groups]
  )




  const ungroup = useCallback(
    async (groupId: string): Promise<void> => {
      try {
        await syncDeleteGroup(canvasId, groupId)
        console.log(`Group ungrouped: ${groupId}`)
      } catch (error) {
        console.error('Error ungrouping:', error)
        throw error
      }
    },
    [canvasId]
  )




  const addToGroup = useCallback(
    async (groupId: string, shapeId: string): Promise<void> => {

      if (hasCircularDependency(groupId, shapeId, groups)) {
        console.error('Cannot add to group: circular dependency detected')
        return
      }

      try {
        await syncAddToGroup(canvasId, groupId, shapeId)
        console.log(`Added ${shapeId} to group ${groupId}`)
      } catch (error) {
        console.error('Error adding to group:', error)
        throw error
      }
    },
    [canvasId, groups]
  )




  const removeFromGroup = useCallback(
    async (groupId: string, shapeId: string): Promise<void> => {
      try {
        await syncRemoveFromGroup(canvasId, groupId, shapeId)
        console.log(`Removed ${shapeId} from group ${groupId}`)
      } catch (error) {
        console.error('Error removing from group:', error)
        throw error
      }
    },
    [canvasId]
  )




  const updateGroup = useCallback(
    async (
      groupId: string,
      updates: Partial<Omit<Group, 'id' | 'createdAt' | 'createdBy'>>
    ): Promise<void> => {
      try {
        await syncUpdateGroup(canvasId, groupId, updates)
        console.log(`Group updated: ${groupId}`)
      } catch (error) {
        console.error('Error updating group:', error)
        throw error
      }
    },
    [canvasId]
  )




  const getGroupById = useCallback(
    (groupId: string): Group | undefined => {
      return groups.find((g) => g.id === groupId)
    },
    [groups]
  )




  const isShapeInGroup = useCallback(
    (shapeId: string): string | null => {
      return isInAnyGroup(shapeId, groups)
    },
    [groups]
  )




  const getGroupMembers = useCallback(
    (groupId: string): string[] => {
      return getAllGroupMembers(groupId, groups)
    },
    [groups]
  )




  const calculateBounds = useCallback(
    (groupId: string, shapes: Shape[]): { x: number; y: number; width: number; height: number } | null => {
      const group = groups.find((g) => g.id === groupId)
      if (!group) {
        return null
      }

      const memberShapes = getGroupShapes(groupId, groups, shapes)
      if (memberShapes.length === 0) {
        return null
      }

      return updateGroupBounds(group, shapes, groups)
    },
    [groups]
  )

  return {
    groups,
    createGroup,
    ungroup,
    addToGroup,
    removeFromGroup,
    updateGroup,
    getGroupById,
    isShapeInGroup,
    getGroupMembers,
    calculateBounds,
  }
}
</file>

<file path="src/hooks/useKeyboardShortcuts.ts">
import { useEffect } from 'react'

interface KeyboardShortcutHandlers {
  [action: string]: () => void
}





export function useKeyboardShortcuts(handlers: KeyboardShortcutHandlers) {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {

      const target = e.target as HTMLElement
      if (
        target.tagName === 'INPUT' ||
        target.tagName === 'TEXTAREA' ||
        target.isContentEditable
      ) {
        return
      }

      const key = e.key.toUpperCase()
      const ctrl = e.metaKey || e.ctrlKey
      const shift = e.shiftKey
      const alt = e.altKey


      if (!ctrl && !shift && !alt) {
        if (key === 'V' && handlers.selectTool) {
          e.preventDefault()
          handlers.selectTool()
        } else if (key === 'H' && handlers.handTool) {
          e.preventDefault()
          handlers.handTool()
        } else if (key === 'R' && handlers.rectangleTool) {
          e.preventDefault()
          handlers.rectangleTool()
        } else if (key === 'O' && handlers.circleTool) {
          e.preventDefault()
          handlers.circleTool()
        } else if (key === 'T' && handlers.textTool) {
          e.preventDefault()
          handlers.textTool()
        } else if (key === 'L' && handlers.lineTool) {
          e.preventDefault()
          handlers.lineTool()
        } else if (key === 'P' && handlers.pencilTool) {
          e.preventDefault()
          handlers.pencilTool()
        } else if (key === 'N' && handlers.penTool) {
          e.preventDefault()
          handlers.penTool()
        } else if (key === '?' && handlers.showShortcuts) {
          e.preventDefault()
          handlers.showShortcuts()
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
          if (handlers.delete) {
            e.preventDefault()
            handlers.delete()
          }
        } else if (e.key === 'Escape' && handlers.clearSelection) {
          e.preventDefault()
          handlers.clearSelection()
        }
      }


      if (ctrl && !shift && !alt) {
        if (key === 'C' && handlers.copy) {
          e.preventDefault()
          handlers.copy()
        } else if (key === 'V' && handlers.paste) {
          e.preventDefault()
          handlers.paste()
        } else if (key === 'D' && handlers.duplicate) {
          e.preventDefault()
          handlers.duplicate()
        } else if (key === 'A' && handlers.selectAll) {
          e.preventDefault()
          handlers.selectAll()
        } else if (key === 'Z' && handlers.undo) {
          e.preventDefault()
          handlers.undo()
        } else if (key === 'E' && handlers.export) {
          e.preventDefault()
          handlers.export()
        } else if (key === 'G' && handlers.group) {
          e.preventDefault()
          handlers.group()
        } else if (key === ']' && handlers.bringForward) {
          e.preventDefault()
          handlers.bringForward()
        } else if (key === '[' && handlers.sendBackward) {
          e.preventDefault()
          handlers.sendBackward()
        }
      }


      if (ctrl && shift && !alt) {
        if (key === 'Z' && handlers.redo) {
          e.preventDefault()
          handlers.redo()
        } else if (key === 'G' && handlers.ungroup) {
          e.preventDefault()
          handlers.ungroup()
        } else if (key === ']' && handlers.bringToFront) {
          e.preventDefault()
          handlers.bringToFront()
        } else if (key === '[' && handlers.sendToBack) {
          e.preventDefault()
          handlers.sendToBack()
        }
      }
    }

    const handleKeyUp = (e: KeyboardEvent) => {

      if (e.key === ' ' && handlers.tempHandToolRelease) {
        e.preventDefault()
        handlers.tempHandToolRelease()
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    document.addEventListener('keyup', handleKeyUp)

    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.removeEventListener('keyup', handleKeyUp)
    }
  }, [handlers])
}
</file>

<file path="src/hooks/useLayers.ts">
import { useState, useCallback, useEffect } from 'react'
import { ref, onValue, off, update } from 'firebase/database'
import { db } from '../services/firebase'
import type { LayerVisibility, LayerLock } from '../types/layer'
import type { Shape } from '../types/canvas'

interface UseLayersOptions {
  canvasId: string
  enableSync?: boolean
}

interface UseLayersReturn {
  visibility: LayerVisibility
  locks: LayerLock
  toggleVisibility: (objectId: string) => Promise<void>
  toggleLock: (objectId: string) => Promise<void>
  setVisibility: (objectId: string, visible: boolean) => Promise<void>
  setLock: (objectId: string, locked: boolean) => Promise<void>
  reorderLayers: (fromIndex: number, toIndex: number, shapes: Shape[]) => Promise<void>
  isVisible: (objectId: string) => boolean
  isLocked: (objectId: string) => boolean
}





export function useLayers(options?: UseLayersOptions): UseLayersReturn {
  const [visibility, setVisibilityState] = useState<LayerVisibility>({})
  const [locks, setLocksState] = useState<LayerLock>({})
  const syncEnabled = options?.enableSync ?? true
  const canvasId = options?.canvasId ?? 'default-canvas'




  useEffect(() => {
    if (!syncEnabled) return

    const visibilityRef = ref(db, `canvases/${canvasId}/visibility`)
    const locksRef = ref(db, `canvases/${canvasId}/locks`)

    const handleVisibilityChange = (snapshot: any) => {
      if (snapshot.exists()) {
        setVisibilityState(snapshot.val())
      } else {
        setVisibilityState({})
      }
    }

    const handleLocksChange = (snapshot: any) => {
      if (snapshot.exists()) {
        setLocksState(snapshot.val())
      } else {
        setLocksState({})
      }
    }

    onValue(visibilityRef, handleVisibilityChange)
    onValue(locksRef, handleLocksChange)

    return () => {
      off(visibilityRef, 'value', handleVisibilityChange)
      off(locksRef, 'value', handleLocksChange)
    }
  }, [canvasId, syncEnabled])




  const toggleVisibility = useCallback(
    async (objectId: string): Promise<void> => {
      const currentVisibility = visibility[objectId] !== false
      const newVisibility = !currentVisibility

      if (syncEnabled) {
        const visibilityRef = ref(db, `canvases/${canvasId}/visibility/${objectId}`)
        await update(visibilityRef, { value: newVisibility })
      } else {
        setVisibilityState((prev) => ({
          ...prev,
          [objectId]: newVisibility,
        }))
      }
    },
    [canvasId, syncEnabled, visibility]
  )




  const toggleLock = useCallback(
    async (objectId: string): Promise<void> => {
      const currentLock = locks[objectId] === true
      const newLock = !currentLock

      if (syncEnabled) {
        const lockRef = ref(db, `canvases/${canvasId}/locks/${objectId}`)
        await update(lockRef, { value: newLock })
      } else {
        setLocksState((prev) => ({
          ...prev,
          [objectId]: newLock,
        }))
      }
    },
    [canvasId, syncEnabled, locks]
  )




  const setVisibility = useCallback(
    async (objectId: string, visible: boolean): Promise<void> => {
      if (syncEnabled) {
        const visibilityRef = ref(db, `canvases/${canvasId}/visibility/${objectId}`)
        await update(visibilityRef, { value: visible })
      } else {
        setVisibilityState((prev) => ({
          ...prev,
          [objectId]: visible,
        }))
      }
    },
    [canvasId, syncEnabled]
  )




  const setLock = useCallback(
    async (objectId: string, locked: boolean): Promise<void> => {
      if (syncEnabled) {
        const lockRef = ref(db, `canvases/${canvasId}/locks/${objectId}`)
        await update(lockRef, { value: locked })
      } else {
        setLocksState((prev) => ({
          ...prev,
          [objectId]: locked,
        }))
      }
    },
    [canvasId, syncEnabled]
  )




  const reorderLayers = useCallback(
    async (fromIndex: number, toIndex: number, shapes: Shape[]): Promise<void> => {
      if (fromIndex === toIndex) return


      const reordered = [...shapes]
      const [moved] = reordered.splice(fromIndex, 1)
      reordered.splice(toIndex, 0, moved)


      const updates: { [key: string]: any } = {}
      reordered.forEach((shape, index) => {
        if (syncEnabled) {
          updates[`canvases/${canvasId}/objects/${shape.id}/zIndex`] = index
        }
      })

      if (syncEnabled && Object.keys(updates).length > 0) {
        await update(ref(db), updates)
      }
    },
    [canvasId, syncEnabled]
  )




  const isVisible = useCallback(
    (objectId: string): boolean => {
      return visibility[objectId] !== false
    },
    [visibility]
  )




  const isLocked = useCallback(
    (objectId: string): boolean => {
      return locks[objectId] === true
    },
    [locks]
  )

  return {
    visibility,
    locks,
    toggleVisibility,
    toggleLock,
    setVisibility,
    setLock,
    reorderLayers,
    isVisible,
    isLocked,
  }
}
</file>

<file path="src/hooks/usePresence.ts">
import { useEffect, useRef, useCallback, useState } from 'react'
import { ref, set, onValue, onDisconnect, off } from 'firebase/database'
import { db } from '../services/firebase'
import type { Presence, PresenceData } from '../types/firebase'
import { throttle } from '../utils/throttle'


const USER_COLORS = [
  '#EF4444',
  '#F59E0B',
  '#10B981',
  '#3B82F6',
  '#8B5CF6',
  '#EC4899',
  '#14B8A6',
  '#F97316',
]




function getUserColor(userId: string): string {

  let hash = 0
  for (let i = 0; i < userId.length; i++) {
    hash = userId.charCodeAt(i) + ((hash << 5) - hash)
  }
  const index = Math.abs(hash) % USER_COLORS.length
  return USER_COLORS[index]
}

interface UsePresenceOptions {
  userId: string
  userName: string
  canvasId: string
}

interface UsePresenceReturn {
  otherUsers: Map<string, Presence>
  updateCursorPosition: (x: number, y: number) => void
  updateSelection: (objectIds: string[] | null) => void
}





export function usePresence({
  userId,
  userName,
  canvasId: _canvasId,
}: UsePresenceOptions): UsePresenceReturn {
  const [otherUsers, setOtherUsers] = useState<Map<string, Presence>>(new Map())
  const userColor = useRef<string>(getUserColor(userId || 'default'))
  const currentPresence = useRef<Presence>({
    n: userName,
    cl: userColor.current,
    c: [0, 0],
    sel: null,
  })




  const updateCursorPosition = useCallback(
    throttle((x: number, y: number) => {

      if (!userId || !_canvasId) return


      const collabSpaces = ['collab-art', 'collab-design', 'collab-education', 'collab-content', 'collab-gamedev', 'collab-architecture']
      const presencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}/${userId}` : `presence/${_canvasId}/${userId}`
      const presenceRef = ref(db, presencePath)

      currentPresence.current.c = [x, y]
      set(presenceRef, currentPresence.current).catch((error) => {
        console.error('Failed to update cursor position:', error)
      })
    }, 50),
    [userId, _canvasId]
  )





  const updateSelection = useCallback(
    (objectIds: string[] | null) => {

      if (!userId || !_canvasId) return


      const collabSpaces = ['collab-art', 'collab-design', 'collab-education', 'collab-content', 'collab-gamedev', 'collab-architecture']
      const presencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}/${userId}` : `presence/${_canvasId}/${userId}`
      const presenceRef = ref(db, presencePath)

      currentPresence.current.sel = objectIds
      set(presenceRef, currentPresence.current).catch((error) => {
        console.error('Failed to update selection:', error)
      })
    },
    [userId, _canvasId]
  )




  useEffect(() => {

    if (!userId || !_canvasId) {
      return
    }


    const collabSpaces = ['collab-art', 'collab-design', 'collab-education', 'collab-brainstorm', 'collab-content', 'collab-gamedev', 'collab-architecture']
    const presencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}/${userId}` : `presence/${_canvasId}/${userId}`
    const presenceRef = ref(db, presencePath)


    const initialPresence: Presence = {
      n: userName,
      cl: userColor.current,
      c: [0, 0],
      sel: null,
    }
    currentPresence.current = initialPresence
    set(presenceRef, initialPresence).catch((error) => {
      console.error('Failed to set initial presence:', error)
    })


    const disconnectRef = onDisconnect(presenceRef)
    disconnectRef.remove().catch((error) => {
      console.error('Failed to set onDisconnect:', error)
    })


    const allPresencePath = collabSpaces.includes(_canvasId) ? `collab-presence/${_canvasId}` : `presence/${_canvasId}`
    const allPresenceRef = ref(db, allPresencePath)
    const unsubscribe = onValue(
      allPresenceRef,
      (snapshot) => {
        const presenceData = snapshot.val() as PresenceData | null
        if (!presenceData) {
          setOtherUsers(new Map())
          return
        }


        const otherUsersMap = new Map<string, Presence>()
        Object.entries(presenceData).forEach(([uid, presence]) => {
          if (uid !== userId) {
            otherUsersMap.set(uid, presence)
          }
        })

        setOtherUsers(otherUsersMap)
      },
      (error) => {
        console.error('Failed to listen to presence:', error)
      }
    )


    return () => {

      set(presenceRef, null).catch((error) => {
        console.error('Failed to remove presence:', error)
      })

      off(allPresenceRef, 'value', unsubscribe)
    }
  }, [userId, userName, _canvasId])

  return {
    otherUsers,
    updateCursorPosition,
    updateSelection,
  }
}
</file>

<file path="src/hooks/useShapeKeyboardShortcuts.ts">
import { useEffect } from 'react'
import type { Group as GroupType } from '../types/group'

interface UseShapeKeyboardShortcutsProps {
  selectedIds: Set<string>
  groups: GroupType[]
  canUndo: boolean
  canRedo: boolean
  isColorSamplingMode: boolean
  bulkDelete: () => void
  clearSelection: () => void
  selectAll: () => void
  copySelected: () => void
  paste: () => void
  duplicateSelected: () => void
  undo: () => void
  redo: () => void
  createGroup: (shapeIds: string[]) => Promise<string | null>
  ungroup: (groupId: string) => Promise<void>
  cancelColorSampling: () => void
}















export function useShapeKeyboardShortcuts({
  selectedIds,
  groups,
  canUndo,
  canRedo,
  isColorSamplingMode,
  bulkDelete,
  clearSelection,
  selectAll,
  copySelected,
  paste,
  duplicateSelected,
  undo,
  redo,
  createGroup,
  ungroup,
  cancelColorSampling,
}: UseShapeKeyboardShortcutsProps) {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {

      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedIds.size > 0) {
        e.preventDefault()
        bulkDelete()
      }


      if (e.key === 'Escape') {
        e.preventDefault()
        if (isColorSamplingMode) {
          cancelColorSampling()
        } else {
          clearSelection()
        }
      }


      if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
        e.preventDefault()
        selectAll()
      }


      if ((e.metaKey || e.ctrlKey) && e.key === 'c' && selectedIds.size > 0) {
        e.preventDefault()
        copySelected()
      }


      if ((e.metaKey || e.ctrlKey) && e.key === 'v') {
        e.preventDefault()
        paste()
      }


      if ((e.metaKey || e.ctrlKey) && e.key === 'd' && selectedIds.size > 0) {
        e.preventDefault()
        duplicateSelected()
      }


      if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'z' && canUndo) {
        e.preventDefault()
        undo()
      }


      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'z' && canRedo) {
        e.preventDefault()
        redo()
      }


      if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'g' && selectedIds.size >= 2) {
        e.preventDefault()
        const shapeIds = Array.from(selectedIds)
        createGroup(shapeIds).then((groupId) => {
          if (groupId) {
            clearSelection()
          }
        })
      }


      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'g' && selectedIds.size === 1) {
        e.preventDefault()
        const selectedArray = Array.from(selectedIds)
        const selectedId = selectedArray[0]
        const group = groups.find((g) => g.id === selectedId)
        if (group) {
          ungroup(selectedId).then(() => {
            clearSelection()
          })
        }
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [
    selectedIds,
    groups,
    canUndo,
    canRedo,
    isColorSamplingMode,
    bulkDelete,
    clearSelection,
    selectAll,
    copySelected,
    paste,
    duplicateSelected,
    undo,
    redo,
    createGroup,
    ungroup,
    cancelColorSampling,
  ])
}
</file>

<file path="src/hooks/useTilemap.ts">
import { useState, useCallback, useEffect, useRef, useMemo } from 'react'
import { ref, onValue } from 'firebase/database'
import { db } from '../services/firebase'
import {
  subscribeToChunk,
  subscribeToMeta,
  setTile as syncSetTile,
  setTiles as syncSetTiles,
  deleteTile as syncDeleteTile,
  deleteTiles as syncDeleteTiles,
  getMeta,
  setMeta as syncSetMeta,
  initializeTilemap,
} from '../services/tilemapSync'
import { floodFill } from '../services/tileFill'
import type {
  TileData,
  TilemapMeta,
  TileMode,
  ConnectionStatus,
  PaletteColor,
  coordToKey,
  keyToChunkCoord,
  getVisibleChunks,
} from '../types/tilemap'
import {
  coordToKey as _coordToKey,
  keyToChunkCoord as _keyToChunkCoord,
  getVisibleChunks as _getVisibleChunks,
  DEFAULT_TILEMAP_META,
  isValidTileCoord,
} from '../types/tilemap'


export { coordToKey }

interface UseTilemapOptions {
  canvasId: string
  userId: string
  enableSync?: boolean
}

interface UseTilemapReturn {

  tiles: Map<string, TileData>
  meta: TilemapMeta
  isInitialized: boolean
  isConnected: boolean
  connectionStatus: ConnectionStatus


  setTile: (x: number, y: number, tile: TileData) => void
  getTile: (x: number, y: number) => TileData | undefined
  deleteTile: (x: number, y: number) => void
  clearAllTiles: () => void


  setTiles: (tiles: Array<{ x: number; y: number; tile: TileData }>) => void
  deleteTiles: (tiles: Array<{ x: number; y: number }>) => void
  fillTiles: (x: number, y: number, targetType: string, newType: string, newColor: string) => void


  updateMeta: (updates: Partial<TilemapMeta>) => void


  loadVisibleChunks: (viewport: { x: number; y: number; width: number; height: number }) => void
  loadedChunks: Set<string>


  getTileCount: () => number


  selectedPaletteIndex: number
  setSelectedPaletteIndex: (index: number) => void
  getSelectedTile: () => PaletteColor


  mode: TileMode
  setMode: (mode: TileMode) => void
}





export function useTilemap(options: UseTilemapOptions): UseTilemapReturn {
  const { canvasId, userId, enableSync = true } = options


  const [tiles, setTiles] = useState<Map<string, TileData>>(new Map())
  const [meta, setMeta] = useState<TilemapMeta>(DEFAULT_TILEMAP_META)
  const [isInitialized, setIsInitialized] = useState(false)
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('connected')


  const loadedChunksRef = useRef<Set<string>>(new Set())
  const [loadedChunks, setLoadedChunks] = useState<Set<string>>(new Set())
  const chunkUnsubscribes = useRef<Map<string, () => void>>(new Map())


  const [pendingWrites, setPendingWrites] = useState<Map<string, { x: number; y: number; tile: TileData | null }>>(new Map())
  const writeTimerRef = useRef<NodeJS.Timeout | null>(null)


  const [selectedPaletteIndex, setSelectedPaletteIndex] = useState(0)
  const [mode, setMode] = useState<TileMode>('stamp')





  useEffect(() => {
    const connectedRef = ref(db, '.info/connected')
    const unsubscribe = onValue(connectedRef, (snap) => {
      const connected = snap.val() as boolean
      setConnectionStatus(connected ? 'connected' : 'disconnected')
    })

    return unsubscribe
  }, [])





  useEffect(() => {
    if (!enableSync) return

    const initTilemap = async () => {
      try {

        const existingMeta = await getMeta(canvasId)

        if (existingMeta) {

          setMeta(existingMeta)
        } else {

          await initializeTilemap(canvasId, DEFAULT_TILEMAP_META)
          setMeta(DEFAULT_TILEMAP_META)
        }

        setIsInitialized(true)
      } catch (error) {
        console.error('Failed to initialize tilemap:', error)
      }
    }

    initTilemap()
  }, [canvasId, enableSync])





  useEffect(() => {
    if (!enableSync || !isInitialized) return

    const unsubscribe = subscribeToMeta(canvasId, (newMeta) => {
      setMeta(newMeta)
    })

    return unsubscribe
  }, [canvasId, enableSync, isInitialized])





  useEffect(() => {
    if (pendingWrites.size === 0) return


    if (writeTimerRef.current) {
      clearTimeout(writeTimerRef.current)
    }


    writeTimerRef.current = setTimeout(async () => {
      if (!enableSync) {
        setPendingWrites(new Map())
        return
      }

      try {

        const tilesToSet: Array<{ x: number; y: number; tile: TileData }> = []
        const tilesToDelete: Array<{ x: number; y: number }> = []

        pendingWrites.forEach((entry) => {
          if (entry.tile === null) {
            tilesToDelete.push({ x: entry.x, y: entry.y })
          } else {
            tilesToSet.push({ x: entry.x, y: entry.y, tile: entry.tile })
          }
        })


        if (tilesToSet.length > 0) {
          await syncSetTiles(canvasId, tilesToSet, userId, meta.chunkSize)
        }
        if (tilesToDelete.length > 0) {
          await syncDeleteTiles(canvasId, tilesToDelete, meta.chunkSize)
        }


        setPendingWrites(new Map())
      } catch (error) {
        console.error('Failed to batch write tiles:', error)

      }
    }, 100)

    return () => {
      if (writeTimerRef.current) {
        clearTimeout(writeTimerRef.current)
      }
    }
  }, [pendingWrites, enableSync, canvasId, userId, meta.chunkSize])





  const loadVisibleChunks = useCallback(
    (viewport: { x: number; y: number; width: number; height: number }) => {
      if (!isInitialized) return


      const visibleChunkKeys = _getVisibleChunks(
        viewport.x,
        viewport.y,
        viewport.width,
        viewport.height,
        meta.tileSize,
        meta.chunkSize
      )

      const visibleSet = new Set(visibleChunkKeys)


      loadedChunksRef.current.forEach((chunkKey) => {
        if (!visibleSet.has(chunkKey)) {
          const unsub = chunkUnsubscribes.current.get(chunkKey)
          if (unsub) {
            unsub()
            chunkUnsubscribes.current.delete(chunkKey)
          }
        }
      })


      visibleChunkKeys.forEach((chunkKey) => {
        if (!loadedChunksRef.current.has(chunkKey) && enableSync) {
          const { cx, cy } = _keyToChunkCoord(chunkKey)

          const unsub = subscribeToChunk(
            canvasId,
            cx,
            cy,
            {
              onTile: (x, y, tile) => {
                const key = _coordToKey(x, y)
                setTiles((prev) => {
                  const newTiles = new Map(prev)
                  newTiles.set(key, tile)
                  return newTiles
                })
              },
              onRemove: (x, y) => {
                const key = _coordToKey(x, y)
                setTiles((prev) => {
                  const newTiles = new Map(prev)
                  newTiles.delete(key)
                  return newTiles
                })
              },
            },
            meta.chunkSize
          )

          chunkUnsubscribes.current.set(chunkKey, unsub)
        }
      })


      loadedChunksRef.current = visibleSet
      setLoadedChunks(visibleSet)
    },
    [isInitialized, enableSync, canvasId, meta.tileSize, meta.chunkSize]
  )


  useEffect(() => {
    return () => {
      chunkUnsubscribes.current.forEach((unsub) => unsub())
      chunkUnsubscribes.current.clear()
    }
  }, [])





  const setTileLocal = useCallback(
    (x: number, y: number, tile: TileData) => {

      if (!isValidTileCoord(x, y, meta)) {
        console.warn('Tile coordinates out of bounds:', x, y)
        return
      }

      const key = _coordToKey(x, y)


      setTiles((prev) => {
        const newTiles = new Map(prev)
        newTiles.set(key, tile)
        return newTiles
      })


      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        newPending.set(key, { x, y, tile })
        return newPending
      })
    },
    [meta]
  )

  const getTile = useCallback(
    (x: number, y: number): TileData | undefined => {
      const key = _coordToKey(x, y)
      return tiles.get(key)
    },
    [tiles]
  )

  const deleteTileLocal = useCallback(
    (x: number, y: number) => {
      const key = _coordToKey(x, y)


      setTiles((prev) => {
        const newTiles = new Map(prev)
        newTiles.delete(key)
        return newTiles
      })


      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        newPending.set(key, { x, y, tile: null })
        return newPending
      })
    },
    []
  )

  const setTilesLocal = useCallback(
    (tilesToSet: Array<{ x: number; y: number; tile: TileData }>) => {

      setTiles((prev) => {
        const newTiles = new Map(prev)
        tilesToSet.forEach(({ x, y, tile }) => {
          if (isValidTileCoord(x, y, meta)) {
            const key = _coordToKey(x, y)
            newTiles.set(key, tile)
          }
        })
        return newTiles
      })


      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        tilesToSet.forEach(({ x, y, tile }) => {
          if (isValidTileCoord(x, y, meta)) {
            const key = _coordToKey(x, y)
            newPending.set(key, { x, y, tile })
          }
        })
        return newPending
      })
    },
    [meta]
  )

  const deleteTilesLocal = useCallback(
    (tilesToDelete: Array<{ x: number; y: number }>) => {

      setTiles((prev) => {
        const newTiles = new Map(prev)
        tilesToDelete.forEach(({ x, y }) => {
          const key = _coordToKey(x, y)
          newTiles.delete(key)
        })
        return newTiles
      })


      setPendingWrites((prev) => {
        const newPending = new Map(prev)
        tilesToDelete.forEach(({ x, y }) => {
          const key = _coordToKey(x, y)
          newPending.set(key, { x, y, tile: null })
        })
        return newPending
      })
    },
    []
  )

  const clearAllTiles = useCallback(() => {
    setTiles(new Map())


  }, [])

  const fillTilesLocal = useCallback(
    (x: number, y: number, targetType: string, newType: string, newColor: string) => {

      const fillResult = floodFill(
        tiles,
        x,
        y,
        { type: newType, color: newColor },
        meta.width || 256,
        meta.height || 256,
        1000
      )

      if (fillResult.tiles.length > 0) {

        setTilesLocal(fillResult.tiles)

        if (fillResult.limitReached) {
          console.warn('Fill limit reached (1000 tiles). Large areas may require multiple fills.')
        }
      }
    },
    [tiles, meta, setTilesLocal]
  )





  const updateMeta = useCallback(
    async (updates: Partial<TilemapMeta>) => {
      try {

        setMeta((prev) => ({ ...prev, ...updates }))


        if (enableSync) {
          await syncSetMeta(canvasId, updates)
        }
      } catch (error) {
        console.error('Failed to update tilemap meta:', error)

      }
    },
    [canvasId, enableSync]
  )





  const getTileCount = useCallback(() => {
    return tiles.size
  }, [tiles])

  const getSelectedTile = useCallback((): PaletteColor => {
    return meta.palette[selectedPaletteIndex] || meta.palette[0]
  }, [meta.palette, selectedPaletteIndex])





  return {

    tiles,
    meta,
    isInitialized,
    isConnected: connectionStatus === 'connected',
    connectionStatus,


    setTile: setTileLocal,
    getTile,
    deleteTile: deleteTileLocal,
    clearAllTiles,


    setTiles: setTilesLocal,
    deleteTiles: deleteTilesLocal,
    fillTiles: fillTilesLocal,


    updateMeta,


    loadVisibleChunks,
    loadedChunks,


    getTileCount,


    selectedPaletteIndex,
    setSelectedPaletteIndex,
    getSelectedTile,


    mode,
    setMode,
  }
}
</file>

<file path="src/index.css">
@import "tailwindcss";

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}


html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100vh;
  overflow: hidden;
  background-color: #f3f4f6;
}


button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover {
  opacity: 0.9;
}

button:focus,
button:focus-visible {
  outline: 2px solid #3B82F6;
  outline-offset: 2px;
}
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import ErrorBoundary from './components/ErrorBoundary.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </StrictMode>,
)
</file>

<file path="src/pages/CanvasPage.tsx">
import { useState, useCallback, useEffect, useRef } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import Canvas from '../components/Canvas'
import PresenceBar from '../components/PresenceBar'
import Toolbar from '../components/Toolbar'
import { LayerPanel } from '../components/LayerPanel'
import { useAuth } from '../hooks/useAuth'
import { usePresence } from '../hooks/usePresence'
import { useCanvas } from '../hooks/useCanvas'
import { useGroups } from '../hooks/useGroups'
import { useLayers } from '../hooks/useLayers'
import { getCanvas, updateCanvas, generateThumbnail } from '../services/canvasManager'
import type { ToolType } from '../types/canvas'
import type { CanvasMetadata } from '../services/canvasManager'
import type Konva from 'konva'





export default function CanvasPage() {
  const { canvasId } = useParams<{ canvasId: string }>()
  const navigate = useNavigate()
  const [selectedTool, setSelectedTool] = useState<ToolType>('select')
  const [canvasMetadata, setCanvasMetadata] = useState<CanvasMetadata | null>(null)
  const [viewport, setViewport] = useState({ scale: 1 })
  const stageRef = useRef<Konva.Stage | null>(null)


  const [snapToGrid, setSnapToGrid] = useState(false)


  const [isTilemapMode, setIsTilemapMode] = useState(false)


  const zoomControlsRef = useRef<{
    zoomIn: () => void
    zoomOut: () => void
    zoomReset: () => void
    zoomFit: () => void
  } | null>(null)

  const { user } = useAuth()


  if (!canvasId) {
    navigate('/')
    return null
  }


  const { shapes, selectedIds, setSelection, updateColors, updateShape, getRecentColors, deleteShape } = useCanvas({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  // Color sampling callback (passed from Canvas)
  const [enableColorSampling, setEnableColorSampling] = useState<((callback: (color: string) => void) => void) | null>(null)

  // Wrap setEnableColorSampling to avoid setState during render
  const handleColorSamplingReady = useCallback((fn: (callback: (color: string) => void) => void) => {
    // Defer setState to next tick to avoid "setState during render" error
    setTimeout(() => {
      setEnableColorSampling(() => fn)
    }, 0)
  }, [])

  const { groups } = useGroups({
    canvasId: canvasId,
    userId: user?.uid || '',
    enableSync: true,
  })

  const { toggleVisibility, toggleLock } = useLayers({
    canvasId: canvasId,
    enableSync: true,
  })


  // Load canvas metadata
  useEffect(() => {
    if (!user?.uid || !canvasId) return

    const loadCanvas = async () => {
      try {
        // Check if this is a collab space (public shared canvas)
        // Load canvas from database
        const canvas = await getCanvas(canvasId, user.uid)
        if (!canvas) {
          alert('Canvas not found')
          navigate('/')
          return
        }
        setCanvasMetadata(canvas)
      } catch (error) {
        console.error('Error loading canvas:', error)
        navigate('/')
      }
    }

    loadCanvas()
  }, [canvasId, user?.uid, navigate])


  const { otherUsers } = usePresence({
    userId: user?.uid || '',
    userName: user?.displayName || user?.email || 'Anonymous',
    canvasId: canvasId,
  })


  useEffect(() => {
    if (!user?.uid || !canvasId || !stageRef.current) return

    const interval = setInterval(() => {
      const thumbnail = generateThumbnail(stageRef.current)
      if (thumbnail) {
        updateCanvas(canvasId, user.uid, { thumbnail }).catch(console.error)
      }
    }, 30000)

    return () => clearInterval(interval)
  }, [canvasId, user?.uid])


  const handleToolSelect = useCallback((tool: ToolType) => {
    setSelectedTool(tool)

    if (tool !== 'select' && tool !== 'delete') {
      setSelection(null)
    }
  }, [setSelection])


  const handleShapeSelect = useCallback((id: string | null) => {
    setSelection(id)
  }, [setSelection])


  const [deleteTriggered, setDeleteTriggered] = useState(0)


  const handleDelete = useCallback(() => {

    setDeleteTriggered((prev) => prev + 1)
  }, [])


  const [canUndo, setCanUndo] = useState(false)
  const [canRedo, setCanRedo] = useState(false)
  const [undoFn, setUndoFn] = useState<(() => void) | null>(null)
  const [redoFn, setRedoFn] = useState<(() => void) | null>(null)


  const handleUndoRedoChange = useCallback(
    (canUndo: boolean, canRedo: boolean, undo: () => void, redo: () => void) => {
      setCanUndo(canUndo)
      setCanRedo(canRedo)
      setUndoFn(() => undo)
      setRedoFn(() => redo)
    },
    []
  )


  const handleZoomIn = useCallback(() => {
    zoomControlsRef.current?.zoomIn()
  }, [])

  const handleZoomOut = useCallback(() => {
    zoomControlsRef.current?.zoomOut()
  }, [])

  const handleZoomReset = useCallback(() => {
    zoomControlsRef.current?.zoomReset()
  }, [])

  const handleZoomFit = useCallback(() => {
    zoomControlsRef.current?.zoomFit()
  }, [])


  const handleZoomControlsReady = useCallback((zoomIn: () => void, zoomOut: () => void, zoomReset: () => void, zoomFit: () => void) => {
    zoomControlsRef.current = { zoomIn, zoomOut, zoomReset, zoomFit }
  }, [])


  const handleBack = () => {
    navigate('/', { replace: true })


    setTimeout(() => {
      if (window.location.pathname !== '/') {
        window.location.href = '/'
      }
    }, 100)
  }


  const getDisplayName = () => {
    if (canvasId === 'public-board') {
      return '🌍 Public Collaboration Board'
    }
    return canvasMetadata?.name || 'Loading...'
  }


  const handleCanvasNameChange = useCallback(
    async (newName: string) => {
      if (!user?.uid || !canvasId || !newName.trim()) return

      try {
        await updateCanvas(canvasId, user.uid, { name: newName.trim() })
        setCanvasMetadata((prev) => (prev ? { ...prev, name: newName.trim() } : null))
      } catch (error) {
        console.error('Error updating canvas name:', error)
      }
    },
    [canvasId, user?.uid]
  )


  const handleSelectLayer = useCallback((layerId: string) => {
    setSelection(layerId)
  }, [setSelection])

  const handleRenameLayer = useCallback((layerId: string, newName: string) => {


    console.log(`Rename layer ${layerId} to ${newName}`)
  }, [])

  return (
    <div className="w-full h-screen overflow-hidden flex flex-col bg-neutral-50">
      {}
      <PresenceBar
        currentUser={{
          displayName: user?.displayName || null,
          email: user?.email || null,
        }}
        otherUsers={otherUsers}
        scale={viewport.scale}
        onZoomIn={handleZoomIn}
        onZoomOut={handleZoomOut}
        onZoomReset={handleZoomReset}
        onZoomFit={handleZoomFit}
        canvasName={getDisplayName()}
        onCanvasNameChange={canvasId === 'public-board' ? undefined : handleCanvasNameChange}
        lastEdited="Just now"
        onBack={handleBack}
        snapToGrid={snapToGrid}
        onSnapToggle={() => setSnapToGrid(!snapToGrid)}
        isTilemapMode={isTilemapMode}
        onToggleTilemapMode={() => setIsTilemapMode(!isTilemapMode)}
      />

      {}
      <div className="flex flex-row h-[calc(100vh-64px)]">
        {}
        {!isTilemapMode && (
          <Toolbar
            selectedTool={selectedTool}
            onToolSelect={handleToolSelect}
            hasSelection={selectedIds.size > 0}
            onDelete={handleDelete}
            canUndo={canUndo}
            canRedo={canRedo}
            onUndo={undoFn || undefined}
            onRedo={redoFn || undefined}
          />
        )}

        {}
        <div className="flex-1 h-full overflow-hidden">
          <Canvas
            selectedTool={selectedTool}
            onShapeSelect={handleShapeSelect}
            deleteTriggered={deleteTriggered}
            onUndoRedoChange={handleUndoRedoChange}
            canvasId={canvasId}
            onZoomChange={(scale) => setViewport({ scale })}
            onZoomControlsReady={handleZoomControlsReady}
            snapToGrid={snapToGrid}
            onColorSamplingReady={handleColorSamplingReady}
            isTilemapMode={isTilemapMode}
          />
        </div>

        {}
        {!isTilemapMode && (
          <LayerPanel
            shapes={shapes}
            groups={groups}
            selectedIds={selectedIds}
            onSelectLayer={handleSelectLayer}
            onToggleVisibility={toggleVisibility}
            onToggleLock={toggleLock}
            onRenameLayer={handleRenameLayer}
            onDelete={deleteShape}
            onUpdateColors={(fill, stroke, strokeWidth) => updateColors(fill, stroke, strokeWidth)}
            onUpdateShapeProps={(id, updates) => updateShape(id, updates)}
            recentColors={getRecentColors()}
            onRequestColorSample={enableColorSampling || undefined}
          />
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/pages/DashboardPage.tsx">
import { useAuth } from '../hooks/useAuth'
import { useCanvasList } from '../hooks/useCanvasList'
import { CanvasCard } from '../components/CanvasCard'
import { SkeletonCard } from '../components/Skeleton'
import { logOut } from '../services/auth'




export default function DashboardPage() {
  const { user } = useAuth()
  const {
    canvases,
    loading,
    error,
    createCanvas,
    deleteCanvas,
    duplicateCanvas,
    updateCanvasName,
  } = useCanvasList(user?.uid || '')

  const handleLogout = async () => {
    try {
      await logOut()
    } catch (error) {
      console.error('Logout failed:', error)
    }
  }

  const handleCreateCanvas = async () => {
    const name = prompt('Canvas name:', 'Untitled Canvas')
    if (name && name.trim()) {
      try {
        await createCanvas(name.trim())
      } catch (err) {
        alert('Failed to create canvas')
      }
    }
  }

  return (
    <div className="min-h-screen bg-neutral-50">
      {}
      <header className="fixed top-0 left-0 right-0 h-16 bg-white border-b border-neutral-200 shadow-soft z-50">
        <div className="max-w-7xl mx-auto px-6 h-full flex items-center justify-between">
          {}
          <div className="flex items-center gap-3">
            <h1 className="text-xl font-bold text-neutral-900">CollabCanvas</h1>
          </div>

          {}
          <div className="flex items-center gap-3">
            {}
            <div className="text-sm text-neutral-600">
              {user?.displayName || user?.email}
            </div>

            {}
            <button
              onClick={handleLogout}
              className="px-3 py-1.5 bg-neutral-100 hover:bg-neutral-200 text-neutral-700 text-sm font-medium rounded-lg transition-colors"
            >
              Logout
            </button>
          </div>
        </div>
      </header>

      {}
      <main className="pt-20">
        <div className="max-w-7xl mx-auto px-6 py-8">
          {}
          <div className="mb-12">
            <a href="/canvas/public-board" className="group block">
              <div className="relative bg-gradient-to-br from-slate-600 to-gray-700 rounded-2xl p-8 shadow-xl hover:shadow-2xl transition-all duration-300 transform hover:scale-[1.02] min-h-[240px]">
                {}
                <div className="absolute inset-0 bg-white/10 rounded-2xl" style={{
                  backgroundImage: 'radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px)',
                  backgroundSize: '16px 16px'
                }}></div>

                {}
                <div className="relative z-10 h-full flex flex-col">
                  <div className="flex items-start justify-between mb-6">
                    <div className="flex items-center gap-4">
                      <div className="w-16 h-16 bg-white/20 backdrop-blur-sm rounded-xl flex items-center justify-center text-4xl shadow-lg">
                        🌍
                      </div>
                      <div>
                        <h2 className="text-3xl font-bold text-white mb-2">Public Collaboration Board</h2>
                        <p className="text-slate-200 text-sm">Join the community canvas - collaborate in real-time with everyone</p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2 bg-emerald-500/20 border border-emerald-400/30 backdrop-blur-sm px-4 py-2 rounded-full">
                      <div className="w-2.5 h-2.5 bg-emerald-400 rounded-full animate-pulse"></div>
                      <span className="text-emerald-100 text-sm font-medium">Live Now</span>
                    </div>
                  </div>

                  <p className="text-white/90 text-base mb-6 flex-1 max-w-3xl">
                    A shared creative space where anyone can draw, design, and collaborate together.
                    Perfect for brainstorming, art projects, or just having fun with others.
                  </p>

                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-6">
                      <span className="text-white/80 text-sm flex items-center gap-2">
                        <span className="text-lg">👥</span>
                        <span className="font-medium">12 active users</span>
                      </span>
                      <span className="text-white/80 text-sm flex items-center gap-2">
                        <span className="text-lg">🎨</span>
                        <span className="font-medium">Open to all</span>
                      </span>
                    </div>
                    <span className="text-white text-lg font-semibold group-hover:translate-x-2 transition-transform flex items-center gap-2">
                      Join Public Board →
                    </span>
                  </div>
                </div>
              </div>
            </a>
          </div>

          {}
          <div className="mb-8">
            <h2 className="text-2xl font-bold text-neutral-900 mb-2">
              Your Private Canvases
            </h2>
            <p className="text-neutral-600">
              Create and manage your personal design projects
            </p>
          </div>

          {}
          {error && (
            <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg text-red-600 text-sm">
              {error}
            </div>
          )}

          {}
          {loading ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              <SkeletonCard />
              <SkeletonCard />
              <SkeletonCard />
              <SkeletonCard />
            </div>
          ) : canvases.length === 0 ? (

            <div className="text-center py-16">
              <div className="mb-4">
                <span className="text-6xl">🎨</span>
              </div>
              <h3 className="text-xl font-semibold text-neutral-900 mb-2">
                No canvases yet
              </h3>
              <p className="text-neutral-600 mb-6">
                Create your first canvas to get started
              </p>
              <button
                onClick={handleCreateCanvas}
                className="px-6 py-3 bg-primary-600 hover:bg-primary-700 text-white font-medium rounded-lg transition-colors"
              >
                Create New Canvas
              </button>
            </div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              {}
              <button
                key="create-new"
                onClick={handleCreateCanvas}
                className="h-[260px] bg-white rounded-lg border-2 border-dashed border-neutral-300 hover:border-primary-500 hover:bg-primary-50 transition-all duration-150 flex flex-col items-center justify-center gap-3"
              >
                <span className="text-4xl text-neutral-400">+</span>
                <span className="text-sm font-medium text-neutral-600">
                  Create New Canvas
                </span>
              </button>

              {}
              {canvases.map((canvas) => (
                <CanvasCard
                  key={canvas.id}
                  canvas={canvas}
                  onDelete={deleteCanvas}
                  onDuplicate={duplicateCanvas}
                  onRename={updateCanvasName}
                />
              ))}
            </div>
          )}
        </div>
      </main>
    </div>
  )
}
</file>

<file path="src/services/alignment.ts">
import type { Shape } from '../types/canvas'




export type AlignmentType = 'left' | 'center' | 'right' | 'top' | 'middle' | 'bottom'




export type DistributionType = 'horizontal' | 'vertical'





export interface AlignmentResult {
  [shapeId: string]: { x: number; y: number }
}




export function alignLeft(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}


  const minX = Math.min(...shapes.map(s => s.x))


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: minX, y: shape.y }
  })

  return updates
}




export function alignCenter(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}


  const centerXs = shapes.map(s => s.x + s.width / 2)
  const avgCenterX = centerXs.reduce((sum, x) => sum + x, 0) / centerXs.length


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: avgCenterX - shape.width / 2, y: shape.y }
  })

  return updates
}




export function alignRight(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}


  const maxX = Math.max(...shapes.map(s => s.x + s.width))


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: maxX - shape.width, y: shape.y }
  })

  return updates
}




export function alignTop(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}


  const minY = Math.min(...shapes.map(s => s.y))


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: shape.x, y: minY }
  })

  return updates
}




export function alignMiddle(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}


  const centerYs = shapes.map(s => s.y + s.height / 2)
  const avgCenterY = centerYs.reduce((sum, y) => sum + y, 0) / centerYs.length


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: shape.x, y: avgCenterY - shape.height / 2 }
  })

  return updates
}




export function alignBottom(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 2) return {}


  const maxY = Math.max(...shapes.map(s => s.y + s.height))


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = { x: shape.x, y: maxY - shape.height }
  })

  return updates
}





export function distributeHorizontally(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 3) return {}


  const sortedShapes = [...shapes].sort((a, b) => a.x - b.x)


  const leftmost = sortedShapes[0]
  const rightmost = sortedShapes[sortedShapes.length - 1]
  const leftEdge = leftmost.x
  const rightEdge = rightmost.x + rightmost.width


  const totalWidth = sortedShapes.reduce((sum, s) => sum + s.width, 0)
  const availableSpace = rightEdge - leftEdge - totalWidth
  const spacing = availableSpace / (sortedShapes.length - 1)


  const updates: AlignmentResult = {}
  let currentX = leftEdge

  sortedShapes.forEach((shape, index) => {
    if (index === 0) {

      currentX += shape.width + spacing
    } else if (index === sortedShapes.length - 1) {

    } else {

      updates[shape.id] = { x: currentX, y: shape.y }
      currentX += shape.width + spacing
    }
  })

  return updates
}





export function distributeVertically(shapes: Shape[]): AlignmentResult {
  if (shapes.length < 3) return {}


  const sortedShapes = [...shapes].sort((a, b) => a.y - b.y)


  const topmost = sortedShapes[0]
  const bottommost = sortedShapes[sortedShapes.length - 1]
  const topEdge = topmost.y
  const bottomEdge = bottommost.y + bottommost.height


  const totalHeight = sortedShapes.reduce((sum, s) => sum + s.height, 0)
  const availableSpace = bottomEdge - topEdge - totalHeight
  const spacing = availableSpace / (sortedShapes.length - 1)


  const updates: AlignmentResult = {}
  let currentY = topEdge

  sortedShapes.forEach((shape, index) => {
    if (index === 0) {

      currentY += shape.height + spacing
    } else if (index === sortedShapes.length - 1) {

    } else {

      updates[shape.id] = { x: shape.x, y: currentY }
      currentY += shape.height + spacing
    }
  })

  return updates
}




export function centerInCanvas(
  shapes: Shape[],
  canvasWidth: number,
  canvasHeight: number
): AlignmentResult {
  if (shapes.length === 0) return {}


  const minX = Math.min(...shapes.map(s => s.x))
  const maxX = Math.max(...shapes.map(s => s.x + s.width))
  const minY = Math.min(...shapes.map(s => s.y))
  const maxY = Math.max(...shapes.map(s => s.y + s.height))

  const boundingWidth = maxX - minX
  const boundingHeight = maxY - minY


  const targetCenterX = canvasWidth / 2
  const targetCenterY = canvasHeight / 2
  const currentCenterX = minX + boundingWidth / 2
  const currentCenterY = minY + boundingHeight / 2

  const offsetX = targetCenterX - currentCenterX
  const offsetY = targetCenterY - currentCenterY


  const updates: AlignmentResult = {}
  shapes.forEach(shape => {
    updates[shape.id] = {
      x: shape.x + offsetX,
      y: shape.y + offsetY,
    }
  })

  return updates
}




export function alignShapes(shapes: Shape[], type: AlignmentType): AlignmentResult {
  switch (type) {
    case 'left':
      return alignLeft(shapes)
    case 'center':
      return alignCenter(shapes)
    case 'right':
      return alignRight(shapes)
    case 'top':
      return alignTop(shapes)
    case 'middle':
      return alignMiddle(shapes)
    case 'bottom':
      return alignBottom(shapes)
    default:
      return {}
  }
}
</file>

<file path="src/services/auth.ts">
import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  updateProfile,
} from 'firebase/auth'
import type { UserCredential } from 'firebase/auth'
import { auth } from './firebase'
import type { User } from '../types/firebase'




export async function signUp(
  email: string,
  password: string,
  displayName: string
): Promise<User> {
  try {

    const userCredential: UserCredential = await createUserWithEmailAndPassword(
      auth,
      email,
      password
    )


    await updateProfile(userCredential.user, {
      displayName,
    })


    return {
      uid: userCredential.user.uid,
      email: userCredential.user.email,
      displayName,
    }
  } catch (error: any) {

    if (error.code === 'auth/email-already-in-use') {
      throw new Error('Email already in use')
    } else if (error.code === 'auth/invalid-email') {
      throw new Error('Invalid email address')
    } else if (error.code === 'auth/weak-password') {
      throw new Error('Password should be at least 6 characters')
    } else {
      throw new Error('Failed to create account: ' + error.message)
    }
  }
}




export async function signIn(email: string, password: string): Promise<User> {
  try {
    const userCredential: UserCredential = await signInWithEmailAndPassword(
      auth,
      email,
      password
    )

    return {
      uid: userCredential.user.uid,
      email: userCredential.user.email,
      displayName: userCredential.user.displayName,
    }
  } catch (error: any) {

    if (error.code === 'auth/user-not-found') {
      throw new Error('No account found with this email')
    } else if (error.code === 'auth/wrong-password') {
      throw new Error('Incorrect password')
    } else if (error.code === 'auth/invalid-email') {
      throw new Error('Invalid email address')
    } else if (error.code === 'auth/user-disabled') {
      throw new Error('This account has been disabled')
    } else {
      throw new Error('Failed to sign in: ' + error.message)
    }
  }
}




export async function logOut(): Promise<void> {
  try {
    await signOut(auth)
  } catch (error: any) {
    throw new Error('Failed to log out: ' + error.message)
  }
}
</file>

<file path="src/services/canvasManager.ts">
import { ref, set, get, remove, update } from 'firebase/database'
import { db } from './firebase'
import type Konva from 'konva'

export interface CanvasMetadata {
  id: string
  name: string
  createdAt: number
  updatedAt: number
  thumbnail: string
  ownerId: string
}

export interface CanvasPermission {
  role: 'owner' | 'editor' | 'viewer'
  grantedAt: number
}




function generateCanvasId(): string {
  return `canvas-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}




export async function createCanvas(
  name: string,
  userId: string
): Promise<CanvasMetadata> {
  const canvasId = generateCanvasId()
  const now = Date.now()

  const metadata: CanvasMetadata = {
    id: canvasId,
    name,
    createdAt: now,
    updatedAt: now,
    thumbnail: '',
    ownerId: userId,
  }

  try {
    // Create canvas metadata in users/{userId}/canvases/{canvasId}
    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)
    await set(userCanvasRef, metadata)

    // Create owner permission in canvases/{canvasId}/permissions/{userId}
    const permissionRef = ref(db, `canvases/${canvasId}/permissions/${userId}`)
    await set(permissionRef, {
      role: 'owner',
      grantedAt: now,
    } as CanvasPermission)

    console.log(`Canvas created: ${canvasId}`)
    return metadata
  } catch (error) {
    console.error('Error creating canvas:', error)
    throw error
  }
}




export async function deleteCanvas(
  canvasId: string,
  userId: string
): Promise<void> {
  try {

    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)
    await remove(userCanvasRef)


    const canvasRef = ref(db, `canvases/${canvasId}`)
    await remove(canvasRef)


    const presenceRef = ref(db, `presence/${canvasId}`)
    await remove(presenceRef)

    console.log(`Canvas deleted: ${canvasId}`)
  } catch (error) {
    console.error('Error deleting canvas:', error)
    throw error
  }
}





export async function updateCanvas(
  canvasId: string,
  userId: string,
  updates: Partial<Pick<CanvasMetadata, 'name' | 'thumbnail'>>
): Promise<void> {
  try {

    const collabSpaces = [
      'collab-art', 'collab-design', 'collab-education',
      'collab-content', 'collab-gamedev',
      'collab-architecture'
    ]

    if (collabSpaces.includes(canvasId)) {
      const publicRef = ref(db, `collab-spaces/${canvasId}/metadata`)
      await update(publicRef, {
        ...updates,
        updatedAt: Date.now(),
      })
      console.log(`Collab space ${canvasId} updated`)
      return
    }

    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)

    const updateData: any = {
      ...updates,
      updatedAt: Date.now(),
    }

    await update(userCanvasRef, updateData)
    console.log(`Canvas updated: ${canvasId}`)
  } catch (error) {
    console.error('Error updating canvas:', error)
    throw error
  }
}




export async function getCanvasList(
  userId: string
): Promise<CanvasMetadata[]> {
  try {

    const userCanvasesRef = ref(db, `users/${userId}/canvases`)
    const snapshot = await get(userCanvasesRef)

    if (!snapshot.exists()) {
      return []
    }

    const canvasesData = snapshot.val()
    const canvases: CanvasMetadata[] = Object.values(canvasesData)


    canvases.sort((a, b) => b.updatedAt - a.updatedAt)

    return canvases
  } catch (error) {
    console.error('Error getting canvas list:', error)
    throw error
  }
}




export async function duplicateCanvas(
  sourceCanvasId: string,
  userId: string
): Promise<CanvasMetadata> {
  try {

    const sourceMetadataRef = ref(db, `users/${userId}/canvases/${sourceCanvasId}`)
    const metadataSnapshot = await get(sourceMetadataRef)

    if (!metadataSnapshot.exists()) {
      throw new Error('Source canvas not found')
    }

    const sourceMetadata = metadataSnapshot.val() as CanvasMetadata


    const newCanvas = await createCanvas(
      `${sourceMetadata.name} (Copy)`,
      userId
    )


    const sourceObjectsRef = ref(db, `canvases/${sourceCanvasId}/objects`)
    const objectsSnapshot = await get(sourceObjectsRef)

    if (objectsSnapshot.exists()) {
      const objects = objectsSnapshot.val()
      const newObjectsRef = ref(db, `canvases/${newCanvas.id}/objects`)
      await set(newObjectsRef, objects)
      console.log(`Copied objects from ${sourceCanvasId} to ${newCanvas.id}`)
    }


    const sourceGroupsRef = ref(db, `canvases/${sourceCanvasId}/groups`)
    const groupsSnapshot = await get(sourceGroupsRef)

    if (groupsSnapshot.exists()) {
      const groups = groupsSnapshot.val()
      const newGroupsRef = ref(db, `canvases/${newCanvas.id}/groups`)
      await set(newGroupsRef, groups)
      console.log(`Copied groups from ${sourceCanvasId} to ${newCanvas.id}`)
    }

    console.log(`Canvas duplicated: ${sourceCanvasId} → ${newCanvas.id}`)
    return newCanvas
  } catch (error) {
    console.error('Error duplicating canvas:', error)
    throw error
  }
}




export function generateThumbnail(stage: Konva.Stage | null): string {
  if (!stage) {
    return ''
  }

  try {
    // Create thumbnail at 300x200 resolution
    const thumbnailWidth = 300
    const thumbnailHeight = 200

    // Calculate scale to fit canvas in thumbnail
    const stageWidth = stage.width()
    const stageHeight = stage.height()
    const scale = Math.min(
      thumbnailWidth / stageWidth,
      thumbnailHeight / stageHeight
    )

    // Generate base64 PNG
    const dataURL = stage.toDataURL({
      pixelRatio: scale,
      mimeType: 'image/png',
      quality: 0.8,
    })

    return dataURL
  } catch (error) {
    console.error('Error generating thumbnail:', error)
    return ''
  }
}

/**
 * Get canvas by ID (checks if user has permission)
 */
export async function getCanvas(
  canvasId: string,
  userId: string
): Promise<CanvasMetadata | null> {
  try {
    // Collab Spaces: shared themed boards for all users
    const collabSpaces = [
      'public-board',
      'collab-art', 'collab-design', 'collab-education',
      'collab-content', 'collab-gamedev',
      'collab-architecture'
    ]

    if (collabSpaces.includes(canvasId)) {
      const publicRef = ref(db, `collab-spaces/${canvasId}/metadata`)
      const snapshot = await get(publicRef)

      if (!snapshot.exists()) {

        let name: string
        if (canvasId === 'public-board') {
          name = '🌍 Public Collaboration Board'
        } else {
          const themeName = canvasId.replace('collab-', '')
          name = `${themeName.charAt(0).toUpperCase() + themeName.slice(1)} Collab Space`
        }

        const publicCanvas: CanvasMetadata = {
          id: canvasId,
          name,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          thumbnail: '',
          ownerId: 'system',
        }
        await set(publicRef, publicCanvas)
        return publicCanvas
      }

      return snapshot.val() as CanvasMetadata
    }

    const userCanvasRef = ref(db, `users/${userId}/canvases/${canvasId}`)
    const snapshot = await get(userCanvasRef)

    if (!snapshot.exists()) {
      return null
    }

    return snapshot.val() as CanvasMetadata
  } catch (error) {
    console.error('Error getting canvas:', error)
    throw error
  }
}




export async function hasCanvasPermission(
  canvasId: string,
  userId: string
): Promise<boolean> {
  try {
    const permissionRef = ref(db, `canvases/${canvasId}/permissions/${userId}`)
    const snapshot = await get(permissionRef)

    return snapshot.exists()
  } catch (error) {
    console.error('Error checking canvas permission:', error)
    return false
  }
}




export async function getCanvasPermission(
  canvasId: string,
  userId: string
): Promise<CanvasPermission | null> {
  try {
    const permissionRef = ref(db, `canvases/${canvasId}/permissions/${userId}`)
    const snapshot = await get(permissionRef)

    if (!snapshot.exists()) {
      return null
    }

    return snapshot.val() as CanvasPermission
  } catch (error) {
    console.error('Error getting canvas permission:', error)
    return null
  }
}
</file>

<file path="src/services/canvasSync.ts">
import { ref, set, update, remove, onValue, off } from 'firebase/database'
import { db } from './firebase'
import type { CanvasObject } from '../types/firebase'
import type { Shape, ShapeType } from '../types/canvas'






function compressShape(shape: Shape): CanvasObject {

  let typeCode: 'r' | 'c' | 't' | 'l' | 'pg' | 'st' | 'rr' | 'p' = 'r'
  switch (shape.type) {
    case 'rectangle': typeCode = 'r'; break
    case 'circle': typeCode = 'c'; break
    case 'text': typeCode = 't'; break
    case 'line': typeCode = 'l'; break
    case 'polygon': typeCode = 'pg'; break
    case 'star': typeCode = 'st'; break
    case 'roundRect': typeCode = 'rr'; break
    case 'path': typeCode = 'p'; break
  }

  const compressed: CanvasObject = {
    t: typeCode,
    x: Math.round(shape.x),
    y: Math.round(shape.y),
    w: Math.round(shape.width),
    h: Math.round(shape.height),
    f: shape.fill,
  }


  if (shape.type === 'text' && shape.text) {
    compressed.txt = shape.text

    if (shape.fontFamily) compressed.ff = shape.fontFamily
    if (shape.fontSize) compressed.fs = shape.fontSize
    if (shape.fontWeight && shape.fontWeight !== 'normal') compressed.fw = shape.fontWeight
    if (shape.fontStyle && shape.fontStyle !== 'normal') compressed.fst = shape.fontStyle
    if (shape.textAlign && shape.textAlign !== 'left') compressed.ta = shape.textAlign
    if (shape.textDecoration) compressed.td = shape.textDecoration
  }


  if (shape.rotation !== undefined) {
    compressed.rot = Math.round(shape.rotation)
  }


  if (shape.stroke !== undefined) {
    compressed.s = shape.stroke
  }
  if (shape.strokeWidth !== undefined) {
    compressed.sw = Math.round(shape.strokeWidth)
  }


  if (shape.type === 'line') {
    if (shape.points) {
      compressed.pts = shape.points.map(Math.round)
    }
    if (shape.arrows) {
      compressed.arr = {
        s: shape.arrows.start,
        e: shape.arrows.end,
      }
    }
  }


  if ((shape.type === 'polygon' || shape.type === 'star') && shape.sides !== undefined) {
    compressed.sides = shape.sides
  }


  if (shape.type === 'roundRect' && shape.cornerRadius !== undefined) {
    compressed.cr = Math.round(shape.cornerRadius)
  }


  if (shape.zIndex !== undefined) {
    compressed.z = shape.zIndex
  }


  if (shape.type === 'path') {
    if (shape.points) {
      compressed.pts = shape.points.map(Math.round)
    }
    if (shape.tension !== undefined) {
      compressed.ten = shape.tension
    }
    if (shape.closed !== undefined) {
      compressed.cls = shape.closed
    }
  }

  return compressed
}






function decompressShape(id: string, data: CanvasObject): Shape {

  let type: ShapeType = 'rectangle'
  switch (data.t) {
    case 'r': type = 'rectangle'; break
    case 'c': type = 'circle'; break
    case 't': type = 'text'; break
    case 'p': type = 'path'; break
    case 'l': type = 'line'; break
    case 'pg': type = 'polygon'; break
    case 'st': type = 'star'; break
    case 'rr': type = 'roundRect'; break
  }

  const shape: Shape = {
    id,
    type,
    x: data.x,
    y: data.y,
    width: data.w,
    height: data.h,
    rotation: data.rot ?? 0,
    fill: data.f ?? '#3B82F6FF',
  }


  if (data.txt) {
    shape.text = data.txt

    shape.fontFamily = data.ff || 'Inter, sans-serif'
    shape.fontSize = data.fs || 20
    shape.fontWeight = data.fw || 'normal'
    shape.fontStyle = data.fst || 'normal'
    shape.textAlign = data.ta || 'left'
    shape.textDecoration = data.td || ''
  }

  // Add stroke properties if present
  if (data.s) {
    shape.stroke = data.s
  }
  if (data.sw !== undefined) {
    shape.strokeWidth = data.sw
  }

  // PR-16: Add line-specific properties
  if (data.pts) {
    shape.points = data.pts
  }
  if (data.arr) {
    shape.arrows = {
      start: data.arr.s,
      end: data.arr.e,
    }
  }

  // PR-16: Add polygon/star sides
  if (data.sides !== undefined) {
    shape.sides = data.sides
  }

  // PR-16: Add rounded rect corner radius
  if (data.cr !== undefined) {
    shape.cornerRadius = data.cr
  }

  // PR-17: Add z-index (default to current timestamp if not present)
  shape.zIndex = data.z ?? Date.now()

  // PR-21: Add path-specific properties
  if (data.ten !== undefined) {
    shape.tension = data.ten
  }
  if (data.cls !== undefined) {
    shape.closed = data.cls
  }

  return shape
}

/**
 * Sync shape creation to Firebase
 */
export async function syncCreateShape(
  canvasId: string,
  shapeId: string,
  shape: Shape
): Promise<void> {
  try {
    const shapeRef = ref(db, `canvas/${canvasId}/objects/${shapeId}`)
    const compressed = compressShape(shape)
    await set(shapeRef, compressed)
  } catch (error) {
    console.error('Failed to sync create shape:', error)
    throw error
  }
}

/**
 * Sync shape updates to Firebase
 * Supports position, dimensions, rotation, and color updates (Phase 3)
 */
export async function syncUpdateShape(
  canvasId: string,
  shapeId: string,
  updates: Partial<Shape>
): Promise<void> {
  try {
    const shapeRef = ref(db, `canvas/${canvasId}/objects/${shapeId}`)

    // Build update object with compressed keys
    const compressed: Partial<CanvasObject> = {}

    if (updates.x !== undefined) {
      compressed.x = Math.round(updates.x)
    }
    if (updates.y !== undefined) {
      compressed.y = Math.round(updates.y)
    }
    if (updates.width !== undefined) {
      compressed.w = Math.round(updates.width)
    }
    if (updates.height !== undefined) {
      compressed.h = Math.round(updates.height)
    }
    if (updates.rotation !== undefined) {
      compressed.rot = Math.round(updates.rotation)
    }
    // Phase 3: Color properties
    if (updates.fill !== undefined) {
      compressed.f = updates.fill
    }
    if (updates.stroke !== undefined) {
      compressed.s = updates.stroke
    }
    if (updates.strokeWidth !== undefined) {
      compressed.sw = Math.round(updates.strokeWidth)
    }
    // PR-17: Z-index
    if (updates.zIndex !== undefined) {
      compressed.z = updates.zIndex
    }

    await update(shapeRef, compressed)
  } catch (error) {
    console.error('Failed to sync update shape:', error)
    throw error
  }
}

/**
 * Sync shape deletion to Firebase
 */
export async function syncDeleteShape(
  canvasId: string,
  shapeId: string
): Promise<void> {
  try {
    const shapeRef = ref(db, `canvas/${canvasId}/objects/${shapeId}`)
    await remove(shapeRef)
  } catch (error) {
    console.error('Failed to sync delete shape:', error)
    throw error
  }
}

/**
 * Sync bulk move operation to Firebase
 * Updates multiple shapes' positions at once
 */
export async function syncBulkMove(
  canvasId: string,
  updates: Record<string, { x: number; y: number }>
): Promise<void> {
  try {

    const firebaseUpdates: Record<string, number> = {}

    Object.entries(updates).forEach(([shapeId, position]) => {
      firebaseUpdates[`canvas/${canvasId}/objects/${shapeId}/x`] = Math.round(position.x)
      firebaseUpdates[`canvas/${canvasId}/objects/${shapeId}/y`] = Math.round(position.y)
    })


    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to sync bulk move:', error)
    throw error
  }
}





export async function syncBulkDelete(
  canvasId: string,
  shapeIds: string[]
): Promise<void> {
  try {

    const firebaseUpdates: Record<string, null> = {}

    shapeIds.forEach((shapeId) => {
      firebaseUpdates[`canvas/${canvasId}/objects/${shapeId}`] = null
    })


    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to sync bulk delete:', error)
    throw error
  }
}





export async function syncBatchCreate(
  canvasId: string,
  shapes: Shape[]
): Promise<void> {
  try {

    const firebaseUpdates: Record<string, CanvasObject> = {}

    shapes.forEach((shape) => {
      const compressed = compressShape(shape)
      firebaseUpdates[`canvas/${canvasId}/objects/${shape.id}`] = compressed
    })


    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to sync batch create:', error)
    throw error
  }
}





export async function syncZIndex(
  canvasId: string,
  shapeId: string,
  zIndex: number
): Promise<void> {
  try {
    const zIndexRef = ref(db, `canvas/${canvasId}/objects/${shapeId}/z`)
    await set(zIndexRef, zIndex)
  } catch (error) {
    console.error('Failed to sync z-index:', error)
    throw error
  }
}





export async function syncSelection(
  userId: string,
  selectedIds: string[] | null
): Promise<void> {
  try {
    const selectionRef = ref(db, `presence/${userId}/sel`)
    await set(selectionRef, selectedIds)
  } catch (error) {
    console.error('Failed to sync selection:', error)
    throw error
  }
}





export function subscribeToCanvas(
  canvasId: string,
  callbacks: {
    onCreate?: (shape: Shape) => void
    onUpdate?: (shapeId: string, updates: Partial<Shape>) => void
    onDelete?: (shapeId: string) => void
  }
): () => void {
  const objectsRef = ref(db, `canvas/${canvasId}/objects`)


  let previousShapes = new Map<string, CanvasObject>()

  const handleValue = (snapshot: any) => {
    const data = snapshot.val() as { [key: string]: CanvasObject } | null
    const currentShapes = new Map<string, CanvasObject>()

    if (data) {
      Object.entries(data).forEach(([id, shapeData]) => {
        currentShapes.set(id, shapeData)
      })
    }


    currentShapes.forEach((shapeData, id) => {
      if (!previousShapes.has(id)) {

        if (callbacks.onCreate) {
          const shape = decompressShape(id, shapeData)
          callbacks.onCreate(shape)
        }
      } else {

        const prevData = previousShapes.get(id)!
        const hasChanges =
          prevData.x !== shapeData.x ||
          prevData.y !== shapeData.y ||
          prevData.w !== shapeData.w ||
          prevData.h !== shapeData.h ||
          prevData.rot !== shapeData.rot ||
          prevData.f !== shapeData.f ||
          prevData.s !== shapeData.s ||
          prevData.sw !== shapeData.sw ||
          prevData.z !== shapeData.z

        if (hasChanges) {
          if (callbacks.onUpdate) {
            const updates: Partial<Shape> = {}
            if (prevData.x !== shapeData.x) updates.x = shapeData.x
            if (prevData.y !== shapeData.y) updates.y = shapeData.y
            if (prevData.w !== shapeData.w) updates.width = shapeData.w
            if (prevData.h !== shapeData.h) updates.height = shapeData.h
            if (prevData.rot !== shapeData.rot) updates.rotation = shapeData.rot ?? 0

            if (prevData.f !== shapeData.f) updates.fill = shapeData.f
            if (prevData.s !== shapeData.s) updates.stroke = shapeData.s
            if (prevData.sw !== shapeData.sw) updates.strokeWidth = shapeData.sw

            if (prevData.z !== shapeData.z) updates.zIndex = shapeData.z ?? Date.now()
            callbacks.onUpdate(id, updates)
          }
        }
      }
    })


    previousShapes.forEach((_, id) => {
      if (!currentShapes.has(id)) {

        if (callbacks.onDelete) {
          callbacks.onDelete(id)
        }
      }
    })

    previousShapes = currentShapes
  }

  onValue(objectsRef, handleValue)


  return () => {
    off(objectsRef, 'value', handleValue)
  }
}
</file>

<file path="src/services/clipboard.ts">
import type { Shape } from '../types/canvas'
import { v4 as uuidv4 } from 'uuid'




let clipboardData: Shape[] = []




const PASTE_OFFSET = 20





export const copyShapes = (shapes: Shape[]): void => {

  clipboardData = shapes.map((shape) => ({ ...shape }))
}





export const pasteShapes = (): Shape[] => {
  if (clipboardData.length === 0) {
    return []
  }


  return clipboardData.map((shape) => ({
    ...shape,
    id: uuidv4(),
    x: shape.x + PASTE_OFFSET,
    y: shape.y + PASTE_OFFSET,
  }))
}






export const duplicateShapes = (shapes: Shape[]): Shape[] => {
  if (shapes.length === 0) {
    return []
  }


  return shapes.map((shape) => ({
    ...shape,
    id: uuidv4(),
    x: shape.x + PASTE_OFFSET,
    y: shape.y + PASTE_OFFSET,
  }))
}





export const hasClipboardData = (): boolean => {
  return clipboardData.length > 0
}




export const clearClipboard = (): void => {
  clipboardData = []
}
</file>

<file path="src/services/colorStorage.ts">
const RECENT_COLORS_KEY = 'collabcanvas_recent_colors'
const MAX_RECENT_COLORS = 5




export function saveRecentColors(colors: string[]): void {
  try {
    const toSave = colors.slice(0, MAX_RECENT_COLORS)
    localStorage.setItem(RECENT_COLORS_KEY, JSON.stringify(toSave))
  } catch (error) {
    console.error('Failed to save recent colors:', error)
  }
}





export function loadRecentColors(): string[] {
  try {
    const saved = localStorage.getItem(RECENT_COLORS_KEY)
    if (!saved) {
      return []
    }

    const parsed = JSON.parse(saved)
    if (!Array.isArray(parsed)) {
      return []
    }


    return parsed.filter((item) => typeof item === 'string').slice(0, MAX_RECENT_COLORS)
  } catch (error) {
    console.error('Failed to load recent colors:', error)
    return []
  }
}




export function clearRecentColors(): void {
  try {
    localStorage.removeItem(RECENT_COLORS_KEY)
  } catch (error) {
    console.error('Failed to clear recent colors:', error)
  }
}
</file>

<file path="src/services/commandHistory.ts">
import type { Command } from '../types/command'




const MAX_HISTORY_SIZE = 50





export class HistoryManager {
  private undoStack: Command[] = []
  private redoStack: Command[] = []





  executeCommand(command: Command): void {

    command.execute()


    this.undoStack.push(command)


    if (this.undoStack.length > MAX_HISTORY_SIZE) {
      this.undoStack.shift()
    }


    this.redoStack = []
  }





  undo(): void {
    const command = this.undoStack.pop()
    if (command) {
      command.undo()
      this.redoStack.push(command)
    }
  }





  redo(): void {
    const command = this.redoStack.pop()
    if (command) {
      command.redo()
      this.undoStack.push(command)
    }
  }




  canUndo(): boolean {
    return this.undoStack.length > 0
  }




  canRedo(): boolean {
    return this.redoStack.length > 0
  }




  clear(): void {
    this.undoStack = []
    this.redoStack = []
  }




  getUndoStackSize(): number {
    return this.undoStack.length
  }




  getRedoStackSize(): number {
    return this.redoStack.length
  }
}




export function createHistoryManager(): HistoryManager {
  return new HistoryManager()
}
</file>

<file path="src/services/firebase.ts">
import { initializeApp } from 'firebase/app'
import { getDatabase } from 'firebase/database'
import { getAuth } from 'firebase/auth'


const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  databaseURL: import.meta.env.VITE_FIREBASE_DATABASE_URL,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
}


const app = initializeApp(firebaseConfig)


export const db = getDatabase(app)
export const auth = getAuth(app)

export default app
</file>

<file path="src/services/groupSync.ts">
import { ref, set, get, remove, update } from 'firebase/database'
import { db } from './firebase'
import type { Group } from '../types/group'




function generateGroupId(): string {
  return `group-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}




export async function syncCreateGroup(
  canvasId: string,
  memberIds: string[],
  userId: string,
  name?: string
): Promise<Group> {
  if (memberIds.length < 2) {
    throw new Error('Group must contain at least 2 members')
  }

  const groupId = generateGroupId()
  const now = Date.now()

  const group: Group = {
    id: groupId,
    name: name || `Group ${groupId.slice(-4)}`,
    memberIds,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    rotation: 0,
    locked: false,
    visible: true,
    createdAt: now,
    updatedAt: now,
    createdBy: userId,
    zIndex: 0,
  }

  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    await set(groupRef, group)
    console.log(`Group created: ${groupId}`)
    return group
  } catch (error) {
    console.error('Error creating group:', error)
    throw error
  }
}




export async function syncUpdateGroup(
  canvasId: string,
  groupId: string,
  updates: Partial<Omit<Group, 'id' | 'createdAt' | 'createdBy'>>
): Promise<void> {
  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)

    const updateData = {
      ...updates,
      updatedAt: Date.now(),
    }

    await update(groupRef, updateData)
    console.log(`Group updated: ${groupId}`)
  } catch (error) {
    console.error('Error updating group:', error)
    throw error
  }
}




export async function syncDeleteGroup(
  canvasId: string,
  groupId: string
): Promise<void> {
  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    await remove(groupRef)
    console.log(`Group deleted: ${groupId}`)
  } catch (error) {
    console.error('Error deleting group:', error)
    throw error
  }
}




export async function syncAddToGroup(
  canvasId: string,
  groupId: string,
  shapeId: string
): Promise<void> {
  try {

    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    const snapshot = await get(groupRef)

    if (!snapshot.exists()) {
      throw new Error('Group not found')
    }

    const group = snapshot.val() as Group


    if (group.memberIds.includes(shapeId)) {
      console.log('Shape already in group')
      return
    }


    const updatedMemberIds = [...group.memberIds, shapeId]

    await syncUpdateGroup(canvasId, groupId, {
      memberIds: updatedMemberIds,
    })

    console.log(`Added ${shapeId} to group ${groupId}`)
  } catch (error) {
    console.error('Error adding to group:', error)
    throw error
  }
}




export async function syncRemoveFromGroup(
  canvasId: string,
  groupId: string,
  shapeId: string
): Promise<void> {
  try {

    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    const snapshot = await get(groupRef)

    if (!snapshot.exists()) {
      throw new Error('Group not found')
    }

    const group = snapshot.val() as Group


    const updatedMemberIds = group.memberIds.filter((id) => id !== shapeId)


    if (updatedMemberIds.length < 2) {
      await syncDeleteGroup(canvasId, groupId)
      console.log(`Group ${groupId} dissolved (too few members)`)
      return
    }

    await syncUpdateGroup(canvasId, groupId, {
      memberIds: updatedMemberIds,
    })

    console.log(`Removed ${shapeId} from group ${groupId}`)
  } catch (error) {
    console.error('Error removing from group:', error)
    throw error
  }
}




export async function syncGetGroups(canvasId: string): Promise<Group[]> {
  try {
    const groupsRef = ref(db, `canvases/${canvasId}/groups`)
    const snapshot = await get(groupsRef)

    if (!snapshot.exists()) {
      return []
    }

    const groupsData = snapshot.val()
    return Object.values(groupsData) as Group[]
  } catch (error) {
    console.error('Error getting groups:', error)
    throw error
  }
}




export async function syncGetGroup(
  canvasId: string,
  groupId: string
): Promise<Group | null> {
  try {
    const groupRef = ref(db, `canvases/${canvasId}/groups/${groupId}`)
    const snapshot = await get(groupRef)

    if (!snapshot.exists()) {
      return null
    }

    return snapshot.val() as Group
  } catch (error) {
    console.error('Error getting group:', error)
    throw error
  }
}




export async function syncIsInGroup(
  canvasId: string,
  shapeId: string
): Promise<string | null> {
  try {
    const groups = await syncGetGroups(canvasId)

    for (const group of groups) {
      if (group.memberIds.includes(shapeId)) {
        return group.id
      }
    }

    return null
  } catch (error) {
    console.error('Error checking if in group:', error)
    return null
  }
}
</file>

<file path="src/services/tileFill.ts">
import type { TileData } from '../types/tilemap'
import { coordToKey } from '../types/tilemap'




export interface FillResult {
  tiles: Array<{ x: number; y: number; tile: TileData }>
  count: number
  limitReached: boolean
}














export function floodFill(
  tiles: Map<string, TileData>,
  startX: number,
  startY: number,
  fillTile: TileData,
  maxWidth: number,
  maxHeight: number,
  maxTiles: number = 1000
): FillResult {

  const startKey = coordToKey(startX, startY)
  const startTile = tiles.get(startKey)


  const targetType = startTile?.type || 'empty'
  const targetColor = startTile?.color || ''

  // If trying to fill with the same type/color, return empty result
  if (targetType === fillTile.type && targetColor === fillTile.color) {
    return { tiles: [], count: 0, limitReached: false }
  }

  // BFS queue and visited set
  const queue: Array<{ x: number; y: number }> = [{ x: startX, y: startY }]
  const visited = new Set<string>()
  const result: Array<{ x: number; y: number; tile: TileData }> = []

  // 4-directional neighbors (up, down, left, right)
  const directions = [
    { dx: 0, dy: -1 },  // up
    { dx: 0, dy: 1 },   // down
    { dx: -1, dy: 0 },  // left
    { dx: 1, dy: 0 },   // right
  ]

  let limitReached = false

  // BFS loop
  while (queue.length > 0 && result.length < maxTiles) {
    const current = queue.shift()!
    const currentKey = coordToKey(current.x, current.y)

    // Skip if already visited
    if (visited.has(currentKey)) {
      continue
    }

    // Mark as visited
    visited.add(currentKey)

    // Check bounds
    if (current.x < 0 || current.x >= maxWidth || current.y < 0 || current.y >= maxHeight) {
      continue
    }

    // Check if this tile matches the target type/color
    const currentTile = tiles.get(currentKey)
    const currentType = currentTile?.type || 'empty'
    const currentColor = currentTile?.color || ''

    if (currentType !== targetType || currentColor !== targetColor) {
      continue
    }


    result.push({
      x: current.x,
      y: current.y,
      tile: fillTile,
    })


    for (const dir of directions) {
      const nextX = current.x + dir.dx
      const nextY = current.y + dir.dy
      const nextKey = coordToKey(nextX, nextY)

      if (!visited.has(nextKey)) {
        queue.push({ x: nextX, y: nextY })
      }
    }
  }


  if (result.length >= maxTiles) {
    limitReached = true
  }

  return {
    tiles: result,
    count: result.length,
    limitReached,
  }
}












export function rectangularFill(
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  fillTile: TileData
): Array<{ x: number; y: number; tile: TileData }> {
  const result: Array<{ x: number; y: number; tile: TileData }> = []


  const minX = Math.min(startX, endX)
  const maxX = Math.max(startX, endX)
  const minY = Math.min(startY, endY)
  const maxY = Math.max(startY, endY)


  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      result.push({ x, y, tile: fillTile })
    }
  }

  return result
}
</file>

<file path="src/services/tilemapExport.ts">
import type { TileData, TilemapMeta, ExportedTilemap } from '../types/tilemap'











export function exportTilemapJSON(
  tiles: Map<string, TileData>,
  meta: TilemapMeta,
  exportedBy: string,
  format: 'sparse' | 'dense' = 'sparse'
): ExportedTilemap {
  const exportedAt = new Date().toISOString()
  const tileCount = tiles.size

  if (format === 'sparse') {

    const sparseTiles: Record<string, TileData> = {}
    tiles.forEach((tile, key) => {
      sparseTiles[key] = tile
    })

    return {
      version: 1,
      meta,
      format: 'sparse',
      tiles: sparseTiles,
      exported_at: exportedAt,
      exported_by: exportedBy,
      tile_count: tileCount,
    }
  } else {

    const denseTiles: (TileData | null)[][] = []


    for (let y = 0; y < meta.height; y++) {
      denseTiles[y] = []
      for (let x = 0; x < meta.width; x++) {
        const key = `${x}_${y}`
        const tile = tiles.get(key)
        denseTiles[y][x] = tile || null
      }
    }

    return {
      version: 1,
      meta,
      format: 'dense',
      tiles: denseTiles as any,
      exported_at: exportedAt,
      exported_by: exportedBy,
      tile_count: tileCount,
    }
  }
}






export function generateExportFilename(canvasName?: string): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)
  const name = canvasName ? `${canvasName}-tilemap` : 'tilemap'
  return `${name}-${timestamp}.json`
}








export function validateExportedData(data: any): data is ExportedTilemap {
  if (!data || typeof data !== 'object') {
    return false
  }


  if (typeof data.version !== 'number') return false
  if (!data.meta || typeof data.meta !== 'object') return false
  if (data.format !== 'sparse' && data.format !== 'dense') return false
  if (!data.tiles) return false


  const meta = data.meta
  if (typeof meta.tileSize !== 'number') return false
  if (typeof meta.width !== 'number') return false
  if (typeof meta.height !== 'number') return false
  if (typeof meta.chunkSize !== 'number') return false
  if (!Array.isArray(meta.palette)) return false
  if (typeof meta.version !== 'number') return false

  return true
}
</file>

<file path="src/services/tilemapImport.ts">
import type { TileData, TilemapMeta, ExportedTilemap } from '../types/tilemap'
import { validateExportedData } from './tilemapExport'




export interface ImportResult {
  success: boolean
  tiles: Map<string, TileData>
  meta: TilemapMeta
  tileCount: number
  error?: string
}








export function importTilemapJSON(jsonString: string): ImportResult {
  try {

    const data = JSON.parse(jsonString) as ExportedTilemap


    if (!validateExportedData(data)) {
      return {
        success: false,
        tiles: new Map(),
        meta: data.meta,
        tileCount: 0,
        error: 'Invalid tilemap JSON structure',
      }
    }


    if (data.version !== 1) {
      return {
        success: false,
        tiles: new Map(),
        meta: data.meta,
        tileCount: 0,
        error: `Unsupported tilemap version: ${data.version}. Expected version 1.`,
      }
    }


    const tiles = new Map<string, TileData>()

    if (data.format === 'sparse') {

      const sparseData = data.tiles as Record<string, TileData>
      Object.entries(sparseData).forEach(([key, tile]) => {
        tiles.set(key, tile)
      })
    } else if (data.format === 'dense') {

      const denseData = data.tiles as (TileData | null)[][]
      denseData.forEach((row, y) => {
        row.forEach((tile, x) => {
          if (tile !== null) {
            const key = `${x}_${y}`
            tiles.set(key, tile)
          }
        })
      })
    } else {
      return {
        success: false,
        tiles: new Map(),
        meta: data.meta,
        tileCount: 0,
        error: `Unknown tilemap format: ${data.format}`,
      }
    }

    return {
      success: true,
      tiles,
      meta: data.meta,
      tileCount: tiles.size,
    }
  } catch (error) {
    return {
      success: false,
      tiles: new Map(),
      meta: null as any,
      tileCount: 0,
      error: error instanceof Error ? error.message : 'Failed to parse JSON',
    }
  }
}








export async function importTilemapFromFile(file: File): Promise<ImportResult> {
  try {
    const text = await file.text()
    return importTilemapJSON(text)
  } catch (error) {
    return {
      success: false,
      tiles: new Map(),
      meta: null as any,
      tileCount: 0,
      error: error instanceof Error ? error.message : 'Failed to read file',
    }
  }
}








export function validateTileData(tile: any): tile is TileData {
  if (!tile || typeof tile !== 'object') return false
  if (typeof tile.type !== 'string') return false
  if (typeof tile.color !== 'string') return false
  return true
}
</file>

<file path="src/services/tilemapSync.ts">
import { ref, set, update, remove, onValue, off, serverTimestamp } from 'firebase/database'
import { db } from './firebase'
import type {
  TileData,
  TilemapMeta,
  FirebaseTileData,
  FirebaseTilemapMeta,
  ChunkCoordinate,
  coordToKey,
  chunkToKey,
  coordToChunk,
  keyToCoord,
} from '../types/tilemap'
import {
  coordToKey as _coordToKey,
  chunkToKey as _chunkToKey,
  coordToChunk as _coordToChunk,
  keyToCoord as _keyToCoord,
} from '../types/tilemap'


export { coordToKey, chunkToKey, coordToChunk, keyToCoord }









function compressTile(tile: TileData, userId: string): FirebaseTileData {
  return {
    t: tile.type,
    c: tile.color,
    by: userId,
    ts: Date.now(),
  }
}




function decompressTile(data: FirebaseTileData): TileData {
  const tile: TileData = {
    type: data.t,
    color: data.c,
  }


  if (data.by || data.ts) {
    tile.metadata = {}
    if (data.by) tile.metadata.lastEditedBy = data.by
    if (data.ts) tile.metadata.lastEditedAt = data.ts
  }

  return tile
}








export async function getMeta(canvasId: string): Promise<TilemapMeta | null> {
  try {
    const metaRef = ref(db, `tilemaps/${canvasId}/meta`)

    return new Promise((resolve) => {
      onValue(
        metaRef,
        (snapshot) => {
          const data = snapshot.val() as FirebaseTilemapMeta | null
          resolve(data)
        },
        { onlyOnce: true }
      )
    })
  } catch (error) {
    console.error('Failed to get tilemap meta:', error)
    return null
  }
}




export async function setMeta(canvasId: string, meta: Partial<TilemapMeta>): Promise<void> {
  try {
    const metaRef = ref(db, `tilemaps/${canvasId}/meta`)
    await update(metaRef, meta)
  } catch (error) {
    console.error('Failed to set tilemap meta:', error)
    throw error
  }
}




export async function initializeTilemap(canvasId: string, meta: TilemapMeta): Promise<void> {
  try {
    const metaRef = ref(db, `tilemaps/${canvasId}/meta`)
    await set(metaRef, meta)
  } catch (error) {
    console.error('Failed to initialize tilemap:', error)
    throw error
  }
}








export async function setTile(
  canvasId: string,
  x: number,
  y: number,
  tile: TileData,
  userId: string,
  chunkSize: number = 16
): Promise<void> {
  try {

    const chunk = _coordToChunk(x, y, chunkSize)
    const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
    const tileKey = _coordToKey(chunk.lx, chunk.ly)


    const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`
    const tileRef = ref(db, tilePath)


    const compressed = compressTile(tile, userId)

    const tileData = {
      ...compressed,
      ts: serverTimestamp() as any,
    }

    await set(tileRef, tileData)
  } catch (error) {
    console.error('Failed to set tile:', error)
    throw error
  }
}




export async function setTiles(
  canvasId: string,
  tiles: Array<{ x: number; y: number; tile: TileData }>,
  userId: string,
  chunkSize: number = 16
): Promise<void> {
  try {

    const firebaseUpdates: Record<string, FirebaseTileData> = {}

    tiles.forEach(({ x, y, tile }) => {
      const chunk = _coordToChunk(x, y, chunkSize)
      const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
      const tileKey = _coordToKey(chunk.lx, chunk.ly)
      const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`

      const compressed = compressTile(tile, userId)
      firebaseUpdates[tilePath] = {
        ...compressed,
        ts: Date.now(),
      }
    })


    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to set tiles:', error)
    throw error
  }
}




export async function deleteTile(
  canvasId: string,
  x: number,
  y: number,
  chunkSize: number = 16
): Promise<void> {
  try {

    const chunk = _coordToChunk(x, y, chunkSize)
    const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
    const tileKey = _coordToKey(chunk.lx, chunk.ly)


    const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`
    const tileRef = ref(db, tilePath)

    await remove(tileRef)
  } catch (error) {
    console.error('Failed to delete tile:', error)
    throw error
  }
}




export async function deleteTiles(
  canvasId: string,
  tiles: Array<{ x: number; y: number }>,
  chunkSize: number = 16
): Promise<void> {
  try {

    const firebaseUpdates: Record<string, null> = {}

    tiles.forEach(({ x, y }) => {
      const chunk = _coordToChunk(x, y, chunkSize)
      const chunkKey = _chunkToKey(chunk.cx, chunk.cy)
      const tileKey = _coordToKey(chunk.lx, chunk.ly)
      const tilePath = `tilemaps/${canvasId}/chunks/${chunkKey}/tiles/${tileKey}`

      firebaseUpdates[tilePath] = null
    })


    const dbRef = ref(db)
    await update(dbRef, firebaseUpdates)
  } catch (error) {
    console.error('Failed to delete tiles:', error)
    throw error
  }
}




export async function clearAllTiles(canvasId: string): Promise<void> {
  try {
    const chunksRef = ref(db, `tilemaps/${canvasId}/chunks`)
    await remove(chunksRef)
  } catch (error) {
    console.error('Failed to clear all tiles:', error)
    throw error
  }
}









export function subscribeToChunk(
  canvasId: string,
  chunkX: number,
  chunkY: number,
  callbacks: {
    onTile?: (x: number, y: number, tile: TileData) => void
    onRemove?: (x: number, y: number) => void
  },
  chunkSize: number = 16
): () => void {
  const chunkKey = _chunkToKey(chunkX, chunkY)
  const chunkRef = ref(db, `tilemaps/${canvasId}/chunks/${chunkKey}/tiles`)


  let previousTiles = new Map<string, FirebaseTileData>()

  const handleValue = (snapshot: any) => {
    const data = snapshot.val() as { [key: string]: FirebaseTileData } | null
    const currentTiles = new Map<string, FirebaseTileData>()

    if (data) {
      Object.entries(data).forEach(([tileKey, tileData]) => {
        currentTiles.set(tileKey, tileData)
      })
    }


    currentTiles.forEach((tileData, tileKey) => {
      const { x: lx, y: ly } = _keyToCoord(tileKey)
      const x = chunkX * chunkSize + lx
      const y = chunkY * chunkSize + ly

      if (!previousTiles.has(tileKey) ||
          JSON.stringify(previousTiles.get(tileKey)) !== JSON.stringify(tileData)) {

        if (callbacks.onTile) {
          const tile = decompressTile(tileData)
          callbacks.onTile(x, y, tile)
        }
      }
    })


    previousTiles.forEach((_, tileKey) => {
      if (!currentTiles.has(tileKey)) {

        const { x: lx, y: ly } = _keyToCoord(tileKey)
        const x = chunkX * chunkSize + lx
        const y = chunkY * chunkSize + ly

        if (callbacks.onRemove) {
          callbacks.onRemove(x, y)
        }
      }
    })

    previousTiles = currentTiles
  }

  onValue(chunkRef, handleValue)


  return () => {
    off(chunkRef, 'value', handleValue)
  }
}





export function subscribeToChunks(
  canvasId: string,
  chunkKeys: string[],
  callbacks: {
    onTile?: (x: number, y: number, tile: TileData) => void
    onRemove?: (x: number, y: number) => void
  },
  chunkSize: number = 16
): Map<string, () => void> {
  const unsubscribes = new Map<string, () => void>()

  chunkKeys.forEach((chunkKey) => {
    const { cx, cy } = _keyToCoord(chunkKey)
    const unsub = subscribeToChunk(canvasId, cx, cy, callbacks, chunkSize)
    unsubscribes.set(chunkKey, unsub)
  })

  return unsubscribes
}




export function subscribeToMeta(
  canvasId: string,
  onMetaChange: (meta: TilemapMeta) => void
): () => void {
  const metaRef = ref(db, `tilemaps/${canvasId}/meta`)

  const handleValue = (snapshot: any) => {
    const data = snapshot.val() as FirebaseTilemapMeta | null
    if (data) {
      onMetaChange(data)
    }
  }

  onValue(metaRef, handleValue)


  return () => {
    off(metaRef, 'value', handleValue)
  }
}








export async function getChunkTiles(
  canvasId: string,
  chunkX: number,
  chunkY: number,
  chunkSize: number = 16
): Promise<Map<string, TileData>> {
  try {
    const chunkKey = _chunkToKey(chunkX, chunkY)
    const chunkRef = ref(db, `tilemaps/${canvasId}/chunks/${chunkKey}/tiles`)

    return new Promise((resolve) => {
      onValue(
        chunkRef,
        (snapshot) => {
          const data = snapshot.val() as { [key: string]: FirebaseTileData } | null
          const tiles = new Map<string, TileData>()

          if (data) {
            Object.entries(data).forEach(([tileKey, tileData]) => {
              const { x: lx, y: ly } = _keyToCoord(tileKey)
              const x = chunkX * chunkSize + lx
              const y = chunkY * chunkSize + ly
              const globalKey = _coordToKey(x, y)

              tiles.set(globalKey, decompressTile(tileData))
            })
          }

          resolve(tiles)
        },
        { onlyOnce: true }
      )
    })
  } catch (error) {
    console.error('Failed to get chunk tiles:', error)
    return new Map()
  }
}




export async function tilemapExists(canvasId: string): Promise<boolean> {
  const meta = await getMeta(canvasId)
  return meta !== null
}
</file>

<file path="src/types/canvas.ts">
export interface Position {
  x: number
  y: number
}




export interface ViewportTransform {
  x: number
  y: number
  scale: number
}






export type ShapeType = 'rectangle' | 'circle' | 'text' | 'line' | 'polygon' | 'star' | 'roundRect' | 'path'





export interface Shape {
  id: string
  type: ShapeType
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  text?: string

  fontFamily?: string
  fontSize?: number
  fontWeight?: 'normal' | 'bold'
  fontStyle?: 'normal' | 'italic'
  textAlign?: 'left' | 'center' | 'right'
  textDecoration?: '' | 'underline' | 'line-through'

  fill: string
  stroke?: string
  strokeWidth?: number

  points?: number[]
  arrows?: { start?: boolean; end?: boolean }

  sides?: number

  cornerRadius?: number

  zIndex?: number

  tension?: number
  closed?: boolean
}




export interface CanvasConfig {
  width: number
  height: number
  gridSpacing: number
  defaultShapeSize: number
  defaultColor: string
  minScale: number
  maxScale: number
}






export type ToolType = 'select' | 'rectangle' | 'circle' | 'text' | 'delete' | 'line' | 'polygon' | 'star' | 'roundRect' | 'pencil' | 'pen' | 'hand'




export interface CanvasBounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
}




export const DEFAULT_CANVAS_CONFIG: CanvasConfig = {
  width: 5000,
  height: 5000,
  gridSpacing: 50,
  defaultShapeSize: 100,
  defaultColor: '#3B82F6',
  minScale: 0.1,
  maxScale: 3,
}




export const DEFAULT_CANVAS_BOUNDS: CanvasBounds = {
  minX: 0,
  minY: 0,
  maxX: 5000,
  maxY: 5000,
}
</file>

<file path="src/types/command.ts">
export interface Command {
  type: 'create' | 'delete' | 'move' | 'transform' | 'bulk' | 'color' | 'zindex' | 'alignment'
  execute(): void
  undo(): void
  redo(): void
}




export type CreateCommandType = 'create'




export type DeleteCommandType = 'delete'




export type MoveCommandType = 'move'




export type TransformCommandType = 'transform'




export type BulkCommandType = 'bulk'




export type ColorCommandType = 'color'




export type ZIndexCommandType = 'zindex'




export type AlignmentCommandType = 'alignment'




export type CommandType = CreateCommandType | DeleteCommandType | MoveCommandType | TransformCommandType | BulkCommandType | ColorCommandType | ZIndexCommandType | AlignmentCommandType
</file>

<file path="src/types/firebase.ts">
export interface CanvasObject {
  t: 'r' | 'c' | 't' | 'l' | 'pg' | 'st' | 'rr' | 'p'
  x: number
  y: number
  w: number
  h: number
  rot?: number
  txt?: string

  ff?: string
  fs?: number
  fw?: 'normal' | 'bold'
  fst?: 'normal' | 'italic'
  ta?: 'left' | 'center' | 'right'
  td?: '' | 'underline' | 'line-through'
  f?: string
  s?: string
  sw?: number

  pts?: number[]
  arr?: { s?: boolean; e?: boolean }
  sides?: number
  cr?: number

  z?: number

  ten?: number
  cls?: boolean
}





export interface Presence {
  n: string
  cl: string
  c: [number, number]
  sel: string[] | null
}




export interface User {
  uid: string
  email: string | null
  displayName: string | null
}




export interface CanvasData {
  objects: {
    [objectId: string]: CanvasObject
  }
}




export interface PresenceData {
  [userId: string]: Presence
}
</file>

<file path="src/types/group.ts">
export interface GroupMember {
  id: string
  type: 'shape' | 'group'
}

export interface Group {
  id: string
  name: string
  memberIds: string[]
  x: number
  y: number
  width: number
  height: number
  rotation: number
  locked: boolean
  visible: boolean
  createdAt: number
  updatedAt: number
  createdBy: string
  zIndex: number
}

export interface GroupBounds {
  x: number
  y: number
  width: number
  height: number
}
</file>

<file path="src/types/layer.ts">
export interface Layer {
  id: string
  name: string
  type: 'shape' | 'group'
  visible: boolean
  locked: boolean
  zIndex: number
  parentId?: string
  children?: Layer[]
}

export interface LayerVisibility {
  [id: string]: boolean
}

export interface LayerLock {
  [id: string]: boolean
}

export interface LayerTreeNode extends Layer {
  level: number
  expanded?: boolean
}
</file>

<file path="src/types/selection.ts">
export interface SelectionBox {
  startX: number
  startY: number
  currentX: number
  currentY: number
  visible: boolean
}





export interface SelectionState {
  selectedIds: Set<string>
  lastSelectedId: string | null
}




export const createEmptySelection = (): SelectionState => ({
  selectedIds: new Set<string>(),
  lastSelectedId: null,
})




export const createInitialSelectionBox = (): SelectionBox => ({
  startX: 0,
  startY: 0,
  currentX: 0,
  currentY: 0,
  visible: false,
})





export const getSelectionBoxBounds = (box: SelectionBox) => {
  const x = Math.min(box.startX, box.currentX)
  const y = Math.min(box.startY, box.currentY)
  const width = Math.abs(box.currentX - box.startX)
  const height = Math.abs(box.currentY - box.startY)

  return { x, y, width, height }
}




export const shapeIntersectsSelectionBox = (
  shape: { x: number; y: number; width: number; height: number },
  box: SelectionBox
): boolean => {
  const boxBounds = getSelectionBoxBounds(box)


  return !(
    shape.x + shape.width < boxBounds.x ||
    shape.x > boxBounds.x + boxBounds.width ||
    shape.y + shape.height < boxBounds.y ||
    shape.y > boxBounds.y + boxBounds.height
  )
}
</file>

<file path="src/types/tilemap.ts">
export interface TileData {
  type: string;
  color: string;
  metadata?: Record<string, any>;
}




export interface PaletteColor {
  type: string;
  color: string;
  name: string;
}




export interface TilemapMeta {
  tileSize: number;
  width: number;
  height: number;
  chunkSize: number;
  palette: PaletteColor[];
  version: number;
}








export interface TileCoordinate {
  x: number;
  y: number;
}




export interface ChunkCoordinate {
  cx: number;
  cy: number;
  lx: number;
  ly: number;
}








export type TileMode = 'stamp' | 'erase' | 'fill' | 'pick';




export type ConnectionStatus = 'connected' | 'disconnected' | 'reconnecting';








export interface FirebaseTileData {
  t: string;
  c: string;
  by: string;
  ts: number;
}




export interface FirebaseTilemapMeta {
  tileSize: number;
  width: number;
  height: number;
  chunkSize: number;
  palette: PaletteColor[];
  version: number;
}








export interface ExportedTilemap {
  version: number;
  meta: TilemapMeta;
  format: 'sparse' | 'dense';
  tiles: Record<string, TileData> | TileData[][];
  exported_at: string;
  exported_by: string;
  tile_count: number;
}









export function coordToKey(x: number, y: number): string {
  return `${x}_${y}`;
}





export function keyToCoord(key: string): TileCoordinate {
  const [x, y] = key.split('_').map(Number);
  return { x, y };
}





export function chunkToKey(cx: number, cy: number): string {
  return `${cx}_${cy}`;
}





export function keyToChunkCoord(key: string): { cx: number; cy: number } {
  const [cx, cy] = key.split('_').map(Number);
  return { cx, cy };
}









export function coordToChunk(x: number, y: number, chunkSize: number): ChunkCoordinate {
  const cx = Math.floor(x / chunkSize);
  const cy = Math.floor(y / chunkSize);
  const lx = x % chunkSize;
  const ly = y % chunkSize;

  return { cx, cy, lx, ly };
}











export function chunkToCoord(
  cx: number,
  cy: number,
  lx: number,
  ly: number,
  chunkSize: number
): TileCoordinate {
  return {
    x: cx * chunkSize + lx,
    y: cy * chunkSize + ly,
  };
}











export function getVisibleChunks(
  viewportX: number,
  viewportY: number,
  viewportWidth: number,
  viewportHeight: number,
  tileSize: number,
  chunkSize: number
): string[] {

  const startTileX = Math.floor(viewportX / tileSize);
  const startTileY = Math.floor(viewportY / tileSize);
  const endTileX = Math.ceil((viewportX + viewportWidth) / tileSize);
  const endTileY = Math.ceil((viewportY + viewportHeight) / tileSize);


  const startChunkX = Math.floor(startTileX / chunkSize);
  const startChunkY = Math.floor(startTileY / chunkSize);
  const endChunkX = Math.floor(endTileX / chunkSize);
  const endChunkY = Math.floor(endTileY / chunkSize);


  const chunks: string[] = [];
  for (let cy = startChunkY; cy <= endChunkY; cy++) {
    for (let cx = startChunkX; cx <= endChunkX; cx++) {

      if (cx >= 0 && cy >= 0) {
        chunks.push(chunkToKey(cx, cy));
      }
    }
  }

  return chunks;
}








export function isValidTileCoord(x: number, y: number, meta: TilemapMeta): boolean {
  return x >= 0 && y >= 0 && x < meta.width && y < meta.height;
}




export function clampTileCoord(x: number, y: number, meta: TilemapMeta): TileCoordinate {
  return {
    x: Math.max(0, Math.min(x, meta.width - 1)),
    y: Math.max(0, Math.min(y, meta.height - 1)),
  };
}








export const DEFAULT_TILEMAP_META: TilemapMeta = {
  tileSize: 16,
  width: 256,
  height: 256,
  chunkSize: 16,
  palette: [
    { type: 'solid', color: '#4ade80', name: 'Ground' },
    { type: 'platform', color: '#60a5fa', name: 'Platform' },
    { type: 'spawn', color: '#fbbf24', name: 'Spawn' },
    { type: 'empty', color: '#ef4444', name: 'Empty' },
  ],
  version: 1,
};
</file>

<file path="src/utils/downloadHelper.ts">
export function downloadJSON(data: any, filename: string): void {
  try {

    const jsonString = JSON.stringify(data, null, 2)


    const blob = new Blob([jsonString], {
      type: 'application/json',
    })


    const url = URL.createObjectURL(blob)


    const a = document.createElement('a')
    a.href = url
    a.download = filename


    document.body.appendChild(a)
    a.click()


    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('Failed to download JSON:', error)
    throw error
  }
}








export function downloadText(
  content: string,
  filename: string,
  mimeType: string = 'text/plain'
): void {
  try {

    const blob = new Blob([content], { type: mimeType })


    const url = URL.createObjectURL(blob)


    const a = document.createElement('a')
    a.href = url
    a.download = filename


    document.body.appendChild(a)
    a.click()


    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('Failed to download text:', error)
    throw error
  }
}








export function selectFile(accept: string = '*'): Promise<File | null> {
  return new Promise((resolve) => {

    const input = document.createElement('input')
    input.type = 'file'
    input.accept = accept


    input.onchange = (e) => {
      const target = e.target as HTMLInputElement
      const file = target.files?.[0] || null
      resolve(file)


      document.body.removeChild(input)
    }


    input.oncancel = () => {
      resolve(null)
      document.body.removeChild(input)
    }


    document.body.appendChild(input)
    input.click()
  })
}
</file>

<file path="src/utils/groupHelpers.ts">
import type { Shape } from '../types/canvas'
import type { Group, GroupBounds } from '../types/group'




export function calculateGroupBounds(
  members: Shape[],
  groups?: Group[]
): GroupBounds {
  if (members.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 }
  }


  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  members.forEach((member) => {

    const memberMinX = member.x
    const memberMinY = member.y
    const memberMaxX = member.x + member.width
    const memberMaxY = member.y + member.height

    minX = Math.min(minX, memberMinX)
    minY = Math.min(minY, memberMinY)
    maxX = Math.max(maxX, memberMaxX)
    maxY = Math.max(maxY, memberMaxY)
  })


  if (groups && groups.length > 0) {
    groups.forEach((group) => {
      minX = Math.min(minX, group.x)
      minY = Math.min(minY, group.y)
      maxX = Math.max(maxX, group.x + group.width)
      maxY = Math.max(maxY, group.y + group.height)
    })
  }

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY,
  }
}




export function isInGroup(shapeId: string, groupId: string, groups: Group[]): boolean {
  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return false
  }
  return group.memberIds.includes(shapeId)
}




export function isInAnyGroup(shapeId: string, groups: Group[]): string | null {
  for (const group of groups) {
    if (group.memberIds.includes(shapeId)) {
      return group.id
    }
  }
  return null
}





export function getAllGroupMembers(
  groupId: string,
  groups: Group[],
  maxDepth: number = 10,
  currentDepth: number = 0
): string[] {
  if (currentDepth >= maxDepth) {
    console.warn(`Maximum group nesting depth (${maxDepth}) reached`)
    return []
  }

  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return []
  }

  const allMembers: string[] = []

  for (const memberId of group.memberIds) {
    allMembers.push(memberId)


    const nestedGroup = groups.find((g) => g.id === memberId)
    if (nestedGroup) {

      const nestedMembers = getAllGroupMembers(
        memberId,
        groups,
        maxDepth,
        currentDepth + 1
      )
      allMembers.push(...nestedMembers)
    }
  }

  return allMembers
}




export function getGroupShapes(
  groupId: string,
  groups: Group[],
  allShapes: Shape[]
): Shape[] {
  const memberIds = getAllGroupMembers(groupId, groups)
  return allShapes.filter((shape) => memberIds.includes(shape.id))
}




export function getGroupCenter(bounds: GroupBounds): { x: number; y: number } {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2,
  }
}




export function hasCircularDependency(
  groupId: string,
  potentialMemberId: string,
  groups: Group[]
): boolean {

  if (groupId === potentialMemberId) {
    return true
  }


  const allMembers = getAllGroupMembers(potentialMemberId, groups)
  return allMembers.includes(groupId)
}




export function getGroupDepth(groupId: string, groups: Group[]): number {
  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return 0
  }

  let maxChildDepth = 0
  for (const memberId of group.memberIds) {
    const childGroup = groups.find((g) => g.id === memberId)
    if (childGroup) {
      const childDepth = getGroupDepth(memberId, groups)
      maxChildDepth = Math.max(maxChildDepth, childDepth)
    }
  }

  return maxChildDepth + 1
}




export function getTopLevelGroups(groups: Group[]): Group[] {
  return groups.filter((group) => {

    return !groups.some((otherGroup) =>
      otherGroup.memberIds.includes(group.id)
    )
  })
}




export function getChildGroups(groupId: string, groups: Group[]): Group[] {
  const group = groups.find((g) => g.id === groupId)
  if (!group) {
    return []
  }

  return groups.filter((g) => group.memberIds.includes(g.id))
}




export function updateGroupBounds(
  group: Group,
  shapes: Shape[],
  groups: Group[]
): GroupBounds {
  const memberShapes = shapes.filter((shape) =>
    group.memberIds.includes(shape.id)
  )

  const memberGroups = groups.filter((g) =>
    group.memberIds.includes(g.id)
  )

  return calculateGroupBounds(memberShapes, memberGroups)
}
</file>

<file path="src/utils/migrationScript.ts">
import { ref, get, set } from 'firebase/database'
import { db } from '../services/firebase'

const OLD_CANVAS_PATH = 'canvas/objects'
const DEFAULT_CANVAS_ID = 'default-canvas'

interface MigrationResult {
  success: boolean
  canvasId: string
  objectsMigrated: number
  errors: string[]
}





export async function migrateToMultiCanvas(userId: string): Promise<MigrationResult> {
  const result: MigrationResult = {
    success: false,
    canvasId: DEFAULT_CANVAS_ID,
    objectsMigrated: 0,
    errors: [],
  }

  try {

    const userCanvasesRef = ref(db, `users/${userId}/canvases`)
    const userCanvasesSnapshot = await get(userCanvasesRef)

    if (userCanvasesSnapshot.exists()) {
      console.log('Migration already completed for this user')
      result.success = true
      return result
    }


    const oldObjectsRef = ref(db, OLD_CANVAS_PATH)
    const oldObjectsSnapshot = await get(oldObjectsRef)

    if (!oldObjectsSnapshot.exists()) {
      console.log('No objects to migrate')


      await createDefaultCanvas(userId)
      result.success = true
      return result
    }

    const oldObjects = oldObjectsSnapshot.val()
    const objectIds = Object.keys(oldObjects)

    console.log(`Found ${objectIds.length} objects to migrate`)


    await createDefaultCanvas(userId)


    for (const objectId of objectIds) {
      try {
        const objectData = oldObjects[objectId]


        const newObjectRef = ref(db, `canvases/${DEFAULT_CANVAS_ID}/objects/${objectId}`)
        await set(newObjectRef, objectData)

        result.objectsMigrated++
      } catch (error) {
        const errorMsg = `Failed to migrate object ${objectId}: ${error}`
        console.error(errorMsg)
        result.errors.push(errorMsg)
      }
    }





    result.success = result.errors.length === 0
    console.log(`Migration complete: ${result.objectsMigrated} objects migrated`)

    return result
  } catch (error) {
    const errorMsg = `Migration failed: ${error}`
    console.error(errorMsg)
    result.errors.push(errorMsg)
    return result
  }
}




async function createDefaultCanvas(userId: string): Promise<void> {
  const now = Date.now()


  const canvasMetadata = {
    name: 'My First Canvas',
    createdAt: now,
    updatedAt: now,
    thumbnail: '', // Empty for now
    ownerId: userId,
  }

  const userCanvasRef = ref(db, `users/${userId}/canvases/${DEFAULT_CANVAS_ID}`)
  await set(userCanvasRef, canvasMetadata)

  // Create owner permission in canvases/{canvasId}/permissions/{userId}
  const permissionRef = ref(db, `canvases/${DEFAULT_CANVAS_ID}/permissions/${userId}`)
  await set(permissionRef, {
    role: 'owner',
    grantedAt: now,
  })

  console.log(`Created default canvas for user ${userId}`)
}




export async function needsMigration(userId: string): Promise<boolean> {
  try {
    const userCanvasesRef = ref(db, `users/${userId}/canvases`)
    const snapshot = await get(userCanvasesRef)


    return !snapshot.exists()
  } catch (error) {
    console.error('Error checking migration status:', error)
    return false
  }
}




export async function autoMigrateIfNeeded(userId: string): Promise<void> {
  try {
    const needs = await needsMigration(userId)

    if (needs) {
      console.log('Starting automatic migration...')
      const result = await migrateToMultiCanvas(userId)

      if (result.success) {
        console.log(`✅ Migration successful: ${result.objectsMigrated} objects migrated`)
      } else {
        console.error('❌ Migration completed with errors:', result.errors)
      }
    }
  } catch (error) {
    console.error('Auto-migration failed:', error)
  }
}
</file>

<file path="src/utils/pathHelpers.ts">
function perpendicularDistance(
  point: { x: number; y: number },
  lineStart: { x: number; y: number },
  lineEnd: { x: number; y: number }
): number {
  const dx = lineEnd.x - lineStart.x
  const dy = lineEnd.y - lineStart.y


  const mag = Math.sqrt(dx * dx + dy * dy)
  if (mag > 0) {
    const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag)
    const closest = {
      x: lineStart.x + u * dx,
      y: lineStart.y + u * dy,
    }
    return Math.sqrt(
      (point.x - closest.x) ** 2 + (point.y - closest.y) ** 2
    )
  } else {
    return Math.sqrt(
      (point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2
    )
  }
}








export function simplifyPath(points: number[], tolerance: number = 2): number[] {
  if (points.length <= 4) {

    return points
  }


  const pointObjects: { x: number; y: number }[] = []
  for (let i = 0; i < points.length; i += 2) {
    pointObjects.push({ x: points[i], y: points[i + 1] })
  }


  function douglasPeucker(
    pts: { x: number; y: number }[],
    startIndex: number,
    endIndex: number
  ): { x: number; y: number }[] {
    if (endIndex <= startIndex + 1) {
      return []
    }


    let maxDistance = 0
    let maxIndex = startIndex

    for (let i = startIndex + 1; i < endIndex; i++) {
      const distance = perpendicularDistance(
        pts[i],
        pts[startIndex],
        pts[endIndex]
      )
      if (distance > maxDistance) {
        maxDistance = distance
        maxIndex = i
      }
    }


    if (maxDistance > tolerance) {
      const left = douglasPeucker(pts, startIndex, maxIndex)
      const right = douglasPeucker(pts, maxIndex, endIndex)
      return [...left, pts[maxIndex], ...right]
    } else {
      return []
    }
  }

  const simplified = [
    pointObjects[0],
    ...douglasPeucker(pointObjects, 0, pointObjects.length - 1),
    pointObjects[pointObjects.length - 1],
  ]


  const result: number[] = []
  for (const point of simplified) {
    result.push(point.x, point.y)
  }

  return result
}








export function smoothPath(points: number[]): number[] {




  if (points.length <= 4) {
    return points
  }

  const smoothed: number[] = []
  let lastX: number | null = null
  let lastY: number | null = null

  for (let i = 0; i < points.length; i += 2) {
    const x = points[i]
    const y = points[i + 1]


    if (x !== lastX || y !== lastY) {
      smoothed.push(x, y)
      lastX = x
      lastY = y
    }
  }

  return smoothed
}






export function calculatePathBounds(points: number[]): {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
} {
  if (points.length < 2) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }
  }

  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  for (let i = 0; i < points.length; i += 2) {
    const x = points[i]
    const y = points[i + 1]

    minX = Math.min(minX, x)
    minY = Math.min(minY, y)
    maxX = Math.max(maxX, x)
    maxY = Math.max(maxY, y)
  }

  return {
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY,
  }
}




export function getDistance(x1: number, y1: number, x2: number, y2: number): number {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
}








export function samplePathPoints(points: number[], minSpacing: number = 5): number[] {
  if (points.length <= 2) {
    return points
  }

  const sampled: number[] = [points[0], points[1]]

  let lastX = points[0]
  let lastY = points[1]

  for (let i = 2; i < points.length; i += 2) {
    const x = points[i]
    const y = points[i + 1]

    const distance = getDistance(lastX, lastY, x, y)

    if (distance >= minSpacing) {
      sampled.push(x, y)
      lastX = x
      lastY = y
    }
  }


  const lastPointX = points[points.length - 2]
  const lastPointY = points[points.length - 1]
  if (lastX !== lastPointX || lastY !== lastPointY) {
    sampled.push(lastPointX, lastPointY)
  }

  return sampled
}
</file>

<file path="src/utils/performance.ts">
interface PerformanceMetrics {
  fps: number
  avgFrameTime: number
  minFps: number
  maxFps: number
  sampleCount: number
}





export class FPSMonitor {
  private lastTime: number = performance.now()
  private frames: number = 0
  private fps: number = 0
  private frameTimes: number[] = []
  private readonly maxSamples: number = 60
  private animationFrameId: number | null = null
  private callback: ((metrics: PerformanceMetrics) => void) | null = null

  constructor() {
    this.lastTime = performance.now()
  }




  start(callback?: (metrics: PerformanceMetrics) => void): void {
    this.callback = callback || null
    this.lastTime = performance.now()
    this.frames = 0
    this.frameTimes = []
    this.loop()
  }




  stop(): void {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId)
      this.animationFrameId = null
    }
  }




  getFPS(): number {
    return this.fps
  }




  getMetrics(): PerformanceMetrics {
    const minFps = this.frameTimes.length > 0 ?
      Math.min(...this.frameTimes.map(t => 1000 / t)) : 0
    const maxFps = this.frameTimes.length > 0 ?
      Math.max(...this.frameTimes.map(t => 1000 / t)) : 0
    const avgFrameTime = this.frameTimes.length > 0 ?
      this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length : 0

    return {
      fps: this.fps,
      avgFrameTime,
      minFps: Math.round(minFps),
      maxFps: Math.round(maxFps),
      sampleCount: this.frameTimes.length
    }
  }




  private loop = (): void => {
    const currentTime = performance.now()
    const deltaTime = currentTime - this.lastTime

    this.frames++


    if (deltaTime >= 1000) {
      this.fps = Math.round((this.frames * 1000) / deltaTime)
      this.frames = 0
      this.lastTime = currentTime


      if (this.callback) {
        this.callback(this.getMetrics())
      }
    }


    this.frameTimes.push(deltaTime)
    if (this.frameTimes.length > this.maxSamples) {
      this.frameTimes.shift()
    }

    this.animationFrameId = requestAnimationFrame(this.loop)
  }
}




export async function measureLatency<T>(
  operation: () => Promise<T>,
  label?: string
): Promise<{ result: T; latency: number }> {
  const startTime = performance.now()
  const result = await operation()
  const latency = performance.now() - startTime

  if (label && import.meta.env.DEV) {
    console.log(`[Performance] ${label}: ${latency.toFixed(2)}ms`)
  }

  return { result, latency }
}




export function measureExecutionTime<T>(
  operation: () => T,
  label?: string
): { result: T; time: number } {
  const startTime = performance.now()
  const result = operation()
  const time = performance.now() - startTime

  if (label && import.meta.env.DEV) {
    console.log(`[Performance] ${label}: ${time.toFixed(2)}ms`)
  }

  return { result, time }
}




export function mark(name: string): void {
  if (typeof performance !== 'undefined' && performance.mark) {
    performance.mark(name)
  }
}




export function measure(
  name: string,
  startMark: string,
  endMark: string
): number | null {
  if (typeof performance !== 'undefined' && performance.measure) {
    try {
      performance.measure(name, startMark, endMark)
      const entries = performance.getEntriesByName(name)
      if (entries.length > 0) {
        const duration = entries[entries.length - 1].duration
        if (import.meta.env.DEV) {
          console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`)
        }
        return duration
      }
    } catch (error) {
      console.error('Performance measurement error:', error)
    }
  }
  return null
}




export function logMemoryUsage(): void {
  if (import.meta.env.DEV && 'memory' in performance) {
    const memory = (performance as any).memory
    console.log('[Performance] Memory Usage:', {
      usedJSHeapSize: `${(memory.usedJSHeapSize / 1048576).toFixed(2)} MB`,
      totalJSHeapSize: `${(memory.totalJSHeapSize / 1048576).toFixed(2)} MB`,
      jsHeapSizeLimit: `${(memory.jsHeapSizeLimit / 1048576).toFixed(2)} MB`,
    })
  }
}





export function createFPSHook() {
  let monitor: FPSMonitor | null = null
  let currentFps = 0

  return function useFPSMonitor(): number {
    if (typeof window === 'undefined') return 0

    if (!monitor) {
      monitor = new FPSMonitor()
      monitor.start((metrics) => {
        currentFps = metrics.fps
      })
    }

    return currentFps
  }
}




export class PerformanceBenchmark {
  private metrics: Map<string, number[]> = new Map()




  record(key: string, value: number): void {
    if (!this.metrics.has(key)) {
      this.metrics.set(key, [])
    }
    this.metrics.get(key)!.push(value)
  }




  getStats(key: string): {
    min: number
    max: number
    avg: number
    median: number
    p95: number
    p99: number
  } | null {
    const values = this.metrics.get(key)
    if (!values || values.length === 0) return null

    const sorted = [...values].sort((a, b) => a - b)
    const sum = sorted.reduce((a, b) => a + b, 0)

    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: sum / sorted.length,
      median: sorted[Math.floor(sorted.length / 2)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    }
  }




  getAllStats(): Map<string, any> {
    const stats = new Map()
    this.metrics.forEach((_, key) => {
      stats.set(key, this.getStats(key))
    })
    return stats
  }




  clear(): void {
    this.metrics.clear()
  }




  printStats(): void {
    console.log('=== Performance Benchmark Results ===')
    this.metrics.forEach((_, key) => {
      const stats = this.getStats(key)
      if (stats) {
        console.log(`\n${key}:`)
        console.log(`  Min: ${stats.min.toFixed(2)}ms`)
        console.log(`  Max: ${stats.max.toFixed(2)}ms`)
        console.log(`  Avg: ${stats.avg.toFixed(2)}ms`)
        console.log(`  Median: ${stats.median.toFixed(2)}ms`)
        console.log(`  P95: ${stats.p95.toFixed(2)}ms`)
        console.log(`  P99: ${stats.p99.toFixed(2)}ms`)
      }
    })
    console.log('\n=====================================')
  }
}


export const globalBenchmark = new PerformanceBenchmark()


if (import.meta.env.DEV) {

  setInterval(() => {
    logMemoryUsage()
  }, 30000)
}
</file>

<file path="src/utils/testFirebase.ts">
import { ref, set, onValue, remove } from 'firebase/database'
import { db } from '../services/firebase'





export async function testFirebaseConnection(): Promise<boolean> {
  try {
    const testRef = ref(db, 'test/connection')
    const testValue = {
      timestamp: Date.now(),
      message: 'Firebase connection test',
    }

    console.log('🔍 Testing Firebase connection...')


    await set(testRef, testValue)
    console.log('✅ Successfully wrote test data to Firebase')


    return new Promise((resolve) => {
      onValue(
        testRef,
        (snapshot) => {
          const data = snapshot.val()
          if (data && data.timestamp === testValue.timestamp) {
            console.log('✅ Successfully read test data from Firebase')
            console.log('🎉 Firebase connection working!')


            remove(testRef)
            resolve(true)
          } else {
            console.error('❌ Test data mismatch')
            resolve(false)
          }
        },
        (error) => {
          console.error('❌ Error reading from Firebase:', error)
          resolve(false)
        },
        { onlyOnce: true }
      )
    })
  } catch (error) {
    console.error('❌ Firebase connection test failed:', error)
    return false
  }
}




export function checkFirebaseConfig(): boolean {
  const requiredEnvVars = [
    'VITE_FIREBASE_API_KEY',
    'VITE_FIREBASE_AUTH_DOMAIN',
    'VITE_FIREBASE_DATABASE_URL',
    'VITE_FIREBASE_PROJECT_ID',
  ]

  const missing = requiredEnvVars.filter(
    (varName) => !import.meta.env[varName]
  )

  if (missing.length > 0) {
    console.error('❌ Missing Firebase environment variables:', missing)
    return false
  }

  console.log('✅ Firebase environment variables configured')
  return true
}
</file>

<file path="src/utils/throttle.ts">
export function throttle<T extends (...args: any[]) => void>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let lastCall = 0

  return function (...args: Parameters<T>) {
    const now = Date.now()

    if (now - lastCall >= delay) {
      lastCall = now
      fn(...args)
    }
  }
}
</file>

<file path="src/vite-env.d.ts">

</file>

<file path="tailwind.config.js">
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
      colors: {

        neutral: {
          50: '#FAFAFA',
          100: '#F5F5F5',
          150: '#EDEDED',
          200: '#E5E5E5',
          300: '#D4D4D4',
          400: '#A3A3A3',
          500: '#737373',
          600: '#525252',
          700: '#404040',
          800: '#262626',
          900: '#171717',
        },

        primary: {
          50: '#EEF2FF',
          100: '#E0E7FF',
          200: '#C7D2FE',
          300: '#A5B4FC',
          400: '#818CF8',
          500: '#6366F1',
          600: '#4F46E5',
          700: '#4338CA',
        },
      },
      boxShadow: {
        'soft': '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
        'medium': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
        'hard': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
        'cursor': '0 1px 2px 0 rgba(0, 0, 0, 0.2)',
      },
      borderRadius: {
        'panel': '8px',
      },
      spacing: {
        'toolbar': '48px',
        'header': '64px',
        'panel': '256px',
      },
    },
  },
  plugins: [],
}
</file>

<file path="test-firebase.js">
import { initializeApp } from 'firebase/app'
import { getDatabase, ref, set, get, remove } from 'firebase/database'


const firebaseConfig = {
  apiKey: 'AIzaSyDyw9pXYbkP7YZaOBrM25EwlZe9wATM1sE',
  authDomain: 'collabcanvas-realtime.firebaseapp.com',
  databaseURL: 'https://collabcanvas-realtime-default-rtdb.firebaseio.com',
  projectId: 'collabcanvas-realtime',
}

async function testConnection() {
  try {
    console.log('🔍 Testing Firebase connection...')


    const app = initializeApp(firebaseConfig)
    const db = getDatabase(app)

    console.log('✅ Firebase initialized')


    const testRef = ref(db, 'test/connection')
    const testData = {
      timestamp: Date.now(),
      message: 'Connection test from Node.js',
    }

    await set(testRef, testData)
    console.log('✅ Successfully wrote test data')


    const snapshot = await get(testRef)
    if (snapshot.exists()) {
      console.log('✅ Successfully read test data:', snapshot.val())
    } else {
      console.log('❌ No data found')
    }


    await remove(testRef)
    console.log('✅ Cleaned up test data')

    console.log('🎉 Firebase connection test PASSED!')
    process.exit(0)
  } catch (error) {
    console.error('❌ Firebase connection test FAILED:', error.message)
    process.exit(1)
  }
}

testConnection()
</file>

<file path="TESTING.md">
# CollabCanvas MVP - Testing Checklist

This document provides a comprehensive testing checklist for validating all MVP features.

## Test Environment Setup

- [ ] Application running locally (`npm run dev`)
- [ ] Firebase Realtime Database connected
- [ ] Firebase Authentication working
- [ ] Multiple browser tabs/windows available for multi-user testing

---

## 1. Authentication Tests

### 1.1 Google Sign-In
- [ ] Login page displays on initial load
- [ ] Google Sign-In button is visible and functional
- [ ] Successfully authenticates with Google account
- [ ] Loading spinner shows during authentication
- [ ] Redirects to canvas after successful login
- [ ] User email/name displays in presence bar after login

### 1.2 Session Persistence
- [ ] User stays logged in after page refresh
- [ ] Session persists across browser restarts (if "Remember me")
- [ ] Can sign out successfully
- [ ] Returns to login page after sign out

---

## 2. Canvas Basic Functionality

### 2.1 Canvas Initialization
- [ ] Canvas loads successfully
- [ ] Grid overlay displays (50px spacing)
- [ ] Canvas boundaries are 5000x5000px
- [ ] Initial viewport is centered at (0, 0)
- [ ] No console errors on load

### 2.2 Pan Functionality
- [ ] Can pan canvas by dragging (Select tool active)
- [ ] Pan is smooth and responsive
- [ ] Cannot pan beyond canvas boundaries
- [ ] Hard boundaries enforced at edges
- [ ] Viewport position updates correctly

### 2.3 Zoom Functionality
- [ ] Mouse wheel zooms in/out
- [ ] Zoom centers on mouse cursor position
- [ ] Zoom limits respected (min/max scale)
- [ ] Grid scales correctly with zoom
- [ ] Shapes scale correctly with zoom
- [ ] Zoom is smooth and responsive

---

## 3. Shape Creation

### 3.1 Rectangle Creation
- [ ] Select rectangle tool from toolbar
- [ ] Click on canvas to create rectangle
- [ ] Rectangle appears at click position
- [ ] Rectangle is 100x100px
- [ ] Rectangle is blue (#3B82F6)
- [ ] Can create multiple rectangles
- [ ] Rectangle syncs to Firebase immediately
- [ ] Other users see new rectangle within 100ms

### 3.2 Circle Creation
- [ ] Select circle tool from toolbar
- [ ] Click on canvas to create circle
- [ ] Circle appears at click position
- [ ] Circle is 100x100px (diameter)
- [ ] Circle is blue (#3B82F6)
- [ ] Can create multiple circles
- [ ] Circle syncs to Firebase immediately
- [ ] Other users see new circle within 100ms

### 3.3 Text Creation
- [ ] Select text tool from toolbar
- [ ] Click on canvas to open text input
- [ ] Text input appears at click position
- [ ] Can type text into input
- [ ] Press Enter to create text object
- [ ] Press Escape to cancel text creation
- [ ] Click outside input to cancel
- [ ] Empty text objects are prevented (validation)
- [ ] Text appears with correct content
- [ ] Text object syncs to Firebase immediately
- [ ] Other users see new text within 100ms
- [ ] Text cannot be edited after creation (MVP constraint)

---

## 4. Shape Manipulation

### 4.1 Shape Selection
- [ ] Select tool allows clicking shapes
- [ ] Clicking shape selects it
- [ ] Selected shape shows blue bounding box
- [ ] Only one shape can be selected at a time
- [ ] Clicking canvas background deselects
- [ ] Selection state syncs to Firebase
- [ ] Other users see selection as colored bounding box

### 4.2 Shape Dragging
- [ ] Can drag selected shape
- [ ] Drag is smooth and responsive
- [ ] Shape position updates in real-time
- [ ] Position syncs to Firebase during drag
- [ ] Other users see drag movement within 100ms
- [ ] Cannot drag shape outside canvas boundaries
- [ ] Shape snaps back if dragged beyond boundaries

### 4.3 Shape Deletion
- [ ] Select shape and press Delete key
- [ ] Select shape and press Backspace key
- [ ] Select shape and click Delete button in toolbar
- [ ] Shape is removed from canvas
- [ ] Deletion syncs to Firebase immediately
- [ ] Other users see deletion within 100ms
- [ ] Delete button is disabled when no selection
- [ ] Delete button is enabled when shape is selected

---

## 5. Real-Time Collaboration

### 5.1 Cursor Synchronization
- [ ] Open app in two browser tabs/windows
- [ ] Login with different accounts in each
- [ ] See other user's cursor position
- [ ] Cursor updates at ~20Hz (50ms intervals)
- [ ] Cursor "jumps" to position (no interpolation)
- [ ] Cursor shows user name label
- [ ] Cursor shows user color
- [ ] Cursor color is consistent per user
- [ ] Cursor disappears when user leaves

### 5.2 Object Synchronization
- [ ] Create object in tab 1
- [ ] Object appears in tab 2 within 100ms
- [ ] Move object in tab 1
- [ ] Movement reflects in tab 2 in real-time
- [ ] Delete object in tab 1
- [ ] Deletion reflects in tab 2 within 100ms
- [ ] No duplicate objects appear
- [ ] No ghost objects remain after deletion

### 5.3 Selection Synchronization
- [ ] Select shape in tab 1
- [ ] Selection bounding box appears in tab 2
- [ ] Bounding box uses user's unique color
- [ ] Multiple users can have different selections
- [ ] Deselection syncs to other users
- [ ] Selection indicator disappears when user leaves

### 5.4 Presence Management
- [ ] User appears in presence bar when joining
- [ ] User name/email displays correctly
- [ ] User count is accurate
- [ ] User disappears from presence bar when leaving
- [ ] User status updates in real-time
- [ ] No duplicate users in presence bar

---

## 6. UI/UX Tests

### 6.1 Toolbar
- [ ] Toolbar displays on left side
- [ ] All tool buttons are visible
- [ ] Tool buttons have icons
- [ ] Select tool button
- [ ] Rectangle tool button
- [ ] Circle tool button
- [ ] Text tool button
- [ ] Delete button (only enabled with selection)
- [ ] Selected tool is highlighted
- [ ] Tool selection changes cursor/behavior

### 6.2 Presence Bar
- [ ] Presence bar displays at top
- [ ] Shows current user
- [ ] Shows other online users
- [ ] User count is accurate
- [ ] Email/name displays for each user
- [ ] Layout is clean and readable

### 6.3 Loading States
- [ ] Loading spinner during initial authentication
- [ ] Loading spinner is full-screen
- [ ] Loading message displays
- [ ] Loading state clears after auth completes
- [ ] No flash of unauthenticated content

### 6.4 Responsive Layout
- [ ] Top header is fixed position
- [ ] Left toolbar is fixed position
- [ ] Canvas fills remaining space
- [ ] Layout works at various window sizes
- [ ] No scrollbars on main window
- [ ] Components don't overlap

---

## 7. Error Handling

### 7.1 Network Errors
- [ ] App handles Firebase connection loss gracefully
- [ ] Error boundary catches React errors
- [ ] Error messages are user-friendly
- [ ] Can recover from temporary network issues
- [ ] No uncaught exceptions in console

### 7.2 Authentication Errors
- [ ] Failed login shows error message
- [ ] Expired session redirects to login
- [ ] Auth errors don't crash app
- [ ] Can retry authentication after failure

### 7.3 Validation Errors
- [ ] Empty text objects prevented with clear feedback
- [ ] Invalid operations show helpful messages
- [ ] Validation doesn't crash app

---

## 8. Performance Tests

### 8.1 Rendering Performance
- [ ] Canvas renders smoothly at 60 FPS
- [ ] No jank during pan/zoom
- [ ] No lag during shape creation
- [ ] Multiple shapes (100+) render smoothly
- [ ] Cursor movement is smooth

### 8.2 Network Performance
- [ ] Object creation syncs < 100ms
- [ ] Object updates sync < 100ms
- [ ] Object deletion syncs < 100ms
- [ ] Cursor updates at ~20Hz
- [ ] No excessive Firebase read/writes
- [ ] Bandwidth usage is reasonable

### 8.3 Memory Performance
- [ ] No memory leaks after extended use
- [ ] Memory usage stable with many objects
- [ ] No memory leaks when users join/leave
- [ ] Cleanup on component unmount

---

## 9. Browser Compatibility

### 9.1 Chrome
- [ ] All features work in Chrome
- [ ] UI renders correctly
- [ ] No console errors

### 9.2 Firefox
- [ ] All features work in Firefox
- [ ] UI renders correctly
- [ ] No console errors

### 9.3 Safari
- [ ] All features work in Safari
- [ ] UI renders correctly
- [ ] No console errors

### 9.4 Edge
- [ ] All features work in Edge
- [ ] UI renders correctly
- [ ] No console errors

---

## 10. Data Integrity

### 10.1 Firebase Data Model
- [ ] Canvas objects stored correctly
- [ ] Compressed format used (t, x, y, w, h, txt)
- [ ] No color property stored (all shapes blue)
- [ ] Presence data stored correctly
- [ ] Presence structure: {n, cl, c, sel}
- [ ] Data cleanup on user disconnect

### 10.2 Conflict Resolution
- [ ] Last-write-wins works correctly
- [ ] No data corruption with concurrent edits
- [ ] Shapes don't "jump" unexpectedly
- [ ] Selection conflicts handled gracefully

---

## 11. Security Tests

### 11.1 Authentication Required
- [ ] Cannot access canvas without login
- [ ] Protected routes redirect to login
- [ ] Firebase rules enforce authentication

### 11.2 Firebase Security Rules
- [ ] Cannot read canvas without auth
- [ ] Cannot write canvas without auth
- [ ] Cannot read presence without auth
- [ ] Can only write to own presence path
- [ ] Rules validated with `firebase deploy --only database`

---

## 12. MVP Constraints Validation

### 12.1 Explicitly Excluded Features
- [ ] ❌ No resize functionality (verified absent)
- [ ] ❌ No Konva Transformers (verified absent)
- [ ] ❌ No color picker (verified absent - all blue)
- [ ] ❌ No text editing after creation (verified absent)
- [ ] ❌ No properties panel (verified absent)
- [ ] ❌ No multi-select (verified absent)
- [ ] ❌ No copy/paste (verified absent)
- [ ] ❌ No undo/redo (verified absent)

### 12.2 Fixed Constraints
- [ ] All shapes are 100x100px (verified)
- [ ] All shapes are blue #3B82F6 (verified)
- [ ] Canvas is 5000x5000px (verified)
- [ ] Grid spacing is 50px (verified)
- [ ] Cursor sync is 20Hz (verified)
- [ ] Cursor uses jump positioning, no interpolation (verified)
- [ ] Single shared canvas for all users (verified)

---

## Test Results Summary

**Test Date:** _______________

**Tester:** _______________

**Environment:**
- Node Version: _______________
- Browser(s): _______________
- Firebase Project: collabcanvas-realtime

**Overall Results:**
- Total Tests: _______________
- Passed: _______________
- Failed: _______________
- Blocked: _______________

**Critical Bugs Found:**
1. _______________
2. _______________
3. _______________

**Non-Critical Issues:**
1. _______________
2. _______________
3. _______________

**Performance Metrics:**
- Average FPS: _______________
- Object Creation Latency: _______________
- Object Update Latency: _______________
- Cursor Update Frequency: _______________

**Notes:**
_______________________________________________________________
_______________________________________________________________
_______________________________________________________________

**Sign-off:**
- [ ] All critical features tested
- [ ] All critical bugs fixed
- [ ] Performance targets met
- [ ] Ready for production deployment
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'


export default defineConfig({
  plugins: [react()],
})
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './tests/setup.ts',
    css: true,
  },
})
</file>

</files>
